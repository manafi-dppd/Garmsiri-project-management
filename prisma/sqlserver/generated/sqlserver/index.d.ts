
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AbadeMakhzan
 * 
 */
export type AbadeMakhzan = $Result.DefaultSelection<Prisma.$AbadeMakhzanPayload>
/**
 * Model Abgir
 * 
 */
export type Abgir = $Result.DefaultSelection<Prisma.$AbgirPayload>
/**
 * Model BahrebardairProgram
 * 
 */
export type BahrebardairProgram = $Result.DefaultSelection<Prisma.$BahrebardairProgramPayload>
/**
 * Model BahrebardairProgramSeghli
 * 
 */
export type BahrebardairProgramSeghli = $Result.DefaultSelection<Prisma.$BahrebardairProgramSeghliPayload>
/**
 * Model BahrebardariKeshtDore
 * The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
 */
export type BahrebardariKeshtDore = $Result.DefaultSelection<Prisma.$BahrebardariKeshtDorePayload>
/**
 * Model BahrebardariTaghvim
 * 
 */
export type BahrebardariTaghvim = $Result.DefaultSelection<Prisma.$BahrebardariTaghvimPayload>
/**
 * Model BareshMotaleat
 * 
 */
export type BareshMotaleat = $Result.DefaultSelection<Prisma.$BareshMotaleatPayload>
/**
 * Model DarajePipe
 * 
 */
export type DarajePipe = $Result.DefaultSelection<Prisma.$DarajePipePayload>
/**
 * Model DeliveryPoints
 * 
 */
export type DeliveryPoints = $Result.DefaultSelection<Prisma.$DeliveryPointsPayload>
/**
 * Model DarjeStation
 * 
 */
export type DarjeStation = $Result.DefaultSelection<Prisma.$DarjeStationPayload>
/**
 * Model DoreKesht
 * 
 */
export type DoreKesht = $Result.DefaultSelection<Prisma.$DoreKeshtPayload>
/**
 * Model EshtebahAvamel
 * 
 */
export type EshtebahAvamel = $Result.DefaultSelection<Prisma.$EshtebahAvamelPayload>
/**
 * Model FlowBehbood
 * 
 */
export type FlowBehbood = $Result.DefaultSelection<Prisma.$FlowBehboodPayload>
/**
 * Model Flowmeter
 * 
 */
export type Flowmeter = $Result.DefaultSelection<Prisma.$FlowmeterPayload>
/**
 * Model KhatRanesh
 * 
 */
export type KhatRanesh = $Result.DefaultSelection<Prisma.$KhatRaneshPayload>
/**
 * Model KhatRaneshArea
 * 
 */
export type KhatRaneshArea = $Result.DefaultSelection<Prisma.$KhatRaneshAreaPayload>
/**
 * Model KhatRaneshPump
 * 
 */
export type KhatRaneshPump = $Result.DefaultSelection<Prisma.$KhatRaneshPumpPayload>
/**
 * Model KhatRaneshSegli
 * 
 */
export type KhatRaneshSegli = $Result.DefaultSelection<Prisma.$KhatRaneshSegliPayload>
/**
 * Model Kontor
 * 
 */
export type Kontor = $Result.DefaultSelection<Prisma.$KontorPayload>
/**
 * Model Land
 * 
 */
export type Land = $Result.DefaultSelection<Prisma.$LandPayload>
/**
 * Model MeasuringTool
 * 
 */
export type MeasuringTool = $Result.DefaultSelection<Prisma.$MeasuringToolPayload>
/**
 * Model NashtShabake
 * 
 */
export type NashtShabake = $Result.DefaultSelection<Prisma.$NashtShabakePayload>
/**
 * Model Network
 * 
 */
export type Network = $Result.DefaultSelection<Prisma.$NetworkPayload>
/**
 * Model NoeKesht
 * 
 */
export type NoeKesht = $Result.DefaultSelection<Prisma.$NoeKeshtPayload>
/**
 * Model NoeMahsool
 * 
 */
export type NoeMahsool = $Result.DefaultSelection<Prisma.$NoeMahsoolPayload>
/**
 * Model NonFIT
 * 
 */
export type NonFIT = $Result.DefaultSelection<Prisma.$NonFITPayload>
/**
 * Model PumpStation
 * 
 */
export type PumpStation = $Result.DefaultSelection<Prisma.$PumpStationPayload>
/**
 * Model PumpType
 * 
 */
export type PumpType = $Result.DefaultSelection<Prisma.$PumpTypePayload>
/**
 * Model RainfallStation
 * 
 */
export type RainfallStation = $Result.DefaultSelection<Prisma.$RainfallStationPayload>
/**
 * Model RainfallType
 * 
 */
export type RainfallType = $Result.DefaultSelection<Prisma.$RainfallTypePayload>
/**
 * Model SaleZeraee
 * 
 */
export type SaleZeraee = $Result.DefaultSelection<Prisma.$SaleZeraeePayload>
/**
 * Model SeghliPump
 * 
 */
export type SeghliPump = $Result.DefaultSelection<Prisma.$SeghliPumpPayload>
/**
 * Model SystemPart
 * 
 */
export type SystemPart = $Result.DefaultSelection<Prisma.$SystemPartPayload>
/**
 * Model TakhlieMakhzan
 * 
 */
export type TakhlieMakhzan = $Result.DefaultSelection<Prisma.$TakhlieMakhzanPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TrikhDoreKesht
 * 
 */
export type TrikhDoreKesht = $Result.DefaultSelection<Prisma.$TrikhDoreKeshtPayload>
/**
 * Model WeatherStation
 * 
 */
export type WeatherStation = $Result.DefaultSelection<Prisma.$WeatherStationPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model MahShamsi
 * 
 */
export type MahShamsi = $Result.DefaultSelection<Prisma.$MahShamsiPayload>
/**
 * Model ShabakeDoreKesht
 * 
 */
export type ShabakeDoreKesht = $Result.DefaultSelection<Prisma.$ShabakeDoreKeshtPayload>
/**
 * Model TaeedProgram
 * 
 */
export type TaeedProgram = $Result.DefaultSelection<Prisma.$TaeedProgramPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AbadeMakhzans
 * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  someTable: any;
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AbadeMakhzans
   * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.abadeMakhzan`: Exposes CRUD operations for the **AbadeMakhzan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AbadeMakhzans
    * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
    * ```
    */
  get abadeMakhzan(): Prisma.AbadeMakhzanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.abgir`: Exposes CRUD operations for the **Abgir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abgirs
    * const abgirs = await prisma.abgir.findMany()
    * ```
    */
  get abgir(): Prisma.AbgirDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardairProgram`: Exposes CRUD operations for the **BahrebardairProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardairPrograms
    * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany()
    * ```
    */
  get bahrebardairProgram(): Prisma.BahrebardairProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardairProgramSeghli`: Exposes CRUD operations for the **BahrebardairProgramSeghli** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardairProgramSeghlis
    * const bahrebardairProgramSeghlis = await prisma.bahrebardairProgramSeghli.findMany()
    * ```
    */
  get bahrebardairProgramSeghli(): Prisma.BahrebardairProgramSeghliDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardariKeshtDore`: Exposes CRUD operations for the **BahrebardariKeshtDore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardariKeshtDores
    * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany()
    * ```
    */
  get bahrebardariKeshtDore(): Prisma.BahrebardariKeshtDoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardariTaghvim`: Exposes CRUD operations for the **BahrebardariTaghvim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardariTaghvims
    * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany()
    * ```
    */
  get bahrebardariTaghvim(): Prisma.BahrebardariTaghvimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bareshMotaleat`: Exposes CRUD operations for the **BareshMotaleat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BareshMotaleats
    * const bareshMotaleats = await prisma.bareshMotaleat.findMany()
    * ```
    */
  get bareshMotaleat(): Prisma.BareshMotaleatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.darajePipe`: Exposes CRUD operations for the **DarajePipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DarajePipes
    * const darajePipes = await prisma.darajePipe.findMany()
    * ```
    */
  get darajePipe(): Prisma.DarajePipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryPoints`: Exposes CRUD operations for the **DeliveryPoints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryPoints
    * const deliveryPoints = await prisma.deliveryPoints.findMany()
    * ```
    */
  get deliveryPoints(): Prisma.DeliveryPointsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.darjeStation`: Exposes CRUD operations for the **DarjeStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DarjeStations
    * const darjeStations = await prisma.darjeStation.findMany()
    * ```
    */
  get darjeStation(): Prisma.DarjeStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doreKesht`: Exposes CRUD operations for the **DoreKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoreKeshts
    * const doreKeshts = await prisma.doreKesht.findMany()
    * ```
    */
  get doreKesht(): Prisma.DoreKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eshtebahAvamel`: Exposes CRUD operations for the **EshtebahAvamel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EshtebahAvamels
    * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany()
    * ```
    */
  get eshtebahAvamel(): Prisma.EshtebahAvamelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowBehbood`: Exposes CRUD operations for the **FlowBehbood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowBehboods
    * const flowBehboods = await prisma.flowBehbood.findMany()
    * ```
    */
  get flowBehbood(): Prisma.FlowBehboodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowmeter`: Exposes CRUD operations for the **Flowmeter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flowmeters
    * const flowmeters = await prisma.flowmeter.findMany()
    * ```
    */
  get flowmeter(): Prisma.FlowmeterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRanesh`: Exposes CRUD operations for the **KhatRanesh** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshes
    * const khatRaneshes = await prisma.khatRanesh.findMany()
    * ```
    */
  get khatRanesh(): Prisma.KhatRaneshDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshArea`: Exposes CRUD operations for the **KhatRaneshArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshAreas
    * const khatRaneshAreas = await prisma.khatRaneshArea.findMany()
    * ```
    */
  get khatRaneshArea(): Prisma.KhatRaneshAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshPump`: Exposes CRUD operations for the **KhatRaneshPump** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshPumps
    * const khatRaneshPumps = await prisma.khatRaneshPump.findMany()
    * ```
    */
  get khatRaneshPump(): Prisma.KhatRaneshPumpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshSegli`: Exposes CRUD operations for the **KhatRaneshSegli** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshSeglis
    * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany()
    * ```
    */
  get khatRaneshSegli(): Prisma.KhatRaneshSegliDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kontor`: Exposes CRUD operations for the **Kontor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kontors
    * const kontors = await prisma.kontor.findMany()
    * ```
    */
  get kontor(): Prisma.KontorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land`: Exposes CRUD operations for the **Land** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lands
    * const lands = await prisma.land.findMany()
    * ```
    */
  get land(): Prisma.LandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.measuringTool`: Exposes CRUD operations for the **MeasuringTool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeasuringTools
    * const measuringTools = await prisma.measuringTool.findMany()
    * ```
    */
  get measuringTool(): Prisma.MeasuringToolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nashtShabake`: Exposes CRUD operations for the **NashtShabake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NashtShabakes
    * const nashtShabakes = await prisma.nashtShabake.findMany()
    * ```
    */
  get nashtShabake(): Prisma.NashtShabakeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.network`: Exposes CRUD operations for the **Network** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Networks
    * const networks = await prisma.network.findMany()
    * ```
    */
  get network(): Prisma.NetworkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noeKesht`: Exposes CRUD operations for the **NoeKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoeKeshts
    * const noeKeshts = await prisma.noeKesht.findMany()
    * ```
    */
  get noeKesht(): Prisma.NoeKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noeMahsool`: Exposes CRUD operations for the **NoeMahsool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoeMahsools
    * const noeMahsools = await prisma.noeMahsool.findMany()
    * ```
    */
  get noeMahsool(): Prisma.NoeMahsoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nonFIT`: Exposes CRUD operations for the **NonFIT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NonFITS
    * const nonFITS = await prisma.nonFIT.findMany()
    * ```
    */
  get nonFIT(): Prisma.NonFITDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pumpStation`: Exposes CRUD operations for the **PumpStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PumpStations
    * const pumpStations = await prisma.pumpStation.findMany()
    * ```
    */
  get pumpStation(): Prisma.PumpStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pumpType`: Exposes CRUD operations for the **PumpType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PumpTypes
    * const pumpTypes = await prisma.pumpType.findMany()
    * ```
    */
  get pumpType(): Prisma.PumpTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainfallStation`: Exposes CRUD operations for the **RainfallStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainfallStations
    * const rainfallStations = await prisma.rainfallStation.findMany()
    * ```
    */
  get rainfallStation(): Prisma.RainfallStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainfallType`: Exposes CRUD operations for the **RainfallType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainfallTypes
    * const rainfallTypes = await prisma.rainfallType.findMany()
    * ```
    */
  get rainfallType(): Prisma.RainfallTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleZeraee`: Exposes CRUD operations for the **SaleZeraee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleZeraees
    * const saleZeraees = await prisma.saleZeraee.findMany()
    * ```
    */
  get saleZeraee(): Prisma.SaleZeraeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seghliPump`: Exposes CRUD operations for the **SeghliPump** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeghliPumps
    * const seghliPumps = await prisma.seghliPump.findMany()
    * ```
    */
  get seghliPump(): Prisma.SeghliPumpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemPart`: Exposes CRUD operations for the **SystemPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemParts
    * const systemParts = await prisma.systemPart.findMany()
    * ```
    */
  get systemPart(): Prisma.SystemPartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takhlieMakhzan`: Exposes CRUD operations for the **TakhlieMakhzan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TakhlieMakhzans
    * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany()
    * ```
    */
  get takhlieMakhzan(): Prisma.TakhlieMakhzanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trikhDoreKesht`: Exposes CRUD operations for the **TrikhDoreKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrikhDoreKeshts
    * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany()
    * ```
    */
  get trikhDoreKesht(): Prisma.TrikhDoreKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weatherStation`: Exposes CRUD operations for the **WeatherStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherStations
    * const weatherStations = await prisma.weatherStation.findMany()
    * ```
    */
  get weatherStation(): Prisma.WeatherStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mahShamsi`: Exposes CRUD operations for the **MahShamsi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MahShamsis
    * const mahShamsis = await prisma.mahShamsi.findMany()
    * ```
    */
  get mahShamsi(): Prisma.MahShamsiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shabakeDoreKesht`: Exposes CRUD operations for the **ShabakeDoreKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShabakeDoreKeshts
    * const shabakeDoreKeshts = await prisma.shabakeDoreKesht.findMany()
    * ```
    */
  get shabakeDoreKesht(): Prisma.ShabakeDoreKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taeedProgram`: Exposes CRUD operations for the **TaeedProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaeedPrograms
    * const taeedPrograms = await prisma.taeedProgram.findMany()
    * ```
    */
  get taeedProgram(): Prisma.TaeedProgramDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AbadeMakhzan: 'AbadeMakhzan',
    Abgir: 'Abgir',
    BahrebardairProgram: 'BahrebardairProgram',
    BahrebardairProgramSeghli: 'BahrebardairProgramSeghli',
    BahrebardariKeshtDore: 'BahrebardariKeshtDore',
    BahrebardariTaghvim: 'BahrebardariTaghvim',
    BareshMotaleat: 'BareshMotaleat',
    DarajePipe: 'DarajePipe',
    DeliveryPoints: 'DeliveryPoints',
    DarjeStation: 'DarjeStation',
    DoreKesht: 'DoreKesht',
    EshtebahAvamel: 'EshtebahAvamel',
    FlowBehbood: 'FlowBehbood',
    Flowmeter: 'Flowmeter',
    KhatRanesh: 'KhatRanesh',
    KhatRaneshArea: 'KhatRaneshArea',
    KhatRaneshPump: 'KhatRaneshPump',
    KhatRaneshSegli: 'KhatRaneshSegli',
    Kontor: 'Kontor',
    Land: 'Land',
    MeasuringTool: 'MeasuringTool',
    NashtShabake: 'NashtShabake',
    Network: 'Network',
    NoeKesht: 'NoeKesht',
    NoeMahsool: 'NoeMahsool',
    NonFIT: 'NonFIT',
    PumpStation: 'PumpStation',
    PumpType: 'PumpType',
    RainfallStation: 'RainfallStation',
    RainfallType: 'RainfallType',
    SaleZeraee: 'SaleZeraee',
    SeghliPump: 'SeghliPump',
    SystemPart: 'SystemPart',
    TakhlieMakhzan: 'TakhlieMakhzan',
    Test: 'Test',
    TrikhDoreKesht: 'TrikhDoreKesht',
    WeatherStation: 'WeatherStation',
    sysdiagrams: 'sysdiagrams',
    MahShamsi: 'MahShamsi',
    ShabakeDoreKesht: 'ShabakeDoreKesht',
    TaeedProgram: 'TaeedProgram'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "abadeMakhzan" | "abgir" | "bahrebardairProgram" | "bahrebardairProgramSeghli" | "bahrebardariKeshtDore" | "bahrebardariTaghvim" | "bareshMotaleat" | "darajePipe" | "deliveryPoints" | "darjeStation" | "doreKesht" | "eshtebahAvamel" | "flowBehbood" | "flowmeter" | "khatRanesh" | "khatRaneshArea" | "khatRaneshPump" | "khatRaneshSegli" | "kontor" | "land" | "measuringTool" | "nashtShabake" | "network" | "noeKesht" | "noeMahsool" | "nonFIT" | "pumpStation" | "pumpType" | "rainfallStation" | "rainfallType" | "saleZeraee" | "seghliPump" | "systemPart" | "takhlieMakhzan" | "test" | "trikhDoreKesht" | "weatherStation" | "sysdiagrams" | "mahShamsi" | "shabakeDoreKesht" | "taeedProgram"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AbadeMakhzan: {
        payload: Prisma.$AbadeMakhzanPayload<ExtArgs>
        fields: Prisma.AbadeMakhzanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbadeMakhzanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          findFirst: {
            args: Prisma.AbadeMakhzanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbadeMakhzanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          findMany: {
            args: Prisma.AbadeMakhzanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>[]
          }
          create: {
            args: Prisma.AbadeMakhzanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          createMany: {
            args: Prisma.AbadeMakhzanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbadeMakhzanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          update: {
            args: Prisma.AbadeMakhzanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          deleteMany: {
            args: Prisma.AbadeMakhzanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbadeMakhzanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbadeMakhzanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          aggregate: {
            args: Prisma.AbadeMakhzanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbadeMakhzan>
          }
          groupBy: {
            args: Prisma.AbadeMakhzanGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbadeMakhzanGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbadeMakhzanCountArgs<ExtArgs>
            result: $Utils.Optional<AbadeMakhzanCountAggregateOutputType> | number
          }
        }
      }
      Abgir: {
        payload: Prisma.$AbgirPayload<ExtArgs>
        fields: Prisma.AbgirFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbgirFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbgirFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          findFirst: {
            args: Prisma.AbgirFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbgirFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          findMany: {
            args: Prisma.AbgirFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>[]
          }
          create: {
            args: Prisma.AbgirCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          createMany: {
            args: Prisma.AbgirCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbgirDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          update: {
            args: Prisma.AbgirUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          deleteMany: {
            args: Prisma.AbgirDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbgirUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbgirUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          aggregate: {
            args: Prisma.AbgirAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbgir>
          }
          groupBy: {
            args: Prisma.AbgirGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbgirGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbgirCountArgs<ExtArgs>
            result: $Utils.Optional<AbgirCountAggregateOutputType> | number
          }
        }
      }
      BahrebardairProgram: {
        payload: Prisma.$BahrebardairProgramPayload<ExtArgs>
        fields: Prisma.BahrebardairProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardairProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          findFirst: {
            args: Prisma.BahrebardairProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardairProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          findMany: {
            args: Prisma.BahrebardairProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>[]
          }
          create: {
            args: Prisma.BahrebardairProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          createMany: {
            args: Prisma.BahrebardairProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardairProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          update: {
            args: Prisma.BahrebardairProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          deleteMany: {
            args: Prisma.BahrebardairProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardairProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardairProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          aggregate: {
            args: Prisma.BahrebardairProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardairProgram>
          }
          groupBy: {
            args: Prisma.BahrebardairProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardairProgramCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramCountAggregateOutputType> | number
          }
        }
      }
      BahrebardairProgramSeghli: {
        payload: Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>
        fields: Prisma.BahrebardairProgramSeghliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardairProgramSeghliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardairProgramSeghliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          findFirst: {
            args: Prisma.BahrebardairProgramSeghliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardairProgramSeghliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          findMany: {
            args: Prisma.BahrebardairProgramSeghliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>[]
          }
          create: {
            args: Prisma.BahrebardairProgramSeghliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          createMany: {
            args: Prisma.BahrebardairProgramSeghliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardairProgramSeghliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          update: {
            args: Prisma.BahrebardairProgramSeghliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          deleteMany: {
            args: Prisma.BahrebardairProgramSeghliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardairProgramSeghliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardairProgramSeghliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramSeghliPayload>
          }
          aggregate: {
            args: Prisma.BahrebardairProgramSeghliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardairProgramSeghli>
          }
          groupBy: {
            args: Prisma.BahrebardairProgramSeghliGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramSeghliGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardairProgramSeghliCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramSeghliCountAggregateOutputType> | number
          }
        }
      }
      BahrebardariKeshtDore: {
        payload: Prisma.$BahrebardariKeshtDorePayload<ExtArgs>
        fields: Prisma.BahrebardariKeshtDoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardariKeshtDoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          findFirst: {
            args: Prisma.BahrebardariKeshtDoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          findMany: {
            args: Prisma.BahrebardariKeshtDoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>[]
          }
          create: {
            args: Prisma.BahrebardariKeshtDoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          createMany: {
            args: Prisma.BahrebardariKeshtDoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardariKeshtDoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          update: {
            args: Prisma.BahrebardariKeshtDoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          deleteMany: {
            args: Prisma.BahrebardariKeshtDoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardariKeshtDoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardariKeshtDoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          aggregate: {
            args: Prisma.BahrebardariKeshtDoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardariKeshtDore>
          }
          groupBy: {
            args: Prisma.BahrebardariKeshtDoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariKeshtDoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardariKeshtDoreCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariKeshtDoreCountAggregateOutputType> | number
          }
        }
      }
      BahrebardariTaghvim: {
        payload: Prisma.$BahrebardariTaghvimPayload<ExtArgs>
        fields: Prisma.BahrebardariTaghvimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardariTaghvimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          findFirst: {
            args: Prisma.BahrebardariTaghvimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          findMany: {
            args: Prisma.BahrebardariTaghvimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>[]
          }
          create: {
            args: Prisma.BahrebardariTaghvimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          createMany: {
            args: Prisma.BahrebardariTaghvimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardariTaghvimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          update: {
            args: Prisma.BahrebardariTaghvimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          deleteMany: {
            args: Prisma.BahrebardariTaghvimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardariTaghvimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardariTaghvimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          aggregate: {
            args: Prisma.BahrebardariTaghvimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardariTaghvim>
          }
          groupBy: {
            args: Prisma.BahrebardariTaghvimGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariTaghvimGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardariTaghvimCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariTaghvimCountAggregateOutputType> | number
          }
        }
      }
      BareshMotaleat: {
        payload: Prisma.$BareshMotaleatPayload<ExtArgs>
        fields: Prisma.BareshMotaleatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BareshMotaleatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BareshMotaleatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          findFirst: {
            args: Prisma.BareshMotaleatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BareshMotaleatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          findMany: {
            args: Prisma.BareshMotaleatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>[]
          }
          create: {
            args: Prisma.BareshMotaleatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          createMany: {
            args: Prisma.BareshMotaleatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BareshMotaleatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          update: {
            args: Prisma.BareshMotaleatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          deleteMany: {
            args: Prisma.BareshMotaleatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BareshMotaleatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BareshMotaleatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          aggregate: {
            args: Prisma.BareshMotaleatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBareshMotaleat>
          }
          groupBy: {
            args: Prisma.BareshMotaleatGroupByArgs<ExtArgs>
            result: $Utils.Optional<BareshMotaleatGroupByOutputType>[]
          }
          count: {
            args: Prisma.BareshMotaleatCountArgs<ExtArgs>
            result: $Utils.Optional<BareshMotaleatCountAggregateOutputType> | number
          }
        }
      }
      DarajePipe: {
        payload: Prisma.$DarajePipePayload<ExtArgs>
        fields: Prisma.DarajePipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DarajePipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DarajePipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          findFirst: {
            args: Prisma.DarajePipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DarajePipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          findMany: {
            args: Prisma.DarajePipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>[]
          }
          create: {
            args: Prisma.DarajePipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          createMany: {
            args: Prisma.DarajePipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DarajePipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          update: {
            args: Prisma.DarajePipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          deleteMany: {
            args: Prisma.DarajePipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DarajePipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DarajePipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          aggregate: {
            args: Prisma.DarajePipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDarajePipe>
          }
          groupBy: {
            args: Prisma.DarajePipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DarajePipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DarajePipeCountArgs<ExtArgs>
            result: $Utils.Optional<DarajePipeCountAggregateOutputType> | number
          }
        }
      }
      DeliveryPoints: {
        payload: Prisma.$DeliveryPointsPayload<ExtArgs>
        fields: Prisma.DeliveryPointsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryPointsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryPointsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          findFirst: {
            args: Prisma.DeliveryPointsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryPointsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          findMany: {
            args: Prisma.DeliveryPointsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>[]
          }
          create: {
            args: Prisma.DeliveryPointsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          createMany: {
            args: Prisma.DeliveryPointsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeliveryPointsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          update: {
            args: Prisma.DeliveryPointsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryPointsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryPointsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryPointsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPointsPayload>
          }
          aggregate: {
            args: Prisma.DeliveryPointsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryPoints>
          }
          groupBy: {
            args: Prisma.DeliveryPointsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPointsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryPointsCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPointsCountAggregateOutputType> | number
          }
        }
      }
      DarjeStation: {
        payload: Prisma.$DarjeStationPayload<ExtArgs>
        fields: Prisma.DarjeStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DarjeStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DarjeStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          findFirst: {
            args: Prisma.DarjeStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DarjeStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          findMany: {
            args: Prisma.DarjeStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>[]
          }
          create: {
            args: Prisma.DarjeStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          createMany: {
            args: Prisma.DarjeStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DarjeStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          update: {
            args: Prisma.DarjeStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          deleteMany: {
            args: Prisma.DarjeStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DarjeStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DarjeStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          aggregate: {
            args: Prisma.DarjeStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDarjeStation>
          }
          groupBy: {
            args: Prisma.DarjeStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DarjeStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DarjeStationCountArgs<ExtArgs>
            result: $Utils.Optional<DarjeStationCountAggregateOutputType> | number
          }
        }
      }
      DoreKesht: {
        payload: Prisma.$DoreKeshtPayload<ExtArgs>
        fields: Prisma.DoreKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoreKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoreKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          findFirst: {
            args: Prisma.DoreKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoreKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          findMany: {
            args: Prisma.DoreKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>[]
          }
          create: {
            args: Prisma.DoreKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          createMany: {
            args: Prisma.DoreKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DoreKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          update: {
            args: Prisma.DoreKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          deleteMany: {
            args: Prisma.DoreKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoreKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoreKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          aggregate: {
            args: Prisma.DoreKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoreKesht>
          }
          groupBy: {
            args: Prisma.DoreKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoreKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoreKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<DoreKeshtCountAggregateOutputType> | number
          }
        }
      }
      EshtebahAvamel: {
        payload: Prisma.$EshtebahAvamelPayload<ExtArgs>
        fields: Prisma.EshtebahAvamelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EshtebahAvamelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          findFirst: {
            args: Prisma.EshtebahAvamelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EshtebahAvamelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          findMany: {
            args: Prisma.EshtebahAvamelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>[]
          }
          create: {
            args: Prisma.EshtebahAvamelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          createMany: {
            args: Prisma.EshtebahAvamelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EshtebahAvamelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          update: {
            args: Prisma.EshtebahAvamelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          deleteMany: {
            args: Prisma.EshtebahAvamelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EshtebahAvamelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EshtebahAvamelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          aggregate: {
            args: Prisma.EshtebahAvamelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEshtebahAvamel>
          }
          groupBy: {
            args: Prisma.EshtebahAvamelGroupByArgs<ExtArgs>
            result: $Utils.Optional<EshtebahAvamelGroupByOutputType>[]
          }
          count: {
            args: Prisma.EshtebahAvamelCountArgs<ExtArgs>
            result: $Utils.Optional<EshtebahAvamelCountAggregateOutputType> | number
          }
        }
      }
      FlowBehbood: {
        payload: Prisma.$FlowBehboodPayload<ExtArgs>
        fields: Prisma.FlowBehboodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowBehboodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowBehboodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          findFirst: {
            args: Prisma.FlowBehboodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowBehboodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          findMany: {
            args: Prisma.FlowBehboodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>[]
          }
          create: {
            args: Prisma.FlowBehboodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          createMany: {
            args: Prisma.FlowBehboodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowBehboodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          update: {
            args: Prisma.FlowBehboodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          deleteMany: {
            args: Prisma.FlowBehboodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowBehboodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowBehboodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          aggregate: {
            args: Prisma.FlowBehboodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowBehbood>
          }
          groupBy: {
            args: Prisma.FlowBehboodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowBehboodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowBehboodCountArgs<ExtArgs>
            result: $Utils.Optional<FlowBehboodCountAggregateOutputType> | number
          }
        }
      }
      Flowmeter: {
        payload: Prisma.$FlowmeterPayload<ExtArgs>
        fields: Prisma.FlowmeterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowmeterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowmeterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          findFirst: {
            args: Prisma.FlowmeterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowmeterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          findMany: {
            args: Prisma.FlowmeterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>[]
          }
          create: {
            args: Prisma.FlowmeterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          createMany: {
            args: Prisma.FlowmeterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowmeterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          update: {
            args: Prisma.FlowmeterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          deleteMany: {
            args: Prisma.FlowmeterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowmeterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowmeterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          aggregate: {
            args: Prisma.FlowmeterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowmeter>
          }
          groupBy: {
            args: Prisma.FlowmeterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowmeterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowmeterCountArgs<ExtArgs>
            result: $Utils.Optional<FlowmeterCountAggregateOutputType> | number
          }
        }
      }
      KhatRanesh: {
        payload: Prisma.$KhatRaneshPayload<ExtArgs>
        fields: Prisma.KhatRaneshFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          update: {
            args: Prisma.KhatRaneshUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRanesh>
          }
          groupBy: {
            args: Prisma.KhatRaneshGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshArea: {
        payload: Prisma.$KhatRaneshAreaPayload<ExtArgs>
        fields: Prisma.KhatRaneshAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          update: {
            args: Prisma.KhatRaneshAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshArea>
          }
          groupBy: {
            args: Prisma.KhatRaneshAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshAreaCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshAreaCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshPump: {
        payload: Prisma.$KhatRaneshPumpPayload<ExtArgs>
        fields: Prisma.KhatRaneshPumpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshPumpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshPumpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshPumpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshPumpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshPumpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshPumpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          update: {
            args: Prisma.KhatRaneshPumpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshPumpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshPumpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshPumpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshPumpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshPump>
          }
          groupBy: {
            args: Prisma.KhatRaneshPumpGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshPumpGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshPumpCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshPumpCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshSegli: {
        payload: Prisma.$KhatRaneshSegliPayload<ExtArgs>
        fields: Prisma.KhatRaneshSegliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshSegliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshSegliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshSegliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshSegliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshSegliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshSegliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          update: {
            args: Prisma.KhatRaneshSegliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshSegliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshSegliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshSegliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshSegliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshSegli>
          }
          groupBy: {
            args: Prisma.KhatRaneshSegliGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshSegliGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshSegliCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshSegliCountAggregateOutputType> | number
          }
        }
      }
      Kontor: {
        payload: Prisma.$KontorPayload<ExtArgs>
        fields: Prisma.KontorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KontorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KontorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          findFirst: {
            args: Prisma.KontorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KontorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          findMany: {
            args: Prisma.KontorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>[]
          }
          create: {
            args: Prisma.KontorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          createMany: {
            args: Prisma.KontorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KontorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          update: {
            args: Prisma.KontorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          deleteMany: {
            args: Prisma.KontorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KontorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KontorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          aggregate: {
            args: Prisma.KontorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKontor>
          }
          groupBy: {
            args: Prisma.KontorGroupByArgs<ExtArgs>
            result: $Utils.Optional<KontorGroupByOutputType>[]
          }
          count: {
            args: Prisma.KontorCountArgs<ExtArgs>
            result: $Utils.Optional<KontorCountAggregateOutputType> | number
          }
        }
      }
      Land: {
        payload: Prisma.$LandPayload<ExtArgs>
        fields: Prisma.LandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          findFirst: {
            args: Prisma.LandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          findMany: {
            args: Prisma.LandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>[]
          }
          create: {
            args: Prisma.LandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          createMany: {
            args: Prisma.LandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          update: {
            args: Prisma.LandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          deleteMany: {
            args: Prisma.LandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          aggregate: {
            args: Prisma.LandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand>
          }
          groupBy: {
            args: Prisma.LandGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandCountArgs<ExtArgs>
            result: $Utils.Optional<LandCountAggregateOutputType> | number
          }
        }
      }
      MeasuringTool: {
        payload: Prisma.$MeasuringToolPayload<ExtArgs>
        fields: Prisma.MeasuringToolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeasuringToolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeasuringToolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          findFirst: {
            args: Prisma.MeasuringToolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeasuringToolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          findMany: {
            args: Prisma.MeasuringToolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>[]
          }
          create: {
            args: Prisma.MeasuringToolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          createMany: {
            args: Prisma.MeasuringToolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeasuringToolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          update: {
            args: Prisma.MeasuringToolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          deleteMany: {
            args: Prisma.MeasuringToolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeasuringToolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeasuringToolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          aggregate: {
            args: Prisma.MeasuringToolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeasuringTool>
          }
          groupBy: {
            args: Prisma.MeasuringToolGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeasuringToolGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeasuringToolCountArgs<ExtArgs>
            result: $Utils.Optional<MeasuringToolCountAggregateOutputType> | number
          }
        }
      }
      NashtShabake: {
        payload: Prisma.$NashtShabakePayload<ExtArgs>
        fields: Prisma.NashtShabakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NashtShabakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NashtShabakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          findFirst: {
            args: Prisma.NashtShabakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NashtShabakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          findMany: {
            args: Prisma.NashtShabakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>[]
          }
          create: {
            args: Prisma.NashtShabakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          createMany: {
            args: Prisma.NashtShabakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NashtShabakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          update: {
            args: Prisma.NashtShabakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          deleteMany: {
            args: Prisma.NashtShabakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NashtShabakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NashtShabakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          aggregate: {
            args: Prisma.NashtShabakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNashtShabake>
          }
          groupBy: {
            args: Prisma.NashtShabakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NashtShabakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NashtShabakeCountArgs<ExtArgs>
            result: $Utils.Optional<NashtShabakeCountAggregateOutputType> | number
          }
        }
      }
      Network: {
        payload: Prisma.$NetworkPayload<ExtArgs>
        fields: Prisma.NetworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findFirst: {
            args: Prisma.NetworkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findMany: {
            args: Prisma.NetworkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>[]
          }
          create: {
            args: Prisma.NetworkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          createMany: {
            args: Prisma.NetworkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NetworkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          update: {
            args: Prisma.NetworkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          deleteMany: {
            args: Prisma.NetworkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NetworkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          aggregate: {
            args: Prisma.NetworkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetwork>
          }
          groupBy: {
            args: Prisma.NetworkGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkCountAggregateOutputType> | number
          }
        }
      }
      NoeKesht: {
        payload: Prisma.$NoeKeshtPayload<ExtArgs>
        fields: Prisma.NoeKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoeKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoeKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          findFirst: {
            args: Prisma.NoeKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoeKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          findMany: {
            args: Prisma.NoeKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>[]
          }
          create: {
            args: Prisma.NoeKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          createMany: {
            args: Prisma.NoeKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoeKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          update: {
            args: Prisma.NoeKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          deleteMany: {
            args: Prisma.NoeKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoeKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoeKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          aggregate: {
            args: Prisma.NoeKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoeKesht>
          }
          groupBy: {
            args: Prisma.NoeKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoeKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoeKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<NoeKeshtCountAggregateOutputType> | number
          }
        }
      }
      NoeMahsool: {
        payload: Prisma.$NoeMahsoolPayload<ExtArgs>
        fields: Prisma.NoeMahsoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoeMahsoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoeMahsoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          findFirst: {
            args: Prisma.NoeMahsoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoeMahsoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          findMany: {
            args: Prisma.NoeMahsoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>[]
          }
          create: {
            args: Prisma.NoeMahsoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          createMany: {
            args: Prisma.NoeMahsoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoeMahsoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          update: {
            args: Prisma.NoeMahsoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          deleteMany: {
            args: Prisma.NoeMahsoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoeMahsoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoeMahsoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          aggregate: {
            args: Prisma.NoeMahsoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoeMahsool>
          }
          groupBy: {
            args: Prisma.NoeMahsoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoeMahsoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoeMahsoolCountArgs<ExtArgs>
            result: $Utils.Optional<NoeMahsoolCountAggregateOutputType> | number
          }
        }
      }
      NonFIT: {
        payload: Prisma.$NonFITPayload<ExtArgs>
        fields: Prisma.NonFITFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonFITFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonFITFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          findFirst: {
            args: Prisma.NonFITFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonFITFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          findMany: {
            args: Prisma.NonFITFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>[]
          }
          create: {
            args: Prisma.NonFITCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          createMany: {
            args: Prisma.NonFITCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NonFITDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          update: {
            args: Prisma.NonFITUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          deleteMany: {
            args: Prisma.NonFITDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonFITUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NonFITUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          aggregate: {
            args: Prisma.NonFITAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonFIT>
          }
          groupBy: {
            args: Prisma.NonFITGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonFITGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonFITCountArgs<ExtArgs>
            result: $Utils.Optional<NonFITCountAggregateOutputType> | number
          }
        }
      }
      PumpStation: {
        payload: Prisma.$PumpStationPayload<ExtArgs>
        fields: Prisma.PumpStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PumpStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PumpStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          findFirst: {
            args: Prisma.PumpStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PumpStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          findMany: {
            args: Prisma.PumpStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>[]
          }
          create: {
            args: Prisma.PumpStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          createMany: {
            args: Prisma.PumpStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PumpStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          update: {
            args: Prisma.PumpStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          deleteMany: {
            args: Prisma.PumpStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PumpStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PumpStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          aggregate: {
            args: Prisma.PumpStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePumpStation>
          }
          groupBy: {
            args: Prisma.PumpStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PumpStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PumpStationCountArgs<ExtArgs>
            result: $Utils.Optional<PumpStationCountAggregateOutputType> | number
          }
        }
      }
      PumpType: {
        payload: Prisma.$PumpTypePayload<ExtArgs>
        fields: Prisma.PumpTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PumpTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PumpTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          findFirst: {
            args: Prisma.PumpTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PumpTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          findMany: {
            args: Prisma.PumpTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>[]
          }
          create: {
            args: Prisma.PumpTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          createMany: {
            args: Prisma.PumpTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PumpTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          update: {
            args: Prisma.PumpTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          deleteMany: {
            args: Prisma.PumpTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PumpTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PumpTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          aggregate: {
            args: Prisma.PumpTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePumpType>
          }
          groupBy: {
            args: Prisma.PumpTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PumpTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PumpTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PumpTypeCountAggregateOutputType> | number
          }
        }
      }
      RainfallStation: {
        payload: Prisma.$RainfallStationPayload<ExtArgs>
        fields: Prisma.RainfallStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainfallStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainfallStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          findFirst: {
            args: Prisma.RainfallStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainfallStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          findMany: {
            args: Prisma.RainfallStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>[]
          }
          create: {
            args: Prisma.RainfallStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          createMany: {
            args: Prisma.RainfallStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RainfallStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          update: {
            args: Prisma.RainfallStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          deleteMany: {
            args: Prisma.RainfallStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainfallStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainfallStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          aggregate: {
            args: Prisma.RainfallStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainfallStation>
          }
          groupBy: {
            args: Prisma.RainfallStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainfallStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainfallStationCountArgs<ExtArgs>
            result: $Utils.Optional<RainfallStationCountAggregateOutputType> | number
          }
        }
      }
      RainfallType: {
        payload: Prisma.$RainfallTypePayload<ExtArgs>
        fields: Prisma.RainfallTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainfallTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainfallTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          findFirst: {
            args: Prisma.RainfallTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainfallTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          findMany: {
            args: Prisma.RainfallTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>[]
          }
          create: {
            args: Prisma.RainfallTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          createMany: {
            args: Prisma.RainfallTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RainfallTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          update: {
            args: Prisma.RainfallTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          deleteMany: {
            args: Prisma.RainfallTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainfallTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainfallTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          aggregate: {
            args: Prisma.RainfallTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainfallType>
          }
          groupBy: {
            args: Prisma.RainfallTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainfallTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainfallTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RainfallTypeCountAggregateOutputType> | number
          }
        }
      }
      SaleZeraee: {
        payload: Prisma.$SaleZeraeePayload<ExtArgs>
        fields: Prisma.SaleZeraeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleZeraeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleZeraeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          findFirst: {
            args: Prisma.SaleZeraeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleZeraeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          findMany: {
            args: Prisma.SaleZeraeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>[]
          }
          create: {
            args: Prisma.SaleZeraeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          createMany: {
            args: Prisma.SaleZeraeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaleZeraeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          update: {
            args: Prisma.SaleZeraeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          deleteMany: {
            args: Prisma.SaleZeraeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleZeraeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleZeraeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          aggregate: {
            args: Prisma.SaleZeraeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleZeraee>
          }
          groupBy: {
            args: Prisma.SaleZeraeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleZeraeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleZeraeeCountArgs<ExtArgs>
            result: $Utils.Optional<SaleZeraeeCountAggregateOutputType> | number
          }
        }
      }
      SeghliPump: {
        payload: Prisma.$SeghliPumpPayload<ExtArgs>
        fields: Prisma.SeghliPumpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeghliPumpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeghliPumpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          findFirst: {
            args: Prisma.SeghliPumpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeghliPumpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          findMany: {
            args: Prisma.SeghliPumpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>[]
          }
          create: {
            args: Prisma.SeghliPumpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          createMany: {
            args: Prisma.SeghliPumpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeghliPumpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          update: {
            args: Prisma.SeghliPumpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          deleteMany: {
            args: Prisma.SeghliPumpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeghliPumpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeghliPumpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          aggregate: {
            args: Prisma.SeghliPumpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeghliPump>
          }
          groupBy: {
            args: Prisma.SeghliPumpGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeghliPumpGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeghliPumpCountArgs<ExtArgs>
            result: $Utils.Optional<SeghliPumpCountAggregateOutputType> | number
          }
        }
      }
      SystemPart: {
        payload: Prisma.$SystemPartPayload<ExtArgs>
        fields: Prisma.SystemPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          findFirst: {
            args: Prisma.SystemPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          findMany: {
            args: Prisma.SystemPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>[]
          }
          create: {
            args: Prisma.SystemPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          createMany: {
            args: Prisma.SystemPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          update: {
            args: Prisma.SystemPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          deleteMany: {
            args: Prisma.SystemPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          aggregate: {
            args: Prisma.SystemPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemPart>
          }
          groupBy: {
            args: Prisma.SystemPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemPartCountArgs<ExtArgs>
            result: $Utils.Optional<SystemPartCountAggregateOutputType> | number
          }
        }
      }
      TakhlieMakhzan: {
        payload: Prisma.$TakhlieMakhzanPayload<ExtArgs>
        fields: Prisma.TakhlieMakhzanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakhlieMakhzanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          findFirst: {
            args: Prisma.TakhlieMakhzanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          findMany: {
            args: Prisma.TakhlieMakhzanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>[]
          }
          create: {
            args: Prisma.TakhlieMakhzanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          createMany: {
            args: Prisma.TakhlieMakhzanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TakhlieMakhzanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          update: {
            args: Prisma.TakhlieMakhzanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          deleteMany: {
            args: Prisma.TakhlieMakhzanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakhlieMakhzanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TakhlieMakhzanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          aggregate: {
            args: Prisma.TakhlieMakhzanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakhlieMakhzan>
          }
          groupBy: {
            args: Prisma.TakhlieMakhzanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakhlieMakhzanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakhlieMakhzanCountArgs<ExtArgs>
            result: $Utils.Optional<TakhlieMakhzanCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TrikhDoreKesht: {
        payload: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
        fields: Prisma.TrikhDoreKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrikhDoreKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          findFirst: {
            args: Prisma.TrikhDoreKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          findMany: {
            args: Prisma.TrikhDoreKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>[]
          }
          create: {
            args: Prisma.TrikhDoreKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          createMany: {
            args: Prisma.TrikhDoreKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrikhDoreKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          update: {
            args: Prisma.TrikhDoreKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          deleteMany: {
            args: Prisma.TrikhDoreKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrikhDoreKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrikhDoreKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          aggregate: {
            args: Prisma.TrikhDoreKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrikhDoreKesht>
          }
          groupBy: {
            args: Prisma.TrikhDoreKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrikhDoreKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrikhDoreKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<TrikhDoreKeshtCountAggregateOutputType> | number
          }
        }
      }
      WeatherStation: {
        payload: Prisma.$WeatherStationPayload<ExtArgs>
        fields: Prisma.WeatherStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          findFirst: {
            args: Prisma.WeatherStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          findMany: {
            args: Prisma.WeatherStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>[]
          }
          create: {
            args: Prisma.WeatherStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          createMany: {
            args: Prisma.WeatherStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeatherStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          update: {
            args: Prisma.WeatherStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          deleteMany: {
            args: Prisma.WeatherStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeatherStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          aggregate: {
            args: Prisma.WeatherStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherStation>
          }
          groupBy: {
            args: Prisma.WeatherStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherStationCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherStationCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      MahShamsi: {
        payload: Prisma.$MahShamsiPayload<ExtArgs>
        fields: Prisma.MahShamsiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MahShamsiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MahShamsiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          findFirst: {
            args: Prisma.MahShamsiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MahShamsiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          findMany: {
            args: Prisma.MahShamsiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>[]
          }
          create: {
            args: Prisma.MahShamsiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          createMany: {
            args: Prisma.MahShamsiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MahShamsiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          update: {
            args: Prisma.MahShamsiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          deleteMany: {
            args: Prisma.MahShamsiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MahShamsiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MahShamsiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahShamsiPayload>
          }
          aggregate: {
            args: Prisma.MahShamsiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMahShamsi>
          }
          groupBy: {
            args: Prisma.MahShamsiGroupByArgs<ExtArgs>
            result: $Utils.Optional<MahShamsiGroupByOutputType>[]
          }
          count: {
            args: Prisma.MahShamsiCountArgs<ExtArgs>
            result: $Utils.Optional<MahShamsiCountAggregateOutputType> | number
          }
        }
      }
      ShabakeDoreKesht: {
        payload: Prisma.$ShabakeDoreKeshtPayload<ExtArgs>
        fields: Prisma.ShabakeDoreKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShabakeDoreKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShabakeDoreKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          findFirst: {
            args: Prisma.ShabakeDoreKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShabakeDoreKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          findMany: {
            args: Prisma.ShabakeDoreKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>[]
          }
          create: {
            args: Prisma.ShabakeDoreKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          createMany: {
            args: Prisma.ShabakeDoreKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShabakeDoreKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          update: {
            args: Prisma.ShabakeDoreKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          deleteMany: {
            args: Prisma.ShabakeDoreKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShabakeDoreKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShabakeDoreKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShabakeDoreKeshtPayload>
          }
          aggregate: {
            args: Prisma.ShabakeDoreKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShabakeDoreKesht>
          }
          groupBy: {
            args: Prisma.ShabakeDoreKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShabakeDoreKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShabakeDoreKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<ShabakeDoreKeshtCountAggregateOutputType> | number
          }
        }
      }
      TaeedProgram: {
        payload: Prisma.$TaeedProgramPayload<ExtArgs>
        fields: Prisma.TaeedProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaeedProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaeedProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          findFirst: {
            args: Prisma.TaeedProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaeedProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          findMany: {
            args: Prisma.TaeedProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>[]
          }
          create: {
            args: Prisma.TaeedProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          createMany: {
            args: Prisma.TaeedProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaeedProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          update: {
            args: Prisma.TaeedProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          deleteMany: {
            args: Prisma.TaeedProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaeedProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaeedProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaeedProgramPayload>
          }
          aggregate: {
            args: Prisma.TaeedProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaeedProgram>
          }
          groupBy: {
            args: Prisma.TaeedProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaeedProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaeedProgramCountArgs<ExtArgs>
            result: $Utils.Optional<TaeedProgramCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    abadeMakhzan?: AbadeMakhzanOmit
    abgir?: AbgirOmit
    bahrebardairProgram?: BahrebardairProgramOmit
    bahrebardairProgramSeghli?: BahrebardairProgramSeghliOmit
    bahrebardariKeshtDore?: BahrebardariKeshtDoreOmit
    bahrebardariTaghvim?: BahrebardariTaghvimOmit
    bareshMotaleat?: BareshMotaleatOmit
    darajePipe?: DarajePipeOmit
    deliveryPoints?: DeliveryPointsOmit
    darjeStation?: DarjeStationOmit
    doreKesht?: DoreKeshtOmit
    eshtebahAvamel?: EshtebahAvamelOmit
    flowBehbood?: FlowBehboodOmit
    flowmeter?: FlowmeterOmit
    khatRanesh?: KhatRaneshOmit
    khatRaneshArea?: KhatRaneshAreaOmit
    khatRaneshPump?: KhatRaneshPumpOmit
    khatRaneshSegli?: KhatRaneshSegliOmit
    kontor?: KontorOmit
    land?: LandOmit
    measuringTool?: MeasuringToolOmit
    nashtShabake?: NashtShabakeOmit
    network?: NetworkOmit
    noeKesht?: NoeKeshtOmit
    noeMahsool?: NoeMahsoolOmit
    nonFIT?: NonFITOmit
    pumpStation?: PumpStationOmit
    pumpType?: PumpTypeOmit
    rainfallStation?: RainfallStationOmit
    rainfallType?: RainfallTypeOmit
    saleZeraee?: SaleZeraeeOmit
    seghliPump?: SeghliPumpOmit
    systemPart?: SystemPartOmit
    takhlieMakhzan?: TakhlieMakhzanOmit
    test?: TestOmit
    trikhDoreKesht?: TrikhDoreKeshtOmit
    weatherStation?: WeatherStationOmit
    sysdiagrams?: sysdiagramsOmit
    mahShamsi?: MahShamsiOmit
    shabakeDoreKesht?: ShabakeDoreKeshtOmit
    taeedProgram?: TaeedProgramOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AbadeMakhzanCountOutputType
   */

  export type AbadeMakhzanCountOutputType = {
    PumpStation: number
  }

  export type AbadeMakhzanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStation?: boolean | AbadeMakhzanCountOutputTypeCountPumpStationArgs
  }

  // Custom InputTypes
  /**
   * AbadeMakhzanCountOutputType without action
   */
  export type AbadeMakhzanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzanCountOutputType
     */
    select?: AbadeMakhzanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbadeMakhzanCountOutputType without action
   */
  export type AbadeMakhzanCountOutputTypeCountPumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
  }


  /**
   * Count Type AbgirCountOutputType
   */

  export type AbgirCountOutputType = {
    Kontor: number
  }

  export type AbgirCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Kontor?: boolean | AbgirCountOutputTypeCountKontorArgs
  }

  // Custom InputTypes
  /**
   * AbgirCountOutputType without action
   */
  export type AbgirCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbgirCountOutputType
     */
    select?: AbgirCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbgirCountOutputType without action
   */
  export type AbgirCountOutputTypeCountKontorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorWhereInput
  }


  /**
   * Count Type DarajePipeCountOutputType
   */

  export type DarajePipeCountOutputType = {
    KhatRanesh: number
  }

  export type DarajePipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | DarajePipeCountOutputTypeCountKhatRaneshArgs
  }

  // Custom InputTypes
  /**
   * DarajePipeCountOutputType without action
   */
  export type DarajePipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipeCountOutputType
     */
    select?: DarajePipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DarajePipeCountOutputType without action
   */
  export type DarajePipeCountOutputTypeCountKhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
  }


  /**
   * Count Type DeliveryPointsCountOutputType
   */

  export type DeliveryPointsCountOutputType = {
    PumpStations: number
  }

  export type DeliveryPointsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStations?: boolean | DeliveryPointsCountOutputTypeCountPumpStationsArgs
  }

  // Custom InputTypes
  /**
   * DeliveryPointsCountOutputType without action
   */
  export type DeliveryPointsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPointsCountOutputType
     */
    select?: DeliveryPointsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryPointsCountOutputType without action
   */
  export type DeliveryPointsCountOutputTypeCountPumpStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
  }


  /**
   * Count Type DarjeStationCountOutputType
   */

  export type DarjeStationCountOutputType = {
    PumpStation: number
  }

  export type DarjeStationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStation?: boolean | DarjeStationCountOutputTypeCountPumpStationArgs
  }

  // Custom InputTypes
  /**
   * DarjeStationCountOutputType without action
   */
  export type DarjeStationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStationCountOutputType
     */
    select?: DarjeStationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DarjeStationCountOutputType without action
   */
  export type DarjeStationCountOutputTypeCountPumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
  }


  /**
   * Count Type DoreKeshtCountOutputType
   */

  export type DoreKeshtCountOutputType = {
    ShabakeDoreKesht: number
    TrikhDoreKesht: number
  }

  export type DoreKeshtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShabakeDoreKesht?: boolean | DoreKeshtCountOutputTypeCountShabakeDoreKeshtArgs
    TrikhDoreKesht?: boolean | DoreKeshtCountOutputTypeCountTrikhDoreKeshtArgs
  }

  // Custom InputTypes
  /**
   * DoreKeshtCountOutputType without action
   */
  export type DoreKeshtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKeshtCountOutputType
     */
    select?: DoreKeshtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoreKeshtCountOutputType without action
   */
  export type DoreKeshtCountOutputTypeCountShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShabakeDoreKeshtWhereInput
  }

  /**
   * DoreKeshtCountOutputType without action
   */
  export type DoreKeshtCountOutputTypeCountTrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrikhDoreKeshtWhereInput
  }


  /**
   * Count Type KhatRaneshCountOutputType
   */

  export type KhatRaneshCountOutputType = {
    Abgir: number
    BahrebardairProgram: number
    BahrebardairProgramSeghli: number
    BahrebardariKeshtDore: number
    BahrebardariTaghvim: number
    EshtebahAvamel: number
    FlowBehbood: number
    Flowmeter: number
    KhatRaneshArea: number
    KhatRaneshPump: number
    KhatRaneshSegli: number
    NashtShabake: number
    NonFIT: number
    TakhlieMakhzan: number
    Test: number
  }

  export type KhatRaneshCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Abgir?: boolean | KhatRaneshCountOutputTypeCountAbgirArgs
    BahrebardairProgram?: boolean | KhatRaneshCountOutputTypeCountBahrebardairProgramArgs
    BahrebardairProgramSeghli?: boolean | KhatRaneshCountOutputTypeCountBahrebardairProgramSeghliArgs
    BahrebardariKeshtDore?: boolean | KhatRaneshCountOutputTypeCountBahrebardariKeshtDoreArgs
    BahrebardariTaghvim?: boolean | KhatRaneshCountOutputTypeCountBahrebardariTaghvimArgs
    EshtebahAvamel?: boolean | KhatRaneshCountOutputTypeCountEshtebahAvamelArgs
    FlowBehbood?: boolean | KhatRaneshCountOutputTypeCountFlowBehboodArgs
    Flowmeter?: boolean | KhatRaneshCountOutputTypeCountFlowmeterArgs
    KhatRaneshArea?: boolean | KhatRaneshCountOutputTypeCountKhatRaneshAreaArgs
    KhatRaneshPump?: boolean | KhatRaneshCountOutputTypeCountKhatRaneshPumpArgs
    KhatRaneshSegli?: boolean | KhatRaneshCountOutputTypeCountKhatRaneshSegliArgs
    NashtShabake?: boolean | KhatRaneshCountOutputTypeCountNashtShabakeArgs
    NonFIT?: boolean | KhatRaneshCountOutputTypeCountNonFITArgs
    TakhlieMakhzan?: boolean | KhatRaneshCountOutputTypeCountTakhlieMakhzanArgs
    Test?: boolean | KhatRaneshCountOutputTypeCountTestArgs
  }

  // Custom InputTypes
  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshCountOutputType
     */
    select?: KhatRaneshCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountAbgirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbgirWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountBahrebardairProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountBahrebardairProgramSeghliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramSeghliWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountBahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariKeshtDoreWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountBahrebardariTaghvimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariTaghvimWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountEshtebahAvamelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EshtebahAvamelWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountFlowBehboodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowBehboodWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountFlowmeterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowmeterWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountKhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshAreaWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountKhatRaneshPumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshPumpWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountKhatRaneshSegliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshSegliWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountNashtShabakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NashtShabakeWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountNonFITArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonFITWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountTakhlieMakhzanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakhlieMakhzanWhereInput
  }

  /**
   * KhatRaneshCountOutputType without action
   */
  export type KhatRaneshCountOutputTypeCountTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
  }


  /**
   * Count Type LandCountOutputType
   */

  export type LandCountOutputType = {
    KhatRaneshArea: number
  }

  export type LandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRaneshArea?: boolean | LandCountOutputTypeCountKhatRaneshAreaArgs
  }

  // Custom InputTypes
  /**
   * LandCountOutputType without action
   */
  export type LandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandCountOutputType
     */
    select?: LandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandCountOutputType without action
   */
  export type LandCountOutputTypeCountKhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshAreaWhereInput
  }


  /**
   * Count Type MeasuringToolCountOutputType
   */

  export type MeasuringToolCountOutputType = {
    KhatRanesh: number
  }

  export type MeasuringToolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | MeasuringToolCountOutputTypeCountKhatRaneshArgs
  }

  // Custom InputTypes
  /**
   * MeasuringToolCountOutputType without action
   */
  export type MeasuringToolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringToolCountOutputType
     */
    select?: MeasuringToolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeasuringToolCountOutputType without action
   */
  export type MeasuringToolCountOutputTypeCountKhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
  }


  /**
   * Count Type NetworkCountOutputType
   */

  export type NetworkCountOutputType = {
    BareshMotaleat: number
    KhatRaneshArea: number
    PumpStation: number
    ShabakeDoreKesht: number
  }

  export type NetworkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BareshMotaleat?: boolean | NetworkCountOutputTypeCountBareshMotaleatArgs
    KhatRaneshArea?: boolean | NetworkCountOutputTypeCountKhatRaneshAreaArgs
    PumpStation?: boolean | NetworkCountOutputTypeCountPumpStationArgs
    ShabakeDoreKesht?: boolean | NetworkCountOutputTypeCountShabakeDoreKeshtArgs
  }

  // Custom InputTypes
  /**
   * NetworkCountOutputType without action
   */
  export type NetworkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkCountOutputType
     */
    select?: NetworkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NetworkCountOutputType without action
   */
  export type NetworkCountOutputTypeCountBareshMotaleatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BareshMotaleatWhereInput
  }

  /**
   * NetworkCountOutputType without action
   */
  export type NetworkCountOutputTypeCountKhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshAreaWhereInput
  }

  /**
   * NetworkCountOutputType without action
   */
  export type NetworkCountOutputTypeCountPumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
  }

  /**
   * NetworkCountOutputType without action
   */
  export type NetworkCountOutputTypeCountShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShabakeDoreKeshtWhereInput
  }


  /**
   * Count Type NoeKeshtCountOutputType
   */

  export type NoeKeshtCountOutputType = {
    NoeMahsool: number
  }

  export type NoeKeshtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NoeMahsool?: boolean | NoeKeshtCountOutputTypeCountNoeMahsoolArgs
  }

  // Custom InputTypes
  /**
   * NoeKeshtCountOutputType without action
   */
  export type NoeKeshtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKeshtCountOutputType
     */
    select?: NoeKeshtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoeKeshtCountOutputType without action
   */
  export type NoeKeshtCountOutputTypeCountNoeMahsoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoeMahsoolWhereInput
  }


  /**
   * Count Type NoeMahsoolCountOutputType
   */

  export type NoeMahsoolCountOutputType = {
    BahrebardariKeshtDore: number
  }

  export type NoeMahsoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardariKeshtDore?: boolean | NoeMahsoolCountOutputTypeCountBahrebardariKeshtDoreArgs
  }

  // Custom InputTypes
  /**
   * NoeMahsoolCountOutputType without action
   */
  export type NoeMahsoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsoolCountOutputType
     */
    select?: NoeMahsoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoeMahsoolCountOutputType without action
   */
  export type NoeMahsoolCountOutputTypeCountBahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariKeshtDoreWhereInput
  }


  /**
   * Count Type PumpStationCountOutputType
   */

  export type PumpStationCountOutputType = {
    KhatRanesh: number
  }

  export type PumpStationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | PumpStationCountOutputTypeCountKhatRaneshArgs
  }

  // Custom InputTypes
  /**
   * PumpStationCountOutputType without action
   */
  export type PumpStationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStationCountOutputType
     */
    select?: PumpStationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PumpStationCountOutputType without action
   */
  export type PumpStationCountOutputTypeCountKhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
  }


  /**
   * Count Type PumpTypeCountOutputType
   */

  export type PumpTypeCountOutputType = {
    KhatRaneshPump: number
  }

  export type PumpTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRaneshPump?: boolean | PumpTypeCountOutputTypeCountKhatRaneshPumpArgs
  }

  // Custom InputTypes
  /**
   * PumpTypeCountOutputType without action
   */
  export type PumpTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpTypeCountOutputType
     */
    select?: PumpTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PumpTypeCountOutputType without action
   */
  export type PumpTypeCountOutputTypeCountKhatRaneshPumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshPumpWhereInput
  }


  /**
   * Count Type RainfallTypeCountOutputType
   */

  export type RainfallTypeCountOutputType = {
    RainfallStation: number
  }

  export type RainfallTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainfallStation?: boolean | RainfallTypeCountOutputTypeCountRainfallStationArgs
  }

  // Custom InputTypes
  /**
   * RainfallTypeCountOutputType without action
   */
  export type RainfallTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallTypeCountOutputType
     */
    select?: RainfallTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RainfallTypeCountOutputType without action
   */
  export type RainfallTypeCountOutputTypeCountRainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallStationWhereInput
  }


  /**
   * Count Type SaleZeraeeCountOutputType
   */

  export type SaleZeraeeCountOutputType = {
    ShabakeDoreKesht: number
    TrikhDoreKesht: number
  }

  export type SaleZeraeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShabakeDoreKesht?: boolean | SaleZeraeeCountOutputTypeCountShabakeDoreKeshtArgs
    TrikhDoreKesht?: boolean | SaleZeraeeCountOutputTypeCountTrikhDoreKeshtArgs
  }

  // Custom InputTypes
  /**
   * SaleZeraeeCountOutputType without action
   */
  export type SaleZeraeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraeeCountOutputType
     */
    select?: SaleZeraeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleZeraeeCountOutputType without action
   */
  export type SaleZeraeeCountOutputTypeCountShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShabakeDoreKeshtWhereInput
  }

  /**
   * SaleZeraeeCountOutputType without action
   */
  export type SaleZeraeeCountOutputTypeCountTrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrikhDoreKeshtWhereInput
  }


  /**
   * Count Type SeghliPumpCountOutputType
   */

  export type SeghliPumpCountOutputType = {
    KhatRanesh: number
  }

  export type SeghliPumpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | SeghliPumpCountOutputTypeCountKhatRaneshArgs
  }

  // Custom InputTypes
  /**
   * SeghliPumpCountOutputType without action
   */
  export type SeghliPumpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPumpCountOutputType
     */
    select?: SeghliPumpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeghliPumpCountOutputType without action
   */
  export type SeghliPumpCountOutputTypeCountKhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
  }


  /**
   * Count Type SystemPartCountOutputType
   */

  export type SystemPartCountOutputType = {
    Network: number
  }

  export type SystemPartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Network?: boolean | SystemPartCountOutputTypeCountNetworkArgs
  }

  // Custom InputTypes
  /**
   * SystemPartCountOutputType without action
   */
  export type SystemPartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPartCountOutputType
     */
    select?: SystemPartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemPartCountOutputType without action
   */
  export type SystemPartCountOutputTypeCountNetworkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
  }


  /**
   * Count Type TrikhDoreKeshtCountOutputType
   */

  export type TrikhDoreKeshtCountOutputType = {
    BahrebardairProgram: number
    BahrebardairProgramSeghli: number
    BahrebardariTaghvim: number
    EshtebahAvamel: number
    FlowBehbood: number
    Flowmeter: number
    Kontor: number
    NashtShabake: number
    NonFIT: number
    RainfallStation: number
    TakhlieMakhzan: number
    Test: number
  }

  export type TrikhDoreKeshtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardairProgram?: boolean | TrikhDoreKeshtCountOutputTypeCountBahrebardairProgramArgs
    BahrebardairProgramSeghli?: boolean | TrikhDoreKeshtCountOutputTypeCountBahrebardairProgramSeghliArgs
    BahrebardariTaghvim?: boolean | TrikhDoreKeshtCountOutputTypeCountBahrebardariTaghvimArgs
    EshtebahAvamel?: boolean | TrikhDoreKeshtCountOutputTypeCountEshtebahAvamelArgs
    FlowBehbood?: boolean | TrikhDoreKeshtCountOutputTypeCountFlowBehboodArgs
    Flowmeter?: boolean | TrikhDoreKeshtCountOutputTypeCountFlowmeterArgs
    Kontor?: boolean | TrikhDoreKeshtCountOutputTypeCountKontorArgs
    NashtShabake?: boolean | TrikhDoreKeshtCountOutputTypeCountNashtShabakeArgs
    NonFIT?: boolean | TrikhDoreKeshtCountOutputTypeCountNonFITArgs
    RainfallStation?: boolean | TrikhDoreKeshtCountOutputTypeCountRainfallStationArgs
    TakhlieMakhzan?: boolean | TrikhDoreKeshtCountOutputTypeCountTakhlieMakhzanArgs
    Test?: boolean | TrikhDoreKeshtCountOutputTypeCountTestArgs
  }

  // Custom InputTypes
  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKeshtCountOutputType
     */
    select?: TrikhDoreKeshtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountBahrebardairProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountBahrebardairProgramSeghliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramSeghliWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountBahrebardariTaghvimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariTaghvimWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountEshtebahAvamelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EshtebahAvamelWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountFlowBehboodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowBehboodWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountFlowmeterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowmeterWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountKontorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountNashtShabakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NashtShabakeWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountNonFITArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonFITWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountRainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallStationWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountTakhlieMakhzanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakhlieMakhzanWhereInput
  }

  /**
   * TrikhDoreKeshtCountOutputType without action
   */
  export type TrikhDoreKeshtCountOutputTypeCountTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
  }


  /**
   * Count Type WeatherStationCountOutputType
   */

  export type WeatherStationCountOutputType = {
    RainfallStation: number
  }

  export type WeatherStationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainfallStation?: boolean | WeatherStationCountOutputTypeCountRainfallStationArgs
  }

  // Custom InputTypes
  /**
   * WeatherStationCountOutputType without action
   */
  export type WeatherStationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStationCountOutputType
     */
    select?: WeatherStationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeatherStationCountOutputType without action
   */
  export type WeatherStationCountOutputTypeCountRainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallStationWhereInput
  }


  /**
   * Count Type MahShamsiCountOutputType
   */

  export type MahShamsiCountOutputType = {
    BareshMotaleat: number
    TrikhDoreKesht: number
  }

  export type MahShamsiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BareshMotaleat?: boolean | MahShamsiCountOutputTypeCountBareshMotaleatArgs
    TrikhDoreKesht?: boolean | MahShamsiCountOutputTypeCountTrikhDoreKeshtArgs
  }

  // Custom InputTypes
  /**
   * MahShamsiCountOutputType without action
   */
  export type MahShamsiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsiCountOutputType
     */
    select?: MahShamsiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MahShamsiCountOutputType without action
   */
  export type MahShamsiCountOutputTypeCountBareshMotaleatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BareshMotaleatWhereInput
  }

  /**
   * MahShamsiCountOutputType without action
   */
  export type MahShamsiCountOutputTypeCountTrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrikhDoreKeshtWhereInput
  }


  /**
   * Count Type ShabakeDoreKeshtCountOutputType
   */

  export type ShabakeDoreKeshtCountOutputType = {
    BahrebardariKeshtDore: number
  }

  export type ShabakeDoreKeshtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardariKeshtDore?: boolean | ShabakeDoreKeshtCountOutputTypeCountBahrebardariKeshtDoreArgs
  }

  // Custom InputTypes
  /**
   * ShabakeDoreKeshtCountOutputType without action
   */
  export type ShabakeDoreKeshtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKeshtCountOutputType
     */
    select?: ShabakeDoreKeshtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShabakeDoreKeshtCountOutputType without action
   */
  export type ShabakeDoreKeshtCountOutputTypeCountBahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariKeshtDoreWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AbadeMakhzan
   */

  export type AggregateAbadeMakhzan = {
    _count: AbadeMakhzanCountAggregateOutputType | null
    _avg: AbadeMakhzanAvgAggregateOutputType | null
    _sum: AbadeMakhzanSumAggregateOutputType | null
    _min: AbadeMakhzanMinAggregateOutputType | null
    _max: AbadeMakhzanMaxAggregateOutputType | null
  }

  export type AbadeMakhzanAvgAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
  }

  export type AbadeMakhzanSumAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
  }

  export type AbadeMakhzanMinAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
    NameStation: string | null
  }

  export type AbadeMakhzanMaxAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
    NameStation: string | null
  }

  export type AbadeMakhzanCountAggregateOutputType = {
    IdMakhzan: number
    TooleBala: number
    ArzeBala: number
    TooleKaf: number
    ArzeKaf: number
    Omgh: number
    HajmMohasebat: number
    HadeaghalHajm: number
    NameStation: number
    _all: number
  }


  export type AbadeMakhzanAvgAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
  }

  export type AbadeMakhzanSumAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
  }

  export type AbadeMakhzanMinAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
  }

  export type AbadeMakhzanMaxAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
  }

  export type AbadeMakhzanCountAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
    _all?: true
  }

  export type AbadeMakhzanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbadeMakhzan to aggregate.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AbadeMakhzans
    **/
    _count?: true | AbadeMakhzanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbadeMakhzanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbadeMakhzanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbadeMakhzanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbadeMakhzanMaxAggregateInputType
  }

  export type GetAbadeMakhzanAggregateType<T extends AbadeMakhzanAggregateArgs> = {
        [P in keyof T & keyof AggregateAbadeMakhzan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbadeMakhzan[P]>
      : GetScalarType<T[P], AggregateAbadeMakhzan[P]>
  }




  export type AbadeMakhzanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbadeMakhzanWhereInput
    orderBy?: AbadeMakhzanOrderByWithAggregationInput | AbadeMakhzanOrderByWithAggregationInput[]
    by: AbadeMakhzanScalarFieldEnum[] | AbadeMakhzanScalarFieldEnum
    having?: AbadeMakhzanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbadeMakhzanCountAggregateInputType | true
    _avg?: AbadeMakhzanAvgAggregateInputType
    _sum?: AbadeMakhzanSumAggregateInputType
    _min?: AbadeMakhzanMinAggregateInputType
    _max?: AbadeMakhzanMaxAggregateInputType
  }

  export type AbadeMakhzanGroupByOutputType = {
    IdMakhzan: number
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal
    HadeaghalHajm: number | null
    NameStation: string
    _count: AbadeMakhzanCountAggregateOutputType | null
    _avg: AbadeMakhzanAvgAggregateOutputType | null
    _sum: AbadeMakhzanSumAggregateOutputType | null
    _min: AbadeMakhzanMinAggregateOutputType | null
    _max: AbadeMakhzanMaxAggregateOutputType | null
  }

  type GetAbadeMakhzanGroupByPayload<T extends AbadeMakhzanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbadeMakhzanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbadeMakhzanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbadeMakhzanGroupByOutputType[P]>
            : GetScalarType<T[P], AbadeMakhzanGroupByOutputType[P]>
        }
      >
    >


  export type AbadeMakhzanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMakhzan?: boolean
    TooleBala?: boolean
    ArzeBala?: boolean
    TooleKaf?: boolean
    ArzeKaf?: boolean
    Omgh?: boolean
    HajmMohasebat?: boolean
    HadeaghalHajm?: boolean
    NameStation?: boolean
    PumpStation?: boolean | AbadeMakhzan$PumpStationArgs<ExtArgs>
    _count?: boolean | AbadeMakhzanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abadeMakhzan"]>



  export type AbadeMakhzanSelectScalar = {
    IdMakhzan?: boolean
    TooleBala?: boolean
    ArzeBala?: boolean
    TooleKaf?: boolean
    ArzeKaf?: boolean
    Omgh?: boolean
    HajmMohasebat?: boolean
    HadeaghalHajm?: boolean
    NameStation?: boolean
  }

  export type AbadeMakhzanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMakhzan" | "TooleBala" | "ArzeBala" | "TooleKaf" | "ArzeKaf" | "Omgh" | "HajmMohasebat" | "HadeaghalHajm" | "NameStation", ExtArgs["result"]["abadeMakhzan"]>
  export type AbadeMakhzanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStation?: boolean | AbadeMakhzan$PumpStationArgs<ExtArgs>
    _count?: boolean | AbadeMakhzanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AbadeMakhzanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AbadeMakhzan"
    objects: {
      PumpStation: Prisma.$PumpStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdMakhzan: number
      TooleBala: Prisma.Decimal | null
      ArzeBala: Prisma.Decimal | null
      TooleKaf: Prisma.Decimal | null
      ArzeKaf: Prisma.Decimal | null
      Omgh: Prisma.Decimal | null
      HajmMohasebat: Prisma.Decimal
      HadeaghalHajm: number | null
      NameStation: string
    }, ExtArgs["result"]["abadeMakhzan"]>
    composites: {}
  }

  type AbadeMakhzanGetPayload<S extends boolean | null | undefined | AbadeMakhzanDefaultArgs> = $Result.GetResult<Prisma.$AbadeMakhzanPayload, S>

  type AbadeMakhzanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbadeMakhzanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbadeMakhzanCountAggregateInputType | true
    }

  export interface AbadeMakhzanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AbadeMakhzan'], meta: { name: 'AbadeMakhzan' } }
    /**
     * Find zero or one AbadeMakhzan that matches the filter.
     * @param {AbadeMakhzanFindUniqueArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbadeMakhzanFindUniqueArgs>(args: SelectSubset<T, AbadeMakhzanFindUniqueArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AbadeMakhzan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbadeMakhzanFindUniqueOrThrowArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbadeMakhzanFindUniqueOrThrowArgs>(args: SelectSubset<T, AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AbadeMakhzan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindFirstArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbadeMakhzanFindFirstArgs>(args?: SelectSubset<T, AbadeMakhzanFindFirstArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AbadeMakhzan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindFirstOrThrowArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbadeMakhzanFindFirstOrThrowArgs>(args?: SelectSubset<T, AbadeMakhzanFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AbadeMakhzans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AbadeMakhzans
     * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
     * 
     * // Get first 10 AbadeMakhzans
     * const abadeMakhzans = await prisma.abadeMakhzan.findMany({ take: 10 })
     * 
     * // Only select the `IdMakhzan`
     * const abadeMakhzanWithIdMakhzanOnly = await prisma.abadeMakhzan.findMany({ select: { IdMakhzan: true } })
     * 
     */
    findMany<T extends AbadeMakhzanFindManyArgs>(args?: SelectSubset<T, AbadeMakhzanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AbadeMakhzan.
     * @param {AbadeMakhzanCreateArgs} args - Arguments to create a AbadeMakhzan.
     * @example
     * // Create one AbadeMakhzan
     * const AbadeMakhzan = await prisma.abadeMakhzan.create({
     *   data: {
     *     // ... data to create a AbadeMakhzan
     *   }
     * })
     * 
     */
    create<T extends AbadeMakhzanCreateArgs>(args: SelectSubset<T, AbadeMakhzanCreateArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AbadeMakhzans.
     * @param {AbadeMakhzanCreateManyArgs} args - Arguments to create many AbadeMakhzans.
     * @example
     * // Create many AbadeMakhzans
     * const abadeMakhzan = await prisma.abadeMakhzan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbadeMakhzanCreateManyArgs>(args?: SelectSubset<T, AbadeMakhzanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AbadeMakhzan.
     * @param {AbadeMakhzanDeleteArgs} args - Arguments to delete one AbadeMakhzan.
     * @example
     * // Delete one AbadeMakhzan
     * const AbadeMakhzan = await prisma.abadeMakhzan.delete({
     *   where: {
     *     // ... filter to delete one AbadeMakhzan
     *   }
     * })
     * 
     */
    delete<T extends AbadeMakhzanDeleteArgs>(args: SelectSubset<T, AbadeMakhzanDeleteArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AbadeMakhzan.
     * @param {AbadeMakhzanUpdateArgs} args - Arguments to update one AbadeMakhzan.
     * @example
     * // Update one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbadeMakhzanUpdateArgs>(args: SelectSubset<T, AbadeMakhzanUpdateArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AbadeMakhzans.
     * @param {AbadeMakhzanDeleteManyArgs} args - Arguments to filter AbadeMakhzans to delete.
     * @example
     * // Delete a few AbadeMakhzans
     * const { count } = await prisma.abadeMakhzan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbadeMakhzanDeleteManyArgs>(args?: SelectSubset<T, AbadeMakhzanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbadeMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AbadeMakhzans
     * const abadeMakhzan = await prisma.abadeMakhzan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbadeMakhzanUpdateManyArgs>(args: SelectSubset<T, AbadeMakhzanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AbadeMakhzan.
     * @param {AbadeMakhzanUpsertArgs} args - Arguments to update or create a AbadeMakhzan.
     * @example
     * // Update or create a AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.upsert({
     *   create: {
     *     // ... data to create a AbadeMakhzan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AbadeMakhzan we want to update
     *   }
     * })
     */
    upsert<T extends AbadeMakhzanUpsertArgs>(args: SelectSubset<T, AbadeMakhzanUpsertArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AbadeMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanCountArgs} args - Arguments to filter AbadeMakhzans to count.
     * @example
     * // Count the number of AbadeMakhzans
     * const count = await prisma.abadeMakhzan.count({
     *   where: {
     *     // ... the filter for the AbadeMakhzans we want to count
     *   }
     * })
    **/
    count<T extends AbadeMakhzanCountArgs>(
      args?: Subset<T, AbadeMakhzanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbadeMakhzanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AbadeMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbadeMakhzanAggregateArgs>(args: Subset<T, AbadeMakhzanAggregateArgs>): Prisma.PrismaPromise<GetAbadeMakhzanAggregateType<T>>

    /**
     * Group by AbadeMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbadeMakhzanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbadeMakhzanGroupByArgs['orderBy'] }
        : { orderBy?: AbadeMakhzanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbadeMakhzanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbadeMakhzanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AbadeMakhzan model
   */
  readonly fields: AbadeMakhzanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AbadeMakhzan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbadeMakhzanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PumpStation<T extends AbadeMakhzan$PumpStationArgs<ExtArgs> = {}>(args?: Subset<T, AbadeMakhzan$PumpStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AbadeMakhzan model
   */ 
  interface AbadeMakhzanFieldRefs {
    readonly IdMakhzan: FieldRef<"AbadeMakhzan", 'Int'>
    readonly TooleBala: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly ArzeBala: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly TooleKaf: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly ArzeKaf: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly Omgh: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly HajmMohasebat: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly HadeaghalHajm: FieldRef<"AbadeMakhzan", 'Int'>
    readonly NameStation: FieldRef<"AbadeMakhzan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AbadeMakhzan findUnique
   */
  export type AbadeMakhzanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan findUniqueOrThrow
   */
  export type AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan findFirst
   */
  export type AbadeMakhzanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbadeMakhzans.
     */
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan findFirstOrThrow
   */
  export type AbadeMakhzanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbadeMakhzans.
     */
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan findMany
   */
  export type AbadeMakhzanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzans to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan create
   */
  export type AbadeMakhzanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * The data needed to create a AbadeMakhzan.
     */
    data: XOR<AbadeMakhzanCreateInput, AbadeMakhzanUncheckedCreateInput>
  }

  /**
   * AbadeMakhzan createMany
   */
  export type AbadeMakhzanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AbadeMakhzans.
     */
    data: AbadeMakhzanCreateManyInput | AbadeMakhzanCreateManyInput[]
  }

  /**
   * AbadeMakhzan update
   */
  export type AbadeMakhzanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * The data needed to update a AbadeMakhzan.
     */
    data: XOR<AbadeMakhzanUpdateInput, AbadeMakhzanUncheckedUpdateInput>
    /**
     * Choose, which AbadeMakhzan to update.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan updateMany
   */
  export type AbadeMakhzanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AbadeMakhzans.
     */
    data: XOR<AbadeMakhzanUpdateManyMutationInput, AbadeMakhzanUncheckedUpdateManyInput>
    /**
     * Filter which AbadeMakhzans to update
     */
    where?: AbadeMakhzanWhereInput
    /**
     * Limit how many AbadeMakhzans to update.
     */
    limit?: number
  }

  /**
   * AbadeMakhzan upsert
   */
  export type AbadeMakhzanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * The filter to search for the AbadeMakhzan to update in case it exists.
     */
    where: AbadeMakhzanWhereUniqueInput
    /**
     * In case the AbadeMakhzan found by the `where` argument doesn't exist, create a new AbadeMakhzan with this data.
     */
    create: XOR<AbadeMakhzanCreateInput, AbadeMakhzanUncheckedCreateInput>
    /**
     * In case the AbadeMakhzan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbadeMakhzanUpdateInput, AbadeMakhzanUncheckedUpdateInput>
  }

  /**
   * AbadeMakhzan delete
   */
  export type AbadeMakhzanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    /**
     * Filter which AbadeMakhzan to delete.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan deleteMany
   */
  export type AbadeMakhzanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbadeMakhzans to delete
     */
    where?: AbadeMakhzanWhereInput
    /**
     * Limit how many AbadeMakhzans to delete.
     */
    limit?: number
  }

  /**
   * AbadeMakhzan.PumpStation
   */
  export type AbadeMakhzan$PumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    cursor?: PumpStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan without action
   */
  export type AbadeMakhzanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
  }


  /**
   * Model Abgir
   */

  export type AggregateAbgir = {
    _count: AbgirCountAggregateOutputType | null
    _avg: AbgirAvgAggregateOutputType | null
    _sum: AbgirSumAggregateOutputType | null
    _min: AbgirMinAggregateOutputType | null
    _max: AbgirMaxAggregateOutputType | null
  }

  export type AbgirAvgAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
  }

  export type AbgirSumAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
  }

  export type AbgirMinAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
    Abgir: string | null
  }

  export type AbgirMaxAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
    Abgir: string | null
  }

  export type AbgirCountAggregateOutputType = {
    IdKontor: number
    FIdRanesh: number
    Abgir: number
    _all: number
  }


  export type AbgirAvgAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
  }

  export type AbgirSumAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
  }

  export type AbgirMinAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
  }

  export type AbgirMaxAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
  }

  export type AbgirCountAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
    _all?: true
  }

  export type AbgirAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abgir to aggregate.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abgirs
    **/
    _count?: true | AbgirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbgirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbgirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbgirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbgirMaxAggregateInputType
  }

  export type GetAbgirAggregateType<T extends AbgirAggregateArgs> = {
        [P in keyof T & keyof AggregateAbgir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbgir[P]>
      : GetScalarType<T[P], AggregateAbgir[P]>
  }




  export type AbgirGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbgirWhereInput
    orderBy?: AbgirOrderByWithAggregationInput | AbgirOrderByWithAggregationInput[]
    by: AbgirScalarFieldEnum[] | AbgirScalarFieldEnum
    having?: AbgirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbgirCountAggregateInputType | true
    _avg?: AbgirAvgAggregateInputType
    _sum?: AbgirSumAggregateInputType
    _min?: AbgirMinAggregateInputType
    _max?: AbgirMaxAggregateInputType
  }

  export type AbgirGroupByOutputType = {
    IdKontor: number
    FIdRanesh: number
    Abgir: string
    _count: AbgirCountAggregateOutputType | null
    _avg: AbgirAvgAggregateOutputType | null
    _sum: AbgirSumAggregateOutputType | null
    _min: AbgirMinAggregateOutputType | null
    _max: AbgirMaxAggregateOutputType | null
  }

  type GetAbgirGroupByPayload<T extends AbgirGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbgirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbgirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbgirGroupByOutputType[P]>
            : GetScalarType<T[P], AbgirGroupByOutputType[P]>
        }
      >
    >


  export type AbgirSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdKontor?: boolean
    FIdRanesh?: boolean
    Abgir?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    Kontor?: boolean | Abgir$KontorArgs<ExtArgs>
    _count?: boolean | AbgirCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abgir"]>



  export type AbgirSelectScalar = {
    IdKontor?: boolean
    FIdRanesh?: boolean
    Abgir?: boolean
  }

  export type AbgirOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdKontor" | "FIdRanesh" | "Abgir", ExtArgs["result"]["abgir"]>
  export type AbgirInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    Kontor?: boolean | Abgir$KontorArgs<ExtArgs>
    _count?: boolean | AbgirCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AbgirPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Abgir"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      Kontor: Prisma.$KontorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdKontor: number
      FIdRanesh: number
      Abgir: string
    }, ExtArgs["result"]["abgir"]>
    composites: {}
  }

  type AbgirGetPayload<S extends boolean | null | undefined | AbgirDefaultArgs> = $Result.GetResult<Prisma.$AbgirPayload, S>

  type AbgirCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbgirFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbgirCountAggregateInputType | true
    }

  export interface AbgirDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Abgir'], meta: { name: 'Abgir' } }
    /**
     * Find zero or one Abgir that matches the filter.
     * @param {AbgirFindUniqueArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbgirFindUniqueArgs>(args: SelectSubset<T, AbgirFindUniqueArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Abgir that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbgirFindUniqueOrThrowArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbgirFindUniqueOrThrowArgs>(args: SelectSubset<T, AbgirFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Abgir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindFirstArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbgirFindFirstArgs>(args?: SelectSubset<T, AbgirFindFirstArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Abgir that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindFirstOrThrowArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbgirFindFirstOrThrowArgs>(args?: SelectSubset<T, AbgirFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Abgirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abgirs
     * const abgirs = await prisma.abgir.findMany()
     * 
     * // Get first 10 Abgirs
     * const abgirs = await prisma.abgir.findMany({ take: 10 })
     * 
     * // Only select the `IdKontor`
     * const abgirWithIdKontorOnly = await prisma.abgir.findMany({ select: { IdKontor: true } })
     * 
     */
    findMany<T extends AbgirFindManyArgs>(args?: SelectSubset<T, AbgirFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Abgir.
     * @param {AbgirCreateArgs} args - Arguments to create a Abgir.
     * @example
     * // Create one Abgir
     * const Abgir = await prisma.abgir.create({
     *   data: {
     *     // ... data to create a Abgir
     *   }
     * })
     * 
     */
    create<T extends AbgirCreateArgs>(args: SelectSubset<T, AbgirCreateArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Abgirs.
     * @param {AbgirCreateManyArgs} args - Arguments to create many Abgirs.
     * @example
     * // Create many Abgirs
     * const abgir = await prisma.abgir.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbgirCreateManyArgs>(args?: SelectSubset<T, AbgirCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Abgir.
     * @param {AbgirDeleteArgs} args - Arguments to delete one Abgir.
     * @example
     * // Delete one Abgir
     * const Abgir = await prisma.abgir.delete({
     *   where: {
     *     // ... filter to delete one Abgir
     *   }
     * })
     * 
     */
    delete<T extends AbgirDeleteArgs>(args: SelectSubset<T, AbgirDeleteArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Abgir.
     * @param {AbgirUpdateArgs} args - Arguments to update one Abgir.
     * @example
     * // Update one Abgir
     * const abgir = await prisma.abgir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbgirUpdateArgs>(args: SelectSubset<T, AbgirUpdateArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Abgirs.
     * @param {AbgirDeleteManyArgs} args - Arguments to filter Abgirs to delete.
     * @example
     * // Delete a few Abgirs
     * const { count } = await prisma.abgir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbgirDeleteManyArgs>(args?: SelectSubset<T, AbgirDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abgirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abgirs
     * const abgir = await prisma.abgir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbgirUpdateManyArgs>(args: SelectSubset<T, AbgirUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Abgir.
     * @param {AbgirUpsertArgs} args - Arguments to update or create a Abgir.
     * @example
     * // Update or create a Abgir
     * const abgir = await prisma.abgir.upsert({
     *   create: {
     *     // ... data to create a Abgir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Abgir we want to update
     *   }
     * })
     */
    upsert<T extends AbgirUpsertArgs>(args: SelectSubset<T, AbgirUpsertArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Abgirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirCountArgs} args - Arguments to filter Abgirs to count.
     * @example
     * // Count the number of Abgirs
     * const count = await prisma.abgir.count({
     *   where: {
     *     // ... the filter for the Abgirs we want to count
     *   }
     * })
    **/
    count<T extends AbgirCountArgs>(
      args?: Subset<T, AbgirCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbgirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Abgir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbgirAggregateArgs>(args: Subset<T, AbgirAggregateArgs>): Prisma.PrismaPromise<GetAbgirAggregateType<T>>

    /**
     * Group by Abgir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbgirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbgirGroupByArgs['orderBy'] }
        : { orderBy?: AbgirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbgirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbgirGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Abgir model
   */
  readonly fields: AbgirFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Abgir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbgirClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Kontor<T extends Abgir$KontorArgs<ExtArgs> = {}>(args?: Subset<T, Abgir$KontorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Abgir model
   */ 
  interface AbgirFieldRefs {
    readonly IdKontor: FieldRef<"Abgir", 'Int'>
    readonly FIdRanesh: FieldRef<"Abgir", 'Int'>
    readonly Abgir: FieldRef<"Abgir", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Abgir findUnique
   */
  export type AbgirFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir findUniqueOrThrow
   */
  export type AbgirFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir findFirst
   */
  export type AbgirFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abgirs.
     */
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir findFirstOrThrow
   */
  export type AbgirFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abgirs.
     */
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir findMany
   */
  export type AbgirFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter, which Abgirs to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir create
   */
  export type AbgirCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * The data needed to create a Abgir.
     */
    data: XOR<AbgirCreateInput, AbgirUncheckedCreateInput>
  }

  /**
   * Abgir createMany
   */
  export type AbgirCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abgirs.
     */
    data: AbgirCreateManyInput | AbgirCreateManyInput[]
  }

  /**
   * Abgir update
   */
  export type AbgirUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * The data needed to update a Abgir.
     */
    data: XOR<AbgirUpdateInput, AbgirUncheckedUpdateInput>
    /**
     * Choose, which Abgir to update.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir updateMany
   */
  export type AbgirUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abgirs.
     */
    data: XOR<AbgirUpdateManyMutationInput, AbgirUncheckedUpdateManyInput>
    /**
     * Filter which Abgirs to update
     */
    where?: AbgirWhereInput
    /**
     * Limit how many Abgirs to update.
     */
    limit?: number
  }

  /**
   * Abgir upsert
   */
  export type AbgirUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * The filter to search for the Abgir to update in case it exists.
     */
    where: AbgirWhereUniqueInput
    /**
     * In case the Abgir found by the `where` argument doesn't exist, create a new Abgir with this data.
     */
    create: XOR<AbgirCreateInput, AbgirUncheckedCreateInput>
    /**
     * In case the Abgir was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbgirUpdateInput, AbgirUncheckedUpdateInput>
  }

  /**
   * Abgir delete
   */
  export type AbgirDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    /**
     * Filter which Abgir to delete.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir deleteMany
   */
  export type AbgirDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abgirs to delete
     */
    where?: AbgirWhereInput
    /**
     * Limit how many Abgirs to delete.
     */
    limit?: number
  }

  /**
   * Abgir.Kontor
   */
  export type Abgir$KontorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    where?: KontorWhereInput
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    cursor?: KontorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Abgir without action
   */
  export type AbgirDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
  }


  /**
   * Model BahrebardairProgram
   */

  export type AggregateBahrebardairProgram = {
    _count: BahrebardairProgramCountAggregateOutputType | null
    _avg: BahrebardairProgramAvgAggregateOutputType | null
    _sum: BahrebardairProgramSumAggregateOutputType | null
    _min: BahrebardairProgramMinAggregateOutputType | null
    _max: BahrebardairProgramMaxAggregateOutputType | null
  }

  export type BahrebardairProgramAvgAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
  }

  export type BahrebardairProgramSumAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
  }

  export type BahrebardairProgramMinAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramMaxAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramCountAggregateOutputType = {
    IdProgram: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe: number
    Paian: number
    _all: number
  }


  export type BahrebardairProgramAvgAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
  }

  export type BahrebardairProgramSumAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
  }

  export type BahrebardairProgramMinAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramMaxAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramCountAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
    _all?: true
  }

  export type BahrebardairProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairProgram to aggregate.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardairPrograms
    **/
    _count?: true | BahrebardairProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardairProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardairProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardairProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardairProgramMaxAggregateInputType
  }

  export type GetBahrebardairProgramAggregateType<T extends BahrebardairProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardairProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardairProgram[P]>
      : GetScalarType<T[P], AggregateBahrebardairProgram[P]>
  }




  export type BahrebardairProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramWhereInput
    orderBy?: BahrebardairProgramOrderByWithAggregationInput | BahrebardairProgramOrderByWithAggregationInput[]
    by: BahrebardairProgramScalarFieldEnum[] | BahrebardairProgramScalarFieldEnum
    having?: BahrebardairProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardairProgramCountAggregateInputType | true
    _avg?: BahrebardairProgramAvgAggregateInputType
    _sum?: BahrebardairProgramSumAggregateInputType
    _min?: BahrebardairProgramMinAggregateInputType
    _max?: BahrebardairProgramMaxAggregateInputType
  }

  export type BahrebardairProgramGroupByOutputType = {
    IdProgram: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe: Date | null
    Paian: Date | null
    _count: BahrebardairProgramCountAggregateOutputType | null
    _avg: BahrebardairProgramAvgAggregateOutputType | null
    _sum: BahrebardairProgramSumAggregateOutputType | null
    _min: BahrebardairProgramMinAggregateOutputType | null
    _max: BahrebardairProgramMaxAggregateOutputType | null
  }

  type GetBahrebardairProgramGroupByPayload<T extends BahrebardairProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardairProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardairProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardairProgramGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardairProgramGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardairProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdProgram?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Tedad?: boolean
    Shorooe?: boolean
    Paian?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahrebardairProgram"]>



  export type BahrebardairProgramSelectScalar = {
    IdProgram?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Tedad?: boolean
    Shorooe?: boolean
    Paian?: boolean
  }

  export type BahrebardairProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdProgram" | "FIdRanesh" | "FIdTarDor" | "Tedad" | "Shorooe" | "Paian", ExtArgs["result"]["bahrebardairProgram"]>
  export type BahrebardairProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $BahrebardairProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardairProgram"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdProgram: number
      FIdRanesh: number
      FIdTarDor: number
      Tedad: number
      Shorooe: Date | null
      Paian: Date | null
    }, ExtArgs["result"]["bahrebardairProgram"]>
    composites: {}
  }

  type BahrebardairProgramGetPayload<S extends boolean | null | undefined | BahrebardairProgramDefaultArgs> = $Result.GetResult<Prisma.$BahrebardairProgramPayload, S>

  type BahrebardairProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardairProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardairProgramCountAggregateInputType | true
    }

  export interface BahrebardairProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardairProgram'], meta: { name: 'BahrebardairProgram' } }
    /**
     * Find zero or one BahrebardairProgram that matches the filter.
     * @param {BahrebardairProgramFindUniqueArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardairProgramFindUniqueArgs>(args: SelectSubset<T, BahrebardairProgramFindUniqueArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardairProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardairProgramFindUniqueOrThrowArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardairProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindFirstArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardairProgramFindFirstArgs>(args?: SelectSubset<T, BahrebardairProgramFindFirstArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindFirstOrThrowArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardairProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardairProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardairPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardairPrograms
     * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany()
     * 
     * // Get first 10 BahrebardairPrograms
     * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany({ take: 10 })
     * 
     * // Only select the `IdProgram`
     * const bahrebardairProgramWithIdProgramOnly = await prisma.bahrebardairProgram.findMany({ select: { IdProgram: true } })
     * 
     */
    findMany<T extends BahrebardairProgramFindManyArgs>(args?: SelectSubset<T, BahrebardairProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardairProgram.
     * @param {BahrebardairProgramCreateArgs} args - Arguments to create a BahrebardairProgram.
     * @example
     * // Create one BahrebardairProgram
     * const BahrebardairProgram = await prisma.bahrebardairProgram.create({
     *   data: {
     *     // ... data to create a BahrebardairProgram
     *   }
     * })
     * 
     */
    create<T extends BahrebardairProgramCreateArgs>(args: SelectSubset<T, BahrebardairProgramCreateArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardairPrograms.
     * @param {BahrebardairProgramCreateManyArgs} args - Arguments to create many BahrebardairPrograms.
     * @example
     * // Create many BahrebardairPrograms
     * const bahrebardairProgram = await prisma.bahrebardairProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardairProgramCreateManyArgs>(args?: SelectSubset<T, BahrebardairProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardairProgram.
     * @param {BahrebardairProgramDeleteArgs} args - Arguments to delete one BahrebardairProgram.
     * @example
     * // Delete one BahrebardairProgram
     * const BahrebardairProgram = await prisma.bahrebardairProgram.delete({
     *   where: {
     *     // ... filter to delete one BahrebardairProgram
     *   }
     * })
     * 
     */
    delete<T extends BahrebardairProgramDeleteArgs>(args: SelectSubset<T, BahrebardairProgramDeleteArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardairProgram.
     * @param {BahrebardairProgramUpdateArgs} args - Arguments to update one BahrebardairProgram.
     * @example
     * // Update one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardairProgramUpdateArgs>(args: SelectSubset<T, BahrebardairProgramUpdateArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardairPrograms.
     * @param {BahrebardairProgramDeleteManyArgs} args - Arguments to filter BahrebardairPrograms to delete.
     * @example
     * // Delete a few BahrebardairPrograms
     * const { count } = await prisma.bahrebardairProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardairProgramDeleteManyArgs>(args?: SelectSubset<T, BahrebardairProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardairPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardairPrograms
     * const bahrebardairProgram = await prisma.bahrebardairProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardairProgramUpdateManyArgs>(args: SelectSubset<T, BahrebardairProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardairProgram.
     * @param {BahrebardairProgramUpsertArgs} args - Arguments to update or create a BahrebardairProgram.
     * @example
     * // Update or create a BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.upsert({
     *   create: {
     *     // ... data to create a BahrebardairProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardairProgram we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardairProgramUpsertArgs>(args: SelectSubset<T, BahrebardairProgramUpsertArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardairPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramCountArgs} args - Arguments to filter BahrebardairPrograms to count.
     * @example
     * // Count the number of BahrebardairPrograms
     * const count = await prisma.bahrebardairProgram.count({
     *   where: {
     *     // ... the filter for the BahrebardairPrograms we want to count
     *   }
     * })
    **/
    count<T extends BahrebardairProgramCountArgs>(
      args?: Subset<T, BahrebardairProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardairProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardairProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardairProgramAggregateArgs>(args: Subset<T, BahrebardairProgramAggregateArgs>): Prisma.PrismaPromise<GetBahrebardairProgramAggregateType<T>>

    /**
     * Group by BahrebardairProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardairProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardairProgramGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardairProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardairProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardairProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardairProgram model
   */
  readonly fields: BahrebardairProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardairProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardairProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardairProgram model
   */ 
  interface BahrebardairProgramFieldRefs {
    readonly IdProgram: FieldRef<"BahrebardairProgram", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardairProgram", 'Int'>
    readonly FIdTarDor: FieldRef<"BahrebardairProgram", 'Int'>
    readonly Tedad: FieldRef<"BahrebardairProgram", 'Int'>
    readonly Shorooe: FieldRef<"BahrebardairProgram", 'DateTime'>
    readonly Paian: FieldRef<"BahrebardairProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardairProgram findUnique
   */
  export type BahrebardairProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram findUniqueOrThrow
   */
  export type BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram findFirst
   */
  export type BahrebardairProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairPrograms.
     */
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram findFirstOrThrow
   */
  export type BahrebardairProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairPrograms.
     */
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram findMany
   */
  export type BahrebardairProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairPrograms to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram create
   */
  export type BahrebardairProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a BahrebardairProgram.
     */
    data: XOR<BahrebardairProgramCreateInput, BahrebardairProgramUncheckedCreateInput>
  }

  /**
   * BahrebardairProgram createMany
   */
  export type BahrebardairProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardairPrograms.
     */
    data: BahrebardairProgramCreateManyInput | BahrebardairProgramCreateManyInput[]
  }

  /**
   * BahrebardairProgram update
   */
  export type BahrebardairProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a BahrebardairProgram.
     */
    data: XOR<BahrebardairProgramUpdateInput, BahrebardairProgramUncheckedUpdateInput>
    /**
     * Choose, which BahrebardairProgram to update.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram updateMany
   */
  export type BahrebardairProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardairPrograms.
     */
    data: XOR<BahrebardairProgramUpdateManyMutationInput, BahrebardairProgramUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardairPrograms to update
     */
    where?: BahrebardairProgramWhereInput
    /**
     * Limit how many BahrebardairPrograms to update.
     */
    limit?: number
  }

  /**
   * BahrebardairProgram upsert
   */
  export type BahrebardairProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the BahrebardairProgram to update in case it exists.
     */
    where: BahrebardairProgramWhereUniqueInput
    /**
     * In case the BahrebardairProgram found by the `where` argument doesn't exist, create a new BahrebardairProgram with this data.
     */
    create: XOR<BahrebardairProgramCreateInput, BahrebardairProgramUncheckedCreateInput>
    /**
     * In case the BahrebardairProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardairProgramUpdateInput, BahrebardairProgramUncheckedUpdateInput>
  }

  /**
   * BahrebardairProgram delete
   */
  export type BahrebardairProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    /**
     * Filter which BahrebardairProgram to delete.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram deleteMany
   */
  export type BahrebardairProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairPrograms to delete
     */
    where?: BahrebardairProgramWhereInput
    /**
     * Limit how many BahrebardairPrograms to delete.
     */
    limit?: number
  }

  /**
   * BahrebardairProgram without action
   */
  export type BahrebardairProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
  }


  /**
   * Model BahrebardairProgramSeghli
   */

  export type AggregateBahrebardairProgramSeghli = {
    _count: BahrebardairProgramSeghliCountAggregateOutputType | null
    _avg: BahrebardairProgramSeghliAvgAggregateOutputType | null
    _sum: BahrebardairProgramSeghliSumAggregateOutputType | null
    _min: BahrebardairProgramSeghliMinAggregateOutputType | null
    _max: BahrebardairProgramSeghliMaxAggregateOutputType | null
  }

  export type BahrebardairProgramSeghliAvgAggregateOutputType = {
    IdProSrgl: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Zarfiat: Decimal | null
  }

  export type BahrebardairProgramSeghliSumAggregateOutputType = {
    IdProSrgl: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Zarfiat: Decimal | null
  }

  export type BahrebardairProgramSeghliMinAggregateOutputType = {
    IdProSrgl: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Zarfiat: Decimal | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramSeghliMaxAggregateOutputType = {
    IdProSrgl: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Zarfiat: Decimal | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramSeghliCountAggregateOutputType = {
    IdProSrgl: number
    FIdRanesh: number
    FIdTarDor: number
    Zarfiat: number
    Shorooe: number
    Paian: number
    _all: number
  }


  export type BahrebardairProgramSeghliAvgAggregateInputType = {
    IdProSrgl?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Zarfiat?: true
  }

  export type BahrebardairProgramSeghliSumAggregateInputType = {
    IdProSrgl?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Zarfiat?: true
  }

  export type BahrebardairProgramSeghliMinAggregateInputType = {
    IdProSrgl?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Zarfiat?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramSeghliMaxAggregateInputType = {
    IdProSrgl?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Zarfiat?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramSeghliCountAggregateInputType = {
    IdProSrgl?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Zarfiat?: true
    Shorooe?: true
    Paian?: true
    _all?: true
  }

  export type BahrebardairProgramSeghliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairProgramSeghli to aggregate.
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairProgramSeghlis to fetch.
     */
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairProgramSeghlis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairProgramSeghlis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardairProgramSeghlis
    **/
    _count?: true | BahrebardairProgramSeghliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardairProgramSeghliAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardairProgramSeghliSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardairProgramSeghliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardairProgramSeghliMaxAggregateInputType
  }

  export type GetBahrebardairProgramSeghliAggregateType<T extends BahrebardairProgramSeghliAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardairProgramSeghli]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardairProgramSeghli[P]>
      : GetScalarType<T[P], AggregateBahrebardairProgramSeghli[P]>
  }




  export type BahrebardairProgramSeghliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramSeghliWhereInput
    orderBy?: BahrebardairProgramSeghliOrderByWithAggregationInput | BahrebardairProgramSeghliOrderByWithAggregationInput[]
    by: BahrebardairProgramSeghliScalarFieldEnum[] | BahrebardairProgramSeghliScalarFieldEnum
    having?: BahrebardairProgramSeghliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardairProgramSeghliCountAggregateInputType | true
    _avg?: BahrebardairProgramSeghliAvgAggregateInputType
    _sum?: BahrebardairProgramSeghliSumAggregateInputType
    _min?: BahrebardairProgramSeghliMinAggregateInputType
    _max?: BahrebardairProgramSeghliMaxAggregateInputType
  }

  export type BahrebardairProgramSeghliGroupByOutputType = {
    IdProSrgl: number
    FIdRanesh: number
    FIdTarDor: number
    Zarfiat: Decimal | null
    Shorooe: Date | null
    Paian: Date | null
    _count: BahrebardairProgramSeghliCountAggregateOutputType | null
    _avg: BahrebardairProgramSeghliAvgAggregateOutputType | null
    _sum: BahrebardairProgramSeghliSumAggregateOutputType | null
    _min: BahrebardairProgramSeghliMinAggregateOutputType | null
    _max: BahrebardairProgramSeghliMaxAggregateOutputType | null
  }

  type GetBahrebardairProgramSeghliGroupByPayload<T extends BahrebardairProgramSeghliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardairProgramSeghliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardairProgramSeghliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardairProgramSeghliGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardairProgramSeghliGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardairProgramSeghliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdProSrgl?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Zarfiat?: boolean
    Shorooe?: boolean
    Paian?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahrebardairProgramSeghli"]>



  export type BahrebardairProgramSeghliSelectScalar = {
    IdProSrgl?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Zarfiat?: boolean
    Shorooe?: boolean
    Paian?: boolean
  }

  export type BahrebardairProgramSeghliOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdProSrgl" | "FIdRanesh" | "FIdTarDor" | "Zarfiat" | "Shorooe" | "Paian", ExtArgs["result"]["bahrebardairProgramSeghli"]>
  export type BahrebardairProgramSeghliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $BahrebardairProgramSeghliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardairProgramSeghli"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdProSrgl: number
      FIdRanesh: number
      FIdTarDor: number
      Zarfiat: Prisma.Decimal | null
      Shorooe: Date | null
      Paian: Date | null
    }, ExtArgs["result"]["bahrebardairProgramSeghli"]>
    composites: {}
  }

  type BahrebardairProgramSeghliGetPayload<S extends boolean | null | undefined | BahrebardairProgramSeghliDefaultArgs> = $Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload, S>

  type BahrebardairProgramSeghliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardairProgramSeghliFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardairProgramSeghliCountAggregateInputType | true
    }

  export interface BahrebardairProgramSeghliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardairProgramSeghli'], meta: { name: 'BahrebardairProgramSeghli' } }
    /**
     * Find zero or one BahrebardairProgramSeghli that matches the filter.
     * @param {BahrebardairProgramSeghliFindUniqueArgs} args - Arguments to find a BahrebardairProgramSeghli
     * @example
     * // Get one BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardairProgramSeghliFindUniqueArgs>(args: SelectSubset<T, BahrebardairProgramSeghliFindUniqueArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardairProgramSeghli that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardairProgramSeghliFindUniqueOrThrowArgs} args - Arguments to find a BahrebardairProgramSeghli
     * @example
     * // Get one BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardairProgramSeghliFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardairProgramSeghliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgramSeghli that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliFindFirstArgs} args - Arguments to find a BahrebardairProgramSeghli
     * @example
     * // Get one BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardairProgramSeghliFindFirstArgs>(args?: SelectSubset<T, BahrebardairProgramSeghliFindFirstArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgramSeghli that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliFindFirstOrThrowArgs} args - Arguments to find a BahrebardairProgramSeghli
     * @example
     * // Get one BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardairProgramSeghliFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardairProgramSeghliFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardairProgramSeghlis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardairProgramSeghlis
     * const bahrebardairProgramSeghlis = await prisma.bahrebardairProgramSeghli.findMany()
     * 
     * // Get first 10 BahrebardairProgramSeghlis
     * const bahrebardairProgramSeghlis = await prisma.bahrebardairProgramSeghli.findMany({ take: 10 })
     * 
     * // Only select the `IdProSrgl`
     * const bahrebardairProgramSeghliWithIdProSrglOnly = await prisma.bahrebardairProgramSeghli.findMany({ select: { IdProSrgl: true } })
     * 
     */
    findMany<T extends BahrebardairProgramSeghliFindManyArgs>(args?: SelectSubset<T, BahrebardairProgramSeghliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardairProgramSeghli.
     * @param {BahrebardairProgramSeghliCreateArgs} args - Arguments to create a BahrebardairProgramSeghli.
     * @example
     * // Create one BahrebardairProgramSeghli
     * const BahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.create({
     *   data: {
     *     // ... data to create a BahrebardairProgramSeghli
     *   }
     * })
     * 
     */
    create<T extends BahrebardairProgramSeghliCreateArgs>(args: SelectSubset<T, BahrebardairProgramSeghliCreateArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardairProgramSeghlis.
     * @param {BahrebardairProgramSeghliCreateManyArgs} args - Arguments to create many BahrebardairProgramSeghlis.
     * @example
     * // Create many BahrebardairProgramSeghlis
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardairProgramSeghliCreateManyArgs>(args?: SelectSubset<T, BahrebardairProgramSeghliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardairProgramSeghli.
     * @param {BahrebardairProgramSeghliDeleteArgs} args - Arguments to delete one BahrebardairProgramSeghli.
     * @example
     * // Delete one BahrebardairProgramSeghli
     * const BahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.delete({
     *   where: {
     *     // ... filter to delete one BahrebardairProgramSeghli
     *   }
     * })
     * 
     */
    delete<T extends BahrebardairProgramSeghliDeleteArgs>(args: SelectSubset<T, BahrebardairProgramSeghliDeleteArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardairProgramSeghli.
     * @param {BahrebardairProgramSeghliUpdateArgs} args - Arguments to update one BahrebardairProgramSeghli.
     * @example
     * // Update one BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardairProgramSeghliUpdateArgs>(args: SelectSubset<T, BahrebardairProgramSeghliUpdateArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardairProgramSeghlis.
     * @param {BahrebardairProgramSeghliDeleteManyArgs} args - Arguments to filter BahrebardairProgramSeghlis to delete.
     * @example
     * // Delete a few BahrebardairProgramSeghlis
     * const { count } = await prisma.bahrebardairProgramSeghli.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardairProgramSeghliDeleteManyArgs>(args?: SelectSubset<T, BahrebardairProgramSeghliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardairProgramSeghlis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardairProgramSeghlis
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardairProgramSeghliUpdateManyArgs>(args: SelectSubset<T, BahrebardairProgramSeghliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardairProgramSeghli.
     * @param {BahrebardairProgramSeghliUpsertArgs} args - Arguments to update or create a BahrebardairProgramSeghli.
     * @example
     * // Update or create a BahrebardairProgramSeghli
     * const bahrebardairProgramSeghli = await prisma.bahrebardairProgramSeghli.upsert({
     *   create: {
     *     // ... data to create a BahrebardairProgramSeghli
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardairProgramSeghli we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardairProgramSeghliUpsertArgs>(args: SelectSubset<T, BahrebardairProgramSeghliUpsertArgs<ExtArgs>>): Prisma__BahrebardairProgramSeghliClient<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardairProgramSeghlis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliCountArgs} args - Arguments to filter BahrebardairProgramSeghlis to count.
     * @example
     * // Count the number of BahrebardairProgramSeghlis
     * const count = await prisma.bahrebardairProgramSeghli.count({
     *   where: {
     *     // ... the filter for the BahrebardairProgramSeghlis we want to count
     *   }
     * })
    **/
    count<T extends BahrebardairProgramSeghliCountArgs>(
      args?: Subset<T, BahrebardairProgramSeghliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardairProgramSeghliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardairProgramSeghli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardairProgramSeghliAggregateArgs>(args: Subset<T, BahrebardairProgramSeghliAggregateArgs>): Prisma.PrismaPromise<GetBahrebardairProgramSeghliAggregateType<T>>

    /**
     * Group by BahrebardairProgramSeghli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramSeghliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardairProgramSeghliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardairProgramSeghliGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardairProgramSeghliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardairProgramSeghliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardairProgramSeghliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardairProgramSeghli model
   */
  readonly fields: BahrebardairProgramSeghliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardairProgramSeghli.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardairProgramSeghliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardairProgramSeghli model
   */ 
  interface BahrebardairProgramSeghliFieldRefs {
    readonly IdProSrgl: FieldRef<"BahrebardairProgramSeghli", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardairProgramSeghli", 'Int'>
    readonly FIdTarDor: FieldRef<"BahrebardairProgramSeghli", 'Int'>
    readonly Zarfiat: FieldRef<"BahrebardairProgramSeghli", 'Decimal'>
    readonly Shorooe: FieldRef<"BahrebardairProgramSeghli", 'DateTime'>
    readonly Paian: FieldRef<"BahrebardairProgramSeghli", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardairProgramSeghli findUnique
   */
  export type BahrebardairProgramSeghliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgramSeghli to fetch.
     */
    where: BahrebardairProgramSeghliWhereUniqueInput
  }

  /**
   * BahrebardairProgramSeghli findUniqueOrThrow
   */
  export type BahrebardairProgramSeghliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgramSeghli to fetch.
     */
    where: BahrebardairProgramSeghliWhereUniqueInput
  }

  /**
   * BahrebardairProgramSeghli findFirst
   */
  export type BahrebardairProgramSeghliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgramSeghli to fetch.
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairProgramSeghlis to fetch.
     */
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairProgramSeghlis.
     */
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairProgramSeghlis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairProgramSeghlis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairProgramSeghlis.
     */
    distinct?: BahrebardairProgramSeghliScalarFieldEnum | BahrebardairProgramSeghliScalarFieldEnum[]
  }

  /**
   * BahrebardairProgramSeghli findFirstOrThrow
   */
  export type BahrebardairProgramSeghliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgramSeghli to fetch.
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairProgramSeghlis to fetch.
     */
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairProgramSeghlis.
     */
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairProgramSeghlis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairProgramSeghlis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairProgramSeghlis.
     */
    distinct?: BahrebardairProgramSeghliScalarFieldEnum | BahrebardairProgramSeghliScalarFieldEnum[]
  }

  /**
   * BahrebardairProgramSeghli findMany
   */
  export type BahrebardairProgramSeghliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgramSeghlis to fetch.
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairProgramSeghlis to fetch.
     */
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardairProgramSeghlis.
     */
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairProgramSeghlis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairProgramSeghlis.
     */
    skip?: number
    distinct?: BahrebardairProgramSeghliScalarFieldEnum | BahrebardairProgramSeghliScalarFieldEnum[]
  }

  /**
   * BahrebardairProgramSeghli create
   */
  export type BahrebardairProgramSeghliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * The data needed to create a BahrebardairProgramSeghli.
     */
    data: XOR<BahrebardairProgramSeghliCreateInput, BahrebardairProgramSeghliUncheckedCreateInput>
  }

  /**
   * BahrebardairProgramSeghli createMany
   */
  export type BahrebardairProgramSeghliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardairProgramSeghlis.
     */
    data: BahrebardairProgramSeghliCreateManyInput | BahrebardairProgramSeghliCreateManyInput[]
  }

  /**
   * BahrebardairProgramSeghli update
   */
  export type BahrebardairProgramSeghliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * The data needed to update a BahrebardairProgramSeghli.
     */
    data: XOR<BahrebardairProgramSeghliUpdateInput, BahrebardairProgramSeghliUncheckedUpdateInput>
    /**
     * Choose, which BahrebardairProgramSeghli to update.
     */
    where: BahrebardairProgramSeghliWhereUniqueInput
  }

  /**
   * BahrebardairProgramSeghli updateMany
   */
  export type BahrebardairProgramSeghliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardairProgramSeghlis.
     */
    data: XOR<BahrebardairProgramSeghliUpdateManyMutationInput, BahrebardairProgramSeghliUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardairProgramSeghlis to update
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * Limit how many BahrebardairProgramSeghlis to update.
     */
    limit?: number
  }

  /**
   * BahrebardairProgramSeghli upsert
   */
  export type BahrebardairProgramSeghliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * The filter to search for the BahrebardairProgramSeghli to update in case it exists.
     */
    where: BahrebardairProgramSeghliWhereUniqueInput
    /**
     * In case the BahrebardairProgramSeghli found by the `where` argument doesn't exist, create a new BahrebardairProgramSeghli with this data.
     */
    create: XOR<BahrebardairProgramSeghliCreateInput, BahrebardairProgramSeghliUncheckedCreateInput>
    /**
     * In case the BahrebardairProgramSeghli was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardairProgramSeghliUpdateInput, BahrebardairProgramSeghliUncheckedUpdateInput>
  }

  /**
   * BahrebardairProgramSeghli delete
   */
  export type BahrebardairProgramSeghliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    /**
     * Filter which BahrebardairProgramSeghli to delete.
     */
    where: BahrebardairProgramSeghliWhereUniqueInput
  }

  /**
   * BahrebardairProgramSeghli deleteMany
   */
  export type BahrebardairProgramSeghliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairProgramSeghlis to delete
     */
    where?: BahrebardairProgramSeghliWhereInput
    /**
     * Limit how many BahrebardairProgramSeghlis to delete.
     */
    limit?: number
  }

  /**
   * BahrebardairProgramSeghli without action
   */
  export type BahrebardairProgramSeghliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
  }


  /**
   * Model BahrebardariKeshtDore
   */

  export type AggregateBahrebardariKeshtDore = {
    _count: BahrebardariKeshtDoreCountAggregateOutputType | null
    _avg: BahrebardariKeshtDoreAvgAggregateOutputType | null
    _sum: BahrebardariKeshtDoreSumAggregateOutputType | null
    _min: BahrebardariKeshtDoreMinAggregateOutputType | null
    _max: BahrebardariKeshtDoreMaxAggregateOutputType | null
  }

  export type BahrebardariKeshtDoreAvgAggregateOutputType = {
    IdBahDor: number | null
    FIdShDo: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreSumAggregateOutputType = {
    IdBahDor: number | null
    FIdShDo: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreMinAggregateOutputType = {
    IdBahDor: number | null
    FIdShDo: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreMaxAggregateOutputType = {
    IdBahDor: number | null
    FIdShDo: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreCountAggregateOutputType = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    FIdNoeM: number
    Area: number
    _all: number
  }


  export type BahrebardariKeshtDoreAvgAggregateInputType = {
    IdBahDor?: true
    FIdShDo?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreSumAggregateInputType = {
    IdBahDor?: true
    FIdShDo?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreMinAggregateInputType = {
    IdBahDor?: true
    FIdShDo?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreMaxAggregateInputType = {
    IdBahDor?: true
    FIdShDo?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreCountAggregateInputType = {
    IdBahDor?: true
    FIdShDo?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
    _all?: true
  }

  export type BahrebardariKeshtDoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariKeshtDore to aggregate.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardariKeshtDores
    **/
    _count?: true | BahrebardariKeshtDoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardariKeshtDoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardariKeshtDoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardariKeshtDoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardariKeshtDoreMaxAggregateInputType
  }

  export type GetBahrebardariKeshtDoreAggregateType<T extends BahrebardariKeshtDoreAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardariKeshtDore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardariKeshtDore[P]>
      : GetScalarType<T[P], AggregateBahrebardariKeshtDore[P]>
  }




  export type BahrebardariKeshtDoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariKeshtDoreWhereInput
    orderBy?: BahrebardariKeshtDoreOrderByWithAggregationInput | BahrebardariKeshtDoreOrderByWithAggregationInput[]
    by: BahrebardariKeshtDoreScalarFieldEnum[] | BahrebardariKeshtDoreScalarFieldEnum
    having?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardariKeshtDoreCountAggregateInputType | true
    _avg?: BahrebardariKeshtDoreAvgAggregateInputType
    _sum?: BahrebardariKeshtDoreSumAggregateInputType
    _min?: BahrebardariKeshtDoreMinAggregateInputType
    _max?: BahrebardariKeshtDoreMaxAggregateInputType
  }

  export type BahrebardariKeshtDoreGroupByOutputType = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal
    _count: BahrebardariKeshtDoreCountAggregateOutputType | null
    _avg: BahrebardariKeshtDoreAvgAggregateOutputType | null
    _sum: BahrebardariKeshtDoreSumAggregateOutputType | null
    _min: BahrebardariKeshtDoreMinAggregateOutputType | null
    _max: BahrebardariKeshtDoreMaxAggregateOutputType | null
  }

  type GetBahrebardariKeshtDoreGroupByPayload<T extends BahrebardariKeshtDoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardariKeshtDoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardariKeshtDoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardariKeshtDoreGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardariKeshtDoreGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardariKeshtDoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBahDor?: boolean
    FIdShDo?: boolean
    FIdRanesh?: boolean
    FIdNoeM?: boolean
    Area?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    NoeMahsool?: boolean | NoeMahsoolDefaultArgs<ExtArgs>
    ShabakeDoreKesht?: boolean | ShabakeDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahrebardariKeshtDore"]>



  export type BahrebardariKeshtDoreSelectScalar = {
    IdBahDor?: boolean
    FIdShDo?: boolean
    FIdRanesh?: boolean
    FIdNoeM?: boolean
    Area?: boolean
  }

  export type BahrebardariKeshtDoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBahDor" | "FIdShDo" | "FIdRanesh" | "FIdNoeM" | "Area", ExtArgs["result"]["bahrebardariKeshtDore"]>
  export type BahrebardariKeshtDoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    NoeMahsool?: boolean | NoeMahsoolDefaultArgs<ExtArgs>
    ShabakeDoreKesht?: boolean | ShabakeDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $BahrebardariKeshtDorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardariKeshtDore"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      NoeMahsool: Prisma.$NoeMahsoolPayload<ExtArgs>
      ShabakeDoreKesht: Prisma.$ShabakeDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdBahDor: number
      FIdShDo: number
      FIdRanesh: number
      FIdNoeM: number
      Area: Prisma.Decimal
    }, ExtArgs["result"]["bahrebardariKeshtDore"]>
    composites: {}
  }

  type BahrebardariKeshtDoreGetPayload<S extends boolean | null | undefined | BahrebardariKeshtDoreDefaultArgs> = $Result.GetResult<Prisma.$BahrebardariKeshtDorePayload, S>

  type BahrebardariKeshtDoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardariKeshtDoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardariKeshtDoreCountAggregateInputType | true
    }

  export interface BahrebardariKeshtDoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardariKeshtDore'], meta: { name: 'BahrebardariKeshtDore' } }
    /**
     * Find zero or one BahrebardariKeshtDore that matches the filter.
     * @param {BahrebardariKeshtDoreFindUniqueArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardariKeshtDoreFindUniqueArgs>(args: SelectSubset<T, BahrebardariKeshtDoreFindUniqueArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardariKeshtDore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardariKeshtDoreFindUniqueOrThrowArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardariKeshtDoreFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariKeshtDore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindFirstArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardariKeshtDoreFindFirstArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindFirstArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariKeshtDore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindFirstOrThrowArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardariKeshtDoreFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardariKeshtDores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardariKeshtDores
     * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany()
     * 
     * // Get first 10 BahrebardariKeshtDores
     * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany({ take: 10 })
     * 
     * // Only select the `IdBahDor`
     * const bahrebardariKeshtDoreWithIdBahDorOnly = await prisma.bahrebardariKeshtDore.findMany({ select: { IdBahDor: true } })
     * 
     */
    findMany<T extends BahrebardariKeshtDoreFindManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreCreateArgs} args - Arguments to create a BahrebardariKeshtDore.
     * @example
     * // Create one BahrebardariKeshtDore
     * const BahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.create({
     *   data: {
     *     // ... data to create a BahrebardariKeshtDore
     *   }
     * })
     * 
     */
    create<T extends BahrebardariKeshtDoreCreateArgs>(args: SelectSubset<T, BahrebardariKeshtDoreCreateArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardariKeshtDores.
     * @param {BahrebardariKeshtDoreCreateManyArgs} args - Arguments to create many BahrebardariKeshtDores.
     * @example
     * // Create many BahrebardariKeshtDores
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardariKeshtDoreCreateManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreDeleteArgs} args - Arguments to delete one BahrebardariKeshtDore.
     * @example
     * // Delete one BahrebardariKeshtDore
     * const BahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.delete({
     *   where: {
     *     // ... filter to delete one BahrebardariKeshtDore
     *   }
     * })
     * 
     */
    delete<T extends BahrebardariKeshtDoreDeleteArgs>(args: SelectSubset<T, BahrebardariKeshtDoreDeleteArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreUpdateArgs} args - Arguments to update one BahrebardariKeshtDore.
     * @example
     * // Update one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardariKeshtDoreUpdateArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpdateArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardariKeshtDores.
     * @param {BahrebardariKeshtDoreDeleteManyArgs} args - Arguments to filter BahrebardariKeshtDores to delete.
     * @example
     * // Delete a few BahrebardariKeshtDores
     * const { count } = await prisma.bahrebardariKeshtDore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardariKeshtDoreDeleteManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardariKeshtDores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardariKeshtDores
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardariKeshtDoreUpdateManyArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreUpsertArgs} args - Arguments to update or create a BahrebardariKeshtDore.
     * @example
     * // Update or create a BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.upsert({
     *   create: {
     *     // ... data to create a BahrebardariKeshtDore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardariKeshtDore we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardariKeshtDoreUpsertArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpsertArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardariKeshtDores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreCountArgs} args - Arguments to filter BahrebardariKeshtDores to count.
     * @example
     * // Count the number of BahrebardariKeshtDores
     * const count = await prisma.bahrebardariKeshtDore.count({
     *   where: {
     *     // ... the filter for the BahrebardariKeshtDores we want to count
     *   }
     * })
    **/
    count<T extends BahrebardariKeshtDoreCountArgs>(
      args?: Subset<T, BahrebardariKeshtDoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardariKeshtDoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardariKeshtDore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardariKeshtDoreAggregateArgs>(args: Subset<T, BahrebardariKeshtDoreAggregateArgs>): Prisma.PrismaPromise<GetBahrebardariKeshtDoreAggregateType<T>>

    /**
     * Group by BahrebardariKeshtDore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardariKeshtDoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardariKeshtDoreGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardariKeshtDoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardariKeshtDoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardariKeshtDoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardariKeshtDore model
   */
  readonly fields: BahrebardariKeshtDoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardariKeshtDore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardariKeshtDoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    NoeMahsool<T extends NoeMahsoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NoeMahsoolDefaultArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ShabakeDoreKesht<T extends ShabakeDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShabakeDoreKeshtDefaultArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardariKeshtDore model
   */ 
  interface BahrebardariKeshtDoreFieldRefs {
    readonly IdBahDor: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdShDo: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdNoeM: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly Area: FieldRef<"BahrebardariKeshtDore", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardariKeshtDore findUnique
   */
  export type BahrebardariKeshtDoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore findUniqueOrThrow
   */
  export type BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore findFirst
   */
  export type BahrebardariKeshtDoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariKeshtDores.
     */
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore findFirstOrThrow
   */
  export type BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariKeshtDores.
     */
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore findMany
   */
  export type BahrebardariKeshtDoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDores to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore create
   */
  export type BahrebardariKeshtDoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * The data needed to create a BahrebardariKeshtDore.
     */
    data: XOR<BahrebardariKeshtDoreCreateInput, BahrebardariKeshtDoreUncheckedCreateInput>
  }

  /**
   * BahrebardariKeshtDore createMany
   */
  export type BahrebardariKeshtDoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardariKeshtDores.
     */
    data: BahrebardariKeshtDoreCreateManyInput | BahrebardariKeshtDoreCreateManyInput[]
  }

  /**
   * BahrebardariKeshtDore update
   */
  export type BahrebardariKeshtDoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * The data needed to update a BahrebardariKeshtDore.
     */
    data: XOR<BahrebardariKeshtDoreUpdateInput, BahrebardariKeshtDoreUncheckedUpdateInput>
    /**
     * Choose, which BahrebardariKeshtDore to update.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore updateMany
   */
  export type BahrebardariKeshtDoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardariKeshtDores.
     */
    data: XOR<BahrebardariKeshtDoreUpdateManyMutationInput, BahrebardariKeshtDoreUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardariKeshtDores to update
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * Limit how many BahrebardariKeshtDores to update.
     */
    limit?: number
  }

  /**
   * BahrebardariKeshtDore upsert
   */
  export type BahrebardariKeshtDoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * The filter to search for the BahrebardariKeshtDore to update in case it exists.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * In case the BahrebardariKeshtDore found by the `where` argument doesn't exist, create a new BahrebardariKeshtDore with this data.
     */
    create: XOR<BahrebardariKeshtDoreCreateInput, BahrebardariKeshtDoreUncheckedCreateInput>
    /**
     * In case the BahrebardariKeshtDore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardariKeshtDoreUpdateInput, BahrebardariKeshtDoreUncheckedUpdateInput>
  }

  /**
   * BahrebardariKeshtDore delete
   */
  export type BahrebardariKeshtDoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    /**
     * Filter which BahrebardariKeshtDore to delete.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore deleteMany
   */
  export type BahrebardariKeshtDoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariKeshtDores to delete
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * Limit how many BahrebardariKeshtDores to delete.
     */
    limit?: number
  }

  /**
   * BahrebardariKeshtDore without action
   */
  export type BahrebardariKeshtDoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
  }


  /**
   * Model BahrebardariTaghvim
   */

  export type AggregateBahrebardariTaghvim = {
    _count: BahrebardariTaghvimCountAggregateOutputType | null
    _avg: BahrebardariTaghvimAvgAggregateOutputType | null
    _sum: BahrebardariTaghvimSumAggregateOutputType | null
    _min: BahrebardariTaghvimMinAggregateOutputType | null
    _max: BahrebardariTaghvimMaxAggregateOutputType | null
  }

  export type BahrebardariTaghvimAvgAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimSumAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimMinAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimMaxAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimCountAggregateOutputType = {
    IdTag: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: number
    _all: number
  }


  export type BahrebardariTaghvimAvgAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimSumAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimMinAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimMaxAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimCountAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
    _all?: true
  }

  export type BahrebardariTaghvimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariTaghvim to aggregate.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardariTaghvims
    **/
    _count?: true | BahrebardariTaghvimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardariTaghvimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardariTaghvimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardariTaghvimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardariTaghvimMaxAggregateInputType
  }

  export type GetBahrebardariTaghvimAggregateType<T extends BahrebardariTaghvimAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardariTaghvim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardariTaghvim[P]>
      : GetScalarType<T[P], AggregateBahrebardariTaghvim[P]>
  }




  export type BahrebardariTaghvimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariTaghvimWhereInput
    orderBy?: BahrebardariTaghvimOrderByWithAggregationInput | BahrebardariTaghvimOrderByWithAggregationInput[]
    by: BahrebardariTaghvimScalarFieldEnum[] | BahrebardariTaghvimScalarFieldEnum
    having?: BahrebardariTaghvimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardariTaghvimCountAggregateInputType | true
    _avg?: BahrebardariTaghvimAvgAggregateInputType
    _sum?: BahrebardariTaghvimSumAggregateInputType
    _min?: BahrebardariTaghvimMinAggregateInputType
    _max?: BahrebardariTaghvimMaxAggregateInputType
  }

  export type BahrebardariTaghvimGroupByOutputType = {
    IdTag: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal
    _count: BahrebardariTaghvimCountAggregateOutputType | null
    _avg: BahrebardariTaghvimAvgAggregateOutputType | null
    _sum: BahrebardariTaghvimSumAggregateOutputType | null
    _min: BahrebardariTaghvimMinAggregateOutputType | null
    _max: BahrebardariTaghvimMaxAggregateOutputType | null
  }

  type GetBahrebardariTaghvimGroupByPayload<T extends BahrebardariTaghvimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardariTaghvimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardariTaghvimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardariTaghvimGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardariTaghvimGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardariTaghvimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTag?: boolean
    FIdTarDor?: boolean
    FIdRanesh?: boolean
    Taghvim?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bahrebardariTaghvim"]>



  export type BahrebardariTaghvimSelectScalar = {
    IdTag?: boolean
    FIdTarDor?: boolean
    FIdRanesh?: boolean
    Taghvim?: boolean
  }

  export type BahrebardariTaghvimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTag" | "FIdTarDor" | "FIdRanesh" | "Taghvim", ExtArgs["result"]["bahrebardariTaghvim"]>
  export type BahrebardariTaghvimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $BahrebardariTaghvimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardariTaghvim"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdTag: number
      FIdTarDor: number
      FIdRanesh: number
      Taghvim: Prisma.Decimal
    }, ExtArgs["result"]["bahrebardariTaghvim"]>
    composites: {}
  }

  type BahrebardariTaghvimGetPayload<S extends boolean | null | undefined | BahrebardariTaghvimDefaultArgs> = $Result.GetResult<Prisma.$BahrebardariTaghvimPayload, S>

  type BahrebardariTaghvimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardariTaghvimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardariTaghvimCountAggregateInputType | true
    }

  export interface BahrebardariTaghvimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardariTaghvim'], meta: { name: 'BahrebardariTaghvim' } }
    /**
     * Find zero or one BahrebardariTaghvim that matches the filter.
     * @param {BahrebardariTaghvimFindUniqueArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardariTaghvimFindUniqueArgs>(args: SelectSubset<T, BahrebardariTaghvimFindUniqueArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardariTaghvim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardariTaghvimFindUniqueOrThrowArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardariTaghvimFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariTaghvim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindFirstArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardariTaghvimFindFirstArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindFirstArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariTaghvim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindFirstOrThrowArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardariTaghvimFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardariTaghvims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardariTaghvims
     * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany()
     * 
     * // Get first 10 BahrebardariTaghvims
     * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany({ take: 10 })
     * 
     * // Only select the `IdTag`
     * const bahrebardariTaghvimWithIdTagOnly = await prisma.bahrebardariTaghvim.findMany({ select: { IdTag: true } })
     * 
     */
    findMany<T extends BahrebardariTaghvimFindManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardariTaghvim.
     * @param {BahrebardariTaghvimCreateArgs} args - Arguments to create a BahrebardariTaghvim.
     * @example
     * // Create one BahrebardariTaghvim
     * const BahrebardariTaghvim = await prisma.bahrebardariTaghvim.create({
     *   data: {
     *     // ... data to create a BahrebardariTaghvim
     *   }
     * })
     * 
     */
    create<T extends BahrebardariTaghvimCreateArgs>(args: SelectSubset<T, BahrebardariTaghvimCreateArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardariTaghvims.
     * @param {BahrebardariTaghvimCreateManyArgs} args - Arguments to create many BahrebardariTaghvims.
     * @example
     * // Create many BahrebardariTaghvims
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardariTaghvimCreateManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardariTaghvim.
     * @param {BahrebardariTaghvimDeleteArgs} args - Arguments to delete one BahrebardariTaghvim.
     * @example
     * // Delete one BahrebardariTaghvim
     * const BahrebardariTaghvim = await prisma.bahrebardariTaghvim.delete({
     *   where: {
     *     // ... filter to delete one BahrebardariTaghvim
     *   }
     * })
     * 
     */
    delete<T extends BahrebardariTaghvimDeleteArgs>(args: SelectSubset<T, BahrebardariTaghvimDeleteArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardariTaghvim.
     * @param {BahrebardariTaghvimUpdateArgs} args - Arguments to update one BahrebardariTaghvim.
     * @example
     * // Update one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardariTaghvimUpdateArgs>(args: SelectSubset<T, BahrebardariTaghvimUpdateArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardariTaghvims.
     * @param {BahrebardariTaghvimDeleteManyArgs} args - Arguments to filter BahrebardariTaghvims to delete.
     * @example
     * // Delete a few BahrebardariTaghvims
     * const { count } = await prisma.bahrebardariTaghvim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardariTaghvimDeleteManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardariTaghvims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardariTaghvims
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardariTaghvimUpdateManyArgs>(args: SelectSubset<T, BahrebardariTaghvimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardariTaghvim.
     * @param {BahrebardariTaghvimUpsertArgs} args - Arguments to update or create a BahrebardariTaghvim.
     * @example
     * // Update or create a BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.upsert({
     *   create: {
     *     // ... data to create a BahrebardariTaghvim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardariTaghvim we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardariTaghvimUpsertArgs>(args: SelectSubset<T, BahrebardariTaghvimUpsertArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardariTaghvims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimCountArgs} args - Arguments to filter BahrebardariTaghvims to count.
     * @example
     * // Count the number of BahrebardariTaghvims
     * const count = await prisma.bahrebardariTaghvim.count({
     *   where: {
     *     // ... the filter for the BahrebardariTaghvims we want to count
     *   }
     * })
    **/
    count<T extends BahrebardariTaghvimCountArgs>(
      args?: Subset<T, BahrebardariTaghvimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardariTaghvimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardariTaghvim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardariTaghvimAggregateArgs>(args: Subset<T, BahrebardariTaghvimAggregateArgs>): Prisma.PrismaPromise<GetBahrebardariTaghvimAggregateType<T>>

    /**
     * Group by BahrebardariTaghvim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardariTaghvimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardariTaghvimGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardariTaghvimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardariTaghvimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardariTaghvimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardariTaghvim model
   */
  readonly fields: BahrebardariTaghvimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardariTaghvim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardariTaghvimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardariTaghvim model
   */ 
  interface BahrebardariTaghvimFieldRefs {
    readonly IdTag: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly FIdTarDor: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly Taghvim: FieldRef<"BahrebardariTaghvim", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardariTaghvim findUnique
   */
  export type BahrebardariTaghvimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim findUniqueOrThrow
   */
  export type BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim findFirst
   */
  export type BahrebardariTaghvimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariTaghvims.
     */
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim findFirstOrThrow
   */
  export type BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariTaghvims.
     */
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim findMany
   */
  export type BahrebardariTaghvimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvims to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim create
   */
  export type BahrebardariTaghvimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * The data needed to create a BahrebardariTaghvim.
     */
    data: XOR<BahrebardariTaghvimCreateInput, BahrebardariTaghvimUncheckedCreateInput>
  }

  /**
   * BahrebardariTaghvim createMany
   */
  export type BahrebardariTaghvimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardariTaghvims.
     */
    data: BahrebardariTaghvimCreateManyInput | BahrebardariTaghvimCreateManyInput[]
  }

  /**
   * BahrebardariTaghvim update
   */
  export type BahrebardariTaghvimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * The data needed to update a BahrebardariTaghvim.
     */
    data: XOR<BahrebardariTaghvimUpdateInput, BahrebardariTaghvimUncheckedUpdateInput>
    /**
     * Choose, which BahrebardariTaghvim to update.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim updateMany
   */
  export type BahrebardariTaghvimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardariTaghvims.
     */
    data: XOR<BahrebardariTaghvimUpdateManyMutationInput, BahrebardariTaghvimUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardariTaghvims to update
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * Limit how many BahrebardariTaghvims to update.
     */
    limit?: number
  }

  /**
   * BahrebardariTaghvim upsert
   */
  export type BahrebardariTaghvimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * The filter to search for the BahrebardariTaghvim to update in case it exists.
     */
    where: BahrebardariTaghvimWhereUniqueInput
    /**
     * In case the BahrebardariTaghvim found by the `where` argument doesn't exist, create a new BahrebardariTaghvim with this data.
     */
    create: XOR<BahrebardariTaghvimCreateInput, BahrebardariTaghvimUncheckedCreateInput>
    /**
     * In case the BahrebardariTaghvim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardariTaghvimUpdateInput, BahrebardariTaghvimUncheckedUpdateInput>
  }

  /**
   * BahrebardariTaghvim delete
   */
  export type BahrebardariTaghvimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    /**
     * Filter which BahrebardariTaghvim to delete.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim deleteMany
   */
  export type BahrebardariTaghvimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariTaghvims to delete
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * Limit how many BahrebardariTaghvims to delete.
     */
    limit?: number
  }

  /**
   * BahrebardariTaghvim without action
   */
  export type BahrebardariTaghvimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
  }


  /**
   * Model BareshMotaleat
   */

  export type AggregateBareshMotaleat = {
    _count: BareshMotaleatCountAggregateOutputType | null
    _avg: BareshMotaleatAvgAggregateOutputType | null
    _sum: BareshMotaleatSumAggregateOutputType | null
    _min: BareshMotaleatMinAggregateOutputType | null
    _max: BareshMotaleatMaxAggregateOutputType | null
  }

  export type BareshMotaleatAvgAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatSumAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatMinAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatMaxAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatCountAggregateOutputType = {
    IdBarMot: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: number
    _all: number
  }


  export type BareshMotaleatAvgAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatSumAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatMinAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatMaxAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatCountAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
    _all?: true
  }

  export type BareshMotaleatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BareshMotaleat to aggregate.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BareshMotaleats
    **/
    _count?: true | BareshMotaleatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BareshMotaleatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BareshMotaleatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BareshMotaleatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BareshMotaleatMaxAggregateInputType
  }

  export type GetBareshMotaleatAggregateType<T extends BareshMotaleatAggregateArgs> = {
        [P in keyof T & keyof AggregateBareshMotaleat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBareshMotaleat[P]>
      : GetScalarType<T[P], AggregateBareshMotaleat[P]>
  }




  export type BareshMotaleatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BareshMotaleatWhereInput
    orderBy?: BareshMotaleatOrderByWithAggregationInput | BareshMotaleatOrderByWithAggregationInput[]
    by: BareshMotaleatScalarFieldEnum[] | BareshMotaleatScalarFieldEnum
    having?: BareshMotaleatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BareshMotaleatCountAggregateInputType | true
    _avg?: BareshMotaleatAvgAggregateInputType
    _sum?: BareshMotaleatSumAggregateInputType
    _min?: BareshMotaleatMinAggregateInputType
    _max?: BareshMotaleatMaxAggregateInputType
  }

  export type BareshMotaleatGroupByOutputType = {
    IdBarMot: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal
    _count: BareshMotaleatCountAggregateOutputType | null
    _avg: BareshMotaleatAvgAggregateOutputType | null
    _sum: BareshMotaleatSumAggregateOutputType | null
    _min: BareshMotaleatMinAggregateOutputType | null
    _max: BareshMotaleatMaxAggregateOutputType | null
  }

  type GetBareshMotaleatGroupByPayload<T extends BareshMotaleatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BareshMotaleatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BareshMotaleatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BareshMotaleatGroupByOutputType[P]>
            : GetScalarType<T[P], BareshMotaleatGroupByOutputType[P]>
        }
      >
    >


  export type BareshMotaleatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBarMot?: boolean
    FIdNet?: boolean
    FIdMah?: boolean
    BareshMotaleat?: boolean
    Mah?: boolean | MahShamsiDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bareshMotaleat"]>



  export type BareshMotaleatSelectScalar = {
    IdBarMot?: boolean
    FIdNet?: boolean
    FIdMah?: boolean
    BareshMotaleat?: boolean
  }

  export type BareshMotaleatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBarMot" | "FIdNet" | "FIdMah" | "BareshMotaleat", ExtArgs["result"]["bareshMotaleat"]>
  export type BareshMotaleatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mah?: boolean | MahShamsiDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
  }

  export type $BareshMotaleatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BareshMotaleat"
    objects: {
      Mah: Prisma.$MahShamsiPayload<ExtArgs>
      Network: Prisma.$NetworkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdBarMot: number
      FIdNet: number
      FIdMah: number
      BareshMotaleat: Prisma.Decimal
    }, ExtArgs["result"]["bareshMotaleat"]>
    composites: {}
  }

  type BareshMotaleatGetPayload<S extends boolean | null | undefined | BareshMotaleatDefaultArgs> = $Result.GetResult<Prisma.$BareshMotaleatPayload, S>

  type BareshMotaleatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BareshMotaleatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BareshMotaleatCountAggregateInputType | true
    }

  export interface BareshMotaleatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BareshMotaleat'], meta: { name: 'BareshMotaleat' } }
    /**
     * Find zero or one BareshMotaleat that matches the filter.
     * @param {BareshMotaleatFindUniqueArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BareshMotaleatFindUniqueArgs>(args: SelectSubset<T, BareshMotaleatFindUniqueArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BareshMotaleat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BareshMotaleatFindUniqueOrThrowArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BareshMotaleatFindUniqueOrThrowArgs>(args: SelectSubset<T, BareshMotaleatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BareshMotaleat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindFirstArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BareshMotaleatFindFirstArgs>(args?: SelectSubset<T, BareshMotaleatFindFirstArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BareshMotaleat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindFirstOrThrowArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BareshMotaleatFindFirstOrThrowArgs>(args?: SelectSubset<T, BareshMotaleatFindFirstOrThrowArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BareshMotaleats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BareshMotaleats
     * const bareshMotaleats = await prisma.bareshMotaleat.findMany()
     * 
     * // Get first 10 BareshMotaleats
     * const bareshMotaleats = await prisma.bareshMotaleat.findMany({ take: 10 })
     * 
     * // Only select the `IdBarMot`
     * const bareshMotaleatWithIdBarMotOnly = await prisma.bareshMotaleat.findMany({ select: { IdBarMot: true } })
     * 
     */
    findMany<T extends BareshMotaleatFindManyArgs>(args?: SelectSubset<T, BareshMotaleatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BareshMotaleat.
     * @param {BareshMotaleatCreateArgs} args - Arguments to create a BareshMotaleat.
     * @example
     * // Create one BareshMotaleat
     * const BareshMotaleat = await prisma.bareshMotaleat.create({
     *   data: {
     *     // ... data to create a BareshMotaleat
     *   }
     * })
     * 
     */
    create<T extends BareshMotaleatCreateArgs>(args: SelectSubset<T, BareshMotaleatCreateArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BareshMotaleats.
     * @param {BareshMotaleatCreateManyArgs} args - Arguments to create many BareshMotaleats.
     * @example
     * // Create many BareshMotaleats
     * const bareshMotaleat = await prisma.bareshMotaleat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BareshMotaleatCreateManyArgs>(args?: SelectSubset<T, BareshMotaleatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BareshMotaleat.
     * @param {BareshMotaleatDeleteArgs} args - Arguments to delete one BareshMotaleat.
     * @example
     * // Delete one BareshMotaleat
     * const BareshMotaleat = await prisma.bareshMotaleat.delete({
     *   where: {
     *     // ... filter to delete one BareshMotaleat
     *   }
     * })
     * 
     */
    delete<T extends BareshMotaleatDeleteArgs>(args: SelectSubset<T, BareshMotaleatDeleteArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BareshMotaleat.
     * @param {BareshMotaleatUpdateArgs} args - Arguments to update one BareshMotaleat.
     * @example
     * // Update one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BareshMotaleatUpdateArgs>(args: SelectSubset<T, BareshMotaleatUpdateArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BareshMotaleats.
     * @param {BareshMotaleatDeleteManyArgs} args - Arguments to filter BareshMotaleats to delete.
     * @example
     * // Delete a few BareshMotaleats
     * const { count } = await prisma.bareshMotaleat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BareshMotaleatDeleteManyArgs>(args?: SelectSubset<T, BareshMotaleatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BareshMotaleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BareshMotaleats
     * const bareshMotaleat = await prisma.bareshMotaleat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BareshMotaleatUpdateManyArgs>(args: SelectSubset<T, BareshMotaleatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BareshMotaleat.
     * @param {BareshMotaleatUpsertArgs} args - Arguments to update or create a BareshMotaleat.
     * @example
     * // Update or create a BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.upsert({
     *   create: {
     *     // ... data to create a BareshMotaleat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BareshMotaleat we want to update
     *   }
     * })
     */
    upsert<T extends BareshMotaleatUpsertArgs>(args: SelectSubset<T, BareshMotaleatUpsertArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BareshMotaleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatCountArgs} args - Arguments to filter BareshMotaleats to count.
     * @example
     * // Count the number of BareshMotaleats
     * const count = await prisma.bareshMotaleat.count({
     *   where: {
     *     // ... the filter for the BareshMotaleats we want to count
     *   }
     * })
    **/
    count<T extends BareshMotaleatCountArgs>(
      args?: Subset<T, BareshMotaleatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BareshMotaleatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BareshMotaleat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BareshMotaleatAggregateArgs>(args: Subset<T, BareshMotaleatAggregateArgs>): Prisma.PrismaPromise<GetBareshMotaleatAggregateType<T>>

    /**
     * Group by BareshMotaleat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BareshMotaleatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BareshMotaleatGroupByArgs['orderBy'] }
        : { orderBy?: BareshMotaleatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BareshMotaleatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBareshMotaleatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BareshMotaleat model
   */
  readonly fields: BareshMotaleatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BareshMotaleat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BareshMotaleatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Mah<T extends MahShamsiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MahShamsiDefaultArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Network<T extends NetworkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDefaultArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BareshMotaleat model
   */ 
  interface BareshMotaleatFieldRefs {
    readonly IdBarMot: FieldRef<"BareshMotaleat", 'Int'>
    readonly FIdNet: FieldRef<"BareshMotaleat", 'Int'>
    readonly FIdMah: FieldRef<"BareshMotaleat", 'Int'>
    readonly BareshMotaleat: FieldRef<"BareshMotaleat", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BareshMotaleat findUnique
   */
  export type BareshMotaleatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat findUniqueOrThrow
   */
  export type BareshMotaleatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat findFirst
   */
  export type BareshMotaleatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BareshMotaleats.
     */
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat findFirstOrThrow
   */
  export type BareshMotaleatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BareshMotaleats.
     */
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat findMany
   */
  export type BareshMotaleatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter, which BareshMotaleats to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat create
   */
  export type BareshMotaleatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * The data needed to create a BareshMotaleat.
     */
    data: XOR<BareshMotaleatCreateInput, BareshMotaleatUncheckedCreateInput>
  }

  /**
   * BareshMotaleat createMany
   */
  export type BareshMotaleatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BareshMotaleats.
     */
    data: BareshMotaleatCreateManyInput | BareshMotaleatCreateManyInput[]
  }

  /**
   * BareshMotaleat update
   */
  export type BareshMotaleatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * The data needed to update a BareshMotaleat.
     */
    data: XOR<BareshMotaleatUpdateInput, BareshMotaleatUncheckedUpdateInput>
    /**
     * Choose, which BareshMotaleat to update.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat updateMany
   */
  export type BareshMotaleatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BareshMotaleats.
     */
    data: XOR<BareshMotaleatUpdateManyMutationInput, BareshMotaleatUncheckedUpdateManyInput>
    /**
     * Filter which BareshMotaleats to update
     */
    where?: BareshMotaleatWhereInput
    /**
     * Limit how many BareshMotaleats to update.
     */
    limit?: number
  }

  /**
   * BareshMotaleat upsert
   */
  export type BareshMotaleatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * The filter to search for the BareshMotaleat to update in case it exists.
     */
    where: BareshMotaleatWhereUniqueInput
    /**
     * In case the BareshMotaleat found by the `where` argument doesn't exist, create a new BareshMotaleat with this data.
     */
    create: XOR<BareshMotaleatCreateInput, BareshMotaleatUncheckedCreateInput>
    /**
     * In case the BareshMotaleat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BareshMotaleatUpdateInput, BareshMotaleatUncheckedUpdateInput>
  }

  /**
   * BareshMotaleat delete
   */
  export type BareshMotaleatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    /**
     * Filter which BareshMotaleat to delete.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat deleteMany
   */
  export type BareshMotaleatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BareshMotaleats to delete
     */
    where?: BareshMotaleatWhereInput
    /**
     * Limit how many BareshMotaleats to delete.
     */
    limit?: number
  }

  /**
   * BareshMotaleat without action
   */
  export type BareshMotaleatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
  }


  /**
   * Model DarajePipe
   */

  export type AggregateDarajePipe = {
    _count: DarajePipeCountAggregateOutputType | null
    _avg: DarajePipeAvgAggregateOutputType | null
    _sum: DarajePipeSumAggregateOutputType | null
    _min: DarajePipeMinAggregateOutputType | null
    _max: DarajePipeMaxAggregateOutputType | null
  }

  export type DarajePipeAvgAggregateOutputType = {
    IdDPipe: number | null
  }

  export type DarajePipeSumAggregateOutputType = {
    IdDPipe: number | null
  }

  export type DarajePipeMinAggregateOutputType = {
    IdDPipe: number | null
    DarajePipe: string | null
  }

  export type DarajePipeMaxAggregateOutputType = {
    IdDPipe: number | null
    DarajePipe: string | null
  }

  export type DarajePipeCountAggregateOutputType = {
    IdDPipe: number
    DarajePipe: number
    _all: number
  }


  export type DarajePipeAvgAggregateInputType = {
    IdDPipe?: true
  }

  export type DarajePipeSumAggregateInputType = {
    IdDPipe?: true
  }

  export type DarajePipeMinAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
  }

  export type DarajePipeMaxAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
  }

  export type DarajePipeCountAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
    _all?: true
  }

  export type DarajePipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarajePipe to aggregate.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DarajePipes
    **/
    _count?: true | DarajePipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DarajePipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DarajePipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DarajePipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DarajePipeMaxAggregateInputType
  }

  export type GetDarajePipeAggregateType<T extends DarajePipeAggregateArgs> = {
        [P in keyof T & keyof AggregateDarajePipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDarajePipe[P]>
      : GetScalarType<T[P], AggregateDarajePipe[P]>
  }




  export type DarajePipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarajePipeWhereInput
    orderBy?: DarajePipeOrderByWithAggregationInput | DarajePipeOrderByWithAggregationInput[]
    by: DarajePipeScalarFieldEnum[] | DarajePipeScalarFieldEnum
    having?: DarajePipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DarajePipeCountAggregateInputType | true
    _avg?: DarajePipeAvgAggregateInputType
    _sum?: DarajePipeSumAggregateInputType
    _min?: DarajePipeMinAggregateInputType
    _max?: DarajePipeMaxAggregateInputType
  }

  export type DarajePipeGroupByOutputType = {
    IdDPipe: number
    DarajePipe: string
    _count: DarajePipeCountAggregateOutputType | null
    _avg: DarajePipeAvgAggregateOutputType | null
    _sum: DarajePipeSumAggregateOutputType | null
    _min: DarajePipeMinAggregateOutputType | null
    _max: DarajePipeMaxAggregateOutputType | null
  }

  type GetDarajePipeGroupByPayload<T extends DarajePipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DarajePipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DarajePipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DarajePipeGroupByOutputType[P]>
            : GetScalarType<T[P], DarajePipeGroupByOutputType[P]>
        }
      >
    >


  export type DarajePipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDPipe?: boolean
    DarajePipe?: boolean
    KhatRanesh?: boolean | DarajePipe$KhatRaneshArgs<ExtArgs>
    _count?: boolean | DarajePipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["darajePipe"]>



  export type DarajePipeSelectScalar = {
    IdDPipe?: boolean
    DarajePipe?: boolean
  }

  export type DarajePipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDPipe" | "DarajePipe", ExtArgs["result"]["darajePipe"]>
  export type DarajePipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | DarajePipe$KhatRaneshArgs<ExtArgs>
    _count?: boolean | DarajePipeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DarajePipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DarajePipe"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdDPipe: number
      DarajePipe: string
    }, ExtArgs["result"]["darajePipe"]>
    composites: {}
  }

  type DarajePipeGetPayload<S extends boolean | null | undefined | DarajePipeDefaultArgs> = $Result.GetResult<Prisma.$DarajePipePayload, S>

  type DarajePipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DarajePipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DarajePipeCountAggregateInputType | true
    }

  export interface DarajePipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DarajePipe'], meta: { name: 'DarajePipe' } }
    /**
     * Find zero or one DarajePipe that matches the filter.
     * @param {DarajePipeFindUniqueArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DarajePipeFindUniqueArgs>(args: SelectSubset<T, DarajePipeFindUniqueArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DarajePipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DarajePipeFindUniqueOrThrowArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DarajePipeFindUniqueOrThrowArgs>(args: SelectSubset<T, DarajePipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DarajePipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindFirstArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DarajePipeFindFirstArgs>(args?: SelectSubset<T, DarajePipeFindFirstArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DarajePipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindFirstOrThrowArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DarajePipeFindFirstOrThrowArgs>(args?: SelectSubset<T, DarajePipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DarajePipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DarajePipes
     * const darajePipes = await prisma.darajePipe.findMany()
     * 
     * // Get first 10 DarajePipes
     * const darajePipes = await prisma.darajePipe.findMany({ take: 10 })
     * 
     * // Only select the `IdDPipe`
     * const darajePipeWithIdDPipeOnly = await prisma.darajePipe.findMany({ select: { IdDPipe: true } })
     * 
     */
    findMany<T extends DarajePipeFindManyArgs>(args?: SelectSubset<T, DarajePipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DarajePipe.
     * @param {DarajePipeCreateArgs} args - Arguments to create a DarajePipe.
     * @example
     * // Create one DarajePipe
     * const DarajePipe = await prisma.darajePipe.create({
     *   data: {
     *     // ... data to create a DarajePipe
     *   }
     * })
     * 
     */
    create<T extends DarajePipeCreateArgs>(args: SelectSubset<T, DarajePipeCreateArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DarajePipes.
     * @param {DarajePipeCreateManyArgs} args - Arguments to create many DarajePipes.
     * @example
     * // Create many DarajePipes
     * const darajePipe = await prisma.darajePipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DarajePipeCreateManyArgs>(args?: SelectSubset<T, DarajePipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DarajePipe.
     * @param {DarajePipeDeleteArgs} args - Arguments to delete one DarajePipe.
     * @example
     * // Delete one DarajePipe
     * const DarajePipe = await prisma.darajePipe.delete({
     *   where: {
     *     // ... filter to delete one DarajePipe
     *   }
     * })
     * 
     */
    delete<T extends DarajePipeDeleteArgs>(args: SelectSubset<T, DarajePipeDeleteArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DarajePipe.
     * @param {DarajePipeUpdateArgs} args - Arguments to update one DarajePipe.
     * @example
     * // Update one DarajePipe
     * const darajePipe = await prisma.darajePipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DarajePipeUpdateArgs>(args: SelectSubset<T, DarajePipeUpdateArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DarajePipes.
     * @param {DarajePipeDeleteManyArgs} args - Arguments to filter DarajePipes to delete.
     * @example
     * // Delete a few DarajePipes
     * const { count } = await prisma.darajePipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DarajePipeDeleteManyArgs>(args?: SelectSubset<T, DarajePipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarajePipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DarajePipes
     * const darajePipe = await prisma.darajePipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DarajePipeUpdateManyArgs>(args: SelectSubset<T, DarajePipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DarajePipe.
     * @param {DarajePipeUpsertArgs} args - Arguments to update or create a DarajePipe.
     * @example
     * // Update or create a DarajePipe
     * const darajePipe = await prisma.darajePipe.upsert({
     *   create: {
     *     // ... data to create a DarajePipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DarajePipe we want to update
     *   }
     * })
     */
    upsert<T extends DarajePipeUpsertArgs>(args: SelectSubset<T, DarajePipeUpsertArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DarajePipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeCountArgs} args - Arguments to filter DarajePipes to count.
     * @example
     * // Count the number of DarajePipes
     * const count = await prisma.darajePipe.count({
     *   where: {
     *     // ... the filter for the DarajePipes we want to count
     *   }
     * })
    **/
    count<T extends DarajePipeCountArgs>(
      args?: Subset<T, DarajePipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DarajePipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DarajePipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DarajePipeAggregateArgs>(args: Subset<T, DarajePipeAggregateArgs>): Prisma.PrismaPromise<GetDarajePipeAggregateType<T>>

    /**
     * Group by DarajePipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DarajePipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DarajePipeGroupByArgs['orderBy'] }
        : { orderBy?: DarajePipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DarajePipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDarajePipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DarajePipe model
   */
  readonly fields: DarajePipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DarajePipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DarajePipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends DarajePipe$KhatRaneshArgs<ExtArgs> = {}>(args?: Subset<T, DarajePipe$KhatRaneshArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DarajePipe model
   */ 
  interface DarajePipeFieldRefs {
    readonly IdDPipe: FieldRef<"DarajePipe", 'Int'>
    readonly DarajePipe: FieldRef<"DarajePipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DarajePipe findUnique
   */
  export type DarajePipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe findUniqueOrThrow
   */
  export type DarajePipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe findFirst
   */
  export type DarajePipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarajePipes.
     */
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe findFirstOrThrow
   */
  export type DarajePipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarajePipes.
     */
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe findMany
   */
  export type DarajePipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter, which DarajePipes to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe create
   */
  export type DarajePipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * The data needed to create a DarajePipe.
     */
    data: XOR<DarajePipeCreateInput, DarajePipeUncheckedCreateInput>
  }

  /**
   * DarajePipe createMany
   */
  export type DarajePipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DarajePipes.
     */
    data: DarajePipeCreateManyInput | DarajePipeCreateManyInput[]
  }

  /**
   * DarajePipe update
   */
  export type DarajePipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * The data needed to update a DarajePipe.
     */
    data: XOR<DarajePipeUpdateInput, DarajePipeUncheckedUpdateInput>
    /**
     * Choose, which DarajePipe to update.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe updateMany
   */
  export type DarajePipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DarajePipes.
     */
    data: XOR<DarajePipeUpdateManyMutationInput, DarajePipeUncheckedUpdateManyInput>
    /**
     * Filter which DarajePipes to update
     */
    where?: DarajePipeWhereInput
    /**
     * Limit how many DarajePipes to update.
     */
    limit?: number
  }

  /**
   * DarajePipe upsert
   */
  export type DarajePipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * The filter to search for the DarajePipe to update in case it exists.
     */
    where: DarajePipeWhereUniqueInput
    /**
     * In case the DarajePipe found by the `where` argument doesn't exist, create a new DarajePipe with this data.
     */
    create: XOR<DarajePipeCreateInput, DarajePipeUncheckedCreateInput>
    /**
     * In case the DarajePipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DarajePipeUpdateInput, DarajePipeUncheckedUpdateInput>
  }

  /**
   * DarajePipe delete
   */
  export type DarajePipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
    /**
     * Filter which DarajePipe to delete.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe deleteMany
   */
  export type DarajePipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarajePipes to delete
     */
    where?: DarajePipeWhereInput
    /**
     * Limit how many DarajePipes to delete.
     */
    limit?: number
  }

  /**
   * DarajePipe.KhatRanesh
   */
  export type DarajePipe$KhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    cursor?: KhatRaneshWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * DarajePipe without action
   */
  export type DarajePipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarajePipeInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryPoints
   */

  export type AggregateDeliveryPoints = {
    _count: DeliveryPointsCountAggregateOutputType | null
    _avg: DeliveryPointsAvgAggregateOutputType | null
    _sum: DeliveryPointsSumAggregateOutputType | null
    _min: DeliveryPointsMinAggregateOutputType | null
    _max: DeliveryPointsMaxAggregateOutputType | null
  }

  export type DeliveryPointsAvgAggregateOutputType = {
    IdDp: number | null
  }

  export type DeliveryPointsSumAggregateOutputType = {
    IdDp: number | null
  }

  export type DeliveryPointsMinAggregateOutputType = {
    IdDp: number | null
    DeliveryPoint: string | null
  }

  export type DeliveryPointsMaxAggregateOutputType = {
    IdDp: number | null
    DeliveryPoint: string | null
  }

  export type DeliveryPointsCountAggregateOutputType = {
    IdDp: number
    DeliveryPoint: number
    _all: number
  }


  export type DeliveryPointsAvgAggregateInputType = {
    IdDp?: true
  }

  export type DeliveryPointsSumAggregateInputType = {
    IdDp?: true
  }

  export type DeliveryPointsMinAggregateInputType = {
    IdDp?: true
    DeliveryPoint?: true
  }

  export type DeliveryPointsMaxAggregateInputType = {
    IdDp?: true
    DeliveryPoint?: true
  }

  export type DeliveryPointsCountAggregateInputType = {
    IdDp?: true
    DeliveryPoint?: true
    _all?: true
  }

  export type DeliveryPointsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPoints to aggregate.
     */
    where?: DeliveryPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPoints to fetch.
     */
    orderBy?: DeliveryPointsOrderByWithRelationInput | DeliveryPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryPoints
    **/
    _count?: true | DeliveryPointsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryPointsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryPointsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryPointsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryPointsMaxAggregateInputType
  }

  export type GetDeliveryPointsAggregateType<T extends DeliveryPointsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryPoints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryPoints[P]>
      : GetScalarType<T[P], AggregateDeliveryPoints[P]>
  }




  export type DeliveryPointsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryPointsWhereInput
    orderBy?: DeliveryPointsOrderByWithAggregationInput | DeliveryPointsOrderByWithAggregationInput[]
    by: DeliveryPointsScalarFieldEnum[] | DeliveryPointsScalarFieldEnum
    having?: DeliveryPointsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryPointsCountAggregateInputType | true
    _avg?: DeliveryPointsAvgAggregateInputType
    _sum?: DeliveryPointsSumAggregateInputType
    _min?: DeliveryPointsMinAggregateInputType
    _max?: DeliveryPointsMaxAggregateInputType
  }

  export type DeliveryPointsGroupByOutputType = {
    IdDp: number
    DeliveryPoint: string
    _count: DeliveryPointsCountAggregateOutputType | null
    _avg: DeliveryPointsAvgAggregateOutputType | null
    _sum: DeliveryPointsSumAggregateOutputType | null
    _min: DeliveryPointsMinAggregateOutputType | null
    _max: DeliveryPointsMaxAggregateOutputType | null
  }

  type GetDeliveryPointsGroupByPayload<T extends DeliveryPointsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryPointsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryPointsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryPointsGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryPointsGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryPointsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDp?: boolean
    DeliveryPoint?: boolean
    PumpStations?: boolean | DeliveryPoints$PumpStationsArgs<ExtArgs>
    _count?: boolean | DeliveryPointsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPoints"]>



  export type DeliveryPointsSelectScalar = {
    IdDp?: boolean
    DeliveryPoint?: boolean
  }

  export type DeliveryPointsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDp" | "DeliveryPoint", ExtArgs["result"]["deliveryPoints"]>
  export type DeliveryPointsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStations?: boolean | DeliveryPoints$PumpStationsArgs<ExtArgs>
    _count?: boolean | DeliveryPointsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DeliveryPointsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryPoints"
    objects: {
      PumpStations: Prisma.$PumpStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdDp: number
      DeliveryPoint: string
    }, ExtArgs["result"]["deliveryPoints"]>
    composites: {}
  }

  type DeliveryPointsGetPayload<S extends boolean | null | undefined | DeliveryPointsDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPointsPayload, S>

  type DeliveryPointsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryPointsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryPointsCountAggregateInputType | true
    }

  export interface DeliveryPointsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryPoints'], meta: { name: 'DeliveryPoints' } }
    /**
     * Find zero or one DeliveryPoints that matches the filter.
     * @param {DeliveryPointsFindUniqueArgs} args - Arguments to find a DeliveryPoints
     * @example
     * // Get one DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryPointsFindUniqueArgs>(args: SelectSubset<T, DeliveryPointsFindUniqueArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DeliveryPoints that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryPointsFindUniqueOrThrowArgs} args - Arguments to find a DeliveryPoints
     * @example
     * // Get one DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryPointsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryPointsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DeliveryPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsFindFirstArgs} args - Arguments to find a DeliveryPoints
     * @example
     * // Get one DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryPointsFindFirstArgs>(args?: SelectSubset<T, DeliveryPointsFindFirstArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DeliveryPoints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsFindFirstOrThrowArgs} args - Arguments to find a DeliveryPoints
     * @example
     * // Get one DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryPointsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryPointsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DeliveryPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findMany()
     * 
     * // Get first 10 DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.findMany({ take: 10 })
     * 
     * // Only select the `IdDp`
     * const deliveryPointsWithIdDpOnly = await prisma.deliveryPoints.findMany({ select: { IdDp: true } })
     * 
     */
    findMany<T extends DeliveryPointsFindManyArgs>(args?: SelectSubset<T, DeliveryPointsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DeliveryPoints.
     * @param {DeliveryPointsCreateArgs} args - Arguments to create a DeliveryPoints.
     * @example
     * // Create one DeliveryPoints
     * const DeliveryPoints = await prisma.deliveryPoints.create({
     *   data: {
     *     // ... data to create a DeliveryPoints
     *   }
     * })
     * 
     */
    create<T extends DeliveryPointsCreateArgs>(args: SelectSubset<T, DeliveryPointsCreateArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DeliveryPoints.
     * @param {DeliveryPointsCreateManyArgs} args - Arguments to create many DeliveryPoints.
     * @example
     * // Create many DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryPointsCreateManyArgs>(args?: SelectSubset<T, DeliveryPointsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryPoints.
     * @param {DeliveryPointsDeleteArgs} args - Arguments to delete one DeliveryPoints.
     * @example
     * // Delete one DeliveryPoints
     * const DeliveryPoints = await prisma.deliveryPoints.delete({
     *   where: {
     *     // ... filter to delete one DeliveryPoints
     *   }
     * })
     * 
     */
    delete<T extends DeliveryPointsDeleteArgs>(args: SelectSubset<T, DeliveryPointsDeleteArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DeliveryPoints.
     * @param {DeliveryPointsUpdateArgs} args - Arguments to update one DeliveryPoints.
     * @example
     * // Update one DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryPointsUpdateArgs>(args: SelectSubset<T, DeliveryPointsUpdateArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DeliveryPoints.
     * @param {DeliveryPointsDeleteManyArgs} args - Arguments to filter DeliveryPoints to delete.
     * @example
     * // Delete a few DeliveryPoints
     * const { count } = await prisma.deliveryPoints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryPointsDeleteManyArgs>(args?: SelectSubset<T, DeliveryPointsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryPointsUpdateManyArgs>(args: SelectSubset<T, DeliveryPointsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryPoints.
     * @param {DeliveryPointsUpsertArgs} args - Arguments to update or create a DeliveryPoints.
     * @example
     * // Update or create a DeliveryPoints
     * const deliveryPoints = await prisma.deliveryPoints.upsert({
     *   create: {
     *     // ... data to create a DeliveryPoints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryPoints we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryPointsUpsertArgs>(args: SelectSubset<T, DeliveryPointsUpsertArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DeliveryPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsCountArgs} args - Arguments to filter DeliveryPoints to count.
     * @example
     * // Count the number of DeliveryPoints
     * const count = await prisma.deliveryPoints.count({
     *   where: {
     *     // ... the filter for the DeliveryPoints we want to count
     *   }
     * })
    **/
    count<T extends DeliveryPointsCountArgs>(
      args?: Subset<T, DeliveryPointsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryPointsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryPointsAggregateArgs>(args: Subset<T, DeliveryPointsAggregateArgs>): Prisma.PrismaPromise<GetDeliveryPointsAggregateType<T>>

    /**
     * Group by DeliveryPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPointsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryPointsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryPointsGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryPointsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryPointsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryPointsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryPoints model
   */
  readonly fields: DeliveryPointsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryPoints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryPointsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PumpStations<T extends DeliveryPoints$PumpStationsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPoints$PumpStationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryPoints model
   */ 
  interface DeliveryPointsFieldRefs {
    readonly IdDp: FieldRef<"DeliveryPoints", 'Int'>
    readonly DeliveryPoint: FieldRef<"DeliveryPoints", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryPoints findUnique
   */
  export type DeliveryPointsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPoints to fetch.
     */
    where: DeliveryPointsWhereUniqueInput
  }

  /**
   * DeliveryPoints findUniqueOrThrow
   */
  export type DeliveryPointsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPoints to fetch.
     */
    where: DeliveryPointsWhereUniqueInput
  }

  /**
   * DeliveryPoints findFirst
   */
  export type DeliveryPointsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPoints to fetch.
     */
    where?: DeliveryPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPoints to fetch.
     */
    orderBy?: DeliveryPointsOrderByWithRelationInput | DeliveryPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPoints.
     */
    cursor?: DeliveryPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPoints.
     */
    distinct?: DeliveryPointsScalarFieldEnum | DeliveryPointsScalarFieldEnum[]
  }

  /**
   * DeliveryPoints findFirstOrThrow
   */
  export type DeliveryPointsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPoints to fetch.
     */
    where?: DeliveryPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPoints to fetch.
     */
    orderBy?: DeliveryPointsOrderByWithRelationInput | DeliveryPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPoints.
     */
    cursor?: DeliveryPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPoints.
     */
    distinct?: DeliveryPointsScalarFieldEnum | DeliveryPointsScalarFieldEnum[]
  }

  /**
   * DeliveryPoints findMany
   */
  export type DeliveryPointsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPoints to fetch.
     */
    where?: DeliveryPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPoints to fetch.
     */
    orderBy?: DeliveryPointsOrderByWithRelationInput | DeliveryPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryPoints.
     */
    cursor?: DeliveryPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPoints.
     */
    skip?: number
    distinct?: DeliveryPointsScalarFieldEnum | DeliveryPointsScalarFieldEnum[]
  }

  /**
   * DeliveryPoints create
   */
  export type DeliveryPointsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryPoints.
     */
    data: XOR<DeliveryPointsCreateInput, DeliveryPointsUncheckedCreateInput>
  }

  /**
   * DeliveryPoints createMany
   */
  export type DeliveryPointsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryPoints.
     */
    data: DeliveryPointsCreateManyInput | DeliveryPointsCreateManyInput[]
  }

  /**
   * DeliveryPoints update
   */
  export type DeliveryPointsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryPoints.
     */
    data: XOR<DeliveryPointsUpdateInput, DeliveryPointsUncheckedUpdateInput>
    /**
     * Choose, which DeliveryPoints to update.
     */
    where: DeliveryPointsWhereUniqueInput
  }

  /**
   * DeliveryPoints updateMany
   */
  export type DeliveryPointsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryPoints.
     */
    data: XOR<DeliveryPointsUpdateManyMutationInput, DeliveryPointsUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryPoints to update
     */
    where?: DeliveryPointsWhereInput
    /**
     * Limit how many DeliveryPoints to update.
     */
    limit?: number
  }

  /**
   * DeliveryPoints upsert
   */
  export type DeliveryPointsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryPoints to update in case it exists.
     */
    where: DeliveryPointsWhereUniqueInput
    /**
     * In case the DeliveryPoints found by the `where` argument doesn't exist, create a new DeliveryPoints with this data.
     */
    create: XOR<DeliveryPointsCreateInput, DeliveryPointsUncheckedCreateInput>
    /**
     * In case the DeliveryPoints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryPointsUpdateInput, DeliveryPointsUncheckedUpdateInput>
  }

  /**
   * DeliveryPoints delete
   */
  export type DeliveryPointsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
    /**
     * Filter which DeliveryPoints to delete.
     */
    where: DeliveryPointsWhereUniqueInput
  }

  /**
   * DeliveryPoints deleteMany
   */
  export type DeliveryPointsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPoints to delete
     */
    where?: DeliveryPointsWhereInput
    /**
     * Limit how many DeliveryPoints to delete.
     */
    limit?: number
  }

  /**
   * DeliveryPoints.PumpStations
   */
  export type DeliveryPoints$PumpStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    cursor?: PumpStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * DeliveryPoints without action
   */
  export type DeliveryPointsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPoints
     */
    select?: DeliveryPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPoints
     */
    omit?: DeliveryPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPointsInclude<ExtArgs> | null
  }


  /**
   * Model DarjeStation
   */

  export type AggregateDarjeStation = {
    _count: DarjeStationCountAggregateOutputType | null
    _avg: DarjeStationAvgAggregateOutputType | null
    _sum: DarjeStationSumAggregateOutputType | null
    _min: DarjeStationMinAggregateOutputType | null
    _max: DarjeStationMaxAggregateOutputType | null
  }

  export type DarjeStationAvgAggregateOutputType = {
    IdDStation: number | null
  }

  export type DarjeStationSumAggregateOutputType = {
    IdDStation: number | null
  }

  export type DarjeStationMinAggregateOutputType = {
    IdDStation: number | null
    DarajeStation: string | null
  }

  export type DarjeStationMaxAggregateOutputType = {
    IdDStation: number | null
    DarajeStation: string | null
  }

  export type DarjeStationCountAggregateOutputType = {
    IdDStation: number
    DarajeStation: number
    _all: number
  }


  export type DarjeStationAvgAggregateInputType = {
    IdDStation?: true
  }

  export type DarjeStationSumAggregateInputType = {
    IdDStation?: true
  }

  export type DarjeStationMinAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
  }

  export type DarjeStationMaxAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
  }

  export type DarjeStationCountAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
    _all?: true
  }

  export type DarjeStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarjeStation to aggregate.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DarjeStations
    **/
    _count?: true | DarjeStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DarjeStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DarjeStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DarjeStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DarjeStationMaxAggregateInputType
  }

  export type GetDarjeStationAggregateType<T extends DarjeStationAggregateArgs> = {
        [P in keyof T & keyof AggregateDarjeStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDarjeStation[P]>
      : GetScalarType<T[P], AggregateDarjeStation[P]>
  }




  export type DarjeStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarjeStationWhereInput
    orderBy?: DarjeStationOrderByWithAggregationInput | DarjeStationOrderByWithAggregationInput[]
    by: DarjeStationScalarFieldEnum[] | DarjeStationScalarFieldEnum
    having?: DarjeStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DarjeStationCountAggregateInputType | true
    _avg?: DarjeStationAvgAggregateInputType
    _sum?: DarjeStationSumAggregateInputType
    _min?: DarjeStationMinAggregateInputType
    _max?: DarjeStationMaxAggregateInputType
  }

  export type DarjeStationGroupByOutputType = {
    IdDStation: number
    DarajeStation: string
    _count: DarjeStationCountAggregateOutputType | null
    _avg: DarjeStationAvgAggregateOutputType | null
    _sum: DarjeStationSumAggregateOutputType | null
    _min: DarjeStationMinAggregateOutputType | null
    _max: DarjeStationMaxAggregateOutputType | null
  }

  type GetDarjeStationGroupByPayload<T extends DarjeStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DarjeStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DarjeStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DarjeStationGroupByOutputType[P]>
            : GetScalarType<T[P], DarjeStationGroupByOutputType[P]>
        }
      >
    >


  export type DarjeStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDStation?: boolean
    DarajeStation?: boolean
    PumpStation?: boolean | DarjeStation$PumpStationArgs<ExtArgs>
    _count?: boolean | DarjeStationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["darjeStation"]>



  export type DarjeStationSelectScalar = {
    IdDStation?: boolean
    DarajeStation?: boolean
  }

  export type DarjeStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDStation" | "DarajeStation", ExtArgs["result"]["darjeStation"]>
  export type DarjeStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PumpStation?: boolean | DarjeStation$PumpStationArgs<ExtArgs>
    _count?: boolean | DarjeStationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DarjeStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DarjeStation"
    objects: {
      PumpStation: Prisma.$PumpStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdDStation: number
      DarajeStation: string
    }, ExtArgs["result"]["darjeStation"]>
    composites: {}
  }

  type DarjeStationGetPayload<S extends boolean | null | undefined | DarjeStationDefaultArgs> = $Result.GetResult<Prisma.$DarjeStationPayload, S>

  type DarjeStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DarjeStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DarjeStationCountAggregateInputType | true
    }

  export interface DarjeStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DarjeStation'], meta: { name: 'DarjeStation' } }
    /**
     * Find zero or one DarjeStation that matches the filter.
     * @param {DarjeStationFindUniqueArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DarjeStationFindUniqueArgs>(args: SelectSubset<T, DarjeStationFindUniqueArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DarjeStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DarjeStationFindUniqueOrThrowArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DarjeStationFindUniqueOrThrowArgs>(args: SelectSubset<T, DarjeStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DarjeStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindFirstArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DarjeStationFindFirstArgs>(args?: SelectSubset<T, DarjeStationFindFirstArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DarjeStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindFirstOrThrowArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DarjeStationFindFirstOrThrowArgs>(args?: SelectSubset<T, DarjeStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DarjeStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DarjeStations
     * const darjeStations = await prisma.darjeStation.findMany()
     * 
     * // Get first 10 DarjeStations
     * const darjeStations = await prisma.darjeStation.findMany({ take: 10 })
     * 
     * // Only select the `IdDStation`
     * const darjeStationWithIdDStationOnly = await prisma.darjeStation.findMany({ select: { IdDStation: true } })
     * 
     */
    findMany<T extends DarjeStationFindManyArgs>(args?: SelectSubset<T, DarjeStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DarjeStation.
     * @param {DarjeStationCreateArgs} args - Arguments to create a DarjeStation.
     * @example
     * // Create one DarjeStation
     * const DarjeStation = await prisma.darjeStation.create({
     *   data: {
     *     // ... data to create a DarjeStation
     *   }
     * })
     * 
     */
    create<T extends DarjeStationCreateArgs>(args: SelectSubset<T, DarjeStationCreateArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DarjeStations.
     * @param {DarjeStationCreateManyArgs} args - Arguments to create many DarjeStations.
     * @example
     * // Create many DarjeStations
     * const darjeStation = await prisma.darjeStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DarjeStationCreateManyArgs>(args?: SelectSubset<T, DarjeStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DarjeStation.
     * @param {DarjeStationDeleteArgs} args - Arguments to delete one DarjeStation.
     * @example
     * // Delete one DarjeStation
     * const DarjeStation = await prisma.darjeStation.delete({
     *   where: {
     *     // ... filter to delete one DarjeStation
     *   }
     * })
     * 
     */
    delete<T extends DarjeStationDeleteArgs>(args: SelectSubset<T, DarjeStationDeleteArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DarjeStation.
     * @param {DarjeStationUpdateArgs} args - Arguments to update one DarjeStation.
     * @example
     * // Update one DarjeStation
     * const darjeStation = await prisma.darjeStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DarjeStationUpdateArgs>(args: SelectSubset<T, DarjeStationUpdateArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DarjeStations.
     * @param {DarjeStationDeleteManyArgs} args - Arguments to filter DarjeStations to delete.
     * @example
     * // Delete a few DarjeStations
     * const { count } = await prisma.darjeStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DarjeStationDeleteManyArgs>(args?: SelectSubset<T, DarjeStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarjeStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DarjeStations
     * const darjeStation = await prisma.darjeStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DarjeStationUpdateManyArgs>(args: SelectSubset<T, DarjeStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DarjeStation.
     * @param {DarjeStationUpsertArgs} args - Arguments to update or create a DarjeStation.
     * @example
     * // Update or create a DarjeStation
     * const darjeStation = await prisma.darjeStation.upsert({
     *   create: {
     *     // ... data to create a DarjeStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DarjeStation we want to update
     *   }
     * })
     */
    upsert<T extends DarjeStationUpsertArgs>(args: SelectSubset<T, DarjeStationUpsertArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DarjeStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationCountArgs} args - Arguments to filter DarjeStations to count.
     * @example
     * // Count the number of DarjeStations
     * const count = await prisma.darjeStation.count({
     *   where: {
     *     // ... the filter for the DarjeStations we want to count
     *   }
     * })
    **/
    count<T extends DarjeStationCountArgs>(
      args?: Subset<T, DarjeStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DarjeStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DarjeStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DarjeStationAggregateArgs>(args: Subset<T, DarjeStationAggregateArgs>): Prisma.PrismaPromise<GetDarjeStationAggregateType<T>>

    /**
     * Group by DarjeStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DarjeStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DarjeStationGroupByArgs['orderBy'] }
        : { orderBy?: DarjeStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DarjeStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDarjeStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DarjeStation model
   */
  readonly fields: DarjeStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DarjeStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DarjeStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PumpStation<T extends DarjeStation$PumpStationArgs<ExtArgs> = {}>(args?: Subset<T, DarjeStation$PumpStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DarjeStation model
   */ 
  interface DarjeStationFieldRefs {
    readonly IdDStation: FieldRef<"DarjeStation", 'Int'>
    readonly DarajeStation: FieldRef<"DarjeStation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DarjeStation findUnique
   */
  export type DarjeStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation findUniqueOrThrow
   */
  export type DarjeStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation findFirst
   */
  export type DarjeStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarjeStations.
     */
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation findFirstOrThrow
   */
  export type DarjeStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarjeStations.
     */
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation findMany
   */
  export type DarjeStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter, which DarjeStations to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation create
   */
  export type DarjeStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * The data needed to create a DarjeStation.
     */
    data: XOR<DarjeStationCreateInput, DarjeStationUncheckedCreateInput>
  }

  /**
   * DarjeStation createMany
   */
  export type DarjeStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DarjeStations.
     */
    data: DarjeStationCreateManyInput | DarjeStationCreateManyInput[]
  }

  /**
   * DarjeStation update
   */
  export type DarjeStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * The data needed to update a DarjeStation.
     */
    data: XOR<DarjeStationUpdateInput, DarjeStationUncheckedUpdateInput>
    /**
     * Choose, which DarjeStation to update.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation updateMany
   */
  export type DarjeStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DarjeStations.
     */
    data: XOR<DarjeStationUpdateManyMutationInput, DarjeStationUncheckedUpdateManyInput>
    /**
     * Filter which DarjeStations to update
     */
    where?: DarjeStationWhereInput
    /**
     * Limit how many DarjeStations to update.
     */
    limit?: number
  }

  /**
   * DarjeStation upsert
   */
  export type DarjeStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * The filter to search for the DarjeStation to update in case it exists.
     */
    where: DarjeStationWhereUniqueInput
    /**
     * In case the DarjeStation found by the `where` argument doesn't exist, create a new DarjeStation with this data.
     */
    create: XOR<DarjeStationCreateInput, DarjeStationUncheckedCreateInput>
    /**
     * In case the DarjeStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DarjeStationUpdateInput, DarjeStationUncheckedUpdateInput>
  }

  /**
   * DarjeStation delete
   */
  export type DarjeStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
    /**
     * Filter which DarjeStation to delete.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation deleteMany
   */
  export type DarjeStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarjeStations to delete
     */
    where?: DarjeStationWhereInput
    /**
     * Limit how many DarjeStations to delete.
     */
    limit?: number
  }

  /**
   * DarjeStation.PumpStation
   */
  export type DarjeStation$PumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    cursor?: PumpStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * DarjeStation without action
   */
  export type DarjeStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarjeStationInclude<ExtArgs> | null
  }


  /**
   * Model DoreKesht
   */

  export type AggregateDoreKesht = {
    _count: DoreKeshtCountAggregateOutputType | null
    _avg: DoreKeshtAvgAggregateOutputType | null
    _sum: DoreKeshtSumAggregateOutputType | null
    _min: DoreKeshtMinAggregateOutputType | null
    _max: DoreKeshtMaxAggregateOutputType | null
  }

  export type DoreKeshtAvgAggregateOutputType = {
    IdDore: number | null
  }

  export type DoreKeshtSumAggregateOutputType = {
    IdDore: number | null
  }

  export type DoreKeshtMinAggregateOutputType = {
    IdDore: number | null
    Dore: string | null
  }

  export type DoreKeshtMaxAggregateOutputType = {
    IdDore: number | null
    Dore: string | null
  }

  export type DoreKeshtCountAggregateOutputType = {
    IdDore: number
    Dore: number
    _all: number
  }


  export type DoreKeshtAvgAggregateInputType = {
    IdDore?: true
  }

  export type DoreKeshtSumAggregateInputType = {
    IdDore?: true
  }

  export type DoreKeshtMinAggregateInputType = {
    IdDore?: true
    Dore?: true
  }

  export type DoreKeshtMaxAggregateInputType = {
    IdDore?: true
    Dore?: true
  }

  export type DoreKeshtCountAggregateInputType = {
    IdDore?: true
    Dore?: true
    _all?: true
  }

  export type DoreKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoreKesht to aggregate.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoreKeshts
    **/
    _count?: true | DoreKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoreKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoreKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoreKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoreKeshtMaxAggregateInputType
  }

  export type GetDoreKeshtAggregateType<T extends DoreKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateDoreKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoreKesht[P]>
      : GetScalarType<T[P], AggregateDoreKesht[P]>
  }




  export type DoreKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoreKeshtWhereInput
    orderBy?: DoreKeshtOrderByWithAggregationInput | DoreKeshtOrderByWithAggregationInput[]
    by: DoreKeshtScalarFieldEnum[] | DoreKeshtScalarFieldEnum
    having?: DoreKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoreKeshtCountAggregateInputType | true
    _avg?: DoreKeshtAvgAggregateInputType
    _sum?: DoreKeshtSumAggregateInputType
    _min?: DoreKeshtMinAggregateInputType
    _max?: DoreKeshtMaxAggregateInputType
  }

  export type DoreKeshtGroupByOutputType = {
    IdDore: number
    Dore: string
    _count: DoreKeshtCountAggregateOutputType | null
    _avg: DoreKeshtAvgAggregateOutputType | null
    _sum: DoreKeshtSumAggregateOutputType | null
    _min: DoreKeshtMinAggregateOutputType | null
    _max: DoreKeshtMaxAggregateOutputType | null
  }

  type GetDoreKeshtGroupByPayload<T extends DoreKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoreKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoreKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoreKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], DoreKeshtGroupByOutputType[P]>
        }
      >
    >


  export type DoreKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDore?: boolean
    Dore?: boolean
    ShabakeDoreKesht?: boolean | DoreKesht$ShabakeDoreKeshtArgs<ExtArgs>
    TrikhDoreKesht?: boolean | DoreKesht$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | DoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doreKesht"]>



  export type DoreKeshtSelectScalar = {
    IdDore?: boolean
    Dore?: boolean
  }

  export type DoreKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDore" | "Dore", ExtArgs["result"]["doreKesht"]>
  export type DoreKeshtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShabakeDoreKesht?: boolean | DoreKesht$ShabakeDoreKeshtArgs<ExtArgs>
    TrikhDoreKesht?: boolean | DoreKesht$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | DoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DoreKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoreKesht"
    objects: {
      ShabakeDoreKesht: Prisma.$ShabakeDoreKeshtPayload<ExtArgs>[]
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdDore: number
      Dore: string
    }, ExtArgs["result"]["doreKesht"]>
    composites: {}
  }

  type DoreKeshtGetPayload<S extends boolean | null | undefined | DoreKeshtDefaultArgs> = $Result.GetResult<Prisma.$DoreKeshtPayload, S>

  type DoreKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoreKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoreKeshtCountAggregateInputType | true
    }

  export interface DoreKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoreKesht'], meta: { name: 'DoreKesht' } }
    /**
     * Find zero or one DoreKesht that matches the filter.
     * @param {DoreKeshtFindUniqueArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoreKeshtFindUniqueArgs>(args: SelectSubset<T, DoreKeshtFindUniqueArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DoreKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoreKeshtFindUniqueOrThrowArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoreKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, DoreKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DoreKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindFirstArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoreKeshtFindFirstArgs>(args?: SelectSubset<T, DoreKeshtFindFirstArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DoreKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindFirstOrThrowArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoreKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, DoreKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DoreKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoreKeshts
     * const doreKeshts = await prisma.doreKesht.findMany()
     * 
     * // Get first 10 DoreKeshts
     * const doreKeshts = await prisma.doreKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdDore`
     * const doreKeshtWithIdDoreOnly = await prisma.doreKesht.findMany({ select: { IdDore: true } })
     * 
     */
    findMany<T extends DoreKeshtFindManyArgs>(args?: SelectSubset<T, DoreKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DoreKesht.
     * @param {DoreKeshtCreateArgs} args - Arguments to create a DoreKesht.
     * @example
     * // Create one DoreKesht
     * const DoreKesht = await prisma.doreKesht.create({
     *   data: {
     *     // ... data to create a DoreKesht
     *   }
     * })
     * 
     */
    create<T extends DoreKeshtCreateArgs>(args: SelectSubset<T, DoreKeshtCreateArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DoreKeshts.
     * @param {DoreKeshtCreateManyArgs} args - Arguments to create many DoreKeshts.
     * @example
     * // Create many DoreKeshts
     * const doreKesht = await prisma.doreKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoreKeshtCreateManyArgs>(args?: SelectSubset<T, DoreKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DoreKesht.
     * @param {DoreKeshtDeleteArgs} args - Arguments to delete one DoreKesht.
     * @example
     * // Delete one DoreKesht
     * const DoreKesht = await prisma.doreKesht.delete({
     *   where: {
     *     // ... filter to delete one DoreKesht
     *   }
     * })
     * 
     */
    delete<T extends DoreKeshtDeleteArgs>(args: SelectSubset<T, DoreKeshtDeleteArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DoreKesht.
     * @param {DoreKeshtUpdateArgs} args - Arguments to update one DoreKesht.
     * @example
     * // Update one DoreKesht
     * const doreKesht = await prisma.doreKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoreKeshtUpdateArgs>(args: SelectSubset<T, DoreKeshtUpdateArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DoreKeshts.
     * @param {DoreKeshtDeleteManyArgs} args - Arguments to filter DoreKeshts to delete.
     * @example
     * // Delete a few DoreKeshts
     * const { count } = await prisma.doreKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoreKeshtDeleteManyArgs>(args?: SelectSubset<T, DoreKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoreKeshts
     * const doreKesht = await prisma.doreKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoreKeshtUpdateManyArgs>(args: SelectSubset<T, DoreKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoreKesht.
     * @param {DoreKeshtUpsertArgs} args - Arguments to update or create a DoreKesht.
     * @example
     * // Update or create a DoreKesht
     * const doreKesht = await prisma.doreKesht.upsert({
     *   create: {
     *     // ... data to create a DoreKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoreKesht we want to update
     *   }
     * })
     */
    upsert<T extends DoreKeshtUpsertArgs>(args: SelectSubset<T, DoreKeshtUpsertArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtCountArgs} args - Arguments to filter DoreKeshts to count.
     * @example
     * // Count the number of DoreKeshts
     * const count = await prisma.doreKesht.count({
     *   where: {
     *     // ... the filter for the DoreKeshts we want to count
     *   }
     * })
    **/
    count<T extends DoreKeshtCountArgs>(
      args?: Subset<T, DoreKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoreKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoreKeshtAggregateArgs>(args: Subset<T, DoreKeshtAggregateArgs>): Prisma.PrismaPromise<GetDoreKeshtAggregateType<T>>

    /**
     * Group by DoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoreKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoreKeshtGroupByArgs['orderBy'] }
        : { orderBy?: DoreKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoreKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoreKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoreKesht model
   */
  readonly fields: DoreKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoreKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoreKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShabakeDoreKesht<T extends DoreKesht$ShabakeDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, DoreKesht$ShabakeDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TrikhDoreKesht<T extends DoreKesht$TrikhDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, DoreKesht$TrikhDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoreKesht model
   */ 
  interface DoreKeshtFieldRefs {
    readonly IdDore: FieldRef<"DoreKesht", 'Int'>
    readonly Dore: FieldRef<"DoreKesht", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoreKesht findUnique
   */
  export type DoreKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht findUniqueOrThrow
   */
  export type DoreKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht findFirst
   */
  export type DoreKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoreKeshts.
     */
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht findFirstOrThrow
   */
  export type DoreKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoreKeshts.
     */
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht findMany
   */
  export type DoreKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which DoreKeshts to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht create
   */
  export type DoreKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to create a DoreKesht.
     */
    data: XOR<DoreKeshtCreateInput, DoreKeshtUncheckedCreateInput>
  }

  /**
   * DoreKesht createMany
   */
  export type DoreKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoreKeshts.
     */
    data: DoreKeshtCreateManyInput | DoreKeshtCreateManyInput[]
  }

  /**
   * DoreKesht update
   */
  export type DoreKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to update a DoreKesht.
     */
    data: XOR<DoreKeshtUpdateInput, DoreKeshtUncheckedUpdateInput>
    /**
     * Choose, which DoreKesht to update.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht updateMany
   */
  export type DoreKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoreKeshts.
     */
    data: XOR<DoreKeshtUpdateManyMutationInput, DoreKeshtUncheckedUpdateManyInput>
    /**
     * Filter which DoreKeshts to update
     */
    where?: DoreKeshtWhereInput
    /**
     * Limit how many DoreKeshts to update.
     */
    limit?: number
  }

  /**
   * DoreKesht upsert
   */
  export type DoreKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * The filter to search for the DoreKesht to update in case it exists.
     */
    where: DoreKeshtWhereUniqueInput
    /**
     * In case the DoreKesht found by the `where` argument doesn't exist, create a new DoreKesht with this data.
     */
    create: XOR<DoreKeshtCreateInput, DoreKeshtUncheckedCreateInput>
    /**
     * In case the DoreKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoreKeshtUpdateInput, DoreKeshtUncheckedUpdateInput>
  }

  /**
   * DoreKesht delete
   */
  export type DoreKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
    /**
     * Filter which DoreKesht to delete.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht deleteMany
   */
  export type DoreKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoreKeshts to delete
     */
    where?: DoreKeshtWhereInput
    /**
     * Limit how many DoreKeshts to delete.
     */
    limit?: number
  }

  /**
   * DoreKesht.ShabakeDoreKesht
   */
  export type DoreKesht$ShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    where?: ShabakeDoreKeshtWhereInput
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht.TrikhDoreKesht
   */
  export type DoreKesht$TrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    where?: TrikhDoreKeshtWhereInput
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    cursor?: TrikhDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht without action
   */
  export type DoreKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoreKeshtInclude<ExtArgs> | null
  }


  /**
   * Model EshtebahAvamel
   */

  export type AggregateEshtebahAvamel = {
    _count: EshtebahAvamelCountAggregateOutputType | null
    _avg: EshtebahAvamelAvgAggregateOutputType | null
    _sum: EshtebahAvamelSumAggregateOutputType | null
    _min: EshtebahAvamelMinAggregateOutputType | null
    _max: EshtebahAvamelMaxAggregateOutputType | null
  }

  export type EshtebahAvamelAvgAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelSumAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelMinAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelMaxAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelCountAggregateOutputType = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
    _all: number
  }


  export type EshtebahAvamelAvgAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelSumAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelMinAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelMaxAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelCountAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
    _all?: true
  }

  export type EshtebahAvamelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EshtebahAvamel to aggregate.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EshtebahAvamels
    **/
    _count?: true | EshtebahAvamelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EshtebahAvamelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EshtebahAvamelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EshtebahAvamelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EshtebahAvamelMaxAggregateInputType
  }

  export type GetEshtebahAvamelAggregateType<T extends EshtebahAvamelAggregateArgs> = {
        [P in keyof T & keyof AggregateEshtebahAvamel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEshtebahAvamel[P]>
      : GetScalarType<T[P], AggregateEshtebahAvamel[P]>
  }




  export type EshtebahAvamelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EshtebahAvamelWhereInput
    orderBy?: EshtebahAvamelOrderByWithAggregationInput | EshtebahAvamelOrderByWithAggregationInput[]
    by: EshtebahAvamelScalarFieldEnum[] | EshtebahAvamelScalarFieldEnum
    having?: EshtebahAvamelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EshtebahAvamelCountAggregateInputType | true
    _avg?: EshtebahAvamelAvgAggregateInputType
    _sum?: EshtebahAvamelSumAggregateInputType
    _min?: EshtebahAvamelMinAggregateInputType
    _max?: EshtebahAvamelMaxAggregateInputType
  }

  export type EshtebahAvamelGroupByOutputType = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
    _count: EshtebahAvamelCountAggregateOutputType | null
    _avg: EshtebahAvamelAvgAggregateOutputType | null
    _sum: EshtebahAvamelSumAggregateOutputType | null
    _min: EshtebahAvamelMinAggregateOutputType | null
    _max: EshtebahAvamelMaxAggregateOutputType | null
  }

  type GetEshtebahAvamelGroupByPayload<T extends EshtebahAvamelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EshtebahAvamelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EshtebahAvamelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EshtebahAvamelGroupByOutputType[P]>
            : GetScalarType<T[P], EshtebahAvamelGroupByOutputType[P]>
        }
      >
    >


  export type EshtebahAvamelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdEsht?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Eshtebah?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eshtebahAvamel"]>



  export type EshtebahAvamelSelectScalar = {
    IdEsht?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Eshtebah?: boolean
  }

  export type EshtebahAvamelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdEsht" | "FIdRanesh" | "FIdTarDor" | "Eshtebah", ExtArgs["result"]["eshtebahAvamel"]>
  export type EshtebahAvamelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $EshtebahAvamelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EshtebahAvamel"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdEsht: number
      FIdRanesh: number
      FIdTarDor: number
      Eshtebah: number
    }, ExtArgs["result"]["eshtebahAvamel"]>
    composites: {}
  }

  type EshtebahAvamelGetPayload<S extends boolean | null | undefined | EshtebahAvamelDefaultArgs> = $Result.GetResult<Prisma.$EshtebahAvamelPayload, S>

  type EshtebahAvamelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EshtebahAvamelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EshtebahAvamelCountAggregateInputType | true
    }

  export interface EshtebahAvamelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EshtebahAvamel'], meta: { name: 'EshtebahAvamel' } }
    /**
     * Find zero or one EshtebahAvamel that matches the filter.
     * @param {EshtebahAvamelFindUniqueArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EshtebahAvamelFindUniqueArgs>(args: SelectSubset<T, EshtebahAvamelFindUniqueArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EshtebahAvamel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EshtebahAvamelFindUniqueOrThrowArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EshtebahAvamelFindUniqueOrThrowArgs>(args: SelectSubset<T, EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EshtebahAvamel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindFirstArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EshtebahAvamelFindFirstArgs>(args?: SelectSubset<T, EshtebahAvamelFindFirstArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EshtebahAvamel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindFirstOrThrowArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EshtebahAvamelFindFirstOrThrowArgs>(args?: SelectSubset<T, EshtebahAvamelFindFirstOrThrowArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EshtebahAvamels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EshtebahAvamels
     * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany()
     * 
     * // Get first 10 EshtebahAvamels
     * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany({ take: 10 })
     * 
     * // Only select the `IdEsht`
     * const eshtebahAvamelWithIdEshtOnly = await prisma.eshtebahAvamel.findMany({ select: { IdEsht: true } })
     * 
     */
    findMany<T extends EshtebahAvamelFindManyArgs>(args?: SelectSubset<T, EshtebahAvamelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EshtebahAvamel.
     * @param {EshtebahAvamelCreateArgs} args - Arguments to create a EshtebahAvamel.
     * @example
     * // Create one EshtebahAvamel
     * const EshtebahAvamel = await prisma.eshtebahAvamel.create({
     *   data: {
     *     // ... data to create a EshtebahAvamel
     *   }
     * })
     * 
     */
    create<T extends EshtebahAvamelCreateArgs>(args: SelectSubset<T, EshtebahAvamelCreateArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EshtebahAvamels.
     * @param {EshtebahAvamelCreateManyArgs} args - Arguments to create many EshtebahAvamels.
     * @example
     * // Create many EshtebahAvamels
     * const eshtebahAvamel = await prisma.eshtebahAvamel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EshtebahAvamelCreateManyArgs>(args?: SelectSubset<T, EshtebahAvamelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EshtebahAvamel.
     * @param {EshtebahAvamelDeleteArgs} args - Arguments to delete one EshtebahAvamel.
     * @example
     * // Delete one EshtebahAvamel
     * const EshtebahAvamel = await prisma.eshtebahAvamel.delete({
     *   where: {
     *     // ... filter to delete one EshtebahAvamel
     *   }
     * })
     * 
     */
    delete<T extends EshtebahAvamelDeleteArgs>(args: SelectSubset<T, EshtebahAvamelDeleteArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EshtebahAvamel.
     * @param {EshtebahAvamelUpdateArgs} args - Arguments to update one EshtebahAvamel.
     * @example
     * // Update one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EshtebahAvamelUpdateArgs>(args: SelectSubset<T, EshtebahAvamelUpdateArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EshtebahAvamels.
     * @param {EshtebahAvamelDeleteManyArgs} args - Arguments to filter EshtebahAvamels to delete.
     * @example
     * // Delete a few EshtebahAvamels
     * const { count } = await prisma.eshtebahAvamel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EshtebahAvamelDeleteManyArgs>(args?: SelectSubset<T, EshtebahAvamelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EshtebahAvamels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EshtebahAvamels
     * const eshtebahAvamel = await prisma.eshtebahAvamel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EshtebahAvamelUpdateManyArgs>(args: SelectSubset<T, EshtebahAvamelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EshtebahAvamel.
     * @param {EshtebahAvamelUpsertArgs} args - Arguments to update or create a EshtebahAvamel.
     * @example
     * // Update or create a EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.upsert({
     *   create: {
     *     // ... data to create a EshtebahAvamel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EshtebahAvamel we want to update
     *   }
     * })
     */
    upsert<T extends EshtebahAvamelUpsertArgs>(args: SelectSubset<T, EshtebahAvamelUpsertArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EshtebahAvamels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelCountArgs} args - Arguments to filter EshtebahAvamels to count.
     * @example
     * // Count the number of EshtebahAvamels
     * const count = await prisma.eshtebahAvamel.count({
     *   where: {
     *     // ... the filter for the EshtebahAvamels we want to count
     *   }
     * })
    **/
    count<T extends EshtebahAvamelCountArgs>(
      args?: Subset<T, EshtebahAvamelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EshtebahAvamelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EshtebahAvamel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EshtebahAvamelAggregateArgs>(args: Subset<T, EshtebahAvamelAggregateArgs>): Prisma.PrismaPromise<GetEshtebahAvamelAggregateType<T>>

    /**
     * Group by EshtebahAvamel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EshtebahAvamelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EshtebahAvamelGroupByArgs['orderBy'] }
        : { orderBy?: EshtebahAvamelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EshtebahAvamelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEshtebahAvamelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EshtebahAvamel model
   */
  readonly fields: EshtebahAvamelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EshtebahAvamel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EshtebahAvamelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EshtebahAvamel model
   */ 
  interface EshtebahAvamelFieldRefs {
    readonly IdEsht: FieldRef<"EshtebahAvamel", 'Int'>
    readonly FIdRanesh: FieldRef<"EshtebahAvamel", 'Int'>
    readonly FIdTarDor: FieldRef<"EshtebahAvamel", 'Int'>
    readonly Eshtebah: FieldRef<"EshtebahAvamel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EshtebahAvamel findUnique
   */
  export type EshtebahAvamelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel findUniqueOrThrow
   */
  export type EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel findFirst
   */
  export type EshtebahAvamelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EshtebahAvamels.
     */
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel findFirstOrThrow
   */
  export type EshtebahAvamelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EshtebahAvamels.
     */
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel findMany
   */
  export type EshtebahAvamelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamels to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel create
   */
  export type EshtebahAvamelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * The data needed to create a EshtebahAvamel.
     */
    data: XOR<EshtebahAvamelCreateInput, EshtebahAvamelUncheckedCreateInput>
  }

  /**
   * EshtebahAvamel createMany
   */
  export type EshtebahAvamelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EshtebahAvamels.
     */
    data: EshtebahAvamelCreateManyInput | EshtebahAvamelCreateManyInput[]
  }

  /**
   * EshtebahAvamel update
   */
  export type EshtebahAvamelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * The data needed to update a EshtebahAvamel.
     */
    data: XOR<EshtebahAvamelUpdateInput, EshtebahAvamelUncheckedUpdateInput>
    /**
     * Choose, which EshtebahAvamel to update.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel updateMany
   */
  export type EshtebahAvamelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EshtebahAvamels.
     */
    data: XOR<EshtebahAvamelUpdateManyMutationInput, EshtebahAvamelUncheckedUpdateManyInput>
    /**
     * Filter which EshtebahAvamels to update
     */
    where?: EshtebahAvamelWhereInput
    /**
     * Limit how many EshtebahAvamels to update.
     */
    limit?: number
  }

  /**
   * EshtebahAvamel upsert
   */
  export type EshtebahAvamelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * The filter to search for the EshtebahAvamel to update in case it exists.
     */
    where: EshtebahAvamelWhereUniqueInput
    /**
     * In case the EshtebahAvamel found by the `where` argument doesn't exist, create a new EshtebahAvamel with this data.
     */
    create: XOR<EshtebahAvamelCreateInput, EshtebahAvamelUncheckedCreateInput>
    /**
     * In case the EshtebahAvamel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EshtebahAvamelUpdateInput, EshtebahAvamelUncheckedUpdateInput>
  }

  /**
   * EshtebahAvamel delete
   */
  export type EshtebahAvamelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    /**
     * Filter which EshtebahAvamel to delete.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel deleteMany
   */
  export type EshtebahAvamelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EshtebahAvamels to delete
     */
    where?: EshtebahAvamelWhereInput
    /**
     * Limit how many EshtebahAvamels to delete.
     */
    limit?: number
  }

  /**
   * EshtebahAvamel without action
   */
  export type EshtebahAvamelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
  }


  /**
   * Model FlowBehbood
   */

  export type AggregateFlowBehbood = {
    _count: FlowBehboodCountAggregateOutputType | null
    _avg: FlowBehboodAvgAggregateOutputType | null
    _sum: FlowBehboodSumAggregateOutputType | null
    _min: FlowBehboodMinAggregateOutputType | null
    _max: FlowBehboodMaxAggregateOutputType | null
  }

  export type FlowBehboodAvgAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodSumAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodMinAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodMaxAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodCountAggregateOutputType = {
    IdBehbood: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
    _all: number
  }


  export type FlowBehboodAvgAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodSumAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodMinAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodMaxAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodCountAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
    _all?: true
  }

  export type FlowBehboodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowBehbood to aggregate.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowBehboods
    **/
    _count?: true | FlowBehboodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowBehboodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowBehboodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowBehboodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowBehboodMaxAggregateInputType
  }

  export type GetFlowBehboodAggregateType<T extends FlowBehboodAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowBehbood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowBehbood[P]>
      : GetScalarType<T[P], AggregateFlowBehbood[P]>
  }




  export type FlowBehboodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowBehboodWhereInput
    orderBy?: FlowBehboodOrderByWithAggregationInput | FlowBehboodOrderByWithAggregationInput[]
    by: FlowBehboodScalarFieldEnum[] | FlowBehboodScalarFieldEnum
    having?: FlowBehboodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowBehboodCountAggregateInputType | true
    _avg?: FlowBehboodAvgAggregateInputType
    _sum?: FlowBehboodSumAggregateInputType
    _min?: FlowBehboodMinAggregateInputType
    _max?: FlowBehboodMaxAggregateInputType
  }

  export type FlowBehboodGroupByOutputType = {
    IdBehbood: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
    _count: FlowBehboodCountAggregateOutputType | null
    _avg: FlowBehboodAvgAggregateOutputType | null
    _sum: FlowBehboodSumAggregateOutputType | null
    _min: FlowBehboodMinAggregateOutputType | null
    _max: FlowBehboodMaxAggregateOutputType | null
  }

  type GetFlowBehboodGroupByPayload<T extends FlowBehboodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowBehboodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowBehboodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowBehboodGroupByOutputType[P]>
            : GetScalarType<T[P], FlowBehboodGroupByOutputType[P]>
        }
      >
    >


  export type FlowBehboodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBehbood?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Flow?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowBehbood"]>



  export type FlowBehboodSelectScalar = {
    IdBehbood?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Flow?: boolean
  }

  export type FlowBehboodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBehbood" | "FIdRanesh" | "FIdTarDor" | "Flow", ExtArgs["result"]["flowBehbood"]>
  export type FlowBehboodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $FlowBehboodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowBehbood"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdBehbood: number
      FIdRanesh: number
      FIdTarDor: number
      Flow: number
    }, ExtArgs["result"]["flowBehbood"]>
    composites: {}
  }

  type FlowBehboodGetPayload<S extends boolean | null | undefined | FlowBehboodDefaultArgs> = $Result.GetResult<Prisma.$FlowBehboodPayload, S>

  type FlowBehboodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowBehboodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowBehboodCountAggregateInputType | true
    }

  export interface FlowBehboodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowBehbood'], meta: { name: 'FlowBehbood' } }
    /**
     * Find zero or one FlowBehbood that matches the filter.
     * @param {FlowBehboodFindUniqueArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowBehboodFindUniqueArgs>(args: SelectSubset<T, FlowBehboodFindUniqueArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FlowBehbood that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowBehboodFindUniqueOrThrowArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowBehboodFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowBehboodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FlowBehbood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindFirstArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowBehboodFindFirstArgs>(args?: SelectSubset<T, FlowBehboodFindFirstArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FlowBehbood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindFirstOrThrowArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowBehboodFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowBehboodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FlowBehboods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowBehboods
     * const flowBehboods = await prisma.flowBehbood.findMany()
     * 
     * // Get first 10 FlowBehboods
     * const flowBehboods = await prisma.flowBehbood.findMany({ take: 10 })
     * 
     * // Only select the `IdBehbood`
     * const flowBehboodWithIdBehboodOnly = await prisma.flowBehbood.findMany({ select: { IdBehbood: true } })
     * 
     */
    findMany<T extends FlowBehboodFindManyArgs>(args?: SelectSubset<T, FlowBehboodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FlowBehbood.
     * @param {FlowBehboodCreateArgs} args - Arguments to create a FlowBehbood.
     * @example
     * // Create one FlowBehbood
     * const FlowBehbood = await prisma.flowBehbood.create({
     *   data: {
     *     // ... data to create a FlowBehbood
     *   }
     * })
     * 
     */
    create<T extends FlowBehboodCreateArgs>(args: SelectSubset<T, FlowBehboodCreateArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FlowBehboods.
     * @param {FlowBehboodCreateManyArgs} args - Arguments to create many FlowBehboods.
     * @example
     * // Create many FlowBehboods
     * const flowBehbood = await prisma.flowBehbood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowBehboodCreateManyArgs>(args?: SelectSubset<T, FlowBehboodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FlowBehbood.
     * @param {FlowBehboodDeleteArgs} args - Arguments to delete one FlowBehbood.
     * @example
     * // Delete one FlowBehbood
     * const FlowBehbood = await prisma.flowBehbood.delete({
     *   where: {
     *     // ... filter to delete one FlowBehbood
     *   }
     * })
     * 
     */
    delete<T extends FlowBehboodDeleteArgs>(args: SelectSubset<T, FlowBehboodDeleteArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FlowBehbood.
     * @param {FlowBehboodUpdateArgs} args - Arguments to update one FlowBehbood.
     * @example
     * // Update one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowBehboodUpdateArgs>(args: SelectSubset<T, FlowBehboodUpdateArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FlowBehboods.
     * @param {FlowBehboodDeleteManyArgs} args - Arguments to filter FlowBehboods to delete.
     * @example
     * // Delete a few FlowBehboods
     * const { count } = await prisma.flowBehbood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowBehboodDeleteManyArgs>(args?: SelectSubset<T, FlowBehboodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowBehboods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowBehboods
     * const flowBehbood = await prisma.flowBehbood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowBehboodUpdateManyArgs>(args: SelectSubset<T, FlowBehboodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlowBehbood.
     * @param {FlowBehboodUpsertArgs} args - Arguments to update or create a FlowBehbood.
     * @example
     * // Update or create a FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.upsert({
     *   create: {
     *     // ... data to create a FlowBehbood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowBehbood we want to update
     *   }
     * })
     */
    upsert<T extends FlowBehboodUpsertArgs>(args: SelectSubset<T, FlowBehboodUpsertArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FlowBehboods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodCountArgs} args - Arguments to filter FlowBehboods to count.
     * @example
     * // Count the number of FlowBehboods
     * const count = await prisma.flowBehbood.count({
     *   where: {
     *     // ... the filter for the FlowBehboods we want to count
     *   }
     * })
    **/
    count<T extends FlowBehboodCountArgs>(
      args?: Subset<T, FlowBehboodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowBehboodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowBehbood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowBehboodAggregateArgs>(args: Subset<T, FlowBehboodAggregateArgs>): Prisma.PrismaPromise<GetFlowBehboodAggregateType<T>>

    /**
     * Group by FlowBehbood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowBehboodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowBehboodGroupByArgs['orderBy'] }
        : { orderBy?: FlowBehboodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowBehboodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowBehboodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowBehbood model
   */
  readonly fields: FlowBehboodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowBehbood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowBehboodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowBehbood model
   */ 
  interface FlowBehboodFieldRefs {
    readonly IdBehbood: FieldRef<"FlowBehbood", 'Int'>
    readonly FIdRanesh: FieldRef<"FlowBehbood", 'Int'>
    readonly FIdTarDor: FieldRef<"FlowBehbood", 'Int'>
    readonly Flow: FieldRef<"FlowBehbood", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FlowBehbood findUnique
   */
  export type FlowBehboodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood findUniqueOrThrow
   */
  export type FlowBehboodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood findFirst
   */
  export type FlowBehboodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowBehboods.
     */
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood findFirstOrThrow
   */
  export type FlowBehboodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowBehboods.
     */
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood findMany
   */
  export type FlowBehboodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter, which FlowBehboods to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood create
   */
  export type FlowBehboodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowBehbood.
     */
    data: XOR<FlowBehboodCreateInput, FlowBehboodUncheckedCreateInput>
  }

  /**
   * FlowBehbood createMany
   */
  export type FlowBehboodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowBehboods.
     */
    data: FlowBehboodCreateManyInput | FlowBehboodCreateManyInput[]
  }

  /**
   * FlowBehbood update
   */
  export type FlowBehboodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowBehbood.
     */
    data: XOR<FlowBehboodUpdateInput, FlowBehboodUncheckedUpdateInput>
    /**
     * Choose, which FlowBehbood to update.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood updateMany
   */
  export type FlowBehboodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowBehboods.
     */
    data: XOR<FlowBehboodUpdateManyMutationInput, FlowBehboodUncheckedUpdateManyInput>
    /**
     * Filter which FlowBehboods to update
     */
    where?: FlowBehboodWhereInput
    /**
     * Limit how many FlowBehboods to update.
     */
    limit?: number
  }

  /**
   * FlowBehbood upsert
   */
  export type FlowBehboodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowBehbood to update in case it exists.
     */
    where: FlowBehboodWhereUniqueInput
    /**
     * In case the FlowBehbood found by the `where` argument doesn't exist, create a new FlowBehbood with this data.
     */
    create: XOR<FlowBehboodCreateInput, FlowBehboodUncheckedCreateInput>
    /**
     * In case the FlowBehbood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowBehboodUpdateInput, FlowBehboodUncheckedUpdateInput>
  }

  /**
   * FlowBehbood delete
   */
  export type FlowBehboodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    /**
     * Filter which FlowBehbood to delete.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood deleteMany
   */
  export type FlowBehboodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowBehboods to delete
     */
    where?: FlowBehboodWhereInput
    /**
     * Limit how many FlowBehboods to delete.
     */
    limit?: number
  }

  /**
   * FlowBehbood without action
   */
  export type FlowBehboodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
  }


  /**
   * Model Flowmeter
   */

  export type AggregateFlowmeter = {
    _count: FlowmeterCountAggregateOutputType | null
    _avg: FlowmeterAvgAggregateOutputType | null
    _sum: FlowmeterSumAggregateOutputType | null
    _min: FlowmeterMinAggregateOutputType | null
    _max: FlowmeterMaxAggregateOutputType | null
  }

  export type FlowmeterAvgAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterSumAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterMinAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterMaxAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterCountAggregateOutputType = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
    _all: number
  }


  export type FlowmeterAvgAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterSumAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterMinAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterMaxAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterCountAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
    _all?: true
  }

  export type FlowmeterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowmeter to aggregate.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flowmeters
    **/
    _count?: true | FlowmeterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowmeterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowmeterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowmeterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowmeterMaxAggregateInputType
  }

  export type GetFlowmeterAggregateType<T extends FlowmeterAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowmeter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowmeter[P]>
      : GetScalarType<T[P], AggregateFlowmeter[P]>
  }




  export type FlowmeterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowmeterWhereInput
    orderBy?: FlowmeterOrderByWithAggregationInput | FlowmeterOrderByWithAggregationInput[]
    by: FlowmeterScalarFieldEnum[] | FlowmeterScalarFieldEnum
    having?: FlowmeterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowmeterCountAggregateInputType | true
    _avg?: FlowmeterAvgAggregateInputType
    _sum?: FlowmeterSumAggregateInputType
    _min?: FlowmeterMinAggregateInputType
    _max?: FlowmeterMaxAggregateInputType
  }

  export type FlowmeterGroupByOutputType = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
    _count: FlowmeterCountAggregateOutputType | null
    _avg: FlowmeterAvgAggregateOutputType | null
    _sum: FlowmeterSumAggregateOutputType | null
    _min: FlowmeterMinAggregateOutputType | null
    _max: FlowmeterMaxAggregateOutputType | null
  }

  type GetFlowmeterGroupByPayload<T extends FlowmeterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowmeterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowmeterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowmeterGroupByOutputType[P]>
            : GetScalarType<T[P], FlowmeterGroupByOutputType[P]>
        }
      >
    >


  export type FlowmeterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdFIT?: boolean
    FIdRanesh?: boolean
    FIdTrikh?: boolean
    Flowmeter?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowmeter"]>



  export type FlowmeterSelectScalar = {
    IdFIT?: boolean
    FIdRanesh?: boolean
    FIdTrikh?: boolean
    Flowmeter?: boolean
  }

  export type FlowmeterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdFIT" | "FIdRanesh" | "FIdTrikh" | "Flowmeter", ExtArgs["result"]["flowmeter"]>
  export type FlowmeterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $FlowmeterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flowmeter"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdFIT: number
      FIdRanesh: number
      FIdTrikh: number
      Flowmeter: number
    }, ExtArgs["result"]["flowmeter"]>
    composites: {}
  }

  type FlowmeterGetPayload<S extends boolean | null | undefined | FlowmeterDefaultArgs> = $Result.GetResult<Prisma.$FlowmeterPayload, S>

  type FlowmeterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowmeterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowmeterCountAggregateInputType | true
    }

  export interface FlowmeterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flowmeter'], meta: { name: 'Flowmeter' } }
    /**
     * Find zero or one Flowmeter that matches the filter.
     * @param {FlowmeterFindUniqueArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowmeterFindUniqueArgs>(args: SelectSubset<T, FlowmeterFindUniqueArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Flowmeter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowmeterFindUniqueOrThrowArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowmeterFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowmeterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Flowmeter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindFirstArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowmeterFindFirstArgs>(args?: SelectSubset<T, FlowmeterFindFirstArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Flowmeter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindFirstOrThrowArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowmeterFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowmeterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Flowmeters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flowmeters
     * const flowmeters = await prisma.flowmeter.findMany()
     * 
     * // Get first 10 Flowmeters
     * const flowmeters = await prisma.flowmeter.findMany({ take: 10 })
     * 
     * // Only select the `IdFIT`
     * const flowmeterWithIdFITOnly = await prisma.flowmeter.findMany({ select: { IdFIT: true } })
     * 
     */
    findMany<T extends FlowmeterFindManyArgs>(args?: SelectSubset<T, FlowmeterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Flowmeter.
     * @param {FlowmeterCreateArgs} args - Arguments to create a Flowmeter.
     * @example
     * // Create one Flowmeter
     * const Flowmeter = await prisma.flowmeter.create({
     *   data: {
     *     // ... data to create a Flowmeter
     *   }
     * })
     * 
     */
    create<T extends FlowmeterCreateArgs>(args: SelectSubset<T, FlowmeterCreateArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Flowmeters.
     * @param {FlowmeterCreateManyArgs} args - Arguments to create many Flowmeters.
     * @example
     * // Create many Flowmeters
     * const flowmeter = await prisma.flowmeter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowmeterCreateManyArgs>(args?: SelectSubset<T, FlowmeterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flowmeter.
     * @param {FlowmeterDeleteArgs} args - Arguments to delete one Flowmeter.
     * @example
     * // Delete one Flowmeter
     * const Flowmeter = await prisma.flowmeter.delete({
     *   where: {
     *     // ... filter to delete one Flowmeter
     *   }
     * })
     * 
     */
    delete<T extends FlowmeterDeleteArgs>(args: SelectSubset<T, FlowmeterDeleteArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Flowmeter.
     * @param {FlowmeterUpdateArgs} args - Arguments to update one Flowmeter.
     * @example
     * // Update one Flowmeter
     * const flowmeter = await prisma.flowmeter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowmeterUpdateArgs>(args: SelectSubset<T, FlowmeterUpdateArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Flowmeters.
     * @param {FlowmeterDeleteManyArgs} args - Arguments to filter Flowmeters to delete.
     * @example
     * // Delete a few Flowmeters
     * const { count } = await prisma.flowmeter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowmeterDeleteManyArgs>(args?: SelectSubset<T, FlowmeterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flowmeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flowmeters
     * const flowmeter = await prisma.flowmeter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowmeterUpdateManyArgs>(args: SelectSubset<T, FlowmeterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flowmeter.
     * @param {FlowmeterUpsertArgs} args - Arguments to update or create a Flowmeter.
     * @example
     * // Update or create a Flowmeter
     * const flowmeter = await prisma.flowmeter.upsert({
     *   create: {
     *     // ... data to create a Flowmeter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flowmeter we want to update
     *   }
     * })
     */
    upsert<T extends FlowmeterUpsertArgs>(args: SelectSubset<T, FlowmeterUpsertArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Flowmeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterCountArgs} args - Arguments to filter Flowmeters to count.
     * @example
     * // Count the number of Flowmeters
     * const count = await prisma.flowmeter.count({
     *   where: {
     *     // ... the filter for the Flowmeters we want to count
     *   }
     * })
    **/
    count<T extends FlowmeterCountArgs>(
      args?: Subset<T, FlowmeterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowmeterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flowmeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowmeterAggregateArgs>(args: Subset<T, FlowmeterAggregateArgs>): Prisma.PrismaPromise<GetFlowmeterAggregateType<T>>

    /**
     * Group by Flowmeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowmeterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowmeterGroupByArgs['orderBy'] }
        : { orderBy?: FlowmeterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowmeterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowmeterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flowmeter model
   */
  readonly fields: FlowmeterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flowmeter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowmeterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flowmeter model
   */ 
  interface FlowmeterFieldRefs {
    readonly IdFIT: FieldRef<"Flowmeter", 'Int'>
    readonly FIdRanesh: FieldRef<"Flowmeter", 'Int'>
    readonly FIdTrikh: FieldRef<"Flowmeter", 'Int'>
    readonly Flowmeter: FieldRef<"Flowmeter", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Flowmeter findUnique
   */
  export type FlowmeterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter findUniqueOrThrow
   */
  export type FlowmeterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter findFirst
   */
  export type FlowmeterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowmeters.
     */
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter findFirstOrThrow
   */
  export type FlowmeterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowmeters.
     */
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter findMany
   */
  export type FlowmeterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter, which Flowmeters to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter create
   */
  export type FlowmeterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * The data needed to create a Flowmeter.
     */
    data: XOR<FlowmeterCreateInput, FlowmeterUncheckedCreateInput>
  }

  /**
   * Flowmeter createMany
   */
  export type FlowmeterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flowmeters.
     */
    data: FlowmeterCreateManyInput | FlowmeterCreateManyInput[]
  }

  /**
   * Flowmeter update
   */
  export type FlowmeterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * The data needed to update a Flowmeter.
     */
    data: XOR<FlowmeterUpdateInput, FlowmeterUncheckedUpdateInput>
    /**
     * Choose, which Flowmeter to update.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter updateMany
   */
  export type FlowmeterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flowmeters.
     */
    data: XOR<FlowmeterUpdateManyMutationInput, FlowmeterUncheckedUpdateManyInput>
    /**
     * Filter which Flowmeters to update
     */
    where?: FlowmeterWhereInput
    /**
     * Limit how many Flowmeters to update.
     */
    limit?: number
  }

  /**
   * Flowmeter upsert
   */
  export type FlowmeterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * The filter to search for the Flowmeter to update in case it exists.
     */
    where: FlowmeterWhereUniqueInput
    /**
     * In case the Flowmeter found by the `where` argument doesn't exist, create a new Flowmeter with this data.
     */
    create: XOR<FlowmeterCreateInput, FlowmeterUncheckedCreateInput>
    /**
     * In case the Flowmeter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowmeterUpdateInput, FlowmeterUncheckedUpdateInput>
  }

  /**
   * Flowmeter delete
   */
  export type FlowmeterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    /**
     * Filter which Flowmeter to delete.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter deleteMany
   */
  export type FlowmeterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowmeters to delete
     */
    where?: FlowmeterWhereInput
    /**
     * Limit how many Flowmeters to delete.
     */
    limit?: number
  }

  /**
   * Flowmeter without action
   */
  export type FlowmeterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
  }


  /**
   * Model KhatRanesh
   */

  export type AggregateKhatRanesh = {
    _count: KhatRaneshCountAggregateOutputType | null
    _avg: KhatRaneshAvgAggregateOutputType | null
    _sum: KhatRaneshSumAggregateOutputType | null
    _min: KhatRaneshMinAggregateOutputType | null
    _max: KhatRaneshMaxAggregateOutputType | null
  }

  export type KhatRaneshAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshSumAggregateOutputType = {
    IdRanesh: number | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshMinAggregateOutputType = {
    IdRanesh: number | null
    RaneshName: string | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
    Active: boolean | null
  }

  export type KhatRaneshMaxAggregateOutputType = {
    IdRanesh: number | null
    RaneshName: string | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
    Active: boolean | null
  }

  export type KhatRaneshCountAggregateOutputType = {
    IdRanesh: number
    RaneshName: number
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active: number
    _all: number
  }


  export type KhatRaneshAvgAggregateInputType = {
    IdRanesh?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshSumAggregateInputType = {
    IdRanesh?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshMinAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
    Active?: true
  }

  export type KhatRaneshMaxAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
    Active?: true
  }

  export type KhatRaneshCountAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
    Active?: true
    _all?: true
  }

  export type KhatRaneshAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRanesh to aggregate.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshes
    **/
    _count?: true | KhatRaneshCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshMaxAggregateInputType
  }

  export type GetKhatRaneshAggregateType<T extends KhatRaneshAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRanesh]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRanesh[P]>
      : GetScalarType<T[P], AggregateKhatRanesh[P]>
  }




  export type KhatRaneshGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithAggregationInput | KhatRaneshOrderByWithAggregationInput[]
    by: KhatRaneshScalarFieldEnum[] | KhatRaneshScalarFieldEnum
    having?: KhatRaneshScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshCountAggregateInputType | true
    _avg?: KhatRaneshAvgAggregateInputType
    _sum?: KhatRaneshSumAggregateInputType
    _min?: KhatRaneshMinAggregateInputType
    _max?: KhatRaneshMaxAggregateInputType
  }

  export type KhatRaneshGroupByOutputType = {
    IdRanesh: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active: boolean
    _count: KhatRaneshCountAggregateOutputType | null
    _avg: KhatRaneshAvgAggregateOutputType | null
    _sum: KhatRaneshSumAggregateOutputType | null
    _min: KhatRaneshMinAggregateOutputType | null
    _max: KhatRaneshMaxAggregateOutputType | null
  }

  type GetKhatRaneshGroupByPayload<T extends KhatRaneshGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    RaneshName?: boolean
    FIdPumpSta?: boolean
    FIdDPipe?: boolean
    FIdSePu?: boolean
    FIdMeasuring?: boolean
    Active?: boolean
    Abgir?: boolean | KhatRanesh$AbgirArgs<ExtArgs>
    BahrebardairProgram?: boolean | KhatRanesh$BahrebardairProgramArgs<ExtArgs>
    BahrebardairProgramSeghli?: boolean | KhatRanesh$BahrebardairProgramSeghliArgs<ExtArgs>
    BahrebardariKeshtDore?: boolean | KhatRanesh$BahrebardariKeshtDoreArgs<ExtArgs>
    BahrebardariTaghvim?: boolean | KhatRanesh$BahrebardariTaghvimArgs<ExtArgs>
    EshtebahAvamel?: boolean | KhatRanesh$EshtebahAvamelArgs<ExtArgs>
    FlowBehbood?: boolean | KhatRanesh$FlowBehboodArgs<ExtArgs>
    Flowmeter?: boolean | KhatRanesh$FlowmeterArgs<ExtArgs>
    DarajePipe?: boolean | DarajePipeDefaultArgs<ExtArgs>
    MeasuringTool?: boolean | MeasuringToolDefaultArgs<ExtArgs>
    PumpStation?: boolean | PumpStationDefaultArgs<ExtArgs>
    SeghliPump?: boolean | SeghliPumpDefaultArgs<ExtArgs>
    KhatRaneshArea?: boolean | KhatRanesh$KhatRaneshAreaArgs<ExtArgs>
    KhatRaneshPump?: boolean | KhatRanesh$KhatRaneshPumpArgs<ExtArgs>
    KhatRaneshSegli?: boolean | KhatRanesh$KhatRaneshSegliArgs<ExtArgs>
    NashtShabake?: boolean | KhatRanesh$NashtShabakeArgs<ExtArgs>
    NonFIT?: boolean | KhatRanesh$NonFITArgs<ExtArgs>
    TakhlieMakhzan?: boolean | KhatRanesh$TakhlieMakhzanArgs<ExtArgs>
    Test?: boolean | KhatRanesh$TestArgs<ExtArgs>
    _count?: boolean | KhatRaneshCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["khatRanesh"]>



  export type KhatRaneshSelectScalar = {
    IdRanesh?: boolean
    RaneshName?: boolean
    FIdPumpSta?: boolean
    FIdDPipe?: boolean
    FIdSePu?: boolean
    FIdMeasuring?: boolean
    Active?: boolean
  }

  export type KhatRaneshOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "RaneshName" | "FIdPumpSta" | "FIdDPipe" | "FIdSePu" | "FIdMeasuring" | "Active", ExtArgs["result"]["khatRanesh"]>
  export type KhatRaneshInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Abgir?: boolean | KhatRanesh$AbgirArgs<ExtArgs>
    BahrebardairProgram?: boolean | KhatRanesh$BahrebardairProgramArgs<ExtArgs>
    BahrebardairProgramSeghli?: boolean | KhatRanesh$BahrebardairProgramSeghliArgs<ExtArgs>
    BahrebardariKeshtDore?: boolean | KhatRanesh$BahrebardariKeshtDoreArgs<ExtArgs>
    BahrebardariTaghvim?: boolean | KhatRanesh$BahrebardariTaghvimArgs<ExtArgs>
    EshtebahAvamel?: boolean | KhatRanesh$EshtebahAvamelArgs<ExtArgs>
    FlowBehbood?: boolean | KhatRanesh$FlowBehboodArgs<ExtArgs>
    Flowmeter?: boolean | KhatRanesh$FlowmeterArgs<ExtArgs>
    DarajePipe?: boolean | DarajePipeDefaultArgs<ExtArgs>
    MeasuringTool?: boolean | MeasuringToolDefaultArgs<ExtArgs>
    PumpStation?: boolean | PumpStationDefaultArgs<ExtArgs>
    SeghliPump?: boolean | SeghliPumpDefaultArgs<ExtArgs>
    KhatRaneshArea?: boolean | KhatRanesh$KhatRaneshAreaArgs<ExtArgs>
    KhatRaneshPump?: boolean | KhatRanesh$KhatRaneshPumpArgs<ExtArgs>
    KhatRaneshSegli?: boolean | KhatRanesh$KhatRaneshSegliArgs<ExtArgs>
    NashtShabake?: boolean | KhatRanesh$NashtShabakeArgs<ExtArgs>
    NonFIT?: boolean | KhatRanesh$NonFITArgs<ExtArgs>
    TakhlieMakhzan?: boolean | KhatRanesh$TakhlieMakhzanArgs<ExtArgs>
    Test?: boolean | KhatRanesh$TestArgs<ExtArgs>
    _count?: boolean | KhatRaneshCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $KhatRaneshPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRanesh"
    objects: {
      Abgir: Prisma.$AbgirPayload<ExtArgs>[]
      BahrebardairProgram: Prisma.$BahrebardairProgramPayload<ExtArgs>[]
      BahrebardairProgramSeghli: Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>[]
      BahrebardariKeshtDore: Prisma.$BahrebardariKeshtDorePayload<ExtArgs>[]
      BahrebardariTaghvim: Prisma.$BahrebardariTaghvimPayload<ExtArgs>[]
      EshtebahAvamel: Prisma.$EshtebahAvamelPayload<ExtArgs>[]
      FlowBehbood: Prisma.$FlowBehboodPayload<ExtArgs>[]
      Flowmeter: Prisma.$FlowmeterPayload<ExtArgs>[]
      DarajePipe: Prisma.$DarajePipePayload<ExtArgs>
      MeasuringTool: Prisma.$MeasuringToolPayload<ExtArgs>
      PumpStation: Prisma.$PumpStationPayload<ExtArgs>
      SeghliPump: Prisma.$SeghliPumpPayload<ExtArgs>
      KhatRaneshArea: Prisma.$KhatRaneshAreaPayload<ExtArgs>[]
      KhatRaneshPump: Prisma.$KhatRaneshPumpPayload<ExtArgs>[]
      KhatRaneshSegli: Prisma.$KhatRaneshSegliPayload<ExtArgs>[]
      NashtShabake: Prisma.$NashtShabakePayload<ExtArgs>[]
      NonFIT: Prisma.$NonFITPayload<ExtArgs>[]
      TakhlieMakhzan: Prisma.$TakhlieMakhzanPayload<ExtArgs>[]
      Test: Prisma.$TestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      RaneshName: string
      FIdPumpSta: number
      FIdDPipe: number
      FIdSePu: number
      FIdMeasuring: number
      Active: boolean
    }, ExtArgs["result"]["khatRanesh"]>
    composites: {}
  }

  type KhatRaneshGetPayload<S extends boolean | null | undefined | KhatRaneshDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshPayload, S>

  type KhatRaneshCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshCountAggregateInputType | true
    }

  export interface KhatRaneshDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRanesh'], meta: { name: 'KhatRanesh' } }
    /**
     * Find zero or one KhatRanesh that matches the filter.
     * @param {KhatRaneshFindUniqueArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshFindUniqueArgs>(args: SelectSubset<T, KhatRaneshFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRanesh that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshFindUniqueOrThrowArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRanesh that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindFirstArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshFindFirstArgs>(args?: SelectSubset<T, KhatRaneshFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRanesh that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindFirstOrThrowArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshes
     * const khatRaneshes = await prisma.khatRanesh.findMany()
     * 
     * // Get first 10 KhatRaneshes
     * const khatRaneshes = await prisma.khatRanesh.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshWithIdRaneshOnly = await prisma.khatRanesh.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshFindManyArgs>(args?: SelectSubset<T, KhatRaneshFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRanesh.
     * @param {KhatRaneshCreateArgs} args - Arguments to create a KhatRanesh.
     * @example
     * // Create one KhatRanesh
     * const KhatRanesh = await prisma.khatRanesh.create({
     *   data: {
     *     // ... data to create a KhatRanesh
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshCreateArgs>(args: SelectSubset<T, KhatRaneshCreateArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshes.
     * @param {KhatRaneshCreateManyArgs} args - Arguments to create many KhatRaneshes.
     * @example
     * // Create many KhatRaneshes
     * const khatRanesh = await prisma.khatRanesh.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshCreateManyArgs>(args?: SelectSubset<T, KhatRaneshCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRanesh.
     * @param {KhatRaneshDeleteArgs} args - Arguments to delete one KhatRanesh.
     * @example
     * // Delete one KhatRanesh
     * const KhatRanesh = await prisma.khatRanesh.delete({
     *   where: {
     *     // ... filter to delete one KhatRanesh
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshDeleteArgs>(args: SelectSubset<T, KhatRaneshDeleteArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRanesh.
     * @param {KhatRaneshUpdateArgs} args - Arguments to update one KhatRanesh.
     * @example
     * // Update one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshUpdateArgs>(args: SelectSubset<T, KhatRaneshUpdateArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshes.
     * @param {KhatRaneshDeleteManyArgs} args - Arguments to filter KhatRaneshes to delete.
     * @example
     * // Delete a few KhatRaneshes
     * const { count } = await prisma.khatRanesh.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshes
     * const khatRanesh = await prisma.khatRanesh.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshUpdateManyArgs>(args: SelectSubset<T, KhatRaneshUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRanesh.
     * @param {KhatRaneshUpsertArgs} args - Arguments to update or create a KhatRanesh.
     * @example
     * // Update or create a KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.upsert({
     *   create: {
     *     // ... data to create a KhatRanesh
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRanesh we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshUpsertArgs>(args: SelectSubset<T, KhatRaneshUpsertArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshCountArgs} args - Arguments to filter KhatRaneshes to count.
     * @example
     * // Count the number of KhatRaneshes
     * const count = await prisma.khatRanesh.count({
     *   where: {
     *     // ... the filter for the KhatRaneshes we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshCountArgs>(
      args?: Subset<T, KhatRaneshCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRanesh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshAggregateArgs>(args: Subset<T, KhatRaneshAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshAggregateType<T>>

    /**
     * Group by KhatRanesh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRanesh model
   */
  readonly fields: KhatRaneshFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRanesh.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Abgir<T extends KhatRanesh$AbgirArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$AbgirArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardairProgram<T extends KhatRanesh$BahrebardairProgramArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$BahrebardairProgramArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardairProgramSeghli<T extends KhatRanesh$BahrebardairProgramSeghliArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$BahrebardairProgramSeghliArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardariKeshtDore<T extends KhatRanesh$BahrebardariKeshtDoreArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$BahrebardariKeshtDoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardariTaghvim<T extends KhatRanesh$BahrebardariTaghvimArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$BahrebardariTaghvimArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EshtebahAvamel<T extends KhatRanesh$EshtebahAvamelArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$EshtebahAvamelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FlowBehbood<T extends KhatRanesh$FlowBehboodArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$FlowBehboodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Flowmeter<T extends KhatRanesh$FlowmeterArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$FlowmeterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DarajePipe<T extends DarajePipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DarajePipeDefaultArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    MeasuringTool<T extends MeasuringToolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeasuringToolDefaultArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    PumpStation<T extends PumpStationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PumpStationDefaultArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    SeghliPump<T extends SeghliPumpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeghliPumpDefaultArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    KhatRaneshArea<T extends KhatRanesh$KhatRaneshAreaArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$KhatRaneshAreaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    KhatRaneshPump<T extends KhatRanesh$KhatRaneshPumpArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$KhatRaneshPumpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    KhatRaneshSegli<T extends KhatRanesh$KhatRaneshSegliArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$KhatRaneshSegliArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NashtShabake<T extends KhatRanesh$NashtShabakeArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$NashtShabakeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NonFIT<T extends KhatRanesh$NonFITArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$NonFITArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TakhlieMakhzan<T extends KhatRanesh$TakhlieMakhzanArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$TakhlieMakhzanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Test<T extends KhatRanesh$TestArgs<ExtArgs> = {}>(args?: Subset<T, KhatRanesh$TestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRanesh model
   */ 
  interface KhatRaneshFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRanesh", 'Int'>
    readonly RaneshName: FieldRef<"KhatRanesh", 'String'>
    readonly FIdPumpSta: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdDPipe: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdSePu: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdMeasuring: FieldRef<"KhatRanesh", 'Int'>
    readonly Active: FieldRef<"KhatRanesh", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * KhatRanesh findUnique
   */
  export type KhatRaneshFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh findUniqueOrThrow
   */
  export type KhatRaneshFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh findFirst
   */
  export type KhatRaneshFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshes.
     */
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh findFirstOrThrow
   */
  export type KhatRaneshFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshes.
     */
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh findMany
   */
  export type KhatRaneshFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshes to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh create
   */
  export type KhatRaneshCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * The data needed to create a KhatRanesh.
     */
    data: XOR<KhatRaneshCreateInput, KhatRaneshUncheckedCreateInput>
  }

  /**
   * KhatRanesh createMany
   */
  export type KhatRaneshCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshes.
     */
    data: KhatRaneshCreateManyInput | KhatRaneshCreateManyInput[]
  }

  /**
   * KhatRanesh update
   */
  export type KhatRaneshUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * The data needed to update a KhatRanesh.
     */
    data: XOR<KhatRaneshUpdateInput, KhatRaneshUncheckedUpdateInput>
    /**
     * Choose, which KhatRanesh to update.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh updateMany
   */
  export type KhatRaneshUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshes.
     */
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshes to update
     */
    where?: KhatRaneshWhereInput
    /**
     * Limit how many KhatRaneshes to update.
     */
    limit?: number
  }

  /**
   * KhatRanesh upsert
   */
  export type KhatRaneshUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * The filter to search for the KhatRanesh to update in case it exists.
     */
    where: KhatRaneshWhereUniqueInput
    /**
     * In case the KhatRanesh found by the `where` argument doesn't exist, create a new KhatRanesh with this data.
     */
    create: XOR<KhatRaneshCreateInput, KhatRaneshUncheckedCreateInput>
    /**
     * In case the KhatRanesh was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshUpdateInput, KhatRaneshUncheckedUpdateInput>
  }

  /**
   * KhatRanesh delete
   */
  export type KhatRaneshDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    /**
     * Filter which KhatRanesh to delete.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh deleteMany
   */
  export type KhatRaneshDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshes to delete
     */
    where?: KhatRaneshWhereInput
    /**
     * Limit how many KhatRaneshes to delete.
     */
    limit?: number
  }

  /**
   * KhatRanesh.Abgir
   */
  export type KhatRanesh$AbgirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbgirInclude<ExtArgs> | null
    where?: AbgirWhereInput
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    cursor?: AbgirWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * KhatRanesh.BahrebardairProgram
   */
  export type KhatRanesh$BahrebardairProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    where?: BahrebardairProgramWhereInput
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    cursor?: BahrebardairProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * KhatRanesh.BahrebardairProgramSeghli
   */
  export type KhatRanesh$BahrebardairProgramSeghliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    where?: BahrebardairProgramSeghliWhereInput
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardairProgramSeghliScalarFieldEnum | BahrebardairProgramSeghliScalarFieldEnum[]
  }

  /**
   * KhatRanesh.BahrebardariKeshtDore
   */
  export type KhatRanesh$BahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    where?: BahrebardariKeshtDoreWhereInput
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * KhatRanesh.BahrebardariTaghvim
   */
  export type KhatRanesh$BahrebardariTaghvimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    where?: BahrebardariTaghvimWhereInput
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    cursor?: BahrebardariTaghvimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * KhatRanesh.EshtebahAvamel
   */
  export type KhatRanesh$EshtebahAvamelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    where?: EshtebahAvamelWhereInput
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    cursor?: EshtebahAvamelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * KhatRanesh.FlowBehbood
   */
  export type KhatRanesh$FlowBehboodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    where?: FlowBehboodWhereInput
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    cursor?: FlowBehboodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * KhatRanesh.Flowmeter
   */
  export type KhatRanesh$FlowmeterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    where?: FlowmeterWhereInput
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    cursor?: FlowmeterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * KhatRanesh.KhatRaneshArea
   */
  export type KhatRanesh$KhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    where?: KhatRaneshAreaWhereInput
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    cursor?: KhatRaneshAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRanesh.KhatRaneshPump
   */
  export type KhatRanesh$KhatRaneshPumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    where?: KhatRaneshPumpWhereInput
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    cursor?: KhatRaneshPumpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRanesh.KhatRaneshSegli
   */
  export type KhatRanesh$KhatRaneshSegliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    where?: KhatRaneshSegliWhereInput
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    cursor?: KhatRaneshSegliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRanesh.NashtShabake
   */
  export type KhatRanesh$NashtShabakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    where?: NashtShabakeWhereInput
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    cursor?: NashtShabakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * KhatRanesh.NonFIT
   */
  export type KhatRanesh$NonFITArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    where?: NonFITWhereInput
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    cursor?: NonFITWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * KhatRanesh.TakhlieMakhzan
   */
  export type KhatRanesh$TakhlieMakhzanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    where?: TakhlieMakhzanWhereInput
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    cursor?: TakhlieMakhzanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * KhatRanesh.Test
   */
  export type KhatRanesh$TestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    where?: TestWhereInput
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    cursor?: TestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * KhatRanesh without action
   */
  export type KhatRaneshDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
  }


  /**
   * Model KhatRaneshArea
   */

  export type AggregateKhatRaneshArea = {
    _count: KhatRaneshAreaCountAggregateOutputType | null
    _avg: KhatRaneshAreaAvgAggregateOutputType | null
    _sum: KhatRaneshAreaSumAggregateOutputType | null
    _min: KhatRaneshAreaMinAggregateOutputType | null
    _max: KhatRaneshAreaMaxAggregateOutputType | null
  }

  export type KhatRaneshAreaAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: number
    _all: number
  }


  export type KhatRaneshAreaAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
    _all?: true
  }

  export type KhatRaneshAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshArea to aggregate.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshAreas
    **/
    _count?: true | KhatRaneshAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshAreaMaxAggregateInputType
  }

  export type GetKhatRaneshAreaAggregateType<T extends KhatRaneshAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshArea[P]>
      : GetScalarType<T[P], AggregateKhatRaneshArea[P]>
  }




  export type KhatRaneshAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshAreaWhereInput
    orderBy?: KhatRaneshAreaOrderByWithAggregationInput | KhatRaneshAreaOrderByWithAggregationInput[]
    by: KhatRaneshAreaScalarFieldEnum[] | KhatRaneshAreaScalarFieldEnum
    having?: KhatRaneshAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshAreaCountAggregateInputType | true
    _avg?: KhatRaneshAreaAvgAggregateInputType
    _sum?: KhatRaneshAreaSumAggregateInputType
    _min?: KhatRaneshAreaMinAggregateInputType
    _max?: KhatRaneshAreaMaxAggregateInputType
  }

  export type KhatRaneshAreaGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal
    _count: KhatRaneshAreaCountAggregateOutputType | null
    _avg: KhatRaneshAreaAvgAggregateOutputType | null
    _sum: KhatRaneshAreaSumAggregateOutputType | null
    _min: KhatRaneshAreaMinAggregateOutputType | null
    _max: KhatRaneshAreaMaxAggregateOutputType | null
  }

  type GetKhatRaneshAreaGroupByPayload<T extends KhatRaneshAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshAreaGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshAreaGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    FIdLand?: boolean
    FIdNet?: boolean
    Area?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    Land?: boolean | LandDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["khatRaneshArea"]>



  export type KhatRaneshAreaSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    FIdLand?: boolean
    FIdNet?: boolean
    Area?: boolean
  }

  export type KhatRaneshAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "FIdLand" | "FIdNet" | "Area", ExtArgs["result"]["khatRaneshArea"]>
  export type KhatRaneshAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    Land?: boolean | LandDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
  }

  export type $KhatRaneshAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshArea"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      Land: Prisma.$LandPayload<ExtArgs>
      Network: Prisma.$NetworkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      FIdLand: number
      FIdNet: number
      Area: Prisma.Decimal
    }, ExtArgs["result"]["khatRaneshArea"]>
    composites: {}
  }

  type KhatRaneshAreaGetPayload<S extends boolean | null | undefined | KhatRaneshAreaDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshAreaPayload, S>

  type KhatRaneshAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshAreaCountAggregateInputType | true
    }

  export interface KhatRaneshAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshArea'], meta: { name: 'KhatRaneshArea' } }
    /**
     * Find zero or one KhatRaneshArea that matches the filter.
     * @param {KhatRaneshAreaFindUniqueArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshAreaFindUniqueArgs>(args: SelectSubset<T, KhatRaneshAreaFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshAreaFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindFirstArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshAreaFindFirstArgs>(args?: SelectSubset<T, KhatRaneshAreaFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshAreas
     * const khatRaneshAreas = await prisma.khatRaneshArea.findMany()
     * 
     * // Get first 10 KhatRaneshAreas
     * const khatRaneshAreas = await prisma.khatRaneshArea.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshAreaWithIdRaneshOnly = await prisma.khatRaneshArea.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshAreaFindManyArgs>(args?: SelectSubset<T, KhatRaneshAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshArea.
     * @param {KhatRaneshAreaCreateArgs} args - Arguments to create a KhatRaneshArea.
     * @example
     * // Create one KhatRaneshArea
     * const KhatRaneshArea = await prisma.khatRaneshArea.create({
     *   data: {
     *     // ... data to create a KhatRaneshArea
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshAreaCreateArgs>(args: SelectSubset<T, KhatRaneshAreaCreateArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshAreas.
     * @param {KhatRaneshAreaCreateManyArgs} args - Arguments to create many KhatRaneshAreas.
     * @example
     * // Create many KhatRaneshAreas
     * const khatRaneshArea = await prisma.khatRaneshArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshAreaCreateManyArgs>(args?: SelectSubset<T, KhatRaneshAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshArea.
     * @param {KhatRaneshAreaDeleteArgs} args - Arguments to delete one KhatRaneshArea.
     * @example
     * // Delete one KhatRaneshArea
     * const KhatRaneshArea = await prisma.khatRaneshArea.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshArea
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshAreaDeleteArgs>(args: SelectSubset<T, KhatRaneshAreaDeleteArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshArea.
     * @param {KhatRaneshAreaUpdateArgs} args - Arguments to update one KhatRaneshArea.
     * @example
     * // Update one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshAreaUpdateArgs>(args: SelectSubset<T, KhatRaneshAreaUpdateArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshAreas.
     * @param {KhatRaneshAreaDeleteManyArgs} args - Arguments to filter KhatRaneshAreas to delete.
     * @example
     * // Delete a few KhatRaneshAreas
     * const { count } = await prisma.khatRaneshArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshAreaDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshAreas
     * const khatRaneshArea = await prisma.khatRaneshArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshAreaUpdateManyArgs>(args: SelectSubset<T, KhatRaneshAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshArea.
     * @param {KhatRaneshAreaUpsertArgs} args - Arguments to update or create a KhatRaneshArea.
     * @example
     * // Update or create a KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshArea we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshAreaUpsertArgs>(args: SelectSubset<T, KhatRaneshAreaUpsertArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaCountArgs} args - Arguments to filter KhatRaneshAreas to count.
     * @example
     * // Count the number of KhatRaneshAreas
     * const count = await prisma.khatRaneshArea.count({
     *   where: {
     *     // ... the filter for the KhatRaneshAreas we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshAreaCountArgs>(
      args?: Subset<T, KhatRaneshAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshAreaAggregateArgs>(args: Subset<T, KhatRaneshAreaAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshAreaAggregateType<T>>

    /**
     * Group by KhatRaneshArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshAreaGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshArea model
   */
  readonly fields: KhatRaneshAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Land<T extends LandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LandDefaultArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Network<T extends NetworkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDefaultArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshArea model
   */ 
  interface KhatRaneshAreaFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdLand: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdNet: FieldRef<"KhatRaneshArea", 'Int'>
    readonly Area: FieldRef<"KhatRaneshArea", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshArea findUnique
   */
  export type KhatRaneshAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea findUniqueOrThrow
   */
  export type KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea findFirst
   */
  export type KhatRaneshAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshAreas.
     */
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea findFirstOrThrow
   */
  export type KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshAreas.
     */
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea findMany
   */
  export type KhatRaneshAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshAreas to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea create
   */
  export type KhatRaneshAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshArea.
     */
    data: XOR<KhatRaneshAreaCreateInput, KhatRaneshAreaUncheckedCreateInput>
  }

  /**
   * KhatRaneshArea createMany
   */
  export type KhatRaneshAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshAreas.
     */
    data: KhatRaneshAreaCreateManyInput | KhatRaneshAreaCreateManyInput[]
  }

  /**
   * KhatRaneshArea update
   */
  export type KhatRaneshAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshArea.
     */
    data: XOR<KhatRaneshAreaUpdateInput, KhatRaneshAreaUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshArea to update.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea updateMany
   */
  export type KhatRaneshAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshAreas.
     */
    data: XOR<KhatRaneshAreaUpdateManyMutationInput, KhatRaneshAreaUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshAreas to update
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * Limit how many KhatRaneshAreas to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshArea upsert
   */
  export type KhatRaneshAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshArea to update in case it exists.
     */
    where: KhatRaneshAreaWhereUniqueInput
    /**
     * In case the KhatRaneshArea found by the `where` argument doesn't exist, create a new KhatRaneshArea with this data.
     */
    create: XOR<KhatRaneshAreaCreateInput, KhatRaneshAreaUncheckedCreateInput>
    /**
     * In case the KhatRaneshArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshAreaUpdateInput, KhatRaneshAreaUncheckedUpdateInput>
  }

  /**
   * KhatRaneshArea delete
   */
  export type KhatRaneshAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    /**
     * Filter which KhatRaneshArea to delete.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea deleteMany
   */
  export type KhatRaneshAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshAreas to delete
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * Limit how many KhatRaneshAreas to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshArea without action
   */
  export type KhatRaneshAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
  }


  /**
   * Model KhatRaneshPump
   */

  export type AggregateKhatRaneshPump = {
    _count: KhatRaneshPumpCountAggregateOutputType | null
    _avg: KhatRaneshPumpAvgAggregateOutputType | null
    _sum: KhatRaneshPumpSumAggregateOutputType | null
    _min: KhatRaneshPumpMinAggregateOutputType | null
    _max: KhatRaneshPumpMaxAggregateOutputType | null
  }

  export type KhatRaneshPumpAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    ModelPump: string | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    ModelPump: string | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    ModelPump: number
    FIdPump: number
    TedadPump: number
    DebiPomp: number
    FesharPump: number
    Randeman: number
    TavaneNami: number
    TavaneJazbi: number
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    _all: number
  }


  export type KhatRaneshPumpAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
    _all?: true
  }

  export type KhatRaneshPumpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshPump to aggregate.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshPumps
    **/
    _count?: true | KhatRaneshPumpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshPumpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshPumpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshPumpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshPumpMaxAggregateInputType
  }

  export type GetKhatRaneshPumpAggregateType<T extends KhatRaneshPumpAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshPump]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshPump[P]>
      : GetScalarType<T[P], AggregateKhatRaneshPump[P]>
  }




  export type KhatRaneshPumpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshPumpWhereInput
    orderBy?: KhatRaneshPumpOrderByWithAggregationInput | KhatRaneshPumpOrderByWithAggregationInput[]
    by: KhatRaneshPumpScalarFieldEnum[] | KhatRaneshPumpScalarFieldEnum
    having?: KhatRaneshPumpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshPumpCountAggregateInputType | true
    _avg?: KhatRaneshPumpAvgAggregateInputType
    _sum?: KhatRaneshPumpSumAggregateInputType
    _min?: KhatRaneshPumpMinAggregateInputType
    _max?: KhatRaneshPumpMaxAggregateInputType
  }

  export type KhatRaneshPumpGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    ModelPump: string | null
    FIdPump: number
    TedadPump: number | null
    DebiPomp: Decimal
    FesharPump: Decimal
    Randeman: number
    TavaneNami: Decimal
    TavaneJazbi: Decimal
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    _count: KhatRaneshPumpCountAggregateOutputType | null
    _avg: KhatRaneshPumpAvgAggregateOutputType | null
    _sum: KhatRaneshPumpSumAggregateOutputType | null
    _min: KhatRaneshPumpMinAggregateOutputType | null
    _max: KhatRaneshPumpMaxAggregateOutputType | null
  }

  type GetKhatRaneshPumpGroupByPayload<T extends KhatRaneshPumpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshPumpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshPumpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshPumpGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshPumpGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshPumpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    ModelPump?: boolean
    FIdPump?: boolean
    TedadPump?: boolean
    DebiPomp?: boolean
    FesharPump?: boolean
    Randeman?: boolean
    TavaneNami?: boolean
    TavaneJazbi?: boolean
    Voltazh?: boolean
    DoreMotor?: boolean
    FeshareMakesh?: boolean
    FeshareRanesh?: boolean
    SizeMakesh?: boolean
    SizeRanesh?: boolean
    SizeKolektor?: boolean
    SizeShireKolektor?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    PumpType?: boolean | PumpTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["khatRaneshPump"]>



  export type KhatRaneshPumpSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    ModelPump?: boolean
    FIdPump?: boolean
    TedadPump?: boolean
    DebiPomp?: boolean
    FesharPump?: boolean
    Randeman?: boolean
    TavaneNami?: boolean
    TavaneJazbi?: boolean
    Voltazh?: boolean
    DoreMotor?: boolean
    FeshareMakesh?: boolean
    FeshareRanesh?: boolean
    SizeMakesh?: boolean
    SizeRanesh?: boolean
    SizeKolektor?: boolean
    SizeShireKolektor?: boolean
  }

  export type KhatRaneshPumpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "ModelPump" | "FIdPump" | "TedadPump" | "DebiPomp" | "FesharPump" | "Randeman" | "TavaneNami" | "TavaneJazbi" | "Voltazh" | "DoreMotor" | "FeshareMakesh" | "FeshareRanesh" | "SizeMakesh" | "SizeRanesh" | "SizeKolektor" | "SizeShireKolektor", ExtArgs["result"]["khatRaneshPump"]>
  export type KhatRaneshPumpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    PumpType?: boolean | PumpTypeDefaultArgs<ExtArgs>
  }

  export type $KhatRaneshPumpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshPump"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      PumpType: Prisma.$PumpTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      ModelPump: string | null
      FIdPump: number
      TedadPump: number | null
      DebiPomp: Prisma.Decimal
      FesharPump: Prisma.Decimal
      Randeman: number
      TavaneNami: Prisma.Decimal
      TavaneJazbi: Prisma.Decimal
      Voltazh: number
      DoreMotor: number
      FeshareMakesh: number
      FeshareRanesh: number
      SizeMakesh: number
      SizeRanesh: number
      SizeKolektor: number
      SizeShireKolektor: number
    }, ExtArgs["result"]["khatRaneshPump"]>
    composites: {}
  }

  type KhatRaneshPumpGetPayload<S extends boolean | null | undefined | KhatRaneshPumpDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshPumpPayload, S>

  type KhatRaneshPumpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshPumpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshPumpCountAggregateInputType | true
    }

  export interface KhatRaneshPumpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshPump'], meta: { name: 'KhatRaneshPump' } }
    /**
     * Find zero or one KhatRaneshPump that matches the filter.
     * @param {KhatRaneshPumpFindUniqueArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshPumpFindUniqueArgs>(args: SelectSubset<T, KhatRaneshPumpFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshPump that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshPumpFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshPumpFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshPump that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindFirstArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshPumpFindFirstArgs>(args?: SelectSubset<T, KhatRaneshPumpFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshPump that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshPumpFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshPumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshPumps
     * const khatRaneshPumps = await prisma.khatRaneshPump.findMany()
     * 
     * // Get first 10 KhatRaneshPumps
     * const khatRaneshPumps = await prisma.khatRaneshPump.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshPumpWithIdRaneshOnly = await prisma.khatRaneshPump.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshPumpFindManyArgs>(args?: SelectSubset<T, KhatRaneshPumpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshPump.
     * @param {KhatRaneshPumpCreateArgs} args - Arguments to create a KhatRaneshPump.
     * @example
     * // Create one KhatRaneshPump
     * const KhatRaneshPump = await prisma.khatRaneshPump.create({
     *   data: {
     *     // ... data to create a KhatRaneshPump
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshPumpCreateArgs>(args: SelectSubset<T, KhatRaneshPumpCreateArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshPumps.
     * @param {KhatRaneshPumpCreateManyArgs} args - Arguments to create many KhatRaneshPumps.
     * @example
     * // Create many KhatRaneshPumps
     * const khatRaneshPump = await prisma.khatRaneshPump.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshPumpCreateManyArgs>(args?: SelectSubset<T, KhatRaneshPumpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshPump.
     * @param {KhatRaneshPumpDeleteArgs} args - Arguments to delete one KhatRaneshPump.
     * @example
     * // Delete one KhatRaneshPump
     * const KhatRaneshPump = await prisma.khatRaneshPump.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshPump
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshPumpDeleteArgs>(args: SelectSubset<T, KhatRaneshPumpDeleteArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshPump.
     * @param {KhatRaneshPumpUpdateArgs} args - Arguments to update one KhatRaneshPump.
     * @example
     * // Update one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshPumpUpdateArgs>(args: SelectSubset<T, KhatRaneshPumpUpdateArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshPumps.
     * @param {KhatRaneshPumpDeleteManyArgs} args - Arguments to filter KhatRaneshPumps to delete.
     * @example
     * // Delete a few KhatRaneshPumps
     * const { count } = await prisma.khatRaneshPump.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshPumpDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshPumpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshPumps
     * const khatRaneshPump = await prisma.khatRaneshPump.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshPumpUpdateManyArgs>(args: SelectSubset<T, KhatRaneshPumpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshPump.
     * @param {KhatRaneshPumpUpsertArgs} args - Arguments to update or create a KhatRaneshPump.
     * @example
     * // Update or create a KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshPump
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshPump we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshPumpUpsertArgs>(args: SelectSubset<T, KhatRaneshPumpUpsertArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpCountArgs} args - Arguments to filter KhatRaneshPumps to count.
     * @example
     * // Count the number of KhatRaneshPumps
     * const count = await prisma.khatRaneshPump.count({
     *   where: {
     *     // ... the filter for the KhatRaneshPumps we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshPumpCountArgs>(
      args?: Subset<T, KhatRaneshPumpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshPumpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshPumpAggregateArgs>(args: Subset<T, KhatRaneshPumpAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshPumpAggregateType<T>>

    /**
     * Group by KhatRaneshPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshPumpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshPumpGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshPumpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshPumpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshPumpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshPump model
   */
  readonly fields: KhatRaneshPumpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshPump.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshPumpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    PumpType<T extends PumpTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PumpTypeDefaultArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshPump model
   */ 
  interface KhatRaneshPumpFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly ModelPump: FieldRef<"KhatRaneshPump", 'String'>
    readonly FIdPump: FieldRef<"KhatRaneshPump", 'Int'>
    readonly TedadPump: FieldRef<"KhatRaneshPump", 'Int'>
    readonly DebiPomp: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly FesharPump: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly Randeman: FieldRef<"KhatRaneshPump", 'Int'>
    readonly TavaneNami: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly TavaneJazbi: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly Voltazh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly DoreMotor: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FeshareMakesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FeshareRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeMakesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeKolektor: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeShireKolektor: FieldRef<"KhatRaneshPump", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshPump findUnique
   */
  export type KhatRaneshPumpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump findUniqueOrThrow
   */
  export type KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump findFirst
   */
  export type KhatRaneshPumpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshPumps.
     */
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump findFirstOrThrow
   */
  export type KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshPumps.
     */
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump findMany
   */
  export type KhatRaneshPumpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPumps to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump create
   */
  export type KhatRaneshPumpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshPump.
     */
    data: XOR<KhatRaneshPumpCreateInput, KhatRaneshPumpUncheckedCreateInput>
  }

  /**
   * KhatRaneshPump createMany
   */
  export type KhatRaneshPumpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshPumps.
     */
    data: KhatRaneshPumpCreateManyInput | KhatRaneshPumpCreateManyInput[]
  }

  /**
   * KhatRaneshPump update
   */
  export type KhatRaneshPumpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshPump.
     */
    data: XOR<KhatRaneshPumpUpdateInput, KhatRaneshPumpUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshPump to update.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump updateMany
   */
  export type KhatRaneshPumpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshPumps.
     */
    data: XOR<KhatRaneshPumpUpdateManyMutationInput, KhatRaneshPumpUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshPumps to update
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * Limit how many KhatRaneshPumps to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshPump upsert
   */
  export type KhatRaneshPumpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshPump to update in case it exists.
     */
    where: KhatRaneshPumpWhereUniqueInput
    /**
     * In case the KhatRaneshPump found by the `where` argument doesn't exist, create a new KhatRaneshPump with this data.
     */
    create: XOR<KhatRaneshPumpCreateInput, KhatRaneshPumpUncheckedCreateInput>
    /**
     * In case the KhatRaneshPump was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshPumpUpdateInput, KhatRaneshPumpUncheckedUpdateInput>
  }

  /**
   * KhatRaneshPump delete
   */
  export type KhatRaneshPumpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    /**
     * Filter which KhatRaneshPump to delete.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump deleteMany
   */
  export type KhatRaneshPumpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshPumps to delete
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * Limit how many KhatRaneshPumps to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshPump without action
   */
  export type KhatRaneshPumpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
  }


  /**
   * Model KhatRaneshSegli
   */

  export type AggregateKhatRaneshSegli = {
    _count: KhatRaneshSegliCountAggregateOutputType | null
    _avg: KhatRaneshSegliAvgAggregateOutputType | null
    _sum: KhatRaneshSegliSumAggregateOutputType | null
    _min: KhatRaneshSegliMinAggregateOutputType | null
    _max: KhatRaneshSegliMaxAggregateOutputType | null
  }

  export type KhatRaneshSegliAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    Zarfiat: number
    _all: number
  }


  export type KhatRaneshSegliAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
    _all?: true
  }

  export type KhatRaneshSegliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshSegli to aggregate.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshSeglis
    **/
    _count?: true | KhatRaneshSegliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshSegliAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshSegliSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshSegliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshSegliMaxAggregateInputType
  }

  export type GetKhatRaneshSegliAggregateType<T extends KhatRaneshSegliAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshSegli]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshSegli[P]>
      : GetScalarType<T[P], AggregateKhatRaneshSegli[P]>
  }




  export type KhatRaneshSegliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshSegliWhereInput
    orderBy?: KhatRaneshSegliOrderByWithAggregationInput | KhatRaneshSegliOrderByWithAggregationInput[]
    by: KhatRaneshSegliScalarFieldEnum[] | KhatRaneshSegliScalarFieldEnum
    having?: KhatRaneshSegliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshSegliCountAggregateInputType | true
    _avg?: KhatRaneshSegliAvgAggregateInputType
    _sum?: KhatRaneshSegliSumAggregateInputType
    _min?: KhatRaneshSegliMinAggregateInputType
    _max?: KhatRaneshSegliMaxAggregateInputType
  }

  export type KhatRaneshSegliGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    Zarfiat: Decimal
    _count: KhatRaneshSegliCountAggregateOutputType | null
    _avg: KhatRaneshSegliAvgAggregateOutputType | null
    _sum: KhatRaneshSegliSumAggregateOutputType | null
    _min: KhatRaneshSegliMinAggregateOutputType | null
    _max: KhatRaneshSegliMaxAggregateOutputType | null
  }

  type GetKhatRaneshSegliGroupByPayload<T extends KhatRaneshSegliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshSegliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshSegliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshSegliGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshSegliGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshSegliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    Zarfiat?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["khatRaneshSegli"]>



  export type KhatRaneshSegliSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    Zarfiat?: boolean
  }

  export type KhatRaneshSegliOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "Zarfiat", ExtArgs["result"]["khatRaneshSegli"]>
  export type KhatRaneshSegliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
  }

  export type $KhatRaneshSegliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshSegli"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      Zarfiat: Prisma.Decimal
    }, ExtArgs["result"]["khatRaneshSegli"]>
    composites: {}
  }

  type KhatRaneshSegliGetPayload<S extends boolean | null | undefined | KhatRaneshSegliDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshSegliPayload, S>

  type KhatRaneshSegliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshSegliFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshSegliCountAggregateInputType | true
    }

  export interface KhatRaneshSegliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshSegli'], meta: { name: 'KhatRaneshSegli' } }
    /**
     * Find zero or one KhatRaneshSegli that matches the filter.
     * @param {KhatRaneshSegliFindUniqueArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshSegliFindUniqueArgs>(args: SelectSubset<T, KhatRaneshSegliFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshSegli that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshSegliFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshSegliFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshSegli that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindFirstArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshSegliFindFirstArgs>(args?: SelectSubset<T, KhatRaneshSegliFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshSegli that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshSegliFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshSeglis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshSeglis
     * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany()
     * 
     * // Get first 10 KhatRaneshSeglis
     * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshSegliWithIdRaneshOnly = await prisma.khatRaneshSegli.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshSegliFindManyArgs>(args?: SelectSubset<T, KhatRaneshSegliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshSegli.
     * @param {KhatRaneshSegliCreateArgs} args - Arguments to create a KhatRaneshSegli.
     * @example
     * // Create one KhatRaneshSegli
     * const KhatRaneshSegli = await prisma.khatRaneshSegli.create({
     *   data: {
     *     // ... data to create a KhatRaneshSegli
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshSegliCreateArgs>(args: SelectSubset<T, KhatRaneshSegliCreateArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshSeglis.
     * @param {KhatRaneshSegliCreateManyArgs} args - Arguments to create many KhatRaneshSeglis.
     * @example
     * // Create many KhatRaneshSeglis
     * const khatRaneshSegli = await prisma.khatRaneshSegli.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshSegliCreateManyArgs>(args?: SelectSubset<T, KhatRaneshSegliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshSegli.
     * @param {KhatRaneshSegliDeleteArgs} args - Arguments to delete one KhatRaneshSegli.
     * @example
     * // Delete one KhatRaneshSegli
     * const KhatRaneshSegli = await prisma.khatRaneshSegli.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshSegli
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshSegliDeleteArgs>(args: SelectSubset<T, KhatRaneshSegliDeleteArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshSegli.
     * @param {KhatRaneshSegliUpdateArgs} args - Arguments to update one KhatRaneshSegli.
     * @example
     * // Update one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshSegliUpdateArgs>(args: SelectSubset<T, KhatRaneshSegliUpdateArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshSeglis.
     * @param {KhatRaneshSegliDeleteManyArgs} args - Arguments to filter KhatRaneshSeglis to delete.
     * @example
     * // Delete a few KhatRaneshSeglis
     * const { count } = await prisma.khatRaneshSegli.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshSegliDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshSegliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshSeglis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshSeglis
     * const khatRaneshSegli = await prisma.khatRaneshSegli.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshSegliUpdateManyArgs>(args: SelectSubset<T, KhatRaneshSegliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshSegli.
     * @param {KhatRaneshSegliUpsertArgs} args - Arguments to update or create a KhatRaneshSegli.
     * @example
     * // Update or create a KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshSegli
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshSegli we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshSegliUpsertArgs>(args: SelectSubset<T, KhatRaneshSegliUpsertArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshSeglis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliCountArgs} args - Arguments to filter KhatRaneshSeglis to count.
     * @example
     * // Count the number of KhatRaneshSeglis
     * const count = await prisma.khatRaneshSegli.count({
     *   where: {
     *     // ... the filter for the KhatRaneshSeglis we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshSegliCountArgs>(
      args?: Subset<T, KhatRaneshSegliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshSegliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshSegli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshSegliAggregateArgs>(args: Subset<T, KhatRaneshSegliAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshSegliAggregateType<T>>

    /**
     * Group by KhatRaneshSegli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshSegliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshSegliGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshSegliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshSegliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshSegliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshSegli model
   */
  readonly fields: KhatRaneshSegliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshSegli.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshSegliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshSegli model
   */ 
  interface KhatRaneshSegliFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshSegli", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshSegli", 'Int'>
    readonly Zarfiat: FieldRef<"KhatRaneshSegli", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshSegli findUnique
   */
  export type KhatRaneshSegliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli findUniqueOrThrow
   */
  export type KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli findFirst
   */
  export type KhatRaneshSegliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshSeglis.
     */
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli findFirstOrThrow
   */
  export type KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshSeglis.
     */
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli findMany
   */
  export type KhatRaneshSegliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSeglis to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli create
   */
  export type KhatRaneshSegliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshSegli.
     */
    data: XOR<KhatRaneshSegliCreateInput, KhatRaneshSegliUncheckedCreateInput>
  }

  /**
   * KhatRaneshSegli createMany
   */
  export type KhatRaneshSegliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshSeglis.
     */
    data: KhatRaneshSegliCreateManyInput | KhatRaneshSegliCreateManyInput[]
  }

  /**
   * KhatRaneshSegli update
   */
  export type KhatRaneshSegliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshSegli.
     */
    data: XOR<KhatRaneshSegliUpdateInput, KhatRaneshSegliUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshSegli to update.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli updateMany
   */
  export type KhatRaneshSegliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshSeglis.
     */
    data: XOR<KhatRaneshSegliUpdateManyMutationInput, KhatRaneshSegliUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshSeglis to update
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * Limit how many KhatRaneshSeglis to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshSegli upsert
   */
  export type KhatRaneshSegliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshSegli to update in case it exists.
     */
    where: KhatRaneshSegliWhereUniqueInput
    /**
     * In case the KhatRaneshSegli found by the `where` argument doesn't exist, create a new KhatRaneshSegli with this data.
     */
    create: XOR<KhatRaneshSegliCreateInput, KhatRaneshSegliUncheckedCreateInput>
    /**
     * In case the KhatRaneshSegli was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshSegliUpdateInput, KhatRaneshSegliUncheckedUpdateInput>
  }

  /**
   * KhatRaneshSegli delete
   */
  export type KhatRaneshSegliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
    /**
     * Filter which KhatRaneshSegli to delete.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli deleteMany
   */
  export type KhatRaneshSegliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshSeglis to delete
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * Limit how many KhatRaneshSeglis to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshSegli without action
   */
  export type KhatRaneshSegliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshSegliInclude<ExtArgs> | null
  }


  /**
   * Model Kontor
   */

  export type AggregateKontor = {
    _count: KontorCountAggregateOutputType | null
    _avg: KontorAvgAggregateOutputType | null
    _sum: KontorSumAggregateOutputType | null
    _min: KontorMinAggregateOutputType | null
    _max: KontorMaxAggregateOutputType | null
  }

  export type KontorAvgAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorSumAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorMinAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorMaxAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorCountAggregateOutputType = {
    IdKon: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
    _all: number
  }


  export type KontorAvgAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorSumAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorMinAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorMaxAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorCountAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
    _all?: true
  }

  export type KontorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kontor to aggregate.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kontors
    **/
    _count?: true | KontorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KontorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KontorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KontorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KontorMaxAggregateInputType
  }

  export type GetKontorAggregateType<T extends KontorAggregateArgs> = {
        [P in keyof T & keyof AggregateKontor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKontor[P]>
      : GetScalarType<T[P], AggregateKontor[P]>
  }




  export type KontorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorWhereInput
    orderBy?: KontorOrderByWithAggregationInput | KontorOrderByWithAggregationInput[]
    by: KontorScalarFieldEnum[] | KontorScalarFieldEnum
    having?: KontorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KontorCountAggregateInputType | true
    _avg?: KontorAvgAggregateInputType
    _sum?: KontorSumAggregateInputType
    _min?: KontorMinAggregateInputType
    _max?: KontorMaxAggregateInputType
  }

  export type KontorGroupByOutputType = {
    IdKon: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
    _count: KontorCountAggregateOutputType | null
    _avg: KontorAvgAggregateOutputType | null
    _sum: KontorSumAggregateOutputType | null
    _min: KontorMinAggregateOutputType | null
    _max: KontorMaxAggregateOutputType | null
  }

  type GetKontorGroupByPayload<T extends KontorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KontorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KontorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KontorGroupByOutputType[P]>
            : GetScalarType<T[P], KontorGroupByOutputType[P]>
        }
      >
    >


  export type KontorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdKon?: boolean
    FIdKontor?: boolean
    FIdTarDor?: boolean
    Kontor?: boolean
    Abgir?: boolean | AbgirDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kontor"]>



  export type KontorSelectScalar = {
    IdKon?: boolean
    FIdKontor?: boolean
    FIdTarDor?: boolean
    Kontor?: boolean
  }

  export type KontorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdKon" | "FIdKontor" | "FIdTarDor" | "Kontor", ExtArgs["result"]["kontor"]>
  export type KontorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Abgir?: boolean | AbgirDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $KontorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kontor"
    objects: {
      Abgir: Prisma.$AbgirPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdKon: number
      FIdKontor: number
      FIdTarDor: number
      Kontor: number
    }, ExtArgs["result"]["kontor"]>
    composites: {}
  }

  type KontorGetPayload<S extends boolean | null | undefined | KontorDefaultArgs> = $Result.GetResult<Prisma.$KontorPayload, S>

  type KontorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KontorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KontorCountAggregateInputType | true
    }

  export interface KontorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kontor'], meta: { name: 'Kontor' } }
    /**
     * Find zero or one Kontor that matches the filter.
     * @param {KontorFindUniqueArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KontorFindUniqueArgs>(args: SelectSubset<T, KontorFindUniqueArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Kontor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KontorFindUniqueOrThrowArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KontorFindUniqueOrThrowArgs>(args: SelectSubset<T, KontorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Kontor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindFirstArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KontorFindFirstArgs>(args?: SelectSubset<T, KontorFindFirstArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Kontor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindFirstOrThrowArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KontorFindFirstOrThrowArgs>(args?: SelectSubset<T, KontorFindFirstOrThrowArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Kontors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kontors
     * const kontors = await prisma.kontor.findMany()
     * 
     * // Get first 10 Kontors
     * const kontors = await prisma.kontor.findMany({ take: 10 })
     * 
     * // Only select the `IdKon`
     * const kontorWithIdKonOnly = await prisma.kontor.findMany({ select: { IdKon: true } })
     * 
     */
    findMany<T extends KontorFindManyArgs>(args?: SelectSubset<T, KontorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Kontor.
     * @param {KontorCreateArgs} args - Arguments to create a Kontor.
     * @example
     * // Create one Kontor
     * const Kontor = await prisma.kontor.create({
     *   data: {
     *     // ... data to create a Kontor
     *   }
     * })
     * 
     */
    create<T extends KontorCreateArgs>(args: SelectSubset<T, KontorCreateArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Kontors.
     * @param {KontorCreateManyArgs} args - Arguments to create many Kontors.
     * @example
     * // Create many Kontors
     * const kontor = await prisma.kontor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KontorCreateManyArgs>(args?: SelectSubset<T, KontorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kontor.
     * @param {KontorDeleteArgs} args - Arguments to delete one Kontor.
     * @example
     * // Delete one Kontor
     * const Kontor = await prisma.kontor.delete({
     *   where: {
     *     // ... filter to delete one Kontor
     *   }
     * })
     * 
     */
    delete<T extends KontorDeleteArgs>(args: SelectSubset<T, KontorDeleteArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Kontor.
     * @param {KontorUpdateArgs} args - Arguments to update one Kontor.
     * @example
     * // Update one Kontor
     * const kontor = await prisma.kontor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KontorUpdateArgs>(args: SelectSubset<T, KontorUpdateArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Kontors.
     * @param {KontorDeleteManyArgs} args - Arguments to filter Kontors to delete.
     * @example
     * // Delete a few Kontors
     * const { count } = await prisma.kontor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KontorDeleteManyArgs>(args?: SelectSubset<T, KontorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kontors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kontors
     * const kontor = await prisma.kontor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KontorUpdateManyArgs>(args: SelectSubset<T, KontorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kontor.
     * @param {KontorUpsertArgs} args - Arguments to update or create a Kontor.
     * @example
     * // Update or create a Kontor
     * const kontor = await prisma.kontor.upsert({
     *   create: {
     *     // ... data to create a Kontor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kontor we want to update
     *   }
     * })
     */
    upsert<T extends KontorUpsertArgs>(args: SelectSubset<T, KontorUpsertArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Kontors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorCountArgs} args - Arguments to filter Kontors to count.
     * @example
     * // Count the number of Kontors
     * const count = await prisma.kontor.count({
     *   where: {
     *     // ... the filter for the Kontors we want to count
     *   }
     * })
    **/
    count<T extends KontorCountArgs>(
      args?: Subset<T, KontorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KontorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kontor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KontorAggregateArgs>(args: Subset<T, KontorAggregateArgs>): Prisma.PrismaPromise<GetKontorAggregateType<T>>

    /**
     * Group by Kontor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KontorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KontorGroupByArgs['orderBy'] }
        : { orderBy?: KontorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KontorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKontorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kontor model
   */
  readonly fields: KontorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kontor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KontorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Abgir<T extends AbgirDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AbgirDefaultArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kontor model
   */ 
  interface KontorFieldRefs {
    readonly IdKon: FieldRef<"Kontor", 'Int'>
    readonly FIdKontor: FieldRef<"Kontor", 'Int'>
    readonly FIdTarDor: FieldRef<"Kontor", 'Int'>
    readonly Kontor: FieldRef<"Kontor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Kontor findUnique
   */
  export type KontorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor findUniqueOrThrow
   */
  export type KontorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor findFirst
   */
  export type KontorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kontors.
     */
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor findFirstOrThrow
   */
  export type KontorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kontors.
     */
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor findMany
   */
  export type KontorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter, which Kontors to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor create
   */
  export type KontorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * The data needed to create a Kontor.
     */
    data: XOR<KontorCreateInput, KontorUncheckedCreateInput>
  }

  /**
   * Kontor createMany
   */
  export type KontorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kontors.
     */
    data: KontorCreateManyInput | KontorCreateManyInput[]
  }

  /**
   * Kontor update
   */
  export type KontorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * The data needed to update a Kontor.
     */
    data: XOR<KontorUpdateInput, KontorUncheckedUpdateInput>
    /**
     * Choose, which Kontor to update.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor updateMany
   */
  export type KontorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kontors.
     */
    data: XOR<KontorUpdateManyMutationInput, KontorUncheckedUpdateManyInput>
    /**
     * Filter which Kontors to update
     */
    where?: KontorWhereInput
    /**
     * Limit how many Kontors to update.
     */
    limit?: number
  }

  /**
   * Kontor upsert
   */
  export type KontorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * The filter to search for the Kontor to update in case it exists.
     */
    where: KontorWhereUniqueInput
    /**
     * In case the Kontor found by the `where` argument doesn't exist, create a new Kontor with this data.
     */
    create: XOR<KontorCreateInput, KontorUncheckedCreateInput>
    /**
     * In case the Kontor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KontorUpdateInput, KontorUncheckedUpdateInput>
  }

  /**
   * Kontor delete
   */
  export type KontorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    /**
     * Filter which Kontor to delete.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor deleteMany
   */
  export type KontorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kontors to delete
     */
    where?: KontorWhereInput
    /**
     * Limit how many Kontors to delete.
     */
    limit?: number
  }

  /**
   * Kontor without action
   */
  export type KontorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
  }


  /**
   * Model Land
   */

  export type AggregateLand = {
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  export type LandAvgAggregateOutputType = {
    IdLand: number | null
  }

  export type LandSumAggregateOutputType = {
    IdLand: number | null
  }

  export type LandMinAggregateOutputType = {
    IdLand: number | null
    Land: string | null
  }

  export type LandMaxAggregateOutputType = {
    IdLand: number | null
    Land: string | null
  }

  export type LandCountAggregateOutputType = {
    IdLand: number
    Land: number
    _all: number
  }


  export type LandAvgAggregateInputType = {
    IdLand?: true
  }

  export type LandSumAggregateInputType = {
    IdLand?: true
  }

  export type LandMinAggregateInputType = {
    IdLand?: true
    Land?: true
  }

  export type LandMaxAggregateInputType = {
    IdLand?: true
    Land?: true
  }

  export type LandCountAggregateInputType = {
    IdLand?: true
    Land?: true
    _all?: true
  }

  export type LandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Land to aggregate.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lands
    **/
    _count?: true | LandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandMaxAggregateInputType
  }

  export type GetLandAggregateType<T extends LandAggregateArgs> = {
        [P in keyof T & keyof AggregateLand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand[P]>
      : GetScalarType<T[P], AggregateLand[P]>
  }




  export type LandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandWhereInput
    orderBy?: LandOrderByWithAggregationInput | LandOrderByWithAggregationInput[]
    by: LandScalarFieldEnum[] | LandScalarFieldEnum
    having?: LandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandCountAggregateInputType | true
    _avg?: LandAvgAggregateInputType
    _sum?: LandSumAggregateInputType
    _min?: LandMinAggregateInputType
    _max?: LandMaxAggregateInputType
  }

  export type LandGroupByOutputType = {
    IdLand: number
    Land: string
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  type GetLandGroupByPayload<T extends LandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandGroupByOutputType[P]>
            : GetScalarType<T[P], LandGroupByOutputType[P]>
        }
      >
    >


  export type LandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdLand?: boolean
    Land?: boolean
    KhatRaneshArea?: boolean | Land$KhatRaneshAreaArgs<ExtArgs>
    _count?: boolean | LandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["land"]>



  export type LandSelectScalar = {
    IdLand?: boolean
    Land?: boolean
  }

  export type LandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdLand" | "Land", ExtArgs["result"]["land"]>
  export type LandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRaneshArea?: boolean | Land$KhatRaneshAreaArgs<ExtArgs>
    _count?: boolean | LandCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Land"
    objects: {
      KhatRaneshArea: Prisma.$KhatRaneshAreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdLand: number
      Land: string
    }, ExtArgs["result"]["land"]>
    composites: {}
  }

  type LandGetPayload<S extends boolean | null | undefined | LandDefaultArgs> = $Result.GetResult<Prisma.$LandPayload, S>

  type LandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandCountAggregateInputType | true
    }

  export interface LandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Land'], meta: { name: 'Land' } }
    /**
     * Find zero or one Land that matches the filter.
     * @param {LandFindUniqueArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandFindUniqueArgs>(args: SelectSubset<T, LandFindUniqueArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Land that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandFindUniqueOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandFindUniqueOrThrowArgs>(args: SelectSubset<T, LandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Land that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindFirstArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandFindFirstArgs>(args?: SelectSubset<T, LandFindFirstArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Land that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindFirstOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandFindFirstOrThrowArgs>(args?: SelectSubset<T, LandFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Lands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lands
     * const lands = await prisma.land.findMany()
     * 
     * // Get first 10 Lands
     * const lands = await prisma.land.findMany({ take: 10 })
     * 
     * // Only select the `IdLand`
     * const landWithIdLandOnly = await prisma.land.findMany({ select: { IdLand: true } })
     * 
     */
    findMany<T extends LandFindManyArgs>(args?: SelectSubset<T, LandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Land.
     * @param {LandCreateArgs} args - Arguments to create a Land.
     * @example
     * // Create one Land
     * const Land = await prisma.land.create({
     *   data: {
     *     // ... data to create a Land
     *   }
     * })
     * 
     */
    create<T extends LandCreateArgs>(args: SelectSubset<T, LandCreateArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Lands.
     * @param {LandCreateManyArgs} args - Arguments to create many Lands.
     * @example
     * // Create many Lands
     * const land = await prisma.land.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandCreateManyArgs>(args?: SelectSubset<T, LandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land.
     * @param {LandDeleteArgs} args - Arguments to delete one Land.
     * @example
     * // Delete one Land
     * const Land = await prisma.land.delete({
     *   where: {
     *     // ... filter to delete one Land
     *   }
     * })
     * 
     */
    delete<T extends LandDeleteArgs>(args: SelectSubset<T, LandDeleteArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Land.
     * @param {LandUpdateArgs} args - Arguments to update one Land.
     * @example
     * // Update one Land
     * const land = await prisma.land.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandUpdateArgs>(args: SelectSubset<T, LandUpdateArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Lands.
     * @param {LandDeleteManyArgs} args - Arguments to filter Lands to delete.
     * @example
     * // Delete a few Lands
     * const { count } = await prisma.land.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandDeleteManyArgs>(args?: SelectSubset<T, LandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lands
     * const land = await prisma.land.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandUpdateManyArgs>(args: SelectSubset<T, LandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land.
     * @param {LandUpsertArgs} args - Arguments to update or create a Land.
     * @example
     * // Update or create a Land
     * const land = await prisma.land.upsert({
     *   create: {
     *     // ... data to create a Land
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land we want to update
     *   }
     * })
     */
    upsert<T extends LandUpsertArgs>(args: SelectSubset<T, LandUpsertArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandCountArgs} args - Arguments to filter Lands to count.
     * @example
     * // Count the number of Lands
     * const count = await prisma.land.count({
     *   where: {
     *     // ... the filter for the Lands we want to count
     *   }
     * })
    **/
    count<T extends LandCountArgs>(
      args?: Subset<T, LandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandAggregateArgs>(args: Subset<T, LandAggregateArgs>): Prisma.PrismaPromise<GetLandAggregateType<T>>

    /**
     * Group by Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandGroupByArgs['orderBy'] }
        : { orderBy?: LandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Land model
   */
  readonly fields: LandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Land.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRaneshArea<T extends Land$KhatRaneshAreaArgs<ExtArgs> = {}>(args?: Subset<T, Land$KhatRaneshAreaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Land model
   */ 
  interface LandFieldRefs {
    readonly IdLand: FieldRef<"Land", 'Int'>
    readonly Land: FieldRef<"Land", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Land findUnique
   */
  export type LandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land findUniqueOrThrow
   */
  export type LandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land findFirst
   */
  export type LandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land findFirstOrThrow
   */
  export type LandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land findMany
   */
  export type LandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter, which Lands to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land create
   */
  export type LandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * The data needed to create a Land.
     */
    data: XOR<LandCreateInput, LandUncheckedCreateInput>
  }

  /**
   * Land createMany
   */
  export type LandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lands.
     */
    data: LandCreateManyInput | LandCreateManyInput[]
  }

  /**
   * Land update
   */
  export type LandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * The data needed to update a Land.
     */
    data: XOR<LandUpdateInput, LandUncheckedUpdateInput>
    /**
     * Choose, which Land to update.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land updateMany
   */
  export type LandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lands.
     */
    data: XOR<LandUpdateManyMutationInput, LandUncheckedUpdateManyInput>
    /**
     * Filter which Lands to update
     */
    where?: LandWhereInput
    /**
     * Limit how many Lands to update.
     */
    limit?: number
  }

  /**
   * Land upsert
   */
  export type LandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * The filter to search for the Land to update in case it exists.
     */
    where: LandWhereUniqueInput
    /**
     * In case the Land found by the `where` argument doesn't exist, create a new Land with this data.
     */
    create: XOR<LandCreateInput, LandUncheckedCreateInput>
    /**
     * In case the Land was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandUpdateInput, LandUncheckedUpdateInput>
  }

  /**
   * Land delete
   */
  export type LandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
    /**
     * Filter which Land to delete.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land deleteMany
   */
  export type LandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lands to delete
     */
    where?: LandWhereInput
    /**
     * Limit how many Lands to delete.
     */
    limit?: number
  }

  /**
   * Land.KhatRaneshArea
   */
  export type Land$KhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    where?: KhatRaneshAreaWhereInput
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    cursor?: KhatRaneshAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * Land without action
   */
  export type LandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandInclude<ExtArgs> | null
  }


  /**
   * Model MeasuringTool
   */

  export type AggregateMeasuringTool = {
    _count: MeasuringToolCountAggregateOutputType | null
    _avg: MeasuringToolAvgAggregateOutputType | null
    _sum: MeasuringToolSumAggregateOutputType | null
    _min: MeasuringToolMinAggregateOutputType | null
    _max: MeasuringToolMaxAggregateOutputType | null
  }

  export type MeasuringToolAvgAggregateOutputType = {
    IdMeasuring: number | null
  }

  export type MeasuringToolSumAggregateOutputType = {
    IdMeasuring: number | null
  }

  export type MeasuringToolMinAggregateOutputType = {
    IdMeasuring: number | null
    MeasuringTool: string | null
    Precision: string | null
  }

  export type MeasuringToolMaxAggregateOutputType = {
    IdMeasuring: number | null
    MeasuringTool: string | null
    Precision: string | null
  }

  export type MeasuringToolCountAggregateOutputType = {
    IdMeasuring: number
    MeasuringTool: number
    Precision: number
    _all: number
  }


  export type MeasuringToolAvgAggregateInputType = {
    IdMeasuring?: true
  }

  export type MeasuringToolSumAggregateInputType = {
    IdMeasuring?: true
  }

  export type MeasuringToolMinAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
  }

  export type MeasuringToolMaxAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
  }

  export type MeasuringToolCountAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
    _all?: true
  }

  export type MeasuringToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasuringTool to aggregate.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeasuringTools
    **/
    _count?: true | MeasuringToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeasuringToolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeasuringToolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeasuringToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeasuringToolMaxAggregateInputType
  }

  export type GetMeasuringToolAggregateType<T extends MeasuringToolAggregateArgs> = {
        [P in keyof T & keyof AggregateMeasuringTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeasuringTool[P]>
      : GetScalarType<T[P], AggregateMeasuringTool[P]>
  }




  export type MeasuringToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasuringToolWhereInput
    orderBy?: MeasuringToolOrderByWithAggregationInput | MeasuringToolOrderByWithAggregationInput[]
    by: MeasuringToolScalarFieldEnum[] | MeasuringToolScalarFieldEnum
    having?: MeasuringToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeasuringToolCountAggregateInputType | true
    _avg?: MeasuringToolAvgAggregateInputType
    _sum?: MeasuringToolSumAggregateInputType
    _min?: MeasuringToolMinAggregateInputType
    _max?: MeasuringToolMaxAggregateInputType
  }

  export type MeasuringToolGroupByOutputType = {
    IdMeasuring: number
    MeasuringTool: string
    Precision: string
    _count: MeasuringToolCountAggregateOutputType | null
    _avg: MeasuringToolAvgAggregateOutputType | null
    _sum: MeasuringToolSumAggregateOutputType | null
    _min: MeasuringToolMinAggregateOutputType | null
    _max: MeasuringToolMaxAggregateOutputType | null
  }

  type GetMeasuringToolGroupByPayload<T extends MeasuringToolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeasuringToolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeasuringToolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeasuringToolGroupByOutputType[P]>
            : GetScalarType<T[P], MeasuringToolGroupByOutputType[P]>
        }
      >
    >


  export type MeasuringToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMeasuring?: boolean
    MeasuringTool?: boolean
    Precision?: boolean
    KhatRanesh?: boolean | MeasuringTool$KhatRaneshArgs<ExtArgs>
    _count?: boolean | MeasuringToolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["measuringTool"]>



  export type MeasuringToolSelectScalar = {
    IdMeasuring?: boolean
    MeasuringTool?: boolean
    Precision?: boolean
  }

  export type MeasuringToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMeasuring" | "MeasuringTool" | "Precision", ExtArgs["result"]["measuringTool"]>
  export type MeasuringToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | MeasuringTool$KhatRaneshArgs<ExtArgs>
    _count?: boolean | MeasuringToolCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MeasuringToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeasuringTool"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdMeasuring: number
      MeasuringTool: string
      Precision: string
    }, ExtArgs["result"]["measuringTool"]>
    composites: {}
  }

  type MeasuringToolGetPayload<S extends boolean | null | undefined | MeasuringToolDefaultArgs> = $Result.GetResult<Prisma.$MeasuringToolPayload, S>

  type MeasuringToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeasuringToolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeasuringToolCountAggregateInputType | true
    }

  export interface MeasuringToolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeasuringTool'], meta: { name: 'MeasuringTool' } }
    /**
     * Find zero or one MeasuringTool that matches the filter.
     * @param {MeasuringToolFindUniqueArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeasuringToolFindUniqueArgs>(args: SelectSubset<T, MeasuringToolFindUniqueArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MeasuringTool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeasuringToolFindUniqueOrThrowArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeasuringToolFindUniqueOrThrowArgs>(args: SelectSubset<T, MeasuringToolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MeasuringTool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindFirstArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeasuringToolFindFirstArgs>(args?: SelectSubset<T, MeasuringToolFindFirstArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MeasuringTool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindFirstOrThrowArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeasuringToolFindFirstOrThrowArgs>(args?: SelectSubset<T, MeasuringToolFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MeasuringTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeasuringTools
     * const measuringTools = await prisma.measuringTool.findMany()
     * 
     * // Get first 10 MeasuringTools
     * const measuringTools = await prisma.measuringTool.findMany({ take: 10 })
     * 
     * // Only select the `IdMeasuring`
     * const measuringToolWithIdMeasuringOnly = await prisma.measuringTool.findMany({ select: { IdMeasuring: true } })
     * 
     */
    findMany<T extends MeasuringToolFindManyArgs>(args?: SelectSubset<T, MeasuringToolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MeasuringTool.
     * @param {MeasuringToolCreateArgs} args - Arguments to create a MeasuringTool.
     * @example
     * // Create one MeasuringTool
     * const MeasuringTool = await prisma.measuringTool.create({
     *   data: {
     *     // ... data to create a MeasuringTool
     *   }
     * })
     * 
     */
    create<T extends MeasuringToolCreateArgs>(args: SelectSubset<T, MeasuringToolCreateArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MeasuringTools.
     * @param {MeasuringToolCreateManyArgs} args - Arguments to create many MeasuringTools.
     * @example
     * // Create many MeasuringTools
     * const measuringTool = await prisma.measuringTool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeasuringToolCreateManyArgs>(args?: SelectSubset<T, MeasuringToolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MeasuringTool.
     * @param {MeasuringToolDeleteArgs} args - Arguments to delete one MeasuringTool.
     * @example
     * // Delete one MeasuringTool
     * const MeasuringTool = await prisma.measuringTool.delete({
     *   where: {
     *     // ... filter to delete one MeasuringTool
     *   }
     * })
     * 
     */
    delete<T extends MeasuringToolDeleteArgs>(args: SelectSubset<T, MeasuringToolDeleteArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MeasuringTool.
     * @param {MeasuringToolUpdateArgs} args - Arguments to update one MeasuringTool.
     * @example
     * // Update one MeasuringTool
     * const measuringTool = await prisma.measuringTool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeasuringToolUpdateArgs>(args: SelectSubset<T, MeasuringToolUpdateArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MeasuringTools.
     * @param {MeasuringToolDeleteManyArgs} args - Arguments to filter MeasuringTools to delete.
     * @example
     * // Delete a few MeasuringTools
     * const { count } = await prisma.measuringTool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeasuringToolDeleteManyArgs>(args?: SelectSubset<T, MeasuringToolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeasuringTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeasuringTools
     * const measuringTool = await prisma.measuringTool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeasuringToolUpdateManyArgs>(args: SelectSubset<T, MeasuringToolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeasuringTool.
     * @param {MeasuringToolUpsertArgs} args - Arguments to update or create a MeasuringTool.
     * @example
     * // Update or create a MeasuringTool
     * const measuringTool = await prisma.measuringTool.upsert({
     *   create: {
     *     // ... data to create a MeasuringTool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeasuringTool we want to update
     *   }
     * })
     */
    upsert<T extends MeasuringToolUpsertArgs>(args: SelectSubset<T, MeasuringToolUpsertArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MeasuringTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolCountArgs} args - Arguments to filter MeasuringTools to count.
     * @example
     * // Count the number of MeasuringTools
     * const count = await prisma.measuringTool.count({
     *   where: {
     *     // ... the filter for the MeasuringTools we want to count
     *   }
     * })
    **/
    count<T extends MeasuringToolCountArgs>(
      args?: Subset<T, MeasuringToolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeasuringToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeasuringTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeasuringToolAggregateArgs>(args: Subset<T, MeasuringToolAggregateArgs>): Prisma.PrismaPromise<GetMeasuringToolAggregateType<T>>

    /**
     * Group by MeasuringTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeasuringToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeasuringToolGroupByArgs['orderBy'] }
        : { orderBy?: MeasuringToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeasuringToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeasuringToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeasuringTool model
   */
  readonly fields: MeasuringToolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeasuringTool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeasuringToolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends MeasuringTool$KhatRaneshArgs<ExtArgs> = {}>(args?: Subset<T, MeasuringTool$KhatRaneshArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeasuringTool model
   */ 
  interface MeasuringToolFieldRefs {
    readonly IdMeasuring: FieldRef<"MeasuringTool", 'Int'>
    readonly MeasuringTool: FieldRef<"MeasuringTool", 'String'>
    readonly Precision: FieldRef<"MeasuringTool", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MeasuringTool findUnique
   */
  export type MeasuringToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool findUniqueOrThrow
   */
  export type MeasuringToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool findFirst
   */
  export type MeasuringToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasuringTools.
     */
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool findFirstOrThrow
   */
  export type MeasuringToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasuringTools.
     */
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool findMany
   */
  export type MeasuringToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter, which MeasuringTools to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool create
   */
  export type MeasuringToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * The data needed to create a MeasuringTool.
     */
    data: XOR<MeasuringToolCreateInput, MeasuringToolUncheckedCreateInput>
  }

  /**
   * MeasuringTool createMany
   */
  export type MeasuringToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeasuringTools.
     */
    data: MeasuringToolCreateManyInput | MeasuringToolCreateManyInput[]
  }

  /**
   * MeasuringTool update
   */
  export type MeasuringToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * The data needed to update a MeasuringTool.
     */
    data: XOR<MeasuringToolUpdateInput, MeasuringToolUncheckedUpdateInput>
    /**
     * Choose, which MeasuringTool to update.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool updateMany
   */
  export type MeasuringToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeasuringTools.
     */
    data: XOR<MeasuringToolUpdateManyMutationInput, MeasuringToolUncheckedUpdateManyInput>
    /**
     * Filter which MeasuringTools to update
     */
    where?: MeasuringToolWhereInput
    /**
     * Limit how many MeasuringTools to update.
     */
    limit?: number
  }

  /**
   * MeasuringTool upsert
   */
  export type MeasuringToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * The filter to search for the MeasuringTool to update in case it exists.
     */
    where: MeasuringToolWhereUniqueInput
    /**
     * In case the MeasuringTool found by the `where` argument doesn't exist, create a new MeasuringTool with this data.
     */
    create: XOR<MeasuringToolCreateInput, MeasuringToolUncheckedCreateInput>
    /**
     * In case the MeasuringTool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeasuringToolUpdateInput, MeasuringToolUncheckedUpdateInput>
  }

  /**
   * MeasuringTool delete
   */
  export type MeasuringToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
    /**
     * Filter which MeasuringTool to delete.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool deleteMany
   */
  export type MeasuringToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasuringTools to delete
     */
    where?: MeasuringToolWhereInput
    /**
     * Limit how many MeasuringTools to delete.
     */
    limit?: number
  }

  /**
   * MeasuringTool.KhatRanesh
   */
  export type MeasuringTool$KhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    cursor?: KhatRaneshWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * MeasuringTool without action
   */
  export type MeasuringToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasuringToolInclude<ExtArgs> | null
  }


  /**
   * Model NashtShabake
   */

  export type AggregateNashtShabake = {
    _count: NashtShabakeCountAggregateOutputType | null
    _avg: NashtShabakeAvgAggregateOutputType | null
    _sum: NashtShabakeSumAggregateOutputType | null
    _min: NashtShabakeMinAggregateOutputType | null
    _max: NashtShabakeMaxAggregateOutputType | null
  }

  export type NashtShabakeAvgAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeSumAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeMinAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeMaxAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeCountAggregateOutputType = {
    IdNasht: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
    _all: number
  }


  export type NashtShabakeAvgAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeSumAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeMinAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeMaxAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeCountAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
    _all?: true
  }

  export type NashtShabakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NashtShabake to aggregate.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NashtShabakes
    **/
    _count?: true | NashtShabakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NashtShabakeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NashtShabakeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NashtShabakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NashtShabakeMaxAggregateInputType
  }

  export type GetNashtShabakeAggregateType<T extends NashtShabakeAggregateArgs> = {
        [P in keyof T & keyof AggregateNashtShabake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNashtShabake[P]>
      : GetScalarType<T[P], AggregateNashtShabake[P]>
  }




  export type NashtShabakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NashtShabakeWhereInput
    orderBy?: NashtShabakeOrderByWithAggregationInput | NashtShabakeOrderByWithAggregationInput[]
    by: NashtShabakeScalarFieldEnum[] | NashtShabakeScalarFieldEnum
    having?: NashtShabakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NashtShabakeCountAggregateInputType | true
    _avg?: NashtShabakeAvgAggregateInputType
    _sum?: NashtShabakeSumAggregateInputType
    _min?: NashtShabakeMinAggregateInputType
    _max?: NashtShabakeMaxAggregateInputType
  }

  export type NashtShabakeGroupByOutputType = {
    IdNasht: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
    _count: NashtShabakeCountAggregateOutputType | null
    _avg: NashtShabakeAvgAggregateOutputType | null
    _sum: NashtShabakeSumAggregateOutputType | null
    _min: NashtShabakeMinAggregateOutputType | null
    _max: NashtShabakeMaxAggregateOutputType | null
  }

  type GetNashtShabakeGroupByPayload<T extends NashtShabakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NashtShabakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NashtShabakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NashtShabakeGroupByOutputType[P]>
            : GetScalarType<T[P], NashtShabakeGroupByOutputType[P]>
        }
      >
    >


  export type NashtShabakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNasht?: boolean
    FIdRanesh?: boolean
    FIdTriDor?: boolean
    NashtShabake?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nashtShabake"]>



  export type NashtShabakeSelectScalar = {
    IdNasht?: boolean
    FIdRanesh?: boolean
    FIdTriDor?: boolean
    NashtShabake?: boolean
  }

  export type NashtShabakeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNasht" | "FIdRanesh" | "FIdTriDor" | "NashtShabake", ExtArgs["result"]["nashtShabake"]>
  export type NashtShabakeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $NashtShabakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NashtShabake"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdNasht: number
      FIdRanesh: number
      FIdTriDor: number
      NashtShabake: number
    }, ExtArgs["result"]["nashtShabake"]>
    composites: {}
  }

  type NashtShabakeGetPayload<S extends boolean | null | undefined | NashtShabakeDefaultArgs> = $Result.GetResult<Prisma.$NashtShabakePayload, S>

  type NashtShabakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NashtShabakeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NashtShabakeCountAggregateInputType | true
    }

  export interface NashtShabakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NashtShabake'], meta: { name: 'NashtShabake' } }
    /**
     * Find zero or one NashtShabake that matches the filter.
     * @param {NashtShabakeFindUniqueArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NashtShabakeFindUniqueArgs>(args: SelectSubset<T, NashtShabakeFindUniqueArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NashtShabake that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NashtShabakeFindUniqueOrThrowArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NashtShabakeFindUniqueOrThrowArgs>(args: SelectSubset<T, NashtShabakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NashtShabake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindFirstArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NashtShabakeFindFirstArgs>(args?: SelectSubset<T, NashtShabakeFindFirstArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NashtShabake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindFirstOrThrowArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NashtShabakeFindFirstOrThrowArgs>(args?: SelectSubset<T, NashtShabakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NashtShabakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NashtShabakes
     * const nashtShabakes = await prisma.nashtShabake.findMany()
     * 
     * // Get first 10 NashtShabakes
     * const nashtShabakes = await prisma.nashtShabake.findMany({ take: 10 })
     * 
     * // Only select the `IdNasht`
     * const nashtShabakeWithIdNashtOnly = await prisma.nashtShabake.findMany({ select: { IdNasht: true } })
     * 
     */
    findMany<T extends NashtShabakeFindManyArgs>(args?: SelectSubset<T, NashtShabakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NashtShabake.
     * @param {NashtShabakeCreateArgs} args - Arguments to create a NashtShabake.
     * @example
     * // Create one NashtShabake
     * const NashtShabake = await prisma.nashtShabake.create({
     *   data: {
     *     // ... data to create a NashtShabake
     *   }
     * })
     * 
     */
    create<T extends NashtShabakeCreateArgs>(args: SelectSubset<T, NashtShabakeCreateArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NashtShabakes.
     * @param {NashtShabakeCreateManyArgs} args - Arguments to create many NashtShabakes.
     * @example
     * // Create many NashtShabakes
     * const nashtShabake = await prisma.nashtShabake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NashtShabakeCreateManyArgs>(args?: SelectSubset<T, NashtShabakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NashtShabake.
     * @param {NashtShabakeDeleteArgs} args - Arguments to delete one NashtShabake.
     * @example
     * // Delete one NashtShabake
     * const NashtShabake = await prisma.nashtShabake.delete({
     *   where: {
     *     // ... filter to delete one NashtShabake
     *   }
     * })
     * 
     */
    delete<T extends NashtShabakeDeleteArgs>(args: SelectSubset<T, NashtShabakeDeleteArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NashtShabake.
     * @param {NashtShabakeUpdateArgs} args - Arguments to update one NashtShabake.
     * @example
     * // Update one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NashtShabakeUpdateArgs>(args: SelectSubset<T, NashtShabakeUpdateArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NashtShabakes.
     * @param {NashtShabakeDeleteManyArgs} args - Arguments to filter NashtShabakes to delete.
     * @example
     * // Delete a few NashtShabakes
     * const { count } = await prisma.nashtShabake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NashtShabakeDeleteManyArgs>(args?: SelectSubset<T, NashtShabakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NashtShabakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NashtShabakes
     * const nashtShabake = await prisma.nashtShabake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NashtShabakeUpdateManyArgs>(args: SelectSubset<T, NashtShabakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NashtShabake.
     * @param {NashtShabakeUpsertArgs} args - Arguments to update or create a NashtShabake.
     * @example
     * // Update or create a NashtShabake
     * const nashtShabake = await prisma.nashtShabake.upsert({
     *   create: {
     *     // ... data to create a NashtShabake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NashtShabake we want to update
     *   }
     * })
     */
    upsert<T extends NashtShabakeUpsertArgs>(args: SelectSubset<T, NashtShabakeUpsertArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NashtShabakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeCountArgs} args - Arguments to filter NashtShabakes to count.
     * @example
     * // Count the number of NashtShabakes
     * const count = await prisma.nashtShabake.count({
     *   where: {
     *     // ... the filter for the NashtShabakes we want to count
     *   }
     * })
    **/
    count<T extends NashtShabakeCountArgs>(
      args?: Subset<T, NashtShabakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NashtShabakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NashtShabake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NashtShabakeAggregateArgs>(args: Subset<T, NashtShabakeAggregateArgs>): Prisma.PrismaPromise<GetNashtShabakeAggregateType<T>>

    /**
     * Group by NashtShabake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NashtShabakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NashtShabakeGroupByArgs['orderBy'] }
        : { orderBy?: NashtShabakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NashtShabakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNashtShabakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NashtShabake model
   */
  readonly fields: NashtShabakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NashtShabake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NashtShabakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NashtShabake model
   */ 
  interface NashtShabakeFieldRefs {
    readonly IdNasht: FieldRef<"NashtShabake", 'Int'>
    readonly FIdRanesh: FieldRef<"NashtShabake", 'Int'>
    readonly FIdTriDor: FieldRef<"NashtShabake", 'Int'>
    readonly NashtShabake: FieldRef<"NashtShabake", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NashtShabake findUnique
   */
  export type NashtShabakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake findUniqueOrThrow
   */
  export type NashtShabakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake findFirst
   */
  export type NashtShabakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NashtShabakes.
     */
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake findFirstOrThrow
   */
  export type NashtShabakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NashtShabakes.
     */
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake findMany
   */
  export type NashtShabakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter, which NashtShabakes to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake create
   */
  export type NashtShabakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * The data needed to create a NashtShabake.
     */
    data: XOR<NashtShabakeCreateInput, NashtShabakeUncheckedCreateInput>
  }

  /**
   * NashtShabake createMany
   */
  export type NashtShabakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NashtShabakes.
     */
    data: NashtShabakeCreateManyInput | NashtShabakeCreateManyInput[]
  }

  /**
   * NashtShabake update
   */
  export type NashtShabakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * The data needed to update a NashtShabake.
     */
    data: XOR<NashtShabakeUpdateInput, NashtShabakeUncheckedUpdateInput>
    /**
     * Choose, which NashtShabake to update.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake updateMany
   */
  export type NashtShabakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NashtShabakes.
     */
    data: XOR<NashtShabakeUpdateManyMutationInput, NashtShabakeUncheckedUpdateManyInput>
    /**
     * Filter which NashtShabakes to update
     */
    where?: NashtShabakeWhereInput
    /**
     * Limit how many NashtShabakes to update.
     */
    limit?: number
  }

  /**
   * NashtShabake upsert
   */
  export type NashtShabakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * The filter to search for the NashtShabake to update in case it exists.
     */
    where: NashtShabakeWhereUniqueInput
    /**
     * In case the NashtShabake found by the `where` argument doesn't exist, create a new NashtShabake with this data.
     */
    create: XOR<NashtShabakeCreateInput, NashtShabakeUncheckedCreateInput>
    /**
     * In case the NashtShabake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NashtShabakeUpdateInput, NashtShabakeUncheckedUpdateInput>
  }

  /**
   * NashtShabake delete
   */
  export type NashtShabakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    /**
     * Filter which NashtShabake to delete.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake deleteMany
   */
  export type NashtShabakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NashtShabakes to delete
     */
    where?: NashtShabakeWhereInput
    /**
     * Limit how many NashtShabakes to delete.
     */
    limit?: number
  }

  /**
   * NashtShabake without action
   */
  export type NashtShabakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
  }


  /**
   * Model Network
   */

  export type AggregateNetwork = {
    _count: NetworkCountAggregateOutputType | null
    _avg: NetworkAvgAggregateOutputType | null
    _sum: NetworkSumAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  export type NetworkAvgAggregateOutputType = {
    IdNet: number | null
    FIdSP: number | null
  }

  export type NetworkSumAggregateOutputType = {
    IdNet: number | null
    FIdSP: number | null
  }

  export type NetworkMinAggregateOutputType = {
    IdNet: number | null
    Network: string | null
    FIdSP: number | null
  }

  export type NetworkMaxAggregateOutputType = {
    IdNet: number | null
    Network: string | null
    FIdSP: number | null
  }

  export type NetworkCountAggregateOutputType = {
    IdNet: number
    Network: number
    FIdSP: number
    _all: number
  }


  export type NetworkAvgAggregateInputType = {
    IdNet?: true
    FIdSP?: true
  }

  export type NetworkSumAggregateInputType = {
    IdNet?: true
    FIdSP?: true
  }

  export type NetworkMinAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
  }

  export type NetworkMaxAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
  }

  export type NetworkCountAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
    _all?: true
  }

  export type NetworkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Network to aggregate.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Networks
    **/
    _count?: true | NetworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkMaxAggregateInputType
  }

  export type GetNetworkAggregateType<T extends NetworkAggregateArgs> = {
        [P in keyof T & keyof AggregateNetwork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetwork[P]>
      : GetScalarType<T[P], AggregateNetwork[P]>
  }




  export type NetworkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithAggregationInput | NetworkOrderByWithAggregationInput[]
    by: NetworkScalarFieldEnum[] | NetworkScalarFieldEnum
    having?: NetworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkCountAggregateInputType | true
    _avg?: NetworkAvgAggregateInputType
    _sum?: NetworkSumAggregateInputType
    _min?: NetworkMinAggregateInputType
    _max?: NetworkMaxAggregateInputType
  }

  export type NetworkGroupByOutputType = {
    IdNet: number
    Network: string
    FIdSP: number
    _count: NetworkCountAggregateOutputType | null
    _avg: NetworkAvgAggregateOutputType | null
    _sum: NetworkSumAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  type GetNetworkGroupByPayload<T extends NetworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkGroupByOutputType[P]>
        }
      >
    >


  export type NetworkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNet?: boolean
    Network?: boolean
    FIdSP?: boolean
    BareshMotaleat?: boolean | Network$BareshMotaleatArgs<ExtArgs>
    KhatRaneshArea?: boolean | Network$KhatRaneshAreaArgs<ExtArgs>
    SystemPart?: boolean | SystemPartDefaultArgs<ExtArgs>
    PumpStation?: boolean | Network$PumpStationArgs<ExtArgs>
    ShabakeDoreKesht?: boolean | Network$ShabakeDoreKeshtArgs<ExtArgs>
    _count?: boolean | NetworkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["network"]>



  export type NetworkSelectScalar = {
    IdNet?: boolean
    Network?: boolean
    FIdSP?: boolean
  }

  export type NetworkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNet" | "Network" | "FIdSP", ExtArgs["result"]["network"]>
  export type NetworkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BareshMotaleat?: boolean | Network$BareshMotaleatArgs<ExtArgs>
    KhatRaneshArea?: boolean | Network$KhatRaneshAreaArgs<ExtArgs>
    SystemPart?: boolean | SystemPartDefaultArgs<ExtArgs>
    PumpStation?: boolean | Network$PumpStationArgs<ExtArgs>
    ShabakeDoreKesht?: boolean | Network$ShabakeDoreKeshtArgs<ExtArgs>
    _count?: boolean | NetworkCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NetworkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Network"
    objects: {
      BareshMotaleat: Prisma.$BareshMotaleatPayload<ExtArgs>[]
      KhatRaneshArea: Prisma.$KhatRaneshAreaPayload<ExtArgs>[]
      SystemPart: Prisma.$SystemPartPayload<ExtArgs>
      PumpStation: Prisma.$PumpStationPayload<ExtArgs>[]
      ShabakeDoreKesht: Prisma.$ShabakeDoreKeshtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdNet: number
      Network: string
      FIdSP: number
    }, ExtArgs["result"]["network"]>
    composites: {}
  }

  type NetworkGetPayload<S extends boolean | null | undefined | NetworkDefaultArgs> = $Result.GetResult<Prisma.$NetworkPayload, S>

  type NetworkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkCountAggregateInputType | true
    }

  export interface NetworkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Network'], meta: { name: 'Network' } }
    /**
     * Find zero or one Network that matches the filter.
     * @param {NetworkFindUniqueArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkFindUniqueArgs>(args: SelectSubset<T, NetworkFindUniqueArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Network that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkFindUniqueOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Network that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkFindFirstArgs>(args?: SelectSubset<T, NetworkFindFirstArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Network that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Networks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Networks
     * const networks = await prisma.network.findMany()
     * 
     * // Get first 10 Networks
     * const networks = await prisma.network.findMany({ take: 10 })
     * 
     * // Only select the `IdNet`
     * const networkWithIdNetOnly = await prisma.network.findMany({ select: { IdNet: true } })
     * 
     */
    findMany<T extends NetworkFindManyArgs>(args?: SelectSubset<T, NetworkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Network.
     * @param {NetworkCreateArgs} args - Arguments to create a Network.
     * @example
     * // Create one Network
     * const Network = await prisma.network.create({
     *   data: {
     *     // ... data to create a Network
     *   }
     * })
     * 
     */
    create<T extends NetworkCreateArgs>(args: SelectSubset<T, NetworkCreateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Networks.
     * @param {NetworkCreateManyArgs} args - Arguments to create many Networks.
     * @example
     * // Create many Networks
     * const network = await prisma.network.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkCreateManyArgs>(args?: SelectSubset<T, NetworkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Network.
     * @param {NetworkDeleteArgs} args - Arguments to delete one Network.
     * @example
     * // Delete one Network
     * const Network = await prisma.network.delete({
     *   where: {
     *     // ... filter to delete one Network
     *   }
     * })
     * 
     */
    delete<T extends NetworkDeleteArgs>(args: SelectSubset<T, NetworkDeleteArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Network.
     * @param {NetworkUpdateArgs} args - Arguments to update one Network.
     * @example
     * // Update one Network
     * const network = await prisma.network.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkUpdateArgs>(args: SelectSubset<T, NetworkUpdateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Networks.
     * @param {NetworkDeleteManyArgs} args - Arguments to filter Networks to delete.
     * @example
     * // Delete a few Networks
     * const { count } = await prisma.network.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkDeleteManyArgs>(args?: SelectSubset<T, NetworkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Networks
     * const network = await prisma.network.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkUpdateManyArgs>(args: SelectSubset<T, NetworkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Network.
     * @param {NetworkUpsertArgs} args - Arguments to update or create a Network.
     * @example
     * // Update or create a Network
     * const network = await prisma.network.upsert({
     *   create: {
     *     // ... data to create a Network
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Network we want to update
     *   }
     * })
     */
    upsert<T extends NetworkUpsertArgs>(args: SelectSubset<T, NetworkUpsertArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkCountArgs} args - Arguments to filter Networks to count.
     * @example
     * // Count the number of Networks
     * const count = await prisma.network.count({
     *   where: {
     *     // ... the filter for the Networks we want to count
     *   }
     * })
    **/
    count<T extends NetworkCountArgs>(
      args?: Subset<T, NetworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkAggregateArgs>(args: Subset<T, NetworkAggregateArgs>): Prisma.PrismaPromise<GetNetworkAggregateType<T>>

    /**
     * Group by Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkGroupByArgs['orderBy'] }
        : { orderBy?: NetworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Network model
   */
  readonly fields: NetworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Network.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BareshMotaleat<T extends Network$BareshMotaleatArgs<ExtArgs> = {}>(args?: Subset<T, Network$BareshMotaleatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    KhatRaneshArea<T extends Network$KhatRaneshAreaArgs<ExtArgs> = {}>(args?: Subset<T, Network$KhatRaneshAreaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    SystemPart<T extends SystemPartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemPartDefaultArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    PumpStation<T extends Network$PumpStationArgs<ExtArgs> = {}>(args?: Subset<T, Network$PumpStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ShabakeDoreKesht<T extends Network$ShabakeDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, Network$ShabakeDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Network model
   */ 
  interface NetworkFieldRefs {
    readonly IdNet: FieldRef<"Network", 'Int'>
    readonly Network: FieldRef<"Network", 'String'>
    readonly FIdSP: FieldRef<"Network", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Network findUnique
   */
  export type NetworkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findUniqueOrThrow
   */
  export type NetworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findFirst
   */
  export type NetworkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findFirstOrThrow
   */
  export type NetworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findMany
   */
  export type NetworkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Networks to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network create
   */
  export type NetworkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The data needed to create a Network.
     */
    data: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
  }

  /**
   * Network createMany
   */
  export type NetworkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Networks.
     */
    data: NetworkCreateManyInput | NetworkCreateManyInput[]
  }

  /**
   * Network update
   */
  export type NetworkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The data needed to update a Network.
     */
    data: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
    /**
     * Choose, which Network to update.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network updateMany
   */
  export type NetworkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Networks.
     */
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyInput>
    /**
     * Filter which Networks to update
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to update.
     */
    limit?: number
  }

  /**
   * Network upsert
   */
  export type NetworkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The filter to search for the Network to update in case it exists.
     */
    where: NetworkWhereUniqueInput
    /**
     * In case the Network found by the `where` argument doesn't exist, create a new Network with this data.
     */
    create: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
    /**
     * In case the Network was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
  }

  /**
   * Network delete
   */
  export type NetworkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter which Network to delete.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network deleteMany
   */
  export type NetworkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Networks to delete
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to delete.
     */
    limit?: number
  }

  /**
   * Network.BareshMotaleat
   */
  export type Network$BareshMotaleatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    where?: BareshMotaleatWhereInput
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    cursor?: BareshMotaleatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * Network.KhatRaneshArea
   */
  export type Network$KhatRaneshAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshAreaInclude<ExtArgs> | null
    where?: KhatRaneshAreaWhereInput
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    cursor?: KhatRaneshAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * Network.PumpStation
   */
  export type Network$PumpStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    cursor?: PumpStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * Network.ShabakeDoreKesht
   */
  export type Network$ShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    where?: ShabakeDoreKeshtWhereInput
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * Network without action
   */
  export type NetworkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
  }


  /**
   * Model NoeKesht
   */

  export type AggregateNoeKesht = {
    _count: NoeKeshtCountAggregateOutputType | null
    _avg: NoeKeshtAvgAggregateOutputType | null
    _sum: NoeKeshtSumAggregateOutputType | null
    _min: NoeKeshtMinAggregateOutputType | null
    _max: NoeKeshtMaxAggregateOutputType | null
  }

  export type NoeKeshtAvgAggregateOutputType = {
    IdNoeK: number | null
  }

  export type NoeKeshtSumAggregateOutputType = {
    IdNoeK: number | null
  }

  export type NoeKeshtMinAggregateOutputType = {
    IdNoeK: number | null
    Kesht: string | null
  }

  export type NoeKeshtMaxAggregateOutputType = {
    IdNoeK: number | null
    Kesht: string | null
  }

  export type NoeKeshtCountAggregateOutputType = {
    IdNoeK: number
    Kesht: number
    _all: number
  }


  export type NoeKeshtAvgAggregateInputType = {
    IdNoeK?: true
  }

  export type NoeKeshtSumAggregateInputType = {
    IdNoeK?: true
  }

  export type NoeKeshtMinAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
  }

  export type NoeKeshtMaxAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
  }

  export type NoeKeshtCountAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
    _all?: true
  }

  export type NoeKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeKesht to aggregate.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoeKeshts
    **/
    _count?: true | NoeKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoeKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoeKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoeKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoeKeshtMaxAggregateInputType
  }

  export type GetNoeKeshtAggregateType<T extends NoeKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateNoeKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoeKesht[P]>
      : GetScalarType<T[P], AggregateNoeKesht[P]>
  }




  export type NoeKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoeKeshtWhereInput
    orderBy?: NoeKeshtOrderByWithAggregationInput | NoeKeshtOrderByWithAggregationInput[]
    by: NoeKeshtScalarFieldEnum[] | NoeKeshtScalarFieldEnum
    having?: NoeKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoeKeshtCountAggregateInputType | true
    _avg?: NoeKeshtAvgAggregateInputType
    _sum?: NoeKeshtSumAggregateInputType
    _min?: NoeKeshtMinAggregateInputType
    _max?: NoeKeshtMaxAggregateInputType
  }

  export type NoeKeshtGroupByOutputType = {
    IdNoeK: number
    Kesht: string
    _count: NoeKeshtCountAggregateOutputType | null
    _avg: NoeKeshtAvgAggregateOutputType | null
    _sum: NoeKeshtSumAggregateOutputType | null
    _min: NoeKeshtMinAggregateOutputType | null
    _max: NoeKeshtMaxAggregateOutputType | null
  }

  type GetNoeKeshtGroupByPayload<T extends NoeKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoeKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoeKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoeKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], NoeKeshtGroupByOutputType[P]>
        }
      >
    >


  export type NoeKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNoeK?: boolean
    Kesht?: boolean
    NoeMahsool?: boolean | NoeKesht$NoeMahsoolArgs<ExtArgs>
    _count?: boolean | NoeKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noeKesht"]>



  export type NoeKeshtSelectScalar = {
    IdNoeK?: boolean
    Kesht?: boolean
  }

  export type NoeKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNoeK" | "Kesht", ExtArgs["result"]["noeKesht"]>
  export type NoeKeshtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NoeMahsool?: boolean | NoeKesht$NoeMahsoolArgs<ExtArgs>
    _count?: boolean | NoeKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NoeKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoeKesht"
    objects: {
      NoeMahsool: Prisma.$NoeMahsoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdNoeK: number
      Kesht: string
    }, ExtArgs["result"]["noeKesht"]>
    composites: {}
  }

  type NoeKeshtGetPayload<S extends boolean | null | undefined | NoeKeshtDefaultArgs> = $Result.GetResult<Prisma.$NoeKeshtPayload, S>

  type NoeKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoeKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoeKeshtCountAggregateInputType | true
    }

  export interface NoeKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoeKesht'], meta: { name: 'NoeKesht' } }
    /**
     * Find zero or one NoeKesht that matches the filter.
     * @param {NoeKeshtFindUniqueArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoeKeshtFindUniqueArgs>(args: SelectSubset<T, NoeKeshtFindUniqueArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NoeKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoeKeshtFindUniqueOrThrowArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoeKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, NoeKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NoeKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindFirstArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoeKeshtFindFirstArgs>(args?: SelectSubset<T, NoeKeshtFindFirstArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NoeKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindFirstOrThrowArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoeKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, NoeKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NoeKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoeKeshts
     * const noeKeshts = await prisma.noeKesht.findMany()
     * 
     * // Get first 10 NoeKeshts
     * const noeKeshts = await prisma.noeKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdNoeK`
     * const noeKeshtWithIdNoeKOnly = await prisma.noeKesht.findMany({ select: { IdNoeK: true } })
     * 
     */
    findMany<T extends NoeKeshtFindManyArgs>(args?: SelectSubset<T, NoeKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NoeKesht.
     * @param {NoeKeshtCreateArgs} args - Arguments to create a NoeKesht.
     * @example
     * // Create one NoeKesht
     * const NoeKesht = await prisma.noeKesht.create({
     *   data: {
     *     // ... data to create a NoeKesht
     *   }
     * })
     * 
     */
    create<T extends NoeKeshtCreateArgs>(args: SelectSubset<T, NoeKeshtCreateArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NoeKeshts.
     * @param {NoeKeshtCreateManyArgs} args - Arguments to create many NoeKeshts.
     * @example
     * // Create many NoeKeshts
     * const noeKesht = await prisma.noeKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoeKeshtCreateManyArgs>(args?: SelectSubset<T, NoeKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoeKesht.
     * @param {NoeKeshtDeleteArgs} args - Arguments to delete one NoeKesht.
     * @example
     * // Delete one NoeKesht
     * const NoeKesht = await prisma.noeKesht.delete({
     *   where: {
     *     // ... filter to delete one NoeKesht
     *   }
     * })
     * 
     */
    delete<T extends NoeKeshtDeleteArgs>(args: SelectSubset<T, NoeKeshtDeleteArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NoeKesht.
     * @param {NoeKeshtUpdateArgs} args - Arguments to update one NoeKesht.
     * @example
     * // Update one NoeKesht
     * const noeKesht = await prisma.noeKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoeKeshtUpdateArgs>(args: SelectSubset<T, NoeKeshtUpdateArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NoeKeshts.
     * @param {NoeKeshtDeleteManyArgs} args - Arguments to filter NoeKeshts to delete.
     * @example
     * // Delete a few NoeKeshts
     * const { count } = await prisma.noeKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoeKeshtDeleteManyArgs>(args?: SelectSubset<T, NoeKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoeKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoeKeshts
     * const noeKesht = await prisma.noeKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoeKeshtUpdateManyArgs>(args: SelectSubset<T, NoeKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoeKesht.
     * @param {NoeKeshtUpsertArgs} args - Arguments to update or create a NoeKesht.
     * @example
     * // Update or create a NoeKesht
     * const noeKesht = await prisma.noeKesht.upsert({
     *   create: {
     *     // ... data to create a NoeKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoeKesht we want to update
     *   }
     * })
     */
    upsert<T extends NoeKeshtUpsertArgs>(args: SelectSubset<T, NoeKeshtUpsertArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NoeKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtCountArgs} args - Arguments to filter NoeKeshts to count.
     * @example
     * // Count the number of NoeKeshts
     * const count = await prisma.noeKesht.count({
     *   where: {
     *     // ... the filter for the NoeKeshts we want to count
     *   }
     * })
    **/
    count<T extends NoeKeshtCountArgs>(
      args?: Subset<T, NoeKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoeKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoeKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoeKeshtAggregateArgs>(args: Subset<T, NoeKeshtAggregateArgs>): Prisma.PrismaPromise<GetNoeKeshtAggregateType<T>>

    /**
     * Group by NoeKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoeKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoeKeshtGroupByArgs['orderBy'] }
        : { orderBy?: NoeKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoeKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoeKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoeKesht model
   */
  readonly fields: NoeKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoeKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoeKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NoeMahsool<T extends NoeKesht$NoeMahsoolArgs<ExtArgs> = {}>(args?: Subset<T, NoeKesht$NoeMahsoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoeKesht model
   */ 
  interface NoeKeshtFieldRefs {
    readonly IdNoeK: FieldRef<"NoeKesht", 'Int'>
    readonly Kesht: FieldRef<"NoeKesht", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NoeKesht findUnique
   */
  export type NoeKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht findUniqueOrThrow
   */
  export type NoeKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht findFirst
   */
  export type NoeKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeKeshts.
     */
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht findFirstOrThrow
   */
  export type NoeKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeKeshts.
     */
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht findMany
   */
  export type NoeKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter, which NoeKeshts to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht create
   */
  export type NoeKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * The data needed to create a NoeKesht.
     */
    data: XOR<NoeKeshtCreateInput, NoeKeshtUncheckedCreateInput>
  }

  /**
   * NoeKesht createMany
   */
  export type NoeKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoeKeshts.
     */
    data: NoeKeshtCreateManyInput | NoeKeshtCreateManyInput[]
  }

  /**
   * NoeKesht update
   */
  export type NoeKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * The data needed to update a NoeKesht.
     */
    data: XOR<NoeKeshtUpdateInput, NoeKeshtUncheckedUpdateInput>
    /**
     * Choose, which NoeKesht to update.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht updateMany
   */
  export type NoeKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoeKeshts.
     */
    data: XOR<NoeKeshtUpdateManyMutationInput, NoeKeshtUncheckedUpdateManyInput>
    /**
     * Filter which NoeKeshts to update
     */
    where?: NoeKeshtWhereInput
    /**
     * Limit how many NoeKeshts to update.
     */
    limit?: number
  }

  /**
   * NoeKesht upsert
   */
  export type NoeKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * The filter to search for the NoeKesht to update in case it exists.
     */
    where: NoeKeshtWhereUniqueInput
    /**
     * In case the NoeKesht found by the `where` argument doesn't exist, create a new NoeKesht with this data.
     */
    create: XOR<NoeKeshtCreateInput, NoeKeshtUncheckedCreateInput>
    /**
     * In case the NoeKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoeKeshtUpdateInput, NoeKeshtUncheckedUpdateInput>
  }

  /**
   * NoeKesht delete
   */
  export type NoeKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
    /**
     * Filter which NoeKesht to delete.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht deleteMany
   */
  export type NoeKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeKeshts to delete
     */
    where?: NoeKeshtWhereInput
    /**
     * Limit how many NoeKeshts to delete.
     */
    limit?: number
  }

  /**
   * NoeKesht.NoeMahsool
   */
  export type NoeKesht$NoeMahsoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    where?: NoeMahsoolWhereInput
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    cursor?: NoeMahsoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeKesht without action
   */
  export type NoeKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeKeshtInclude<ExtArgs> | null
  }


  /**
   * Model NoeMahsool
   */

  export type AggregateNoeMahsool = {
    _count: NoeMahsoolCountAggregateOutputType | null
    _avg: NoeMahsoolAvgAggregateOutputType | null
    _sum: NoeMahsoolSumAggregateOutputType | null
    _min: NoeMahsoolMinAggregateOutputType | null
    _max: NoeMahsoolMaxAggregateOutputType | null
  }

  export type NoeMahsoolAvgAggregateOutputType = {
    IdNoeM: number | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolSumAggregateOutputType = {
    IdNoeM: number | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolMinAggregateOutputType = {
    IdNoeM: number | null
    Mahsool: string | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolMaxAggregateOutputType = {
    IdNoeM: number | null
    Mahsool: string | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolCountAggregateOutputType = {
    IdNoeM: number
    Mahsool: number
    FIdNoeK: number
    _all: number
  }


  export type NoeMahsoolAvgAggregateInputType = {
    IdNoeM?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolSumAggregateInputType = {
    IdNoeM?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolMinAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolMaxAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolCountAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
    _all?: true
  }

  export type NoeMahsoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeMahsool to aggregate.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoeMahsools
    **/
    _count?: true | NoeMahsoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoeMahsoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoeMahsoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoeMahsoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoeMahsoolMaxAggregateInputType
  }

  export type GetNoeMahsoolAggregateType<T extends NoeMahsoolAggregateArgs> = {
        [P in keyof T & keyof AggregateNoeMahsool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoeMahsool[P]>
      : GetScalarType<T[P], AggregateNoeMahsool[P]>
  }




  export type NoeMahsoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoeMahsoolWhereInput
    orderBy?: NoeMahsoolOrderByWithAggregationInput | NoeMahsoolOrderByWithAggregationInput[]
    by: NoeMahsoolScalarFieldEnum[] | NoeMahsoolScalarFieldEnum
    having?: NoeMahsoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoeMahsoolCountAggregateInputType | true
    _avg?: NoeMahsoolAvgAggregateInputType
    _sum?: NoeMahsoolSumAggregateInputType
    _min?: NoeMahsoolMinAggregateInputType
    _max?: NoeMahsoolMaxAggregateInputType
  }

  export type NoeMahsoolGroupByOutputType = {
    IdNoeM: number
    Mahsool: string
    FIdNoeK: number
    _count: NoeMahsoolCountAggregateOutputType | null
    _avg: NoeMahsoolAvgAggregateOutputType | null
    _sum: NoeMahsoolSumAggregateOutputType | null
    _min: NoeMahsoolMinAggregateOutputType | null
    _max: NoeMahsoolMaxAggregateOutputType | null
  }

  type GetNoeMahsoolGroupByPayload<T extends NoeMahsoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoeMahsoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoeMahsoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoeMahsoolGroupByOutputType[P]>
            : GetScalarType<T[P], NoeMahsoolGroupByOutputType[P]>
        }
      >
    >


  export type NoeMahsoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNoeM?: boolean
    Mahsool?: boolean
    FIdNoeK?: boolean
    BahrebardariKeshtDore?: boolean | NoeMahsool$BahrebardariKeshtDoreArgs<ExtArgs>
    NoeKesht?: boolean | NoeKeshtDefaultArgs<ExtArgs>
    _count?: boolean | NoeMahsoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noeMahsool"]>



  export type NoeMahsoolSelectScalar = {
    IdNoeM?: boolean
    Mahsool?: boolean
    FIdNoeK?: boolean
  }

  export type NoeMahsoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNoeM" | "Mahsool" | "FIdNoeK", ExtArgs["result"]["noeMahsool"]>
  export type NoeMahsoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardariKeshtDore?: boolean | NoeMahsool$BahrebardariKeshtDoreArgs<ExtArgs>
    NoeKesht?: boolean | NoeKeshtDefaultArgs<ExtArgs>
    _count?: boolean | NoeMahsoolCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NoeMahsoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoeMahsool"
    objects: {
      BahrebardariKeshtDore: Prisma.$BahrebardariKeshtDorePayload<ExtArgs>[]
      NoeKesht: Prisma.$NoeKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdNoeM: number
      Mahsool: string
      FIdNoeK: number
    }, ExtArgs["result"]["noeMahsool"]>
    composites: {}
  }

  type NoeMahsoolGetPayload<S extends boolean | null | undefined | NoeMahsoolDefaultArgs> = $Result.GetResult<Prisma.$NoeMahsoolPayload, S>

  type NoeMahsoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoeMahsoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoeMahsoolCountAggregateInputType | true
    }

  export interface NoeMahsoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoeMahsool'], meta: { name: 'NoeMahsool' } }
    /**
     * Find zero or one NoeMahsool that matches the filter.
     * @param {NoeMahsoolFindUniqueArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoeMahsoolFindUniqueArgs>(args: SelectSubset<T, NoeMahsoolFindUniqueArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NoeMahsool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoeMahsoolFindUniqueOrThrowArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoeMahsoolFindUniqueOrThrowArgs>(args: SelectSubset<T, NoeMahsoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NoeMahsool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindFirstArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoeMahsoolFindFirstArgs>(args?: SelectSubset<T, NoeMahsoolFindFirstArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NoeMahsool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindFirstOrThrowArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoeMahsoolFindFirstOrThrowArgs>(args?: SelectSubset<T, NoeMahsoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NoeMahsools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoeMahsools
     * const noeMahsools = await prisma.noeMahsool.findMany()
     * 
     * // Get first 10 NoeMahsools
     * const noeMahsools = await prisma.noeMahsool.findMany({ take: 10 })
     * 
     * // Only select the `IdNoeM`
     * const noeMahsoolWithIdNoeMOnly = await prisma.noeMahsool.findMany({ select: { IdNoeM: true } })
     * 
     */
    findMany<T extends NoeMahsoolFindManyArgs>(args?: SelectSubset<T, NoeMahsoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NoeMahsool.
     * @param {NoeMahsoolCreateArgs} args - Arguments to create a NoeMahsool.
     * @example
     * // Create one NoeMahsool
     * const NoeMahsool = await prisma.noeMahsool.create({
     *   data: {
     *     // ... data to create a NoeMahsool
     *   }
     * })
     * 
     */
    create<T extends NoeMahsoolCreateArgs>(args: SelectSubset<T, NoeMahsoolCreateArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NoeMahsools.
     * @param {NoeMahsoolCreateManyArgs} args - Arguments to create many NoeMahsools.
     * @example
     * // Create many NoeMahsools
     * const noeMahsool = await prisma.noeMahsool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoeMahsoolCreateManyArgs>(args?: SelectSubset<T, NoeMahsoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoeMahsool.
     * @param {NoeMahsoolDeleteArgs} args - Arguments to delete one NoeMahsool.
     * @example
     * // Delete one NoeMahsool
     * const NoeMahsool = await prisma.noeMahsool.delete({
     *   where: {
     *     // ... filter to delete one NoeMahsool
     *   }
     * })
     * 
     */
    delete<T extends NoeMahsoolDeleteArgs>(args: SelectSubset<T, NoeMahsoolDeleteArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NoeMahsool.
     * @param {NoeMahsoolUpdateArgs} args - Arguments to update one NoeMahsool.
     * @example
     * // Update one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoeMahsoolUpdateArgs>(args: SelectSubset<T, NoeMahsoolUpdateArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NoeMahsools.
     * @param {NoeMahsoolDeleteManyArgs} args - Arguments to filter NoeMahsools to delete.
     * @example
     * // Delete a few NoeMahsools
     * const { count } = await prisma.noeMahsool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoeMahsoolDeleteManyArgs>(args?: SelectSubset<T, NoeMahsoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoeMahsools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoeMahsools
     * const noeMahsool = await prisma.noeMahsool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoeMahsoolUpdateManyArgs>(args: SelectSubset<T, NoeMahsoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoeMahsool.
     * @param {NoeMahsoolUpsertArgs} args - Arguments to update or create a NoeMahsool.
     * @example
     * // Update or create a NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.upsert({
     *   create: {
     *     // ... data to create a NoeMahsool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoeMahsool we want to update
     *   }
     * })
     */
    upsert<T extends NoeMahsoolUpsertArgs>(args: SelectSubset<T, NoeMahsoolUpsertArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NoeMahsools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolCountArgs} args - Arguments to filter NoeMahsools to count.
     * @example
     * // Count the number of NoeMahsools
     * const count = await prisma.noeMahsool.count({
     *   where: {
     *     // ... the filter for the NoeMahsools we want to count
     *   }
     * })
    **/
    count<T extends NoeMahsoolCountArgs>(
      args?: Subset<T, NoeMahsoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoeMahsoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoeMahsool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoeMahsoolAggregateArgs>(args: Subset<T, NoeMahsoolAggregateArgs>): Prisma.PrismaPromise<GetNoeMahsoolAggregateType<T>>

    /**
     * Group by NoeMahsool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoeMahsoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoeMahsoolGroupByArgs['orderBy'] }
        : { orderBy?: NoeMahsoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoeMahsoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoeMahsoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoeMahsool model
   */
  readonly fields: NoeMahsoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoeMahsool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoeMahsoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BahrebardariKeshtDore<T extends NoeMahsool$BahrebardariKeshtDoreArgs<ExtArgs> = {}>(args?: Subset<T, NoeMahsool$BahrebardariKeshtDoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NoeKesht<T extends NoeKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NoeKeshtDefaultArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoeMahsool model
   */ 
  interface NoeMahsoolFieldRefs {
    readonly IdNoeM: FieldRef<"NoeMahsool", 'Int'>
    readonly Mahsool: FieldRef<"NoeMahsool", 'String'>
    readonly FIdNoeK: FieldRef<"NoeMahsool", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NoeMahsool findUnique
   */
  export type NoeMahsoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool findUniqueOrThrow
   */
  export type NoeMahsoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool findFirst
   */
  export type NoeMahsoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeMahsools.
     */
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool findFirstOrThrow
   */
  export type NoeMahsoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeMahsools.
     */
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool findMany
   */
  export type NoeMahsoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter, which NoeMahsools to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool create
   */
  export type NoeMahsoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * The data needed to create a NoeMahsool.
     */
    data: XOR<NoeMahsoolCreateInput, NoeMahsoolUncheckedCreateInput>
  }

  /**
   * NoeMahsool createMany
   */
  export type NoeMahsoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoeMahsools.
     */
    data: NoeMahsoolCreateManyInput | NoeMahsoolCreateManyInput[]
  }

  /**
   * NoeMahsool update
   */
  export type NoeMahsoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * The data needed to update a NoeMahsool.
     */
    data: XOR<NoeMahsoolUpdateInput, NoeMahsoolUncheckedUpdateInput>
    /**
     * Choose, which NoeMahsool to update.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool updateMany
   */
  export type NoeMahsoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoeMahsools.
     */
    data: XOR<NoeMahsoolUpdateManyMutationInput, NoeMahsoolUncheckedUpdateManyInput>
    /**
     * Filter which NoeMahsools to update
     */
    where?: NoeMahsoolWhereInput
    /**
     * Limit how many NoeMahsools to update.
     */
    limit?: number
  }

  /**
   * NoeMahsool upsert
   */
  export type NoeMahsoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * The filter to search for the NoeMahsool to update in case it exists.
     */
    where: NoeMahsoolWhereUniqueInput
    /**
     * In case the NoeMahsool found by the `where` argument doesn't exist, create a new NoeMahsool with this data.
     */
    create: XOR<NoeMahsoolCreateInput, NoeMahsoolUncheckedCreateInput>
    /**
     * In case the NoeMahsool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoeMahsoolUpdateInput, NoeMahsoolUncheckedUpdateInput>
  }

  /**
   * NoeMahsool delete
   */
  export type NoeMahsoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
    /**
     * Filter which NoeMahsool to delete.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool deleteMany
   */
  export type NoeMahsoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeMahsools to delete
     */
    where?: NoeMahsoolWhereInput
    /**
     * Limit how many NoeMahsools to delete.
     */
    limit?: number
  }

  /**
   * NoeMahsool.BahrebardariKeshtDore
   */
  export type NoeMahsool$BahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    where?: BahrebardariKeshtDoreWhereInput
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * NoeMahsool without action
   */
  export type NoeMahsoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoeMahsoolInclude<ExtArgs> | null
  }


  /**
   * Model NonFIT
   */

  export type AggregateNonFIT = {
    _count: NonFITCountAggregateOutputType | null
    _avg: NonFITAvgAggregateOutputType | null
    _sum: NonFITSumAggregateOutputType | null
    _min: NonFITMinAggregateOutputType | null
    _max: NonFITMaxAggregateOutputType | null
  }

  export type NonFITAvgAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITSumAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITMinAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITMaxAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITCountAggregateOutputType = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor: number
    VOLUM: number
    _all: number
  }


  export type NonFITAvgAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITSumAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITMinAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITMaxAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITCountAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
    _all?: true
  }

  export type NonFITAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonFIT to aggregate.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NonFITS
    **/
    _count?: true | NonFITCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonFITAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonFITSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonFITMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonFITMaxAggregateInputType
  }

  export type GetNonFITAggregateType<T extends NonFITAggregateArgs> = {
        [P in keyof T & keyof AggregateNonFIT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonFIT[P]>
      : GetScalarType<T[P], AggregateNonFIT[P]>
  }




  export type NonFITGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonFITWhereInput
    orderBy?: NonFITOrderByWithAggregationInput | NonFITOrderByWithAggregationInput[]
    by: NonFITScalarFieldEnum[] | NonFITScalarFieldEnum
    having?: NonFITScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonFITCountAggregateInputType | true
    _avg?: NonFITAvgAggregateInputType
    _sum?: NonFITSumAggregateInputType
    _min?: NonFITMinAggregateInputType
    _max?: NonFITMaxAggregateInputType
  }

  export type NonFITGroupByOutputType = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor: number
    VOLUM: number
    _count: NonFITCountAggregateOutputType | null
    _avg: NonFITAvgAggregateOutputType | null
    _sum: NonFITSumAggregateOutputType | null
    _min: NonFITMinAggregateOutputType | null
    _max: NonFITMaxAggregateOutputType | null
  }

  type GetNonFITGroupByPayload<T extends NonFITGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonFITGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonFITGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonFITGroupByOutputType[P]>
            : GetScalarType<T[P], NonFITGroupByOutputType[P]>
        }
      >
    >


  export type NonFITSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNonFIT?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    VOLUM?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nonFIT"]>



  export type NonFITSelectScalar = {
    IdNonFIT?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    VOLUM?: boolean
  }

  export type NonFITOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNonFIT" | "FIdRanesh" | "FIdTarDor" | "VOLUM", ExtArgs["result"]["nonFIT"]>
  export type NonFITInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $NonFITPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NonFIT"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdNonFIT: number
      FIdRanesh: number
      FIdTarDor: number
      VOLUM: number
    }, ExtArgs["result"]["nonFIT"]>
    composites: {}
  }

  type NonFITGetPayload<S extends boolean | null | undefined | NonFITDefaultArgs> = $Result.GetResult<Prisma.$NonFITPayload, S>

  type NonFITCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NonFITFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NonFITCountAggregateInputType | true
    }

  export interface NonFITDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NonFIT'], meta: { name: 'NonFIT' } }
    /**
     * Find zero or one NonFIT that matches the filter.
     * @param {NonFITFindUniqueArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonFITFindUniqueArgs>(args: SelectSubset<T, NonFITFindUniqueArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NonFIT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NonFITFindUniqueOrThrowArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonFITFindUniqueOrThrowArgs>(args: SelectSubset<T, NonFITFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NonFIT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindFirstArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonFITFindFirstArgs>(args?: SelectSubset<T, NonFITFindFirstArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NonFIT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindFirstOrThrowArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonFITFindFirstOrThrowArgs>(args?: SelectSubset<T, NonFITFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NonFITS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NonFITS
     * const nonFITS = await prisma.nonFIT.findMany()
     * 
     * // Get first 10 NonFITS
     * const nonFITS = await prisma.nonFIT.findMany({ take: 10 })
     * 
     * // Only select the `IdNonFIT`
     * const nonFITWithIdNonFITOnly = await prisma.nonFIT.findMany({ select: { IdNonFIT: true } })
     * 
     */
    findMany<T extends NonFITFindManyArgs>(args?: SelectSubset<T, NonFITFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NonFIT.
     * @param {NonFITCreateArgs} args - Arguments to create a NonFIT.
     * @example
     * // Create one NonFIT
     * const NonFIT = await prisma.nonFIT.create({
     *   data: {
     *     // ... data to create a NonFIT
     *   }
     * })
     * 
     */
    create<T extends NonFITCreateArgs>(args: SelectSubset<T, NonFITCreateArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NonFITS.
     * @param {NonFITCreateManyArgs} args - Arguments to create many NonFITS.
     * @example
     * // Create many NonFITS
     * const nonFIT = await prisma.nonFIT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonFITCreateManyArgs>(args?: SelectSubset<T, NonFITCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NonFIT.
     * @param {NonFITDeleteArgs} args - Arguments to delete one NonFIT.
     * @example
     * // Delete one NonFIT
     * const NonFIT = await prisma.nonFIT.delete({
     *   where: {
     *     // ... filter to delete one NonFIT
     *   }
     * })
     * 
     */
    delete<T extends NonFITDeleteArgs>(args: SelectSubset<T, NonFITDeleteArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NonFIT.
     * @param {NonFITUpdateArgs} args - Arguments to update one NonFIT.
     * @example
     * // Update one NonFIT
     * const nonFIT = await prisma.nonFIT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonFITUpdateArgs>(args: SelectSubset<T, NonFITUpdateArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NonFITS.
     * @param {NonFITDeleteManyArgs} args - Arguments to filter NonFITS to delete.
     * @example
     * // Delete a few NonFITS
     * const { count } = await prisma.nonFIT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonFITDeleteManyArgs>(args?: SelectSubset<T, NonFITDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonFITS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NonFITS
     * const nonFIT = await prisma.nonFIT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonFITUpdateManyArgs>(args: SelectSubset<T, NonFITUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NonFIT.
     * @param {NonFITUpsertArgs} args - Arguments to update or create a NonFIT.
     * @example
     * // Update or create a NonFIT
     * const nonFIT = await prisma.nonFIT.upsert({
     *   create: {
     *     // ... data to create a NonFIT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NonFIT we want to update
     *   }
     * })
     */
    upsert<T extends NonFITUpsertArgs>(args: SelectSubset<T, NonFITUpsertArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NonFITS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITCountArgs} args - Arguments to filter NonFITS to count.
     * @example
     * // Count the number of NonFITS
     * const count = await prisma.nonFIT.count({
     *   where: {
     *     // ... the filter for the NonFITS we want to count
     *   }
     * })
    **/
    count<T extends NonFITCountArgs>(
      args?: Subset<T, NonFITCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonFITCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NonFIT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonFITAggregateArgs>(args: Subset<T, NonFITAggregateArgs>): Prisma.PrismaPromise<GetNonFITAggregateType<T>>

    /**
     * Group by NonFIT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonFITGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonFITGroupByArgs['orderBy'] }
        : { orderBy?: NonFITGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonFITGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonFITGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NonFIT model
   */
  readonly fields: NonFITFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NonFIT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonFITClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NonFIT model
   */ 
  interface NonFITFieldRefs {
    readonly IdNonFIT: FieldRef<"NonFIT", 'Int'>
    readonly FIdRanesh: FieldRef<"NonFIT", 'Int'>
    readonly FIdTarDor: FieldRef<"NonFIT", 'Int'>
    readonly VOLUM: FieldRef<"NonFIT", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NonFIT findUnique
   */
  export type NonFITFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT findUniqueOrThrow
   */
  export type NonFITFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT findFirst
   */
  export type NonFITFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonFITS.
     */
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT findFirstOrThrow
   */
  export type NonFITFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonFITS.
     */
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT findMany
   */
  export type NonFITFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter, which NonFITS to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT create
   */
  export type NonFITCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * The data needed to create a NonFIT.
     */
    data: XOR<NonFITCreateInput, NonFITUncheckedCreateInput>
  }

  /**
   * NonFIT createMany
   */
  export type NonFITCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NonFITS.
     */
    data: NonFITCreateManyInput | NonFITCreateManyInput[]
  }

  /**
   * NonFIT update
   */
  export type NonFITUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * The data needed to update a NonFIT.
     */
    data: XOR<NonFITUpdateInput, NonFITUncheckedUpdateInput>
    /**
     * Choose, which NonFIT to update.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT updateMany
   */
  export type NonFITUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NonFITS.
     */
    data: XOR<NonFITUpdateManyMutationInput, NonFITUncheckedUpdateManyInput>
    /**
     * Filter which NonFITS to update
     */
    where?: NonFITWhereInput
    /**
     * Limit how many NonFITS to update.
     */
    limit?: number
  }

  /**
   * NonFIT upsert
   */
  export type NonFITUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * The filter to search for the NonFIT to update in case it exists.
     */
    where: NonFITWhereUniqueInput
    /**
     * In case the NonFIT found by the `where` argument doesn't exist, create a new NonFIT with this data.
     */
    create: XOR<NonFITCreateInput, NonFITUncheckedCreateInput>
    /**
     * In case the NonFIT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonFITUpdateInput, NonFITUncheckedUpdateInput>
  }

  /**
   * NonFIT delete
   */
  export type NonFITDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    /**
     * Filter which NonFIT to delete.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT deleteMany
   */
  export type NonFITDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonFITS to delete
     */
    where?: NonFITWhereInput
    /**
     * Limit how many NonFITS to delete.
     */
    limit?: number
  }

  /**
   * NonFIT without action
   */
  export type NonFITDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
  }


  /**
   * Model PumpStation
   */

  export type AggregatePumpStation = {
    _count: PumpStationCountAggregateOutputType | null
    _avg: PumpStationAvgAggregateOutputType | null
    _sum: PumpStationSumAggregateOutputType | null
    _min: PumpStationMinAggregateOutputType | null
    _max: PumpStationMaxAggregateOutputType | null
  }

  export type PumpStationAvgAggregateOutputType = {
    IdPumpSta: number | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
    FIdDP: number | null
  }

  export type PumpStationSumAggregateOutputType = {
    IdPumpSta: number | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
    FIdDP: number | null
  }

  export type PumpStationMinAggregateOutputType = {
    IdPumpSta: number | null
    NameStation: string | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
    FIdDP: number | null
    Ready: boolean | null
  }

  export type PumpStationMaxAggregateOutputType = {
    IdPumpSta: number | null
    NameStation: string | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
    FIdDP: number | null
    Ready: boolean | null
  }

  export type PumpStationCountAggregateOutputType = {
    IdPumpSta: number
    NameStation: number
    KM: number
    FIdNet: number
    FIdDStation: number
    FIdMakhzan: number
    FIdDP: number
    Ready: number
    _all: number
  }


  export type PumpStationAvgAggregateInputType = {
    IdPumpSta?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    FIdDP?: true
  }

  export type PumpStationSumAggregateInputType = {
    IdPumpSta?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    FIdDP?: true
  }

  export type PumpStationMinAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    FIdDP?: true
    Ready?: true
  }

  export type PumpStationMaxAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    FIdDP?: true
    Ready?: true
  }

  export type PumpStationCountAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    FIdDP?: true
    Ready?: true
    _all?: true
  }

  export type PumpStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpStation to aggregate.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PumpStations
    **/
    _count?: true | PumpStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PumpStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PumpStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PumpStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PumpStationMaxAggregateInputType
  }

  export type GetPumpStationAggregateType<T extends PumpStationAggregateArgs> = {
        [P in keyof T & keyof AggregatePumpStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePumpStation[P]>
      : GetScalarType<T[P], AggregatePumpStation[P]>
  }




  export type PumpStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithAggregationInput | PumpStationOrderByWithAggregationInput[]
    by: PumpStationScalarFieldEnum[] | PumpStationScalarFieldEnum
    having?: PumpStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PumpStationCountAggregateInputType | true
    _avg?: PumpStationAvgAggregateInputType
    _sum?: PumpStationSumAggregateInputType
    _min?: PumpStationMinAggregateInputType
    _max?: PumpStationMaxAggregateInputType
  }

  export type PumpStationGroupByOutputType = {
    IdPumpSta: number
    NameStation: string
    KM: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan: number | null
    FIdDP: number
    Ready: boolean
    _count: PumpStationCountAggregateOutputType | null
    _avg: PumpStationAvgAggregateOutputType | null
    _sum: PumpStationSumAggregateOutputType | null
    _min: PumpStationMinAggregateOutputType | null
    _max: PumpStationMaxAggregateOutputType | null
  }

  type GetPumpStationGroupByPayload<T extends PumpStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PumpStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PumpStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PumpStationGroupByOutputType[P]>
            : GetScalarType<T[P], PumpStationGroupByOutputType[P]>
        }
      >
    >


  export type PumpStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPumpSta?: boolean
    NameStation?: boolean
    KM?: boolean
    FIdNet?: boolean
    FIdDStation?: boolean
    FIdMakhzan?: boolean
    FIdDP?: boolean
    Ready?: boolean
    KhatRanesh?: boolean | PumpStation$KhatRaneshArgs<ExtArgs>
    AbadeMakhzan?: boolean | PumpStation$AbadeMakhzanArgs<ExtArgs>
    DarjeStation?: boolean | DarjeStationDefaultArgs<ExtArgs>
    DeliveryPoint?: boolean | DeliveryPointsDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
    _count?: boolean | PumpStationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pumpStation"]>



  export type PumpStationSelectScalar = {
    IdPumpSta?: boolean
    NameStation?: boolean
    KM?: boolean
    FIdNet?: boolean
    FIdDStation?: boolean
    FIdMakhzan?: boolean
    FIdDP?: boolean
    Ready?: boolean
  }

  export type PumpStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdPumpSta" | "NameStation" | "KM" | "FIdNet" | "FIdDStation" | "FIdMakhzan" | "FIdDP" | "Ready", ExtArgs["result"]["pumpStation"]>
  export type PumpStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | PumpStation$KhatRaneshArgs<ExtArgs>
    AbadeMakhzan?: boolean | PumpStation$AbadeMakhzanArgs<ExtArgs>
    DarjeStation?: boolean | DarjeStationDefaultArgs<ExtArgs>
    DeliveryPoint?: boolean | DeliveryPointsDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
    _count?: boolean | PumpStationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PumpStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PumpStation"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>[]
      AbadeMakhzan: Prisma.$AbadeMakhzanPayload<ExtArgs> | null
      DarjeStation: Prisma.$DarjeStationPayload<ExtArgs>
      DeliveryPoint: Prisma.$DeliveryPointsPayload<ExtArgs>
      Network: Prisma.$NetworkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdPumpSta: number
      NameStation: string
      KM: number | null
      FIdNet: number
      FIdDStation: number
      FIdMakhzan: number | null
      FIdDP: number
      Ready: boolean
    }, ExtArgs["result"]["pumpStation"]>
    composites: {}
  }

  type PumpStationGetPayload<S extends boolean | null | undefined | PumpStationDefaultArgs> = $Result.GetResult<Prisma.$PumpStationPayload, S>

  type PumpStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PumpStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PumpStationCountAggregateInputType | true
    }

  export interface PumpStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PumpStation'], meta: { name: 'PumpStation' } }
    /**
     * Find zero or one PumpStation that matches the filter.
     * @param {PumpStationFindUniqueArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PumpStationFindUniqueArgs>(args: SelectSubset<T, PumpStationFindUniqueArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PumpStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PumpStationFindUniqueOrThrowArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PumpStationFindUniqueOrThrowArgs>(args: SelectSubset<T, PumpStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PumpStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindFirstArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PumpStationFindFirstArgs>(args?: SelectSubset<T, PumpStationFindFirstArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PumpStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindFirstOrThrowArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PumpStationFindFirstOrThrowArgs>(args?: SelectSubset<T, PumpStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PumpStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PumpStations
     * const pumpStations = await prisma.pumpStation.findMany()
     * 
     * // Get first 10 PumpStations
     * const pumpStations = await prisma.pumpStation.findMany({ take: 10 })
     * 
     * // Only select the `IdPumpSta`
     * const pumpStationWithIdPumpStaOnly = await prisma.pumpStation.findMany({ select: { IdPumpSta: true } })
     * 
     */
    findMany<T extends PumpStationFindManyArgs>(args?: SelectSubset<T, PumpStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PumpStation.
     * @param {PumpStationCreateArgs} args - Arguments to create a PumpStation.
     * @example
     * // Create one PumpStation
     * const PumpStation = await prisma.pumpStation.create({
     *   data: {
     *     // ... data to create a PumpStation
     *   }
     * })
     * 
     */
    create<T extends PumpStationCreateArgs>(args: SelectSubset<T, PumpStationCreateArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PumpStations.
     * @param {PumpStationCreateManyArgs} args - Arguments to create many PumpStations.
     * @example
     * // Create many PumpStations
     * const pumpStation = await prisma.pumpStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PumpStationCreateManyArgs>(args?: SelectSubset<T, PumpStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PumpStation.
     * @param {PumpStationDeleteArgs} args - Arguments to delete one PumpStation.
     * @example
     * // Delete one PumpStation
     * const PumpStation = await prisma.pumpStation.delete({
     *   where: {
     *     // ... filter to delete one PumpStation
     *   }
     * })
     * 
     */
    delete<T extends PumpStationDeleteArgs>(args: SelectSubset<T, PumpStationDeleteArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PumpStation.
     * @param {PumpStationUpdateArgs} args - Arguments to update one PumpStation.
     * @example
     * // Update one PumpStation
     * const pumpStation = await prisma.pumpStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PumpStationUpdateArgs>(args: SelectSubset<T, PumpStationUpdateArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PumpStations.
     * @param {PumpStationDeleteManyArgs} args - Arguments to filter PumpStations to delete.
     * @example
     * // Delete a few PumpStations
     * const { count } = await prisma.pumpStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PumpStationDeleteManyArgs>(args?: SelectSubset<T, PumpStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PumpStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PumpStations
     * const pumpStation = await prisma.pumpStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PumpStationUpdateManyArgs>(args: SelectSubset<T, PumpStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PumpStation.
     * @param {PumpStationUpsertArgs} args - Arguments to update or create a PumpStation.
     * @example
     * // Update or create a PumpStation
     * const pumpStation = await prisma.pumpStation.upsert({
     *   create: {
     *     // ... data to create a PumpStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PumpStation we want to update
     *   }
     * })
     */
    upsert<T extends PumpStationUpsertArgs>(args: SelectSubset<T, PumpStationUpsertArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PumpStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationCountArgs} args - Arguments to filter PumpStations to count.
     * @example
     * // Count the number of PumpStations
     * const count = await prisma.pumpStation.count({
     *   where: {
     *     // ... the filter for the PumpStations we want to count
     *   }
     * })
    **/
    count<T extends PumpStationCountArgs>(
      args?: Subset<T, PumpStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PumpStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PumpStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PumpStationAggregateArgs>(args: Subset<T, PumpStationAggregateArgs>): Prisma.PrismaPromise<GetPumpStationAggregateType<T>>

    /**
     * Group by PumpStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PumpStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PumpStationGroupByArgs['orderBy'] }
        : { orderBy?: PumpStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PumpStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPumpStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PumpStation model
   */
  readonly fields: PumpStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PumpStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PumpStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends PumpStation$KhatRaneshArgs<ExtArgs> = {}>(args?: Subset<T, PumpStation$KhatRaneshArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AbadeMakhzan<T extends PumpStation$AbadeMakhzanArgs<ExtArgs> = {}>(args?: Subset<T, PumpStation$AbadeMakhzanArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    DarjeStation<T extends DarjeStationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DarjeStationDefaultArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DeliveryPoint<T extends DeliveryPointsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPointsDefaultArgs<ExtArgs>>): Prisma__DeliveryPointsClient<$Result.GetResult<Prisma.$DeliveryPointsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Network<T extends NetworkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDefaultArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PumpStation model
   */ 
  interface PumpStationFieldRefs {
    readonly IdPumpSta: FieldRef<"PumpStation", 'Int'>
    readonly NameStation: FieldRef<"PumpStation", 'String'>
    readonly KM: FieldRef<"PumpStation", 'Int'>
    readonly FIdNet: FieldRef<"PumpStation", 'Int'>
    readonly FIdDStation: FieldRef<"PumpStation", 'Int'>
    readonly FIdMakhzan: FieldRef<"PumpStation", 'Int'>
    readonly FIdDP: FieldRef<"PumpStation", 'Int'>
    readonly Ready: FieldRef<"PumpStation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PumpStation findUnique
   */
  export type PumpStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation findUniqueOrThrow
   */
  export type PumpStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation findFirst
   */
  export type PumpStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpStations.
     */
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation findFirstOrThrow
   */
  export type PumpStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpStations.
     */
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation findMany
   */
  export type PumpStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter, which PumpStations to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation create
   */
  export type PumpStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * The data needed to create a PumpStation.
     */
    data: XOR<PumpStationCreateInput, PumpStationUncheckedCreateInput>
  }

  /**
   * PumpStation createMany
   */
  export type PumpStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PumpStations.
     */
    data: PumpStationCreateManyInput | PumpStationCreateManyInput[]
  }

  /**
   * PumpStation update
   */
  export type PumpStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * The data needed to update a PumpStation.
     */
    data: XOR<PumpStationUpdateInput, PumpStationUncheckedUpdateInput>
    /**
     * Choose, which PumpStation to update.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation updateMany
   */
  export type PumpStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PumpStations.
     */
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyInput>
    /**
     * Filter which PumpStations to update
     */
    where?: PumpStationWhereInput
    /**
     * Limit how many PumpStations to update.
     */
    limit?: number
  }

  /**
   * PumpStation upsert
   */
  export type PumpStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * The filter to search for the PumpStation to update in case it exists.
     */
    where: PumpStationWhereUniqueInput
    /**
     * In case the PumpStation found by the `where` argument doesn't exist, create a new PumpStation with this data.
     */
    create: XOR<PumpStationCreateInput, PumpStationUncheckedCreateInput>
    /**
     * In case the PumpStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PumpStationUpdateInput, PumpStationUncheckedUpdateInput>
  }

  /**
   * PumpStation delete
   */
  export type PumpStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
    /**
     * Filter which PumpStation to delete.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation deleteMany
   */
  export type PumpStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpStations to delete
     */
    where?: PumpStationWhereInput
    /**
     * Limit how many PumpStations to delete.
     */
    limit?: number
  }

  /**
   * PumpStation.KhatRanesh
   */
  export type PumpStation$KhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    cursor?: KhatRaneshWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * PumpStation.AbadeMakhzan
   */
  export type PumpStation$AbadeMakhzanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbadeMakhzanInclude<ExtArgs> | null
    where?: AbadeMakhzanWhereInput
  }

  /**
   * PumpStation without action
   */
  export type PumpStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpStationInclude<ExtArgs> | null
  }


  /**
   * Model PumpType
   */

  export type AggregatePumpType = {
    _count: PumpTypeCountAggregateOutputType | null
    _avg: PumpTypeAvgAggregateOutputType | null
    _sum: PumpTypeSumAggregateOutputType | null
    _min: PumpTypeMinAggregateOutputType | null
    _max: PumpTypeMaxAggregateOutputType | null
  }

  export type PumpTypeAvgAggregateOutputType = {
    IdPump: number | null
  }

  export type PumpTypeSumAggregateOutputType = {
    IdPump: number | null
  }

  export type PumpTypeMinAggregateOutputType = {
    IdPump: number | null
    PumpType: string | null
  }

  export type PumpTypeMaxAggregateOutputType = {
    IdPump: number | null
    PumpType: string | null
  }

  export type PumpTypeCountAggregateOutputType = {
    IdPump: number
    PumpType: number
    _all: number
  }


  export type PumpTypeAvgAggregateInputType = {
    IdPump?: true
  }

  export type PumpTypeSumAggregateInputType = {
    IdPump?: true
  }

  export type PumpTypeMinAggregateInputType = {
    IdPump?: true
    PumpType?: true
  }

  export type PumpTypeMaxAggregateInputType = {
    IdPump?: true
    PumpType?: true
  }

  export type PumpTypeCountAggregateInputType = {
    IdPump?: true
    PumpType?: true
    _all?: true
  }

  export type PumpTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpType to aggregate.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PumpTypes
    **/
    _count?: true | PumpTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PumpTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PumpTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PumpTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PumpTypeMaxAggregateInputType
  }

  export type GetPumpTypeAggregateType<T extends PumpTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePumpType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePumpType[P]>
      : GetScalarType<T[P], AggregatePumpType[P]>
  }




  export type PumpTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpTypeWhereInput
    orderBy?: PumpTypeOrderByWithAggregationInput | PumpTypeOrderByWithAggregationInput[]
    by: PumpTypeScalarFieldEnum[] | PumpTypeScalarFieldEnum
    having?: PumpTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PumpTypeCountAggregateInputType | true
    _avg?: PumpTypeAvgAggregateInputType
    _sum?: PumpTypeSumAggregateInputType
    _min?: PumpTypeMinAggregateInputType
    _max?: PumpTypeMaxAggregateInputType
  }

  export type PumpTypeGroupByOutputType = {
    IdPump: number
    PumpType: string
    _count: PumpTypeCountAggregateOutputType | null
    _avg: PumpTypeAvgAggregateOutputType | null
    _sum: PumpTypeSumAggregateOutputType | null
    _min: PumpTypeMinAggregateOutputType | null
    _max: PumpTypeMaxAggregateOutputType | null
  }

  type GetPumpTypeGroupByPayload<T extends PumpTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PumpTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PumpTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PumpTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PumpTypeGroupByOutputType[P]>
        }
      >
    >


  export type PumpTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPump?: boolean
    PumpType?: boolean
    KhatRaneshPump?: boolean | PumpType$KhatRaneshPumpArgs<ExtArgs>
    _count?: boolean | PumpTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pumpType"]>



  export type PumpTypeSelectScalar = {
    IdPump?: boolean
    PumpType?: boolean
  }

  export type PumpTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdPump" | "PumpType", ExtArgs["result"]["pumpType"]>
  export type PumpTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRaneshPump?: boolean | PumpType$KhatRaneshPumpArgs<ExtArgs>
    _count?: boolean | PumpTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PumpTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PumpType"
    objects: {
      KhatRaneshPump: Prisma.$KhatRaneshPumpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdPump: number
      PumpType: string
    }, ExtArgs["result"]["pumpType"]>
    composites: {}
  }

  type PumpTypeGetPayload<S extends boolean | null | undefined | PumpTypeDefaultArgs> = $Result.GetResult<Prisma.$PumpTypePayload, S>

  type PumpTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PumpTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PumpTypeCountAggregateInputType | true
    }

  export interface PumpTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PumpType'], meta: { name: 'PumpType' } }
    /**
     * Find zero or one PumpType that matches the filter.
     * @param {PumpTypeFindUniqueArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PumpTypeFindUniqueArgs>(args: SelectSubset<T, PumpTypeFindUniqueArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PumpType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PumpTypeFindUniqueOrThrowArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PumpTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PumpTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PumpType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindFirstArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PumpTypeFindFirstArgs>(args?: SelectSubset<T, PumpTypeFindFirstArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PumpType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindFirstOrThrowArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PumpTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PumpTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PumpTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PumpTypes
     * const pumpTypes = await prisma.pumpType.findMany()
     * 
     * // Get first 10 PumpTypes
     * const pumpTypes = await prisma.pumpType.findMany({ take: 10 })
     * 
     * // Only select the `IdPump`
     * const pumpTypeWithIdPumpOnly = await prisma.pumpType.findMany({ select: { IdPump: true } })
     * 
     */
    findMany<T extends PumpTypeFindManyArgs>(args?: SelectSubset<T, PumpTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PumpType.
     * @param {PumpTypeCreateArgs} args - Arguments to create a PumpType.
     * @example
     * // Create one PumpType
     * const PumpType = await prisma.pumpType.create({
     *   data: {
     *     // ... data to create a PumpType
     *   }
     * })
     * 
     */
    create<T extends PumpTypeCreateArgs>(args: SelectSubset<T, PumpTypeCreateArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PumpTypes.
     * @param {PumpTypeCreateManyArgs} args - Arguments to create many PumpTypes.
     * @example
     * // Create many PumpTypes
     * const pumpType = await prisma.pumpType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PumpTypeCreateManyArgs>(args?: SelectSubset<T, PumpTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PumpType.
     * @param {PumpTypeDeleteArgs} args - Arguments to delete one PumpType.
     * @example
     * // Delete one PumpType
     * const PumpType = await prisma.pumpType.delete({
     *   where: {
     *     // ... filter to delete one PumpType
     *   }
     * })
     * 
     */
    delete<T extends PumpTypeDeleteArgs>(args: SelectSubset<T, PumpTypeDeleteArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PumpType.
     * @param {PumpTypeUpdateArgs} args - Arguments to update one PumpType.
     * @example
     * // Update one PumpType
     * const pumpType = await prisma.pumpType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PumpTypeUpdateArgs>(args: SelectSubset<T, PumpTypeUpdateArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PumpTypes.
     * @param {PumpTypeDeleteManyArgs} args - Arguments to filter PumpTypes to delete.
     * @example
     * // Delete a few PumpTypes
     * const { count } = await prisma.pumpType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PumpTypeDeleteManyArgs>(args?: SelectSubset<T, PumpTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PumpTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PumpTypes
     * const pumpType = await prisma.pumpType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PumpTypeUpdateManyArgs>(args: SelectSubset<T, PumpTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PumpType.
     * @param {PumpTypeUpsertArgs} args - Arguments to update or create a PumpType.
     * @example
     * // Update or create a PumpType
     * const pumpType = await prisma.pumpType.upsert({
     *   create: {
     *     // ... data to create a PumpType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PumpType we want to update
     *   }
     * })
     */
    upsert<T extends PumpTypeUpsertArgs>(args: SelectSubset<T, PumpTypeUpsertArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PumpTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeCountArgs} args - Arguments to filter PumpTypes to count.
     * @example
     * // Count the number of PumpTypes
     * const count = await prisma.pumpType.count({
     *   where: {
     *     // ... the filter for the PumpTypes we want to count
     *   }
     * })
    **/
    count<T extends PumpTypeCountArgs>(
      args?: Subset<T, PumpTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PumpTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PumpType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PumpTypeAggregateArgs>(args: Subset<T, PumpTypeAggregateArgs>): Prisma.PrismaPromise<GetPumpTypeAggregateType<T>>

    /**
     * Group by PumpType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PumpTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PumpTypeGroupByArgs['orderBy'] }
        : { orderBy?: PumpTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PumpTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPumpTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PumpType model
   */
  readonly fields: PumpTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PumpType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PumpTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRaneshPump<T extends PumpType$KhatRaneshPumpArgs<ExtArgs> = {}>(args?: Subset<T, PumpType$KhatRaneshPumpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PumpType model
   */ 
  interface PumpTypeFieldRefs {
    readonly IdPump: FieldRef<"PumpType", 'Int'>
    readonly PumpType: FieldRef<"PumpType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PumpType findUnique
   */
  export type PumpTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType findUniqueOrThrow
   */
  export type PumpTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType findFirst
   */
  export type PumpTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpTypes.
     */
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType findFirstOrThrow
   */
  export type PumpTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpTypes.
     */
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType findMany
   */
  export type PumpTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter, which PumpTypes to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType create
   */
  export type PumpTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PumpType.
     */
    data: XOR<PumpTypeCreateInput, PumpTypeUncheckedCreateInput>
  }

  /**
   * PumpType createMany
   */
  export type PumpTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PumpTypes.
     */
    data: PumpTypeCreateManyInput | PumpTypeCreateManyInput[]
  }

  /**
   * PumpType update
   */
  export type PumpTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PumpType.
     */
    data: XOR<PumpTypeUpdateInput, PumpTypeUncheckedUpdateInput>
    /**
     * Choose, which PumpType to update.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType updateMany
   */
  export type PumpTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PumpTypes.
     */
    data: XOR<PumpTypeUpdateManyMutationInput, PumpTypeUncheckedUpdateManyInput>
    /**
     * Filter which PumpTypes to update
     */
    where?: PumpTypeWhereInput
    /**
     * Limit how many PumpTypes to update.
     */
    limit?: number
  }

  /**
   * PumpType upsert
   */
  export type PumpTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PumpType to update in case it exists.
     */
    where: PumpTypeWhereUniqueInput
    /**
     * In case the PumpType found by the `where` argument doesn't exist, create a new PumpType with this data.
     */
    create: XOR<PumpTypeCreateInput, PumpTypeUncheckedCreateInput>
    /**
     * In case the PumpType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PumpTypeUpdateInput, PumpTypeUncheckedUpdateInput>
  }

  /**
   * PumpType delete
   */
  export type PumpTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
    /**
     * Filter which PumpType to delete.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType deleteMany
   */
  export type PumpTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpTypes to delete
     */
    where?: PumpTypeWhereInput
    /**
     * Limit how many PumpTypes to delete.
     */
    limit?: number
  }

  /**
   * PumpType.KhatRaneshPump
   */
  export type PumpType$KhatRaneshPumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshPumpInclude<ExtArgs> | null
    where?: KhatRaneshPumpWhereInput
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    cursor?: KhatRaneshPumpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * PumpType without action
   */
  export type PumpTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PumpTypeInclude<ExtArgs> | null
  }


  /**
   * Model RainfallStation
   */

  export type AggregateRainfallStation = {
    _count: RainfallStationCountAggregateOutputType | null
    _avg: RainfallStationAvgAggregateOutputType | null
    _sum: RainfallStationSumAggregateOutputType | null
    _min: RainfallStationMinAggregateOutputType | null
    _max: RainfallStationMaxAggregateOutputType | null
  }

  export type RainfallStationAvgAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationSumAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationMinAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationMaxAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationCountAggregateOutputType = {
    IdRaiSta: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: number
    _all: number
  }


  export type RainfallStationAvgAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationSumAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationMinAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationMaxAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationCountAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
    _all?: true
  }

  export type RainfallStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallStation to aggregate.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainfallStations
    **/
    _count?: true | RainfallStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainfallStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainfallStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainfallStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainfallStationMaxAggregateInputType
  }

  export type GetRainfallStationAggregateType<T extends RainfallStationAggregateArgs> = {
        [P in keyof T & keyof AggregateRainfallStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainfallStation[P]>
      : GetScalarType<T[P], AggregateRainfallStation[P]>
  }




  export type RainfallStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallStationWhereInput
    orderBy?: RainfallStationOrderByWithAggregationInput | RainfallStationOrderByWithAggregationInput[]
    by: RainfallStationScalarFieldEnum[] | RainfallStationScalarFieldEnum
    having?: RainfallStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainfallStationCountAggregateInputType | true
    _avg?: RainfallStationAvgAggregateInputType
    _sum?: RainfallStationSumAggregateInputType
    _min?: RainfallStationMinAggregateInputType
    _max?: RainfallStationMaxAggregateInputType
  }

  export type RainfallStationGroupByOutputType = {
    IdRaiSta: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal
    _count: RainfallStationCountAggregateOutputType | null
    _avg: RainfallStationAvgAggregateOutputType | null
    _sum: RainfallStationSumAggregateOutputType | null
    _min: RainfallStationMinAggregateOutputType | null
    _max: RainfallStationMaxAggregateOutputType | null
  }

  type GetRainfallStationGroupByPayload<T extends RainfallStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainfallStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainfallStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainfallStationGroupByOutputType[P]>
            : GetScalarType<T[P], RainfallStationGroupByOutputType[P]>
        }
      >
    >


  export type RainfallStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRaiSta?: boolean
    FIdWeaSta?: boolean
    FIdTrikh?: boolean
    FIdRaiTy?: boolean
    ErtefaeBaresh?: boolean
    RainfallType?: boolean | RainfallTypeDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
    WeatherStation?: boolean | WeatherStationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainfallStation"]>



  export type RainfallStationSelectScalar = {
    IdRaiSta?: boolean
    FIdWeaSta?: boolean
    FIdTrikh?: boolean
    FIdRaiTy?: boolean
    ErtefaeBaresh?: boolean
  }

  export type RainfallStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRaiSta" | "FIdWeaSta" | "FIdTrikh" | "FIdRaiTy" | "ErtefaeBaresh", ExtArgs["result"]["rainfallStation"]>
  export type RainfallStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainfallType?: boolean | RainfallTypeDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
    WeatherStation?: boolean | WeatherStationDefaultArgs<ExtArgs>
  }

  export type $RainfallStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainfallStation"
    objects: {
      RainfallType: Prisma.$RainfallTypePayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
      WeatherStation: Prisma.$WeatherStationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRaiSta: number
      FIdWeaSta: number
      FIdTrikh: number
      FIdRaiTy: number
      ErtefaeBaresh: Prisma.Decimal
    }, ExtArgs["result"]["rainfallStation"]>
    composites: {}
  }

  type RainfallStationGetPayload<S extends boolean | null | undefined | RainfallStationDefaultArgs> = $Result.GetResult<Prisma.$RainfallStationPayload, S>

  type RainfallStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainfallStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainfallStationCountAggregateInputType | true
    }

  export interface RainfallStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainfallStation'], meta: { name: 'RainfallStation' } }
    /**
     * Find zero or one RainfallStation that matches the filter.
     * @param {RainfallStationFindUniqueArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainfallStationFindUniqueArgs>(args: SelectSubset<T, RainfallStationFindUniqueArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RainfallStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainfallStationFindUniqueOrThrowArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainfallStationFindUniqueOrThrowArgs>(args: SelectSubset<T, RainfallStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindFirstArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainfallStationFindFirstArgs>(args?: SelectSubset<T, RainfallStationFindFirstArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindFirstOrThrowArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainfallStationFindFirstOrThrowArgs>(args?: SelectSubset<T, RainfallStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RainfallStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainfallStations
     * const rainfallStations = await prisma.rainfallStation.findMany()
     * 
     * // Get first 10 RainfallStations
     * const rainfallStations = await prisma.rainfallStation.findMany({ take: 10 })
     * 
     * // Only select the `IdRaiSta`
     * const rainfallStationWithIdRaiStaOnly = await prisma.rainfallStation.findMany({ select: { IdRaiSta: true } })
     * 
     */
    findMany<T extends RainfallStationFindManyArgs>(args?: SelectSubset<T, RainfallStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RainfallStation.
     * @param {RainfallStationCreateArgs} args - Arguments to create a RainfallStation.
     * @example
     * // Create one RainfallStation
     * const RainfallStation = await prisma.rainfallStation.create({
     *   data: {
     *     // ... data to create a RainfallStation
     *   }
     * })
     * 
     */
    create<T extends RainfallStationCreateArgs>(args: SelectSubset<T, RainfallStationCreateArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RainfallStations.
     * @param {RainfallStationCreateManyArgs} args - Arguments to create many RainfallStations.
     * @example
     * // Create many RainfallStations
     * const rainfallStation = await prisma.rainfallStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainfallStationCreateManyArgs>(args?: SelectSubset<T, RainfallStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RainfallStation.
     * @param {RainfallStationDeleteArgs} args - Arguments to delete one RainfallStation.
     * @example
     * // Delete one RainfallStation
     * const RainfallStation = await prisma.rainfallStation.delete({
     *   where: {
     *     // ... filter to delete one RainfallStation
     *   }
     * })
     * 
     */
    delete<T extends RainfallStationDeleteArgs>(args: SelectSubset<T, RainfallStationDeleteArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RainfallStation.
     * @param {RainfallStationUpdateArgs} args - Arguments to update one RainfallStation.
     * @example
     * // Update one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainfallStationUpdateArgs>(args: SelectSubset<T, RainfallStationUpdateArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RainfallStations.
     * @param {RainfallStationDeleteManyArgs} args - Arguments to filter RainfallStations to delete.
     * @example
     * // Delete a few RainfallStations
     * const { count } = await prisma.rainfallStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainfallStationDeleteManyArgs>(args?: SelectSubset<T, RainfallStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainfallStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainfallStations
     * const rainfallStation = await prisma.rainfallStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainfallStationUpdateManyArgs>(args: SelectSubset<T, RainfallStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainfallStation.
     * @param {RainfallStationUpsertArgs} args - Arguments to update or create a RainfallStation.
     * @example
     * // Update or create a RainfallStation
     * const rainfallStation = await prisma.rainfallStation.upsert({
     *   create: {
     *     // ... data to create a RainfallStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainfallStation we want to update
     *   }
     * })
     */
    upsert<T extends RainfallStationUpsertArgs>(args: SelectSubset<T, RainfallStationUpsertArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RainfallStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationCountArgs} args - Arguments to filter RainfallStations to count.
     * @example
     * // Count the number of RainfallStations
     * const count = await prisma.rainfallStation.count({
     *   where: {
     *     // ... the filter for the RainfallStations we want to count
     *   }
     * })
    **/
    count<T extends RainfallStationCountArgs>(
      args?: Subset<T, RainfallStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainfallStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainfallStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainfallStationAggregateArgs>(args: Subset<T, RainfallStationAggregateArgs>): Prisma.PrismaPromise<GetRainfallStationAggregateType<T>>

    /**
     * Group by RainfallStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainfallStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainfallStationGroupByArgs['orderBy'] }
        : { orderBy?: RainfallStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainfallStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainfallStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainfallStation model
   */
  readonly fields: RainfallStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainfallStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainfallStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainfallType<T extends RainfallTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainfallTypeDefaultArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    WeatherStation<T extends WeatherStationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeatherStationDefaultArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainfallStation model
   */ 
  interface RainfallStationFieldRefs {
    readonly IdRaiSta: FieldRef<"RainfallStation", 'Int'>
    readonly FIdWeaSta: FieldRef<"RainfallStation", 'Int'>
    readonly FIdTrikh: FieldRef<"RainfallStation", 'Int'>
    readonly FIdRaiTy: FieldRef<"RainfallStation", 'Int'>
    readonly ErtefaeBaresh: FieldRef<"RainfallStation", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * RainfallStation findUnique
   */
  export type RainfallStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation findUniqueOrThrow
   */
  export type RainfallStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation findFirst
   */
  export type RainfallStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallStations.
     */
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation findFirstOrThrow
   */
  export type RainfallStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallStations.
     */
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation findMany
   */
  export type RainfallStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter, which RainfallStations to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation create
   */
  export type RainfallStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * The data needed to create a RainfallStation.
     */
    data: XOR<RainfallStationCreateInput, RainfallStationUncheckedCreateInput>
  }

  /**
   * RainfallStation createMany
   */
  export type RainfallStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainfallStations.
     */
    data: RainfallStationCreateManyInput | RainfallStationCreateManyInput[]
  }

  /**
   * RainfallStation update
   */
  export type RainfallStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * The data needed to update a RainfallStation.
     */
    data: XOR<RainfallStationUpdateInput, RainfallStationUncheckedUpdateInput>
    /**
     * Choose, which RainfallStation to update.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation updateMany
   */
  export type RainfallStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainfallStations.
     */
    data: XOR<RainfallStationUpdateManyMutationInput, RainfallStationUncheckedUpdateManyInput>
    /**
     * Filter which RainfallStations to update
     */
    where?: RainfallStationWhereInput
    /**
     * Limit how many RainfallStations to update.
     */
    limit?: number
  }

  /**
   * RainfallStation upsert
   */
  export type RainfallStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * The filter to search for the RainfallStation to update in case it exists.
     */
    where: RainfallStationWhereUniqueInput
    /**
     * In case the RainfallStation found by the `where` argument doesn't exist, create a new RainfallStation with this data.
     */
    create: XOR<RainfallStationCreateInput, RainfallStationUncheckedCreateInput>
    /**
     * In case the RainfallStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainfallStationUpdateInput, RainfallStationUncheckedUpdateInput>
  }

  /**
   * RainfallStation delete
   */
  export type RainfallStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    /**
     * Filter which RainfallStation to delete.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation deleteMany
   */
  export type RainfallStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallStations to delete
     */
    where?: RainfallStationWhereInput
    /**
     * Limit how many RainfallStations to delete.
     */
    limit?: number
  }

  /**
   * RainfallStation without action
   */
  export type RainfallStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
  }


  /**
   * Model RainfallType
   */

  export type AggregateRainfallType = {
    _count: RainfallTypeCountAggregateOutputType | null
    _avg: RainfallTypeAvgAggregateOutputType | null
    _sum: RainfallTypeSumAggregateOutputType | null
    _min: RainfallTypeMinAggregateOutputType | null
    _max: RainfallTypeMaxAggregateOutputType | null
  }

  export type RainfallTypeAvgAggregateOutputType = {
    IdRaiTy: number | null
  }

  export type RainfallTypeSumAggregateOutputType = {
    IdRaiTy: number | null
  }

  export type RainfallTypeMinAggregateOutputType = {
    IdRaiTy: number | null
    RainfallType: string | null
  }

  export type RainfallTypeMaxAggregateOutputType = {
    IdRaiTy: number | null
    RainfallType: string | null
  }

  export type RainfallTypeCountAggregateOutputType = {
    IdRaiTy: number
    RainfallType: number
    _all: number
  }


  export type RainfallTypeAvgAggregateInputType = {
    IdRaiTy?: true
  }

  export type RainfallTypeSumAggregateInputType = {
    IdRaiTy?: true
  }

  export type RainfallTypeMinAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
  }

  export type RainfallTypeMaxAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
  }

  export type RainfallTypeCountAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
    _all?: true
  }

  export type RainfallTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallType to aggregate.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainfallTypes
    **/
    _count?: true | RainfallTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainfallTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainfallTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainfallTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainfallTypeMaxAggregateInputType
  }

  export type GetRainfallTypeAggregateType<T extends RainfallTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRainfallType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainfallType[P]>
      : GetScalarType<T[P], AggregateRainfallType[P]>
  }




  export type RainfallTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallTypeWhereInput
    orderBy?: RainfallTypeOrderByWithAggregationInput | RainfallTypeOrderByWithAggregationInput[]
    by: RainfallTypeScalarFieldEnum[] | RainfallTypeScalarFieldEnum
    having?: RainfallTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainfallTypeCountAggregateInputType | true
    _avg?: RainfallTypeAvgAggregateInputType
    _sum?: RainfallTypeSumAggregateInputType
    _min?: RainfallTypeMinAggregateInputType
    _max?: RainfallTypeMaxAggregateInputType
  }

  export type RainfallTypeGroupByOutputType = {
    IdRaiTy: number
    RainfallType: string
    _count: RainfallTypeCountAggregateOutputType | null
    _avg: RainfallTypeAvgAggregateOutputType | null
    _sum: RainfallTypeSumAggregateOutputType | null
    _min: RainfallTypeMinAggregateOutputType | null
    _max: RainfallTypeMaxAggregateOutputType | null
  }

  type GetRainfallTypeGroupByPayload<T extends RainfallTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainfallTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainfallTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainfallTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RainfallTypeGroupByOutputType[P]>
        }
      >
    >


  export type RainfallTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRaiTy?: boolean
    RainfallType?: boolean
    RainfallStation?: boolean | RainfallType$RainfallStationArgs<ExtArgs>
    _count?: boolean | RainfallTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainfallType"]>



  export type RainfallTypeSelectScalar = {
    IdRaiTy?: boolean
    RainfallType?: boolean
  }

  export type RainfallTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRaiTy" | "RainfallType", ExtArgs["result"]["rainfallType"]>
  export type RainfallTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainfallStation?: boolean | RainfallType$RainfallStationArgs<ExtArgs>
    _count?: boolean | RainfallTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RainfallTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainfallType"
    objects: {
      RainfallStation: Prisma.$RainfallStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdRaiTy: number
      RainfallType: string
    }, ExtArgs["result"]["rainfallType"]>
    composites: {}
  }

  type RainfallTypeGetPayload<S extends boolean | null | undefined | RainfallTypeDefaultArgs> = $Result.GetResult<Prisma.$RainfallTypePayload, S>

  type RainfallTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainfallTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainfallTypeCountAggregateInputType | true
    }

  export interface RainfallTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainfallType'], meta: { name: 'RainfallType' } }
    /**
     * Find zero or one RainfallType that matches the filter.
     * @param {RainfallTypeFindUniqueArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainfallTypeFindUniqueArgs>(args: SelectSubset<T, RainfallTypeFindUniqueArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RainfallType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainfallTypeFindUniqueOrThrowArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainfallTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RainfallTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindFirstArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainfallTypeFindFirstArgs>(args?: SelectSubset<T, RainfallTypeFindFirstArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindFirstOrThrowArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainfallTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RainfallTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RainfallTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainfallTypes
     * const rainfallTypes = await prisma.rainfallType.findMany()
     * 
     * // Get first 10 RainfallTypes
     * const rainfallTypes = await prisma.rainfallType.findMany({ take: 10 })
     * 
     * // Only select the `IdRaiTy`
     * const rainfallTypeWithIdRaiTyOnly = await prisma.rainfallType.findMany({ select: { IdRaiTy: true } })
     * 
     */
    findMany<T extends RainfallTypeFindManyArgs>(args?: SelectSubset<T, RainfallTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RainfallType.
     * @param {RainfallTypeCreateArgs} args - Arguments to create a RainfallType.
     * @example
     * // Create one RainfallType
     * const RainfallType = await prisma.rainfallType.create({
     *   data: {
     *     // ... data to create a RainfallType
     *   }
     * })
     * 
     */
    create<T extends RainfallTypeCreateArgs>(args: SelectSubset<T, RainfallTypeCreateArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RainfallTypes.
     * @param {RainfallTypeCreateManyArgs} args - Arguments to create many RainfallTypes.
     * @example
     * // Create many RainfallTypes
     * const rainfallType = await prisma.rainfallType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainfallTypeCreateManyArgs>(args?: SelectSubset<T, RainfallTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RainfallType.
     * @param {RainfallTypeDeleteArgs} args - Arguments to delete one RainfallType.
     * @example
     * // Delete one RainfallType
     * const RainfallType = await prisma.rainfallType.delete({
     *   where: {
     *     // ... filter to delete one RainfallType
     *   }
     * })
     * 
     */
    delete<T extends RainfallTypeDeleteArgs>(args: SelectSubset<T, RainfallTypeDeleteArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RainfallType.
     * @param {RainfallTypeUpdateArgs} args - Arguments to update one RainfallType.
     * @example
     * // Update one RainfallType
     * const rainfallType = await prisma.rainfallType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainfallTypeUpdateArgs>(args: SelectSubset<T, RainfallTypeUpdateArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RainfallTypes.
     * @param {RainfallTypeDeleteManyArgs} args - Arguments to filter RainfallTypes to delete.
     * @example
     * // Delete a few RainfallTypes
     * const { count } = await prisma.rainfallType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainfallTypeDeleteManyArgs>(args?: SelectSubset<T, RainfallTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainfallTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainfallTypes
     * const rainfallType = await prisma.rainfallType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainfallTypeUpdateManyArgs>(args: SelectSubset<T, RainfallTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainfallType.
     * @param {RainfallTypeUpsertArgs} args - Arguments to update or create a RainfallType.
     * @example
     * // Update or create a RainfallType
     * const rainfallType = await prisma.rainfallType.upsert({
     *   create: {
     *     // ... data to create a RainfallType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainfallType we want to update
     *   }
     * })
     */
    upsert<T extends RainfallTypeUpsertArgs>(args: SelectSubset<T, RainfallTypeUpsertArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RainfallTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeCountArgs} args - Arguments to filter RainfallTypes to count.
     * @example
     * // Count the number of RainfallTypes
     * const count = await prisma.rainfallType.count({
     *   where: {
     *     // ... the filter for the RainfallTypes we want to count
     *   }
     * })
    **/
    count<T extends RainfallTypeCountArgs>(
      args?: Subset<T, RainfallTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainfallTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainfallType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainfallTypeAggregateArgs>(args: Subset<T, RainfallTypeAggregateArgs>): Prisma.PrismaPromise<GetRainfallTypeAggregateType<T>>

    /**
     * Group by RainfallType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainfallTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainfallTypeGroupByArgs['orderBy'] }
        : { orderBy?: RainfallTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainfallTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainfallTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainfallType model
   */
  readonly fields: RainfallTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainfallType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainfallTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainfallStation<T extends RainfallType$RainfallStationArgs<ExtArgs> = {}>(args?: Subset<T, RainfallType$RainfallStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainfallType model
   */ 
  interface RainfallTypeFieldRefs {
    readonly IdRaiTy: FieldRef<"RainfallType", 'Int'>
    readonly RainfallType: FieldRef<"RainfallType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RainfallType findUnique
   */
  export type RainfallTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType findUniqueOrThrow
   */
  export type RainfallTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType findFirst
   */
  export type RainfallTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallTypes.
     */
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType findFirstOrThrow
   */
  export type RainfallTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallTypes.
     */
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType findMany
   */
  export type RainfallTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter, which RainfallTypes to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType create
   */
  export type RainfallTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RainfallType.
     */
    data: XOR<RainfallTypeCreateInput, RainfallTypeUncheckedCreateInput>
  }

  /**
   * RainfallType createMany
   */
  export type RainfallTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainfallTypes.
     */
    data: RainfallTypeCreateManyInput | RainfallTypeCreateManyInput[]
  }

  /**
   * RainfallType update
   */
  export type RainfallTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RainfallType.
     */
    data: XOR<RainfallTypeUpdateInput, RainfallTypeUncheckedUpdateInput>
    /**
     * Choose, which RainfallType to update.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType updateMany
   */
  export type RainfallTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainfallTypes.
     */
    data: XOR<RainfallTypeUpdateManyMutationInput, RainfallTypeUncheckedUpdateManyInput>
    /**
     * Filter which RainfallTypes to update
     */
    where?: RainfallTypeWhereInput
    /**
     * Limit how many RainfallTypes to update.
     */
    limit?: number
  }

  /**
   * RainfallType upsert
   */
  export type RainfallTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RainfallType to update in case it exists.
     */
    where: RainfallTypeWhereUniqueInput
    /**
     * In case the RainfallType found by the `where` argument doesn't exist, create a new RainfallType with this data.
     */
    create: XOR<RainfallTypeCreateInput, RainfallTypeUncheckedCreateInput>
    /**
     * In case the RainfallType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainfallTypeUpdateInput, RainfallTypeUncheckedUpdateInput>
  }

  /**
   * RainfallType delete
   */
  export type RainfallTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
    /**
     * Filter which RainfallType to delete.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType deleteMany
   */
  export type RainfallTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallTypes to delete
     */
    where?: RainfallTypeWhereInput
    /**
     * Limit how many RainfallTypes to delete.
     */
    limit?: number
  }

  /**
   * RainfallType.RainfallStation
   */
  export type RainfallType$RainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    where?: RainfallStationWhereInput
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    cursor?: RainfallStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallType without action
   */
  export type RainfallTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallTypeInclude<ExtArgs> | null
  }


  /**
   * Model SaleZeraee
   */

  export type AggregateSaleZeraee = {
    _count: SaleZeraeeCountAggregateOutputType | null
    _avg: SaleZeraeeAvgAggregateOutputType | null
    _sum: SaleZeraeeSumAggregateOutputType | null
    _min: SaleZeraeeMinAggregateOutputType | null
    _max: SaleZeraeeMaxAggregateOutputType | null
  }

  export type SaleZeraeeAvgAggregateOutputType = {
    IdSal: number | null
  }

  export type SaleZeraeeSumAggregateOutputType = {
    IdSal: number | null
  }

  export type SaleZeraeeMinAggregateOutputType = {
    IdSal: number | null
    SaleZeraee: string | null
  }

  export type SaleZeraeeMaxAggregateOutputType = {
    IdSal: number | null
    SaleZeraee: string | null
  }

  export type SaleZeraeeCountAggregateOutputType = {
    IdSal: number
    SaleZeraee: number
    _all: number
  }


  export type SaleZeraeeAvgAggregateInputType = {
    IdSal?: true
  }

  export type SaleZeraeeSumAggregateInputType = {
    IdSal?: true
  }

  export type SaleZeraeeMinAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
  }

  export type SaleZeraeeMaxAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
  }

  export type SaleZeraeeCountAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
    _all?: true
  }

  export type SaleZeraeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleZeraee to aggregate.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleZeraees
    **/
    _count?: true | SaleZeraeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleZeraeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleZeraeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleZeraeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleZeraeeMaxAggregateInputType
  }

  export type GetSaleZeraeeAggregateType<T extends SaleZeraeeAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleZeraee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleZeraee[P]>
      : GetScalarType<T[P], AggregateSaleZeraee[P]>
  }




  export type SaleZeraeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleZeraeeWhereInput
    orderBy?: SaleZeraeeOrderByWithAggregationInput | SaleZeraeeOrderByWithAggregationInput[]
    by: SaleZeraeeScalarFieldEnum[] | SaleZeraeeScalarFieldEnum
    having?: SaleZeraeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleZeraeeCountAggregateInputType | true
    _avg?: SaleZeraeeAvgAggregateInputType
    _sum?: SaleZeraeeSumAggregateInputType
    _min?: SaleZeraeeMinAggregateInputType
    _max?: SaleZeraeeMaxAggregateInputType
  }

  export type SaleZeraeeGroupByOutputType = {
    IdSal: number
    SaleZeraee: string
    _count: SaleZeraeeCountAggregateOutputType | null
    _avg: SaleZeraeeAvgAggregateOutputType | null
    _sum: SaleZeraeeSumAggregateOutputType | null
    _min: SaleZeraeeMinAggregateOutputType | null
    _max: SaleZeraeeMaxAggregateOutputType | null
  }

  type GetSaleZeraeeGroupByPayload<T extends SaleZeraeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleZeraeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleZeraeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleZeraeeGroupByOutputType[P]>
            : GetScalarType<T[P], SaleZeraeeGroupByOutputType[P]>
        }
      >
    >


  export type SaleZeraeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSal?: boolean
    SaleZeraee?: boolean
    ShabakeDoreKesht?: boolean | SaleZeraee$ShabakeDoreKeshtArgs<ExtArgs>
    TrikhDoreKesht?: boolean | SaleZeraee$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | SaleZeraeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleZeraee"]>



  export type SaleZeraeeSelectScalar = {
    IdSal?: boolean
    SaleZeraee?: boolean
  }

  export type SaleZeraeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSal" | "SaleZeraee", ExtArgs["result"]["saleZeraee"]>
  export type SaleZeraeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShabakeDoreKesht?: boolean | SaleZeraee$ShabakeDoreKeshtArgs<ExtArgs>
    TrikhDoreKesht?: boolean | SaleZeraee$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | SaleZeraeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SaleZeraeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleZeraee"
    objects: {
      ShabakeDoreKesht: Prisma.$ShabakeDoreKeshtPayload<ExtArgs>[]
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdSal: number
      SaleZeraee: string
    }, ExtArgs["result"]["saleZeraee"]>
    composites: {}
  }

  type SaleZeraeeGetPayload<S extends boolean | null | undefined | SaleZeraeeDefaultArgs> = $Result.GetResult<Prisma.$SaleZeraeePayload, S>

  type SaleZeraeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleZeraeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleZeraeeCountAggregateInputType | true
    }

  export interface SaleZeraeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleZeraee'], meta: { name: 'SaleZeraee' } }
    /**
     * Find zero or one SaleZeraee that matches the filter.
     * @param {SaleZeraeeFindUniqueArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleZeraeeFindUniqueArgs>(args: SelectSubset<T, SaleZeraeeFindUniqueArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SaleZeraee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleZeraeeFindUniqueOrThrowArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleZeraeeFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleZeraeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SaleZeraee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindFirstArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleZeraeeFindFirstArgs>(args?: SelectSubset<T, SaleZeraeeFindFirstArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SaleZeraee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindFirstOrThrowArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleZeraeeFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleZeraeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SaleZeraees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleZeraees
     * const saleZeraees = await prisma.saleZeraee.findMany()
     * 
     * // Get first 10 SaleZeraees
     * const saleZeraees = await prisma.saleZeraee.findMany({ take: 10 })
     * 
     * // Only select the `IdSal`
     * const saleZeraeeWithIdSalOnly = await prisma.saleZeraee.findMany({ select: { IdSal: true } })
     * 
     */
    findMany<T extends SaleZeraeeFindManyArgs>(args?: SelectSubset<T, SaleZeraeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SaleZeraee.
     * @param {SaleZeraeeCreateArgs} args - Arguments to create a SaleZeraee.
     * @example
     * // Create one SaleZeraee
     * const SaleZeraee = await prisma.saleZeraee.create({
     *   data: {
     *     // ... data to create a SaleZeraee
     *   }
     * })
     * 
     */
    create<T extends SaleZeraeeCreateArgs>(args: SelectSubset<T, SaleZeraeeCreateArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SaleZeraees.
     * @param {SaleZeraeeCreateManyArgs} args - Arguments to create many SaleZeraees.
     * @example
     * // Create many SaleZeraees
     * const saleZeraee = await prisma.saleZeraee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleZeraeeCreateManyArgs>(args?: SelectSubset<T, SaleZeraeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SaleZeraee.
     * @param {SaleZeraeeDeleteArgs} args - Arguments to delete one SaleZeraee.
     * @example
     * // Delete one SaleZeraee
     * const SaleZeraee = await prisma.saleZeraee.delete({
     *   where: {
     *     // ... filter to delete one SaleZeraee
     *   }
     * })
     * 
     */
    delete<T extends SaleZeraeeDeleteArgs>(args: SelectSubset<T, SaleZeraeeDeleteArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SaleZeraee.
     * @param {SaleZeraeeUpdateArgs} args - Arguments to update one SaleZeraee.
     * @example
     * // Update one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleZeraeeUpdateArgs>(args: SelectSubset<T, SaleZeraeeUpdateArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SaleZeraees.
     * @param {SaleZeraeeDeleteManyArgs} args - Arguments to filter SaleZeraees to delete.
     * @example
     * // Delete a few SaleZeraees
     * const { count } = await prisma.saleZeraee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleZeraeeDeleteManyArgs>(args?: SelectSubset<T, SaleZeraeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleZeraees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleZeraees
     * const saleZeraee = await prisma.saleZeraee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleZeraeeUpdateManyArgs>(args: SelectSubset<T, SaleZeraeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleZeraee.
     * @param {SaleZeraeeUpsertArgs} args - Arguments to update or create a SaleZeraee.
     * @example
     * // Update or create a SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.upsert({
     *   create: {
     *     // ... data to create a SaleZeraee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleZeraee we want to update
     *   }
     * })
     */
    upsert<T extends SaleZeraeeUpsertArgs>(args: SelectSubset<T, SaleZeraeeUpsertArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SaleZeraees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeCountArgs} args - Arguments to filter SaleZeraees to count.
     * @example
     * // Count the number of SaleZeraees
     * const count = await prisma.saleZeraee.count({
     *   where: {
     *     // ... the filter for the SaleZeraees we want to count
     *   }
     * })
    **/
    count<T extends SaleZeraeeCountArgs>(
      args?: Subset<T, SaleZeraeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleZeraeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleZeraee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleZeraeeAggregateArgs>(args: Subset<T, SaleZeraeeAggregateArgs>): Prisma.PrismaPromise<GetSaleZeraeeAggregateType<T>>

    /**
     * Group by SaleZeraee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleZeraeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleZeraeeGroupByArgs['orderBy'] }
        : { orderBy?: SaleZeraeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleZeraeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleZeraeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleZeraee model
   */
  readonly fields: SaleZeraeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleZeraee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleZeraeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShabakeDoreKesht<T extends SaleZeraee$ShabakeDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, SaleZeraee$ShabakeDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TrikhDoreKesht<T extends SaleZeraee$TrikhDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, SaleZeraee$TrikhDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleZeraee model
   */ 
  interface SaleZeraeeFieldRefs {
    readonly IdSal: FieldRef<"SaleZeraee", 'Int'>
    readonly SaleZeraee: FieldRef<"SaleZeraee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SaleZeraee findUnique
   */
  export type SaleZeraeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee findUniqueOrThrow
   */
  export type SaleZeraeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee findFirst
   */
  export type SaleZeraeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleZeraees.
     */
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee findFirstOrThrow
   */
  export type SaleZeraeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleZeraees.
     */
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee findMany
   */
  export type SaleZeraeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter, which SaleZeraees to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee create
   */
  export type SaleZeraeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleZeraee.
     */
    data: XOR<SaleZeraeeCreateInput, SaleZeraeeUncheckedCreateInput>
  }

  /**
   * SaleZeraee createMany
   */
  export type SaleZeraeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleZeraees.
     */
    data: SaleZeraeeCreateManyInput | SaleZeraeeCreateManyInput[]
  }

  /**
   * SaleZeraee update
   */
  export type SaleZeraeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleZeraee.
     */
    data: XOR<SaleZeraeeUpdateInput, SaleZeraeeUncheckedUpdateInput>
    /**
     * Choose, which SaleZeraee to update.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee updateMany
   */
  export type SaleZeraeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleZeraees.
     */
    data: XOR<SaleZeraeeUpdateManyMutationInput, SaleZeraeeUncheckedUpdateManyInput>
    /**
     * Filter which SaleZeraees to update
     */
    where?: SaleZeraeeWhereInput
    /**
     * Limit how many SaleZeraees to update.
     */
    limit?: number
  }

  /**
   * SaleZeraee upsert
   */
  export type SaleZeraeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleZeraee to update in case it exists.
     */
    where: SaleZeraeeWhereUniqueInput
    /**
     * In case the SaleZeraee found by the `where` argument doesn't exist, create a new SaleZeraee with this data.
     */
    create: XOR<SaleZeraeeCreateInput, SaleZeraeeUncheckedCreateInput>
    /**
     * In case the SaleZeraee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleZeraeeUpdateInput, SaleZeraeeUncheckedUpdateInput>
  }

  /**
   * SaleZeraee delete
   */
  export type SaleZeraeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
    /**
     * Filter which SaleZeraee to delete.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee deleteMany
   */
  export type SaleZeraeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleZeraees to delete
     */
    where?: SaleZeraeeWhereInput
    /**
     * Limit how many SaleZeraees to delete.
     */
    limit?: number
  }

  /**
   * SaleZeraee.ShabakeDoreKesht
   */
  export type SaleZeraee$ShabakeDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    where?: ShabakeDoreKeshtWhereInput
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * SaleZeraee.TrikhDoreKesht
   */
  export type SaleZeraee$TrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    where?: TrikhDoreKeshtWhereInput
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    cursor?: TrikhDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * SaleZeraee without action
   */
  export type SaleZeraeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleZeraeeInclude<ExtArgs> | null
  }


  /**
   * Model SeghliPump
   */

  export type AggregateSeghliPump = {
    _count: SeghliPumpCountAggregateOutputType | null
    _avg: SeghliPumpAvgAggregateOutputType | null
    _sum: SeghliPumpSumAggregateOutputType | null
    _min: SeghliPumpMinAggregateOutputType | null
    _max: SeghliPumpMaxAggregateOutputType | null
  }

  export type SeghliPumpAvgAggregateOutputType = {
    IdSePu: number | null
  }

  export type SeghliPumpSumAggregateOutputType = {
    IdSePu: number | null
  }

  export type SeghliPumpMinAggregateOutputType = {
    IdSePu: number | null
    SeghliPump: string | null
  }

  export type SeghliPumpMaxAggregateOutputType = {
    IdSePu: number | null
    SeghliPump: string | null
  }

  export type SeghliPumpCountAggregateOutputType = {
    IdSePu: number
    SeghliPump: number
    _all: number
  }


  export type SeghliPumpAvgAggregateInputType = {
    IdSePu?: true
  }

  export type SeghliPumpSumAggregateInputType = {
    IdSePu?: true
  }

  export type SeghliPumpMinAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
  }

  export type SeghliPumpMaxAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
  }

  export type SeghliPumpCountAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
    _all?: true
  }

  export type SeghliPumpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeghliPump to aggregate.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeghliPumps
    **/
    _count?: true | SeghliPumpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeghliPumpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeghliPumpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeghliPumpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeghliPumpMaxAggregateInputType
  }

  export type GetSeghliPumpAggregateType<T extends SeghliPumpAggregateArgs> = {
        [P in keyof T & keyof AggregateSeghliPump]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeghliPump[P]>
      : GetScalarType<T[P], AggregateSeghliPump[P]>
  }




  export type SeghliPumpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeghliPumpWhereInput
    orderBy?: SeghliPumpOrderByWithAggregationInput | SeghliPumpOrderByWithAggregationInput[]
    by: SeghliPumpScalarFieldEnum[] | SeghliPumpScalarFieldEnum
    having?: SeghliPumpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeghliPumpCountAggregateInputType | true
    _avg?: SeghliPumpAvgAggregateInputType
    _sum?: SeghliPumpSumAggregateInputType
    _min?: SeghliPumpMinAggregateInputType
    _max?: SeghliPumpMaxAggregateInputType
  }

  export type SeghliPumpGroupByOutputType = {
    IdSePu: number
    SeghliPump: string
    _count: SeghliPumpCountAggregateOutputType | null
    _avg: SeghliPumpAvgAggregateOutputType | null
    _sum: SeghliPumpSumAggregateOutputType | null
    _min: SeghliPumpMinAggregateOutputType | null
    _max: SeghliPumpMaxAggregateOutputType | null
  }

  type GetSeghliPumpGroupByPayload<T extends SeghliPumpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeghliPumpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeghliPumpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeghliPumpGroupByOutputType[P]>
            : GetScalarType<T[P], SeghliPumpGroupByOutputType[P]>
        }
      >
    >


  export type SeghliPumpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSePu?: boolean
    SeghliPump?: boolean
    KhatRanesh?: boolean | SeghliPump$KhatRaneshArgs<ExtArgs>
    _count?: boolean | SeghliPumpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seghliPump"]>



  export type SeghliPumpSelectScalar = {
    IdSePu?: boolean
    SeghliPump?: boolean
  }

  export type SeghliPumpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSePu" | "SeghliPump", ExtArgs["result"]["seghliPump"]>
  export type SeghliPumpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | SeghliPump$KhatRaneshArgs<ExtArgs>
    _count?: boolean | SeghliPumpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SeghliPumpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeghliPump"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdSePu: number
      SeghliPump: string
    }, ExtArgs["result"]["seghliPump"]>
    composites: {}
  }

  type SeghliPumpGetPayload<S extends boolean | null | undefined | SeghliPumpDefaultArgs> = $Result.GetResult<Prisma.$SeghliPumpPayload, S>

  type SeghliPumpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeghliPumpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeghliPumpCountAggregateInputType | true
    }

  export interface SeghliPumpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeghliPump'], meta: { name: 'SeghliPump' } }
    /**
     * Find zero or one SeghliPump that matches the filter.
     * @param {SeghliPumpFindUniqueArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeghliPumpFindUniqueArgs>(args: SelectSubset<T, SeghliPumpFindUniqueArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SeghliPump that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeghliPumpFindUniqueOrThrowArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeghliPumpFindUniqueOrThrowArgs>(args: SelectSubset<T, SeghliPumpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SeghliPump that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindFirstArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeghliPumpFindFirstArgs>(args?: SelectSubset<T, SeghliPumpFindFirstArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SeghliPump that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindFirstOrThrowArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeghliPumpFindFirstOrThrowArgs>(args?: SelectSubset<T, SeghliPumpFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SeghliPumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeghliPumps
     * const seghliPumps = await prisma.seghliPump.findMany()
     * 
     * // Get first 10 SeghliPumps
     * const seghliPumps = await prisma.seghliPump.findMany({ take: 10 })
     * 
     * // Only select the `IdSePu`
     * const seghliPumpWithIdSePuOnly = await prisma.seghliPump.findMany({ select: { IdSePu: true } })
     * 
     */
    findMany<T extends SeghliPumpFindManyArgs>(args?: SelectSubset<T, SeghliPumpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SeghliPump.
     * @param {SeghliPumpCreateArgs} args - Arguments to create a SeghliPump.
     * @example
     * // Create one SeghliPump
     * const SeghliPump = await prisma.seghliPump.create({
     *   data: {
     *     // ... data to create a SeghliPump
     *   }
     * })
     * 
     */
    create<T extends SeghliPumpCreateArgs>(args: SelectSubset<T, SeghliPumpCreateArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SeghliPumps.
     * @param {SeghliPumpCreateManyArgs} args - Arguments to create many SeghliPumps.
     * @example
     * // Create many SeghliPumps
     * const seghliPump = await prisma.seghliPump.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeghliPumpCreateManyArgs>(args?: SelectSubset<T, SeghliPumpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeghliPump.
     * @param {SeghliPumpDeleteArgs} args - Arguments to delete one SeghliPump.
     * @example
     * // Delete one SeghliPump
     * const SeghliPump = await prisma.seghliPump.delete({
     *   where: {
     *     // ... filter to delete one SeghliPump
     *   }
     * })
     * 
     */
    delete<T extends SeghliPumpDeleteArgs>(args: SelectSubset<T, SeghliPumpDeleteArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SeghliPump.
     * @param {SeghliPumpUpdateArgs} args - Arguments to update one SeghliPump.
     * @example
     * // Update one SeghliPump
     * const seghliPump = await prisma.seghliPump.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeghliPumpUpdateArgs>(args: SelectSubset<T, SeghliPumpUpdateArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SeghliPumps.
     * @param {SeghliPumpDeleteManyArgs} args - Arguments to filter SeghliPumps to delete.
     * @example
     * // Delete a few SeghliPumps
     * const { count } = await prisma.seghliPump.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeghliPumpDeleteManyArgs>(args?: SelectSubset<T, SeghliPumpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeghliPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeghliPumps
     * const seghliPump = await prisma.seghliPump.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeghliPumpUpdateManyArgs>(args: SelectSubset<T, SeghliPumpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeghliPump.
     * @param {SeghliPumpUpsertArgs} args - Arguments to update or create a SeghliPump.
     * @example
     * // Update or create a SeghliPump
     * const seghliPump = await prisma.seghliPump.upsert({
     *   create: {
     *     // ... data to create a SeghliPump
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeghliPump we want to update
     *   }
     * })
     */
    upsert<T extends SeghliPumpUpsertArgs>(args: SelectSubset<T, SeghliPumpUpsertArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SeghliPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpCountArgs} args - Arguments to filter SeghliPumps to count.
     * @example
     * // Count the number of SeghliPumps
     * const count = await prisma.seghliPump.count({
     *   where: {
     *     // ... the filter for the SeghliPumps we want to count
     *   }
     * })
    **/
    count<T extends SeghliPumpCountArgs>(
      args?: Subset<T, SeghliPumpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeghliPumpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeghliPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeghliPumpAggregateArgs>(args: Subset<T, SeghliPumpAggregateArgs>): Prisma.PrismaPromise<GetSeghliPumpAggregateType<T>>

    /**
     * Group by SeghliPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeghliPumpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeghliPumpGroupByArgs['orderBy'] }
        : { orderBy?: SeghliPumpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeghliPumpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeghliPumpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeghliPump model
   */
  readonly fields: SeghliPumpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeghliPump.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeghliPumpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends SeghliPump$KhatRaneshArgs<ExtArgs> = {}>(args?: Subset<T, SeghliPump$KhatRaneshArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeghliPump model
   */ 
  interface SeghliPumpFieldRefs {
    readonly IdSePu: FieldRef<"SeghliPump", 'Int'>
    readonly SeghliPump: FieldRef<"SeghliPump", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeghliPump findUnique
   */
  export type SeghliPumpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump findUniqueOrThrow
   */
  export type SeghliPumpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump findFirst
   */
  export type SeghliPumpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeghliPumps.
     */
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump findFirstOrThrow
   */
  export type SeghliPumpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeghliPumps.
     */
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump findMany
   */
  export type SeghliPumpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter, which SeghliPumps to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump create
   */
  export type SeghliPumpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * The data needed to create a SeghliPump.
     */
    data: XOR<SeghliPumpCreateInput, SeghliPumpUncheckedCreateInput>
  }

  /**
   * SeghliPump createMany
   */
  export type SeghliPumpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeghliPumps.
     */
    data: SeghliPumpCreateManyInput | SeghliPumpCreateManyInput[]
  }

  /**
   * SeghliPump update
   */
  export type SeghliPumpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * The data needed to update a SeghliPump.
     */
    data: XOR<SeghliPumpUpdateInput, SeghliPumpUncheckedUpdateInput>
    /**
     * Choose, which SeghliPump to update.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump updateMany
   */
  export type SeghliPumpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeghliPumps.
     */
    data: XOR<SeghliPumpUpdateManyMutationInput, SeghliPumpUncheckedUpdateManyInput>
    /**
     * Filter which SeghliPumps to update
     */
    where?: SeghliPumpWhereInput
    /**
     * Limit how many SeghliPumps to update.
     */
    limit?: number
  }

  /**
   * SeghliPump upsert
   */
  export type SeghliPumpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * The filter to search for the SeghliPump to update in case it exists.
     */
    where: SeghliPumpWhereUniqueInput
    /**
     * In case the SeghliPump found by the `where` argument doesn't exist, create a new SeghliPump with this data.
     */
    create: XOR<SeghliPumpCreateInput, SeghliPumpUncheckedCreateInput>
    /**
     * In case the SeghliPump was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeghliPumpUpdateInput, SeghliPumpUncheckedUpdateInput>
  }

  /**
   * SeghliPump delete
   */
  export type SeghliPumpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
    /**
     * Filter which SeghliPump to delete.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump deleteMany
   */
  export type SeghliPumpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeghliPumps to delete
     */
    where?: SeghliPumpWhereInput
    /**
     * Limit how many SeghliPumps to delete.
     */
    limit?: number
  }

  /**
   * SeghliPump.KhatRanesh
   */
  export type SeghliPump$KhatRaneshArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KhatRaneshInclude<ExtArgs> | null
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    cursor?: KhatRaneshWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * SeghliPump without action
   */
  export type SeghliPumpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeghliPumpInclude<ExtArgs> | null
  }


  /**
   * Model SystemPart
   */

  export type AggregateSystemPart = {
    _count: SystemPartCountAggregateOutputType | null
    _avg: SystemPartAvgAggregateOutputType | null
    _sum: SystemPartSumAggregateOutputType | null
    _min: SystemPartMinAggregateOutputType | null
    _max: SystemPartMaxAggregateOutputType | null
  }

  export type SystemPartAvgAggregateOutputType = {
    IdSP: number | null
    KM: number | null
  }

  export type SystemPartSumAggregateOutputType = {
    IdSP: number | null
    KM: number | null
  }

  export type SystemPartMinAggregateOutputType = {
    IdSP: number | null
    Part: string | null
    KM: number | null
  }

  export type SystemPartMaxAggregateOutputType = {
    IdSP: number | null
    Part: string | null
    KM: number | null
  }

  export type SystemPartCountAggregateOutputType = {
    IdSP: number
    Part: number
    KM: number
    _all: number
  }


  export type SystemPartAvgAggregateInputType = {
    IdSP?: true
    KM?: true
  }

  export type SystemPartSumAggregateInputType = {
    IdSP?: true
    KM?: true
  }

  export type SystemPartMinAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
  }

  export type SystemPartMaxAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
  }

  export type SystemPartCountAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
    _all?: true
  }

  export type SystemPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPart to aggregate.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemParts
    **/
    _count?: true | SystemPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemPartMaxAggregateInputType
  }

  export type GetSystemPartAggregateType<T extends SystemPartAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemPart[P]>
      : GetScalarType<T[P], AggregateSystemPart[P]>
  }




  export type SystemPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemPartWhereInput
    orderBy?: SystemPartOrderByWithAggregationInput | SystemPartOrderByWithAggregationInput[]
    by: SystemPartScalarFieldEnum[] | SystemPartScalarFieldEnum
    having?: SystemPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemPartCountAggregateInputType | true
    _avg?: SystemPartAvgAggregateInputType
    _sum?: SystemPartSumAggregateInputType
    _min?: SystemPartMinAggregateInputType
    _max?: SystemPartMaxAggregateInputType
  }

  export type SystemPartGroupByOutputType = {
    IdSP: number
    Part: string
    KM: number
    _count: SystemPartCountAggregateOutputType | null
    _avg: SystemPartAvgAggregateOutputType | null
    _sum: SystemPartSumAggregateOutputType | null
    _min: SystemPartMinAggregateOutputType | null
    _max: SystemPartMaxAggregateOutputType | null
  }

  type GetSystemPartGroupByPayload<T extends SystemPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemPartGroupByOutputType[P]>
            : GetScalarType<T[P], SystemPartGroupByOutputType[P]>
        }
      >
    >


  export type SystemPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSP?: boolean
    Part?: boolean
    KM?: boolean
    Network?: boolean | SystemPart$NetworkArgs<ExtArgs>
    _count?: boolean | SystemPartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemPart"]>



  export type SystemPartSelectScalar = {
    IdSP?: boolean
    Part?: boolean
    KM?: boolean
  }

  export type SystemPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSP" | "Part" | "KM", ExtArgs["result"]["systemPart"]>
  export type SystemPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Network?: boolean | SystemPart$NetworkArgs<ExtArgs>
    _count?: boolean | SystemPartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SystemPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemPart"
    objects: {
      Network: Prisma.$NetworkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdSP: number
      Part: string
      KM: number
    }, ExtArgs["result"]["systemPart"]>
    composites: {}
  }

  type SystemPartGetPayload<S extends boolean | null | undefined | SystemPartDefaultArgs> = $Result.GetResult<Prisma.$SystemPartPayload, S>

  type SystemPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemPartCountAggregateInputType | true
    }

  export interface SystemPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemPart'], meta: { name: 'SystemPart' } }
    /**
     * Find zero or one SystemPart that matches the filter.
     * @param {SystemPartFindUniqueArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemPartFindUniqueArgs>(args: SelectSubset<T, SystemPartFindUniqueArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SystemPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemPartFindUniqueOrThrowArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemPartFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SystemPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindFirstArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemPartFindFirstArgs>(args?: SelectSubset<T, SystemPartFindFirstArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SystemPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindFirstOrThrowArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemPartFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SystemParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemParts
     * const systemParts = await prisma.systemPart.findMany()
     * 
     * // Get first 10 SystemParts
     * const systemParts = await prisma.systemPart.findMany({ take: 10 })
     * 
     * // Only select the `IdSP`
     * const systemPartWithIdSPOnly = await prisma.systemPart.findMany({ select: { IdSP: true } })
     * 
     */
    findMany<T extends SystemPartFindManyArgs>(args?: SelectSubset<T, SystemPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SystemPart.
     * @param {SystemPartCreateArgs} args - Arguments to create a SystemPart.
     * @example
     * // Create one SystemPart
     * const SystemPart = await prisma.systemPart.create({
     *   data: {
     *     // ... data to create a SystemPart
     *   }
     * })
     * 
     */
    create<T extends SystemPartCreateArgs>(args: SelectSubset<T, SystemPartCreateArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SystemParts.
     * @param {SystemPartCreateManyArgs} args - Arguments to create many SystemParts.
     * @example
     * // Create many SystemParts
     * const systemPart = await prisma.systemPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemPartCreateManyArgs>(args?: SelectSubset<T, SystemPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemPart.
     * @param {SystemPartDeleteArgs} args - Arguments to delete one SystemPart.
     * @example
     * // Delete one SystemPart
     * const SystemPart = await prisma.systemPart.delete({
     *   where: {
     *     // ... filter to delete one SystemPart
     *   }
     * })
     * 
     */
    delete<T extends SystemPartDeleteArgs>(args: SelectSubset<T, SystemPartDeleteArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SystemPart.
     * @param {SystemPartUpdateArgs} args - Arguments to update one SystemPart.
     * @example
     * // Update one SystemPart
     * const systemPart = await prisma.systemPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemPartUpdateArgs>(args: SelectSubset<T, SystemPartUpdateArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SystemParts.
     * @param {SystemPartDeleteManyArgs} args - Arguments to filter SystemParts to delete.
     * @example
     * // Delete a few SystemParts
     * const { count } = await prisma.systemPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemPartDeleteManyArgs>(args?: SelectSubset<T, SystemPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemParts
     * const systemPart = await prisma.systemPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemPartUpdateManyArgs>(args: SelectSubset<T, SystemPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemPart.
     * @param {SystemPartUpsertArgs} args - Arguments to update or create a SystemPart.
     * @example
     * // Update or create a SystemPart
     * const systemPart = await prisma.systemPart.upsert({
     *   create: {
     *     // ... data to create a SystemPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemPart we want to update
     *   }
     * })
     */
    upsert<T extends SystemPartUpsertArgs>(args: SelectSubset<T, SystemPartUpsertArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SystemParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartCountArgs} args - Arguments to filter SystemParts to count.
     * @example
     * // Count the number of SystemParts
     * const count = await prisma.systemPart.count({
     *   where: {
     *     // ... the filter for the SystemParts we want to count
     *   }
     * })
    **/
    count<T extends SystemPartCountArgs>(
      args?: Subset<T, SystemPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemPartAggregateArgs>(args: Subset<T, SystemPartAggregateArgs>): Prisma.PrismaPromise<GetSystemPartAggregateType<T>>

    /**
     * Group by SystemPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemPartGroupByArgs['orderBy'] }
        : { orderBy?: SystemPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemPart model
   */
  readonly fields: SystemPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Network<T extends SystemPart$NetworkArgs<ExtArgs> = {}>(args?: Subset<T, SystemPart$NetworkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemPart model
   */ 
  interface SystemPartFieldRefs {
    readonly IdSP: FieldRef<"SystemPart", 'Int'>
    readonly Part: FieldRef<"SystemPart", 'String'>
    readonly KM: FieldRef<"SystemPart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SystemPart findUnique
   */
  export type SystemPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart findUniqueOrThrow
   */
  export type SystemPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart findFirst
   */
  export type SystemPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemParts.
     */
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart findFirstOrThrow
   */
  export type SystemPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemParts.
     */
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart findMany
   */
  export type SystemPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter, which SystemParts to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart create
   */
  export type SystemPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemPart.
     */
    data: XOR<SystemPartCreateInput, SystemPartUncheckedCreateInput>
  }

  /**
   * SystemPart createMany
   */
  export type SystemPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemParts.
     */
    data: SystemPartCreateManyInput | SystemPartCreateManyInput[]
  }

  /**
   * SystemPart update
   */
  export type SystemPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemPart.
     */
    data: XOR<SystemPartUpdateInput, SystemPartUncheckedUpdateInput>
    /**
     * Choose, which SystemPart to update.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart updateMany
   */
  export type SystemPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemParts.
     */
    data: XOR<SystemPartUpdateManyMutationInput, SystemPartUncheckedUpdateManyInput>
    /**
     * Filter which SystemParts to update
     */
    where?: SystemPartWhereInput
    /**
     * Limit how many SystemParts to update.
     */
    limit?: number
  }

  /**
   * SystemPart upsert
   */
  export type SystemPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemPart to update in case it exists.
     */
    where: SystemPartWhereUniqueInput
    /**
     * In case the SystemPart found by the `where` argument doesn't exist, create a new SystemPart with this data.
     */
    create: XOR<SystemPartCreateInput, SystemPartUncheckedCreateInput>
    /**
     * In case the SystemPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemPartUpdateInput, SystemPartUncheckedUpdateInput>
  }

  /**
   * SystemPart delete
   */
  export type SystemPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
    /**
     * Filter which SystemPart to delete.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart deleteMany
   */
  export type SystemPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemParts to delete
     */
    where?: SystemPartWhereInput
    /**
     * Limit how many SystemParts to delete.
     */
    limit?: number
  }

  /**
   * SystemPart.Network
   */
  export type SystemPart$NetworkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    cursor?: NetworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * SystemPart without action
   */
  export type SystemPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPartInclude<ExtArgs> | null
  }


  /**
   * Model TakhlieMakhzan
   */

  export type AggregateTakhlieMakhzan = {
    _count: TakhlieMakhzanCountAggregateOutputType | null
    _avg: TakhlieMakhzanAvgAggregateOutputType | null
    _sum: TakhlieMakhzanSumAggregateOutputType | null
    _min: TakhlieMakhzanMinAggregateOutputType | null
    _max: TakhlieMakhzanMaxAggregateOutputType | null
  }

  export type TakhlieMakhzanAvgAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanSumAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanMinAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanMaxAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanCountAggregateOutputType = {
    IdTakhlie: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
    _all: number
  }


  export type TakhlieMakhzanAvgAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanSumAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanMinAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanMaxAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanCountAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
    _all?: true
  }

  export type TakhlieMakhzanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakhlieMakhzan to aggregate.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TakhlieMakhzans
    **/
    _count?: true | TakhlieMakhzanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TakhlieMakhzanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TakhlieMakhzanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakhlieMakhzanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakhlieMakhzanMaxAggregateInputType
  }

  export type GetTakhlieMakhzanAggregateType<T extends TakhlieMakhzanAggregateArgs> = {
        [P in keyof T & keyof AggregateTakhlieMakhzan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakhlieMakhzan[P]>
      : GetScalarType<T[P], AggregateTakhlieMakhzan[P]>
  }




  export type TakhlieMakhzanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakhlieMakhzanWhereInput
    orderBy?: TakhlieMakhzanOrderByWithAggregationInput | TakhlieMakhzanOrderByWithAggregationInput[]
    by: TakhlieMakhzanScalarFieldEnum[] | TakhlieMakhzanScalarFieldEnum
    having?: TakhlieMakhzanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakhlieMakhzanCountAggregateInputType | true
    _avg?: TakhlieMakhzanAvgAggregateInputType
    _sum?: TakhlieMakhzanSumAggregateInputType
    _min?: TakhlieMakhzanMinAggregateInputType
    _max?: TakhlieMakhzanMaxAggregateInputType
  }

  export type TakhlieMakhzanGroupByOutputType = {
    IdTakhlie: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
    _count: TakhlieMakhzanCountAggregateOutputType | null
    _avg: TakhlieMakhzanAvgAggregateOutputType | null
    _sum: TakhlieMakhzanSumAggregateOutputType | null
    _min: TakhlieMakhzanMinAggregateOutputType | null
    _max: TakhlieMakhzanMaxAggregateOutputType | null
  }

  type GetTakhlieMakhzanGroupByPayload<T extends TakhlieMakhzanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakhlieMakhzanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakhlieMakhzanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakhlieMakhzanGroupByOutputType[P]>
            : GetScalarType<T[P], TakhlieMakhzanGroupByOutputType[P]>
        }
      >
    >


  export type TakhlieMakhzanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTakhlie?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Takhlie?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takhlieMakhzan"]>



  export type TakhlieMakhzanSelectScalar = {
    IdTakhlie?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Takhlie?: boolean
  }

  export type TakhlieMakhzanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTakhlie" | "FIdRanesh" | "FIdTarDor" | "Takhlie", ExtArgs["result"]["takhlieMakhzan"]>
  export type TakhlieMakhzanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $TakhlieMakhzanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TakhlieMakhzan"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdTakhlie: number
      FIdRanesh: number
      FIdTarDor: number
      Takhlie: number
    }, ExtArgs["result"]["takhlieMakhzan"]>
    composites: {}
  }

  type TakhlieMakhzanGetPayload<S extends boolean | null | undefined | TakhlieMakhzanDefaultArgs> = $Result.GetResult<Prisma.$TakhlieMakhzanPayload, S>

  type TakhlieMakhzanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakhlieMakhzanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakhlieMakhzanCountAggregateInputType | true
    }

  export interface TakhlieMakhzanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TakhlieMakhzan'], meta: { name: 'TakhlieMakhzan' } }
    /**
     * Find zero or one TakhlieMakhzan that matches the filter.
     * @param {TakhlieMakhzanFindUniqueArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakhlieMakhzanFindUniqueArgs>(args: SelectSubset<T, TakhlieMakhzanFindUniqueArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TakhlieMakhzan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakhlieMakhzanFindUniqueOrThrowArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakhlieMakhzanFindUniqueOrThrowArgs>(args: SelectSubset<T, TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TakhlieMakhzan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindFirstArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakhlieMakhzanFindFirstArgs>(args?: SelectSubset<T, TakhlieMakhzanFindFirstArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TakhlieMakhzan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindFirstOrThrowArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakhlieMakhzanFindFirstOrThrowArgs>(args?: SelectSubset<T, TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TakhlieMakhzans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TakhlieMakhzans
     * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany()
     * 
     * // Get first 10 TakhlieMakhzans
     * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany({ take: 10 })
     * 
     * // Only select the `IdTakhlie`
     * const takhlieMakhzanWithIdTakhlieOnly = await prisma.takhlieMakhzan.findMany({ select: { IdTakhlie: true } })
     * 
     */
    findMany<T extends TakhlieMakhzanFindManyArgs>(args?: SelectSubset<T, TakhlieMakhzanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TakhlieMakhzan.
     * @param {TakhlieMakhzanCreateArgs} args - Arguments to create a TakhlieMakhzan.
     * @example
     * // Create one TakhlieMakhzan
     * const TakhlieMakhzan = await prisma.takhlieMakhzan.create({
     *   data: {
     *     // ... data to create a TakhlieMakhzan
     *   }
     * })
     * 
     */
    create<T extends TakhlieMakhzanCreateArgs>(args: SelectSubset<T, TakhlieMakhzanCreateArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TakhlieMakhzans.
     * @param {TakhlieMakhzanCreateManyArgs} args - Arguments to create many TakhlieMakhzans.
     * @example
     * // Create many TakhlieMakhzans
     * const takhlieMakhzan = await prisma.takhlieMakhzan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakhlieMakhzanCreateManyArgs>(args?: SelectSubset<T, TakhlieMakhzanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TakhlieMakhzan.
     * @param {TakhlieMakhzanDeleteArgs} args - Arguments to delete one TakhlieMakhzan.
     * @example
     * // Delete one TakhlieMakhzan
     * const TakhlieMakhzan = await prisma.takhlieMakhzan.delete({
     *   where: {
     *     // ... filter to delete one TakhlieMakhzan
     *   }
     * })
     * 
     */
    delete<T extends TakhlieMakhzanDeleteArgs>(args: SelectSubset<T, TakhlieMakhzanDeleteArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TakhlieMakhzan.
     * @param {TakhlieMakhzanUpdateArgs} args - Arguments to update one TakhlieMakhzan.
     * @example
     * // Update one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakhlieMakhzanUpdateArgs>(args: SelectSubset<T, TakhlieMakhzanUpdateArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TakhlieMakhzans.
     * @param {TakhlieMakhzanDeleteManyArgs} args - Arguments to filter TakhlieMakhzans to delete.
     * @example
     * // Delete a few TakhlieMakhzans
     * const { count } = await prisma.takhlieMakhzan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakhlieMakhzanDeleteManyArgs>(args?: SelectSubset<T, TakhlieMakhzanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakhlieMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TakhlieMakhzans
     * const takhlieMakhzan = await prisma.takhlieMakhzan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakhlieMakhzanUpdateManyArgs>(args: SelectSubset<T, TakhlieMakhzanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TakhlieMakhzan.
     * @param {TakhlieMakhzanUpsertArgs} args - Arguments to update or create a TakhlieMakhzan.
     * @example
     * // Update or create a TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.upsert({
     *   create: {
     *     // ... data to create a TakhlieMakhzan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TakhlieMakhzan we want to update
     *   }
     * })
     */
    upsert<T extends TakhlieMakhzanUpsertArgs>(args: SelectSubset<T, TakhlieMakhzanUpsertArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TakhlieMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanCountArgs} args - Arguments to filter TakhlieMakhzans to count.
     * @example
     * // Count the number of TakhlieMakhzans
     * const count = await prisma.takhlieMakhzan.count({
     *   where: {
     *     // ... the filter for the TakhlieMakhzans we want to count
     *   }
     * })
    **/
    count<T extends TakhlieMakhzanCountArgs>(
      args?: Subset<T, TakhlieMakhzanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakhlieMakhzanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TakhlieMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakhlieMakhzanAggregateArgs>(args: Subset<T, TakhlieMakhzanAggregateArgs>): Prisma.PrismaPromise<GetTakhlieMakhzanAggregateType<T>>

    /**
     * Group by TakhlieMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakhlieMakhzanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakhlieMakhzanGroupByArgs['orderBy'] }
        : { orderBy?: TakhlieMakhzanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakhlieMakhzanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakhlieMakhzanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TakhlieMakhzan model
   */
  readonly fields: TakhlieMakhzanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TakhlieMakhzan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakhlieMakhzanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TakhlieMakhzan model
   */ 
  interface TakhlieMakhzanFieldRefs {
    readonly IdTakhlie: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly FIdRanesh: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly FIdTarDor: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly Takhlie: FieldRef<"TakhlieMakhzan", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TakhlieMakhzan findUnique
   */
  export type TakhlieMakhzanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan findUniqueOrThrow
   */
  export type TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan findFirst
   */
  export type TakhlieMakhzanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakhlieMakhzans.
     */
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan findFirstOrThrow
   */
  export type TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakhlieMakhzans.
     */
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan findMany
   */
  export type TakhlieMakhzanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzans to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan create
   */
  export type TakhlieMakhzanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * The data needed to create a TakhlieMakhzan.
     */
    data: XOR<TakhlieMakhzanCreateInput, TakhlieMakhzanUncheckedCreateInput>
  }

  /**
   * TakhlieMakhzan createMany
   */
  export type TakhlieMakhzanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TakhlieMakhzans.
     */
    data: TakhlieMakhzanCreateManyInput | TakhlieMakhzanCreateManyInput[]
  }

  /**
   * TakhlieMakhzan update
   */
  export type TakhlieMakhzanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * The data needed to update a TakhlieMakhzan.
     */
    data: XOR<TakhlieMakhzanUpdateInput, TakhlieMakhzanUncheckedUpdateInput>
    /**
     * Choose, which TakhlieMakhzan to update.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan updateMany
   */
  export type TakhlieMakhzanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TakhlieMakhzans.
     */
    data: XOR<TakhlieMakhzanUpdateManyMutationInput, TakhlieMakhzanUncheckedUpdateManyInput>
    /**
     * Filter which TakhlieMakhzans to update
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * Limit how many TakhlieMakhzans to update.
     */
    limit?: number
  }

  /**
   * TakhlieMakhzan upsert
   */
  export type TakhlieMakhzanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * The filter to search for the TakhlieMakhzan to update in case it exists.
     */
    where: TakhlieMakhzanWhereUniqueInput
    /**
     * In case the TakhlieMakhzan found by the `where` argument doesn't exist, create a new TakhlieMakhzan with this data.
     */
    create: XOR<TakhlieMakhzanCreateInput, TakhlieMakhzanUncheckedCreateInput>
    /**
     * In case the TakhlieMakhzan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakhlieMakhzanUpdateInput, TakhlieMakhzanUncheckedUpdateInput>
  }

  /**
   * TakhlieMakhzan delete
   */
  export type TakhlieMakhzanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    /**
     * Filter which TakhlieMakhzan to delete.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan deleteMany
   */
  export type TakhlieMakhzanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakhlieMakhzans to delete
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * Limit how many TakhlieMakhzans to delete.
     */
    limit?: number
  }

  /**
   * TakhlieMakhzan without action
   */
  export type TakhlieMakhzanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestSumAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestMinAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestMaxAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestCountAggregateOutputType = {
    IdTest: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestSumAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestMinAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestMaxAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestCountAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    IdTest: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTest?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Test?: boolean
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>



  export type TestSelectScalar = {
    IdTest?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Test?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTest" | "FIdRanesh" | "FIdTarDor" | "Test", ExtArgs["result"]["test"]>
  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KhatRanesh?: boolean | KhatRaneshDefaultArgs<ExtArgs>
    TrikhDoreKesht?: boolean | TrikhDoreKeshtDefaultArgs<ExtArgs>
  }

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      KhatRanesh: Prisma.$KhatRaneshPayload<ExtArgs>
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdTest: number
      FIdRanesh: number
      FIdTarDor: number
      Test: number
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `IdTest`
     * const testWithIdTestOnly = await prisma.test.findMany({ select: { IdTest: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KhatRanesh<T extends KhatRaneshDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KhatRaneshDefaultArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TrikhDoreKesht<T extends TrikhDoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKeshtDefaultArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */ 
  interface TestFieldRefs {
    readonly IdTest: FieldRef<"Test", 'Int'>
    readonly FIdRanesh: FieldRef<"Test", 'Int'>
    readonly FIdTarDor: FieldRef<"Test", 'Int'>
    readonly Test: FieldRef<"Test", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
  }


  /**
   * Model TrikhDoreKesht
   */

  export type AggregateTrikhDoreKesht = {
    _count: TrikhDoreKeshtCountAggregateOutputType | null
    _avg: TrikhDoreKeshtAvgAggregateOutputType | null
    _sum: TrikhDoreKeshtSumAggregateOutputType | null
    _min: TrikhDoreKeshtMinAggregateOutputType | null
    _max: TrikhDoreKeshtMaxAggregateOutputType | null
  }

  export type TrikhDoreKeshtAvgAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Dahe: number | null
    Sal: number | null
    Mah: number | null
  }

  export type TrikhDoreKeshtSumAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Dahe: number | null
    Sal: number | null
    Mah: number | null
  }

  export type TrikhDoreKeshtMinAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Trikh: Date | null
    TrikhKhorshidi: string | null
    Dahe: number | null
    Sal: number | null
    Mah: number | null
  }

  export type TrikhDoreKeshtMaxAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Trikh: Date | null
    TrikhKhorshidi: string | null
    Dahe: number | null
    Sal: number | null
    Mah: number | null
  }

  export type TrikhDoreKeshtCountAggregateOutputType = {
    IdTarDor: number
    FIdSal: number
    FIdDore: number
    Trikh: number
    TrikhKhorshidi: number
    Dahe: number
    Sal: number
    Mah: number
    _all: number
  }


  export type TrikhDoreKeshtAvgAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Dahe?: true
    Sal?: true
    Mah?: true
  }

  export type TrikhDoreKeshtSumAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Dahe?: true
    Sal?: true
    Mah?: true
  }

  export type TrikhDoreKeshtMinAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
    Dahe?: true
    Sal?: true
    Mah?: true
  }

  export type TrikhDoreKeshtMaxAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
    Dahe?: true
    Sal?: true
    Mah?: true
  }

  export type TrikhDoreKeshtCountAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
    Dahe?: true
    Sal?: true
    Mah?: true
    _all?: true
  }

  export type TrikhDoreKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrikhDoreKesht to aggregate.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrikhDoreKeshts
    **/
    _count?: true | TrikhDoreKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrikhDoreKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrikhDoreKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrikhDoreKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrikhDoreKeshtMaxAggregateInputType
  }

  export type GetTrikhDoreKeshtAggregateType<T extends TrikhDoreKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateTrikhDoreKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrikhDoreKesht[P]>
      : GetScalarType<T[P], AggregateTrikhDoreKesht[P]>
  }




  export type TrikhDoreKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrikhDoreKeshtWhereInput
    orderBy?: TrikhDoreKeshtOrderByWithAggregationInput | TrikhDoreKeshtOrderByWithAggregationInput[]
    by: TrikhDoreKeshtScalarFieldEnum[] | TrikhDoreKeshtScalarFieldEnum
    having?: TrikhDoreKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrikhDoreKeshtCountAggregateInputType | true
    _avg?: TrikhDoreKeshtAvgAggregateInputType
    _sum?: TrikhDoreKeshtSumAggregateInputType
    _min?: TrikhDoreKeshtMinAggregateInputType
    _max?: TrikhDoreKeshtMaxAggregateInputType
  }

  export type TrikhDoreKeshtGroupByOutputType = {
    IdTarDor: number
    FIdSal: number
    FIdDore: number
    Trikh: Date
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    _count: TrikhDoreKeshtCountAggregateOutputType | null
    _avg: TrikhDoreKeshtAvgAggregateOutputType | null
    _sum: TrikhDoreKeshtSumAggregateOutputType | null
    _min: TrikhDoreKeshtMinAggregateOutputType | null
    _max: TrikhDoreKeshtMaxAggregateOutputType | null
  }

  type GetTrikhDoreKeshtGroupByPayload<T extends TrikhDoreKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrikhDoreKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrikhDoreKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrikhDoreKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], TrikhDoreKeshtGroupByOutputType[P]>
        }
      >
    >


  export type TrikhDoreKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTarDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Trikh?: boolean
    TrikhKhorshidi?: boolean
    Dahe?: boolean
    Sal?: boolean
    Mah?: boolean
    BahrebardairProgram?: boolean | TrikhDoreKesht$BahrebardairProgramArgs<ExtArgs>
    BahrebardairProgramSeghli?: boolean | TrikhDoreKesht$BahrebardairProgramSeghliArgs<ExtArgs>
    BahrebardariTaghvim?: boolean | TrikhDoreKesht$BahrebardariTaghvimArgs<ExtArgs>
    EshtebahAvamel?: boolean | TrikhDoreKesht$EshtebahAvamelArgs<ExtArgs>
    FlowBehbood?: boolean | TrikhDoreKesht$FlowBehboodArgs<ExtArgs>
    Flowmeter?: boolean | TrikhDoreKesht$FlowmeterArgs<ExtArgs>
    Kontor?: boolean | TrikhDoreKesht$KontorArgs<ExtArgs>
    NashtShabake?: boolean | TrikhDoreKesht$NashtShabakeArgs<ExtArgs>
    NonFIT?: boolean | TrikhDoreKesht$NonFITArgs<ExtArgs>
    RainfallStation?: boolean | TrikhDoreKesht$RainfallStationArgs<ExtArgs>
    TakhlieMakhzan?: boolean | TrikhDoreKesht$TakhlieMakhzanArgs<ExtArgs>
    Test?: boolean | TrikhDoreKesht$TestArgs<ExtArgs>
    DoreKesht?: boolean | DoreKeshtDefaultArgs<ExtArgs>
    MahShamsi?: boolean | MahShamsiDefaultArgs<ExtArgs>
    SaleZeraee?: boolean | SaleZeraeeDefaultArgs<ExtArgs>
    _count?: boolean | TrikhDoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trikhDoreKesht"]>



  export type TrikhDoreKeshtSelectScalar = {
    IdTarDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Trikh?: boolean
    TrikhKhorshidi?: boolean
    Dahe?: boolean
    Sal?: boolean
    Mah?: boolean
  }

  export type TrikhDoreKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTarDor" | "FIdSal" | "FIdDore" | "Trikh" | "TrikhKhorshidi" | "Dahe" | "Sal" | "Mah", ExtArgs["result"]["trikhDoreKesht"]>
  export type TrikhDoreKeshtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardairProgram?: boolean | TrikhDoreKesht$BahrebardairProgramArgs<ExtArgs>
    BahrebardairProgramSeghli?: boolean | TrikhDoreKesht$BahrebardairProgramSeghliArgs<ExtArgs>
    BahrebardariTaghvim?: boolean | TrikhDoreKesht$BahrebardariTaghvimArgs<ExtArgs>
    EshtebahAvamel?: boolean | TrikhDoreKesht$EshtebahAvamelArgs<ExtArgs>
    FlowBehbood?: boolean | TrikhDoreKesht$FlowBehboodArgs<ExtArgs>
    Flowmeter?: boolean | TrikhDoreKesht$FlowmeterArgs<ExtArgs>
    Kontor?: boolean | TrikhDoreKesht$KontorArgs<ExtArgs>
    NashtShabake?: boolean | TrikhDoreKesht$NashtShabakeArgs<ExtArgs>
    NonFIT?: boolean | TrikhDoreKesht$NonFITArgs<ExtArgs>
    RainfallStation?: boolean | TrikhDoreKesht$RainfallStationArgs<ExtArgs>
    TakhlieMakhzan?: boolean | TrikhDoreKesht$TakhlieMakhzanArgs<ExtArgs>
    Test?: boolean | TrikhDoreKesht$TestArgs<ExtArgs>
    DoreKesht?: boolean | DoreKeshtDefaultArgs<ExtArgs>
    MahShamsi?: boolean | MahShamsiDefaultArgs<ExtArgs>
    SaleZeraee?: boolean | SaleZeraeeDefaultArgs<ExtArgs>
    _count?: boolean | TrikhDoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TrikhDoreKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrikhDoreKesht"
    objects: {
      BahrebardairProgram: Prisma.$BahrebardairProgramPayload<ExtArgs>[]
      BahrebardairProgramSeghli: Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>[]
      BahrebardariTaghvim: Prisma.$BahrebardariTaghvimPayload<ExtArgs>[]
      EshtebahAvamel: Prisma.$EshtebahAvamelPayload<ExtArgs>[]
      FlowBehbood: Prisma.$FlowBehboodPayload<ExtArgs>[]
      Flowmeter: Prisma.$FlowmeterPayload<ExtArgs>[]
      Kontor: Prisma.$KontorPayload<ExtArgs>[]
      NashtShabake: Prisma.$NashtShabakePayload<ExtArgs>[]
      NonFIT: Prisma.$NonFITPayload<ExtArgs>[]
      RainfallStation: Prisma.$RainfallStationPayload<ExtArgs>[]
      TakhlieMakhzan: Prisma.$TakhlieMakhzanPayload<ExtArgs>[]
      Test: Prisma.$TestPayload<ExtArgs>[]
      DoreKesht: Prisma.$DoreKeshtPayload<ExtArgs>
      MahShamsi: Prisma.$MahShamsiPayload<ExtArgs>
      SaleZeraee: Prisma.$SaleZeraeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdTarDor: number
      FIdSal: number
      FIdDore: number
      Trikh: Date
      TrikhKhorshidi: string
      Dahe: number
      Sal: number
      Mah: number
    }, ExtArgs["result"]["trikhDoreKesht"]>
    composites: {}
  }

  type TrikhDoreKeshtGetPayload<S extends boolean | null | undefined | TrikhDoreKeshtDefaultArgs> = $Result.GetResult<Prisma.$TrikhDoreKeshtPayload, S>

  type TrikhDoreKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrikhDoreKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrikhDoreKeshtCountAggregateInputType | true
    }

  export interface TrikhDoreKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrikhDoreKesht'], meta: { name: 'TrikhDoreKesht' } }
    /**
     * Find zero or one TrikhDoreKesht that matches the filter.
     * @param {TrikhDoreKeshtFindUniqueArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrikhDoreKeshtFindUniqueArgs>(args: SelectSubset<T, TrikhDoreKeshtFindUniqueArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TrikhDoreKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrikhDoreKeshtFindUniqueOrThrowArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrikhDoreKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TrikhDoreKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindFirstArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrikhDoreKeshtFindFirstArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindFirstArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TrikhDoreKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindFirstOrThrowArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrikhDoreKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TrikhDoreKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrikhDoreKeshts
     * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany()
     * 
     * // Get first 10 TrikhDoreKeshts
     * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdTarDor`
     * const trikhDoreKeshtWithIdTarDorOnly = await prisma.trikhDoreKesht.findMany({ select: { IdTarDor: true } })
     * 
     */
    findMany<T extends TrikhDoreKeshtFindManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TrikhDoreKesht.
     * @param {TrikhDoreKeshtCreateArgs} args - Arguments to create a TrikhDoreKesht.
     * @example
     * // Create one TrikhDoreKesht
     * const TrikhDoreKesht = await prisma.trikhDoreKesht.create({
     *   data: {
     *     // ... data to create a TrikhDoreKesht
     *   }
     * })
     * 
     */
    create<T extends TrikhDoreKeshtCreateArgs>(args: SelectSubset<T, TrikhDoreKeshtCreateArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TrikhDoreKeshts.
     * @param {TrikhDoreKeshtCreateManyArgs} args - Arguments to create many TrikhDoreKeshts.
     * @example
     * // Create many TrikhDoreKeshts
     * const trikhDoreKesht = await prisma.trikhDoreKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrikhDoreKeshtCreateManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrikhDoreKesht.
     * @param {TrikhDoreKeshtDeleteArgs} args - Arguments to delete one TrikhDoreKesht.
     * @example
     * // Delete one TrikhDoreKesht
     * const TrikhDoreKesht = await prisma.trikhDoreKesht.delete({
     *   where: {
     *     // ... filter to delete one TrikhDoreKesht
     *   }
     * })
     * 
     */
    delete<T extends TrikhDoreKeshtDeleteArgs>(args: SelectSubset<T, TrikhDoreKeshtDeleteArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TrikhDoreKesht.
     * @param {TrikhDoreKeshtUpdateArgs} args - Arguments to update one TrikhDoreKesht.
     * @example
     * // Update one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrikhDoreKeshtUpdateArgs>(args: SelectSubset<T, TrikhDoreKeshtUpdateArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TrikhDoreKeshts.
     * @param {TrikhDoreKeshtDeleteManyArgs} args - Arguments to filter TrikhDoreKeshts to delete.
     * @example
     * // Delete a few TrikhDoreKeshts
     * const { count } = await prisma.trikhDoreKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrikhDoreKeshtDeleteManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrikhDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrikhDoreKeshts
     * const trikhDoreKesht = await prisma.trikhDoreKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrikhDoreKeshtUpdateManyArgs>(args: SelectSubset<T, TrikhDoreKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrikhDoreKesht.
     * @param {TrikhDoreKeshtUpsertArgs} args - Arguments to update or create a TrikhDoreKesht.
     * @example
     * // Update or create a TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.upsert({
     *   create: {
     *     // ... data to create a TrikhDoreKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrikhDoreKesht we want to update
     *   }
     * })
     */
    upsert<T extends TrikhDoreKeshtUpsertArgs>(args: SelectSubset<T, TrikhDoreKeshtUpsertArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TrikhDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtCountArgs} args - Arguments to filter TrikhDoreKeshts to count.
     * @example
     * // Count the number of TrikhDoreKeshts
     * const count = await prisma.trikhDoreKesht.count({
     *   where: {
     *     // ... the filter for the TrikhDoreKeshts we want to count
     *   }
     * })
    **/
    count<T extends TrikhDoreKeshtCountArgs>(
      args?: Subset<T, TrikhDoreKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrikhDoreKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrikhDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrikhDoreKeshtAggregateArgs>(args: Subset<T, TrikhDoreKeshtAggregateArgs>): Prisma.PrismaPromise<GetTrikhDoreKeshtAggregateType<T>>

    /**
     * Group by TrikhDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrikhDoreKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrikhDoreKeshtGroupByArgs['orderBy'] }
        : { orderBy?: TrikhDoreKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrikhDoreKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrikhDoreKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrikhDoreKesht model
   */
  readonly fields: TrikhDoreKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrikhDoreKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrikhDoreKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BahrebardairProgram<T extends TrikhDoreKesht$BahrebardairProgramArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$BahrebardairProgramArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardairProgramSeghli<T extends TrikhDoreKesht$BahrebardairProgramSeghliArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$BahrebardairProgramSeghliArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramSeghliPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BahrebardariTaghvim<T extends TrikhDoreKesht$BahrebardariTaghvimArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$BahrebardariTaghvimArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EshtebahAvamel<T extends TrikhDoreKesht$EshtebahAvamelArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$EshtebahAvamelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FlowBehbood<T extends TrikhDoreKesht$FlowBehboodArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$FlowBehboodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Flowmeter<T extends TrikhDoreKesht$FlowmeterArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$FlowmeterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Kontor<T extends TrikhDoreKesht$KontorArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$KontorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NashtShabake<T extends TrikhDoreKesht$NashtShabakeArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$NashtShabakeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    NonFIT<T extends TrikhDoreKesht$NonFITArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$NonFITArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RainfallStation<T extends TrikhDoreKesht$RainfallStationArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$RainfallStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TakhlieMakhzan<T extends TrikhDoreKesht$TakhlieMakhzanArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$TakhlieMakhzanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Test<T extends TrikhDoreKesht$TestArgs<ExtArgs> = {}>(args?: Subset<T, TrikhDoreKesht$TestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DoreKesht<T extends DoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoreKeshtDefaultArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    MahShamsi<T extends MahShamsiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MahShamsiDefaultArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    SaleZeraee<T extends SaleZeraeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleZeraeeDefaultArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrikhDoreKesht model
   */ 
  interface TrikhDoreKeshtFieldRefs {
    readonly IdTarDor: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly FIdSal: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly FIdDore: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly Trikh: FieldRef<"TrikhDoreKesht", 'DateTime'>
    readonly TrikhKhorshidi: FieldRef<"TrikhDoreKesht", 'String'>
    readonly Dahe: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly Sal: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly Mah: FieldRef<"TrikhDoreKesht", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TrikhDoreKesht findUnique
   */
  export type TrikhDoreKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht findUniqueOrThrow
   */
  export type TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht findFirst
   */
  export type TrikhDoreKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrikhDoreKeshts.
     */
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht findFirstOrThrow
   */
  export type TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrikhDoreKeshts.
     */
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht findMany
   */
  export type TrikhDoreKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKeshts to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht create
   */
  export type TrikhDoreKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to create a TrikhDoreKesht.
     */
    data: XOR<TrikhDoreKeshtCreateInput, TrikhDoreKeshtUncheckedCreateInput>
  }

  /**
   * TrikhDoreKesht createMany
   */
  export type TrikhDoreKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrikhDoreKeshts.
     */
    data: TrikhDoreKeshtCreateManyInput | TrikhDoreKeshtCreateManyInput[]
  }

  /**
   * TrikhDoreKesht update
   */
  export type TrikhDoreKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to update a TrikhDoreKesht.
     */
    data: XOR<TrikhDoreKeshtUpdateInput, TrikhDoreKeshtUncheckedUpdateInput>
    /**
     * Choose, which TrikhDoreKesht to update.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht updateMany
   */
  export type TrikhDoreKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrikhDoreKeshts.
     */
    data: XOR<TrikhDoreKeshtUpdateManyMutationInput, TrikhDoreKeshtUncheckedUpdateManyInput>
    /**
     * Filter which TrikhDoreKeshts to update
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * Limit how many TrikhDoreKeshts to update.
     */
    limit?: number
  }

  /**
   * TrikhDoreKesht upsert
   */
  export type TrikhDoreKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * The filter to search for the TrikhDoreKesht to update in case it exists.
     */
    where: TrikhDoreKeshtWhereUniqueInput
    /**
     * In case the TrikhDoreKesht found by the `where` argument doesn't exist, create a new TrikhDoreKesht with this data.
     */
    create: XOR<TrikhDoreKeshtCreateInput, TrikhDoreKeshtUncheckedCreateInput>
    /**
     * In case the TrikhDoreKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrikhDoreKeshtUpdateInput, TrikhDoreKeshtUncheckedUpdateInput>
  }

  /**
   * TrikhDoreKesht delete
   */
  export type TrikhDoreKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter which TrikhDoreKesht to delete.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht deleteMany
   */
  export type TrikhDoreKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrikhDoreKeshts to delete
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * Limit how many TrikhDoreKeshts to delete.
     */
    limit?: number
  }

  /**
   * TrikhDoreKesht.BahrebardairProgram
   */
  export type TrikhDoreKesht$BahrebardairProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramInclude<ExtArgs> | null
    where?: BahrebardairProgramWhereInput
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    cursor?: BahrebardairProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.BahrebardairProgramSeghli
   */
  export type TrikhDoreKesht$BahrebardairProgramSeghliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgramSeghli
     */
    select?: BahrebardairProgramSeghliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgramSeghli
     */
    omit?: BahrebardairProgramSeghliOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardairProgramSeghliInclude<ExtArgs> | null
    where?: BahrebardairProgramSeghliWhereInput
    orderBy?: BahrebardairProgramSeghliOrderByWithRelationInput | BahrebardairProgramSeghliOrderByWithRelationInput[]
    cursor?: BahrebardairProgramSeghliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardairProgramSeghliScalarFieldEnum | BahrebardairProgramSeghliScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.BahrebardariTaghvim
   */
  export type TrikhDoreKesht$BahrebardariTaghvimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariTaghvimInclude<ExtArgs> | null
    where?: BahrebardariTaghvimWhereInput
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    cursor?: BahrebardariTaghvimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.EshtebahAvamel
   */
  export type TrikhDoreKesht$EshtebahAvamelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EshtebahAvamelInclude<ExtArgs> | null
    where?: EshtebahAvamelWhereInput
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    cursor?: EshtebahAvamelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.FlowBehbood
   */
  export type TrikhDoreKesht$FlowBehboodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowBehboodInclude<ExtArgs> | null
    where?: FlowBehboodWhereInput
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    cursor?: FlowBehboodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.Flowmeter
   */
  export type TrikhDoreKesht$FlowmeterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowmeterInclude<ExtArgs> | null
    where?: FlowmeterWhereInput
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    cursor?: FlowmeterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.Kontor
   */
  export type TrikhDoreKesht$KontorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorInclude<ExtArgs> | null
    where?: KontorWhereInput
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    cursor?: KontorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.NashtShabake
   */
  export type TrikhDoreKesht$NashtShabakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NashtShabakeInclude<ExtArgs> | null
    where?: NashtShabakeWhereInput
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    cursor?: NashtShabakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.NonFIT
   */
  export type TrikhDoreKesht$NonFITArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NonFITInclude<ExtArgs> | null
    where?: NonFITWhereInput
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    cursor?: NonFITWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.RainfallStation
   */
  export type TrikhDoreKesht$RainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    where?: RainfallStationWhereInput
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    cursor?: RainfallStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.TakhlieMakhzan
   */
  export type TrikhDoreKesht$TakhlieMakhzanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakhlieMakhzanInclude<ExtArgs> | null
    where?: TakhlieMakhzanWhereInput
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    cursor?: TakhlieMakhzanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht.Test
   */
  export type TrikhDoreKesht$TestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    where?: TestWhereInput
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    cursor?: TestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht without action
   */
  export type TrikhDoreKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
  }


  /**
   * Model WeatherStation
   */

  export type AggregateWeatherStation = {
    _count: WeatherStationCountAggregateOutputType | null
    _avg: WeatherStationAvgAggregateOutputType | null
    _sum: WeatherStationSumAggregateOutputType | null
    _min: WeatherStationMinAggregateOutputType | null
    _max: WeatherStationMaxAggregateOutputType | null
  }

  export type WeatherStationAvgAggregateOutputType = {
    IdWeaSta: number | null
  }

  export type WeatherStationSumAggregateOutputType = {
    IdWeaSta: number | null
  }

  export type WeatherStationMinAggregateOutputType = {
    IdWeaSta: number | null
    Station: string | null
  }

  export type WeatherStationMaxAggregateOutputType = {
    IdWeaSta: number | null
    Station: string | null
  }

  export type WeatherStationCountAggregateOutputType = {
    IdWeaSta: number
    Station: number
    _all: number
  }


  export type WeatherStationAvgAggregateInputType = {
    IdWeaSta?: true
  }

  export type WeatherStationSumAggregateInputType = {
    IdWeaSta?: true
  }

  export type WeatherStationMinAggregateInputType = {
    IdWeaSta?: true
    Station?: true
  }

  export type WeatherStationMaxAggregateInputType = {
    IdWeaSta?: true
    Station?: true
  }

  export type WeatherStationCountAggregateInputType = {
    IdWeaSta?: true
    Station?: true
    _all?: true
  }

  export type WeatherStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherStation to aggregate.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherStations
    **/
    _count?: true | WeatherStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherStationMaxAggregateInputType
  }

  export type GetWeatherStationAggregateType<T extends WeatherStationAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherStation[P]>
      : GetScalarType<T[P], AggregateWeatherStation[P]>
  }




  export type WeatherStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherStationWhereInput
    orderBy?: WeatherStationOrderByWithAggregationInput | WeatherStationOrderByWithAggregationInput[]
    by: WeatherStationScalarFieldEnum[] | WeatherStationScalarFieldEnum
    having?: WeatherStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherStationCountAggregateInputType | true
    _avg?: WeatherStationAvgAggregateInputType
    _sum?: WeatherStationSumAggregateInputType
    _min?: WeatherStationMinAggregateInputType
    _max?: WeatherStationMaxAggregateInputType
  }

  export type WeatherStationGroupByOutputType = {
    IdWeaSta: number
    Station: string
    _count: WeatherStationCountAggregateOutputType | null
    _avg: WeatherStationAvgAggregateOutputType | null
    _sum: WeatherStationSumAggregateOutputType | null
    _min: WeatherStationMinAggregateOutputType | null
    _max: WeatherStationMaxAggregateOutputType | null
  }

  type GetWeatherStationGroupByPayload<T extends WeatherStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherStationGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherStationGroupByOutputType[P]>
        }
      >
    >


  export type WeatherStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdWeaSta?: boolean
    Station?: boolean
    RainfallStation?: boolean | WeatherStation$RainfallStationArgs<ExtArgs>
    _count?: boolean | WeatherStationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherStation"]>



  export type WeatherStationSelectScalar = {
    IdWeaSta?: boolean
    Station?: boolean
  }

  export type WeatherStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdWeaSta" | "Station", ExtArgs["result"]["weatherStation"]>
  export type WeatherStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainfallStation?: boolean | WeatherStation$RainfallStationArgs<ExtArgs>
    _count?: boolean | WeatherStationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WeatherStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherStation"
    objects: {
      RainfallStation: Prisma.$RainfallStationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdWeaSta: number
      Station: string
    }, ExtArgs["result"]["weatherStation"]>
    composites: {}
  }

  type WeatherStationGetPayload<S extends boolean | null | undefined | WeatherStationDefaultArgs> = $Result.GetResult<Prisma.$WeatherStationPayload, S>

  type WeatherStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherStationCountAggregateInputType | true
    }

  export interface WeatherStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherStation'], meta: { name: 'WeatherStation' } }
    /**
     * Find zero or one WeatherStation that matches the filter.
     * @param {WeatherStationFindUniqueArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherStationFindUniqueArgs>(args: SelectSubset<T, WeatherStationFindUniqueArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WeatherStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherStationFindUniqueOrThrowArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherStationFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindFirstArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherStationFindFirstArgs>(args?: SelectSubset<T, WeatherStationFindFirstArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindFirstOrThrowArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherStationFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WeatherStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherStations
     * const weatherStations = await prisma.weatherStation.findMany()
     * 
     * // Get first 10 WeatherStations
     * const weatherStations = await prisma.weatherStation.findMany({ take: 10 })
     * 
     * // Only select the `IdWeaSta`
     * const weatherStationWithIdWeaStaOnly = await prisma.weatherStation.findMany({ select: { IdWeaSta: true } })
     * 
     */
    findMany<T extends WeatherStationFindManyArgs>(args?: SelectSubset<T, WeatherStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WeatherStation.
     * @param {WeatherStationCreateArgs} args - Arguments to create a WeatherStation.
     * @example
     * // Create one WeatherStation
     * const WeatherStation = await prisma.weatherStation.create({
     *   data: {
     *     // ... data to create a WeatherStation
     *   }
     * })
     * 
     */
    create<T extends WeatherStationCreateArgs>(args: SelectSubset<T, WeatherStationCreateArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WeatherStations.
     * @param {WeatherStationCreateManyArgs} args - Arguments to create many WeatherStations.
     * @example
     * // Create many WeatherStations
     * const weatherStation = await prisma.weatherStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherStationCreateManyArgs>(args?: SelectSubset<T, WeatherStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WeatherStation.
     * @param {WeatherStationDeleteArgs} args - Arguments to delete one WeatherStation.
     * @example
     * // Delete one WeatherStation
     * const WeatherStation = await prisma.weatherStation.delete({
     *   where: {
     *     // ... filter to delete one WeatherStation
     *   }
     * })
     * 
     */
    delete<T extends WeatherStationDeleteArgs>(args: SelectSubset<T, WeatherStationDeleteArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WeatherStation.
     * @param {WeatherStationUpdateArgs} args - Arguments to update one WeatherStation.
     * @example
     * // Update one WeatherStation
     * const weatherStation = await prisma.weatherStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherStationUpdateArgs>(args: SelectSubset<T, WeatherStationUpdateArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WeatherStations.
     * @param {WeatherStationDeleteManyArgs} args - Arguments to filter WeatherStations to delete.
     * @example
     * // Delete a few WeatherStations
     * const { count } = await prisma.weatherStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherStationDeleteManyArgs>(args?: SelectSubset<T, WeatherStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherStations
     * const weatherStation = await prisma.weatherStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherStationUpdateManyArgs>(args: SelectSubset<T, WeatherStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeatherStation.
     * @param {WeatherStationUpsertArgs} args - Arguments to update or create a WeatherStation.
     * @example
     * // Update or create a WeatherStation
     * const weatherStation = await prisma.weatherStation.upsert({
     *   create: {
     *     // ... data to create a WeatherStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherStation we want to update
     *   }
     * })
     */
    upsert<T extends WeatherStationUpsertArgs>(args: SelectSubset<T, WeatherStationUpsertArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WeatherStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationCountArgs} args - Arguments to filter WeatherStations to count.
     * @example
     * // Count the number of WeatherStations
     * const count = await prisma.weatherStation.count({
     *   where: {
     *     // ... the filter for the WeatherStations we want to count
     *   }
     * })
    **/
    count<T extends WeatherStationCountArgs>(
      args?: Subset<T, WeatherStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherStationAggregateArgs>(args: Subset<T, WeatherStationAggregateArgs>): Prisma.PrismaPromise<GetWeatherStationAggregateType<T>>

    /**
     * Group by WeatherStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherStationGroupByArgs['orderBy'] }
        : { orderBy?: WeatherStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherStation model
   */
  readonly fields: WeatherStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainfallStation<T extends WeatherStation$RainfallStationArgs<ExtArgs> = {}>(args?: Subset<T, WeatherStation$RainfallStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherStation model
   */ 
  interface WeatherStationFieldRefs {
    readonly IdWeaSta: FieldRef<"WeatherStation", 'Int'>
    readonly Station: FieldRef<"WeatherStation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeatherStation findUnique
   */
  export type WeatherStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation findUniqueOrThrow
   */
  export type WeatherStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation findFirst
   */
  export type WeatherStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherStations.
     */
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation findFirstOrThrow
   */
  export type WeatherStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherStations.
     */
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation findMany
   */
  export type WeatherStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter, which WeatherStations to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation create
   */
  export type WeatherStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * The data needed to create a WeatherStation.
     */
    data: XOR<WeatherStationCreateInput, WeatherStationUncheckedCreateInput>
  }

  /**
   * WeatherStation createMany
   */
  export type WeatherStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherStations.
     */
    data: WeatherStationCreateManyInput | WeatherStationCreateManyInput[]
  }

  /**
   * WeatherStation update
   */
  export type WeatherStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * The data needed to update a WeatherStation.
     */
    data: XOR<WeatherStationUpdateInput, WeatherStationUncheckedUpdateInput>
    /**
     * Choose, which WeatherStation to update.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation updateMany
   */
  export type WeatherStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherStations.
     */
    data: XOR<WeatherStationUpdateManyMutationInput, WeatherStationUncheckedUpdateManyInput>
    /**
     * Filter which WeatherStations to update
     */
    where?: WeatherStationWhereInput
    /**
     * Limit how many WeatherStations to update.
     */
    limit?: number
  }

  /**
   * WeatherStation upsert
   */
  export type WeatherStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * The filter to search for the WeatherStation to update in case it exists.
     */
    where: WeatherStationWhereUniqueInput
    /**
     * In case the WeatherStation found by the `where` argument doesn't exist, create a new WeatherStation with this data.
     */
    create: XOR<WeatherStationCreateInput, WeatherStationUncheckedCreateInput>
    /**
     * In case the WeatherStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherStationUpdateInput, WeatherStationUncheckedUpdateInput>
  }

  /**
   * WeatherStation delete
   */
  export type WeatherStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
    /**
     * Filter which WeatherStation to delete.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation deleteMany
   */
  export type WeatherStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherStations to delete
     */
    where?: WeatherStationWhereInput
    /**
     * Limit how many WeatherStations to delete.
     */
    limit?: number
  }

  /**
   * WeatherStation.RainfallStation
   */
  export type WeatherStation$RainfallStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainfallStationInclude<ExtArgs> | null
    where?: RainfallStationWhereInput
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    cursor?: RainfallStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * WeatherStation without action
   */
  export type WeatherStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherStationInclude<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Uint8Array | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>



  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }

  export type sysdiagramsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "principal_id" | "diagram_id" | "version" | "definition", ExtArgs["result"]["sysdiagrams"]>

  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Uint8Array | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */ 
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to update.
     */
    limit?: number
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to delete.
     */
    limit?: number
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
  }


  /**
   * Model MahShamsi
   */

  export type AggregateMahShamsi = {
    _count: MahShamsiCountAggregateOutputType | null
    _avg: MahShamsiAvgAggregateOutputType | null
    _sum: MahShamsiSumAggregateOutputType | null
    _min: MahShamsiMinAggregateOutputType | null
    _max: MahShamsiMaxAggregateOutputType | null
  }

  export type MahShamsiAvgAggregateOutputType = {
    IdMah: number | null
  }

  export type MahShamsiSumAggregateOutputType = {
    IdMah: number | null
  }

  export type MahShamsiMinAggregateOutputType = {
    IdMah: number | null
    Mah: string | null
  }

  export type MahShamsiMaxAggregateOutputType = {
    IdMah: number | null
    Mah: string | null
  }

  export type MahShamsiCountAggregateOutputType = {
    IdMah: number
    Mah: number
    _all: number
  }


  export type MahShamsiAvgAggregateInputType = {
    IdMah?: true
  }

  export type MahShamsiSumAggregateInputType = {
    IdMah?: true
  }

  export type MahShamsiMinAggregateInputType = {
    IdMah?: true
    Mah?: true
  }

  export type MahShamsiMaxAggregateInputType = {
    IdMah?: true
    Mah?: true
  }

  export type MahShamsiCountAggregateInputType = {
    IdMah?: true
    Mah?: true
    _all?: true
  }

  export type MahShamsiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MahShamsi to aggregate.
     */
    where?: MahShamsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MahShamsis to fetch.
     */
    orderBy?: MahShamsiOrderByWithRelationInput | MahShamsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MahShamsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MahShamsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MahShamsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MahShamsis
    **/
    _count?: true | MahShamsiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MahShamsiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MahShamsiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MahShamsiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MahShamsiMaxAggregateInputType
  }

  export type GetMahShamsiAggregateType<T extends MahShamsiAggregateArgs> = {
        [P in keyof T & keyof AggregateMahShamsi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMahShamsi[P]>
      : GetScalarType<T[P], AggregateMahShamsi[P]>
  }




  export type MahShamsiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahShamsiWhereInput
    orderBy?: MahShamsiOrderByWithAggregationInput | MahShamsiOrderByWithAggregationInput[]
    by: MahShamsiScalarFieldEnum[] | MahShamsiScalarFieldEnum
    having?: MahShamsiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MahShamsiCountAggregateInputType | true
    _avg?: MahShamsiAvgAggregateInputType
    _sum?: MahShamsiSumAggregateInputType
    _min?: MahShamsiMinAggregateInputType
    _max?: MahShamsiMaxAggregateInputType
  }

  export type MahShamsiGroupByOutputType = {
    IdMah: number
    Mah: string
    _count: MahShamsiCountAggregateOutputType | null
    _avg: MahShamsiAvgAggregateOutputType | null
    _sum: MahShamsiSumAggregateOutputType | null
    _min: MahShamsiMinAggregateOutputType | null
    _max: MahShamsiMaxAggregateOutputType | null
  }

  type GetMahShamsiGroupByPayload<T extends MahShamsiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MahShamsiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MahShamsiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MahShamsiGroupByOutputType[P]>
            : GetScalarType<T[P], MahShamsiGroupByOutputType[P]>
        }
      >
    >


  export type MahShamsiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMah?: boolean
    Mah?: boolean
    BareshMotaleat?: boolean | MahShamsi$BareshMotaleatArgs<ExtArgs>
    TrikhDoreKesht?: boolean | MahShamsi$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | MahShamsiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mahShamsi"]>



  export type MahShamsiSelectScalar = {
    IdMah?: boolean
    Mah?: boolean
  }

  export type MahShamsiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMah" | "Mah", ExtArgs["result"]["mahShamsi"]>
  export type MahShamsiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BareshMotaleat?: boolean | MahShamsi$BareshMotaleatArgs<ExtArgs>
    TrikhDoreKesht?: boolean | MahShamsi$TrikhDoreKeshtArgs<ExtArgs>
    _count?: boolean | MahShamsiCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MahShamsiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MahShamsi"
    objects: {
      BareshMotaleat: Prisma.$BareshMotaleatPayload<ExtArgs>[]
      TrikhDoreKesht: Prisma.$TrikhDoreKeshtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IdMah: number
      Mah: string
    }, ExtArgs["result"]["mahShamsi"]>
    composites: {}
  }

  type MahShamsiGetPayload<S extends boolean | null | undefined | MahShamsiDefaultArgs> = $Result.GetResult<Prisma.$MahShamsiPayload, S>

  type MahShamsiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MahShamsiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MahShamsiCountAggregateInputType | true
    }

  export interface MahShamsiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MahShamsi'], meta: { name: 'MahShamsi' } }
    /**
     * Find zero or one MahShamsi that matches the filter.
     * @param {MahShamsiFindUniqueArgs} args - Arguments to find a MahShamsi
     * @example
     * // Get one MahShamsi
     * const mahShamsi = await prisma.mahShamsi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MahShamsiFindUniqueArgs>(args: SelectSubset<T, MahShamsiFindUniqueArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MahShamsi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MahShamsiFindUniqueOrThrowArgs} args - Arguments to find a MahShamsi
     * @example
     * // Get one MahShamsi
     * const mahShamsi = await prisma.mahShamsi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MahShamsiFindUniqueOrThrowArgs>(args: SelectSubset<T, MahShamsiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MahShamsi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiFindFirstArgs} args - Arguments to find a MahShamsi
     * @example
     * // Get one MahShamsi
     * const mahShamsi = await prisma.mahShamsi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MahShamsiFindFirstArgs>(args?: SelectSubset<T, MahShamsiFindFirstArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MahShamsi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiFindFirstOrThrowArgs} args - Arguments to find a MahShamsi
     * @example
     * // Get one MahShamsi
     * const mahShamsi = await prisma.mahShamsi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MahShamsiFindFirstOrThrowArgs>(args?: SelectSubset<T, MahShamsiFindFirstOrThrowArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MahShamsis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MahShamsis
     * const mahShamsis = await prisma.mahShamsi.findMany()
     * 
     * // Get first 10 MahShamsis
     * const mahShamsis = await prisma.mahShamsi.findMany({ take: 10 })
     * 
     * // Only select the `IdMah`
     * const mahShamsiWithIdMahOnly = await prisma.mahShamsi.findMany({ select: { IdMah: true } })
     * 
     */
    findMany<T extends MahShamsiFindManyArgs>(args?: SelectSubset<T, MahShamsiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MahShamsi.
     * @param {MahShamsiCreateArgs} args - Arguments to create a MahShamsi.
     * @example
     * // Create one MahShamsi
     * const MahShamsi = await prisma.mahShamsi.create({
     *   data: {
     *     // ... data to create a MahShamsi
     *   }
     * })
     * 
     */
    create<T extends MahShamsiCreateArgs>(args: SelectSubset<T, MahShamsiCreateArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MahShamsis.
     * @param {MahShamsiCreateManyArgs} args - Arguments to create many MahShamsis.
     * @example
     * // Create many MahShamsis
     * const mahShamsi = await prisma.mahShamsi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MahShamsiCreateManyArgs>(args?: SelectSubset<T, MahShamsiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MahShamsi.
     * @param {MahShamsiDeleteArgs} args - Arguments to delete one MahShamsi.
     * @example
     * // Delete one MahShamsi
     * const MahShamsi = await prisma.mahShamsi.delete({
     *   where: {
     *     // ... filter to delete one MahShamsi
     *   }
     * })
     * 
     */
    delete<T extends MahShamsiDeleteArgs>(args: SelectSubset<T, MahShamsiDeleteArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MahShamsi.
     * @param {MahShamsiUpdateArgs} args - Arguments to update one MahShamsi.
     * @example
     * // Update one MahShamsi
     * const mahShamsi = await prisma.mahShamsi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MahShamsiUpdateArgs>(args: SelectSubset<T, MahShamsiUpdateArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MahShamsis.
     * @param {MahShamsiDeleteManyArgs} args - Arguments to filter MahShamsis to delete.
     * @example
     * // Delete a few MahShamsis
     * const { count } = await prisma.mahShamsi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MahShamsiDeleteManyArgs>(args?: SelectSubset<T, MahShamsiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MahShamsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MahShamsis
     * const mahShamsi = await prisma.mahShamsi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MahShamsiUpdateManyArgs>(args: SelectSubset<T, MahShamsiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MahShamsi.
     * @param {MahShamsiUpsertArgs} args - Arguments to update or create a MahShamsi.
     * @example
     * // Update or create a MahShamsi
     * const mahShamsi = await prisma.mahShamsi.upsert({
     *   create: {
     *     // ... data to create a MahShamsi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MahShamsi we want to update
     *   }
     * })
     */
    upsert<T extends MahShamsiUpsertArgs>(args: SelectSubset<T, MahShamsiUpsertArgs<ExtArgs>>): Prisma__MahShamsiClient<$Result.GetResult<Prisma.$MahShamsiPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MahShamsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiCountArgs} args - Arguments to filter MahShamsis to count.
     * @example
     * // Count the number of MahShamsis
     * const count = await prisma.mahShamsi.count({
     *   where: {
     *     // ... the filter for the MahShamsis we want to count
     *   }
     * })
    **/
    count<T extends MahShamsiCountArgs>(
      args?: Subset<T, MahShamsiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MahShamsiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MahShamsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MahShamsiAggregateArgs>(args: Subset<T, MahShamsiAggregateArgs>): Prisma.PrismaPromise<GetMahShamsiAggregateType<T>>

    /**
     * Group by MahShamsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahShamsiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MahShamsiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MahShamsiGroupByArgs['orderBy'] }
        : { orderBy?: MahShamsiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MahShamsiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMahShamsiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MahShamsi model
   */
  readonly fields: MahShamsiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MahShamsi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MahShamsiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BareshMotaleat<T extends MahShamsi$BareshMotaleatArgs<ExtArgs> = {}>(args?: Subset<T, MahShamsi$BareshMotaleatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TrikhDoreKesht<T extends MahShamsi$TrikhDoreKeshtArgs<ExtArgs> = {}>(args?: Subset<T, MahShamsi$TrikhDoreKeshtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MahShamsi model
   */ 
  interface MahShamsiFieldRefs {
    readonly IdMah: FieldRef<"MahShamsi", 'Int'>
    readonly Mah: FieldRef<"MahShamsi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MahShamsi findUnique
   */
  export type MahShamsiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter, which MahShamsi to fetch.
     */
    where: MahShamsiWhereUniqueInput
  }

  /**
   * MahShamsi findUniqueOrThrow
   */
  export type MahShamsiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter, which MahShamsi to fetch.
     */
    where: MahShamsiWhereUniqueInput
  }

  /**
   * MahShamsi findFirst
   */
  export type MahShamsiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter, which MahShamsi to fetch.
     */
    where?: MahShamsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MahShamsis to fetch.
     */
    orderBy?: MahShamsiOrderByWithRelationInput | MahShamsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MahShamsis.
     */
    cursor?: MahShamsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MahShamsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MahShamsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MahShamsis.
     */
    distinct?: MahShamsiScalarFieldEnum | MahShamsiScalarFieldEnum[]
  }

  /**
   * MahShamsi findFirstOrThrow
   */
  export type MahShamsiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter, which MahShamsi to fetch.
     */
    where?: MahShamsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MahShamsis to fetch.
     */
    orderBy?: MahShamsiOrderByWithRelationInput | MahShamsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MahShamsis.
     */
    cursor?: MahShamsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MahShamsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MahShamsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MahShamsis.
     */
    distinct?: MahShamsiScalarFieldEnum | MahShamsiScalarFieldEnum[]
  }

  /**
   * MahShamsi findMany
   */
  export type MahShamsiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter, which MahShamsis to fetch.
     */
    where?: MahShamsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MahShamsis to fetch.
     */
    orderBy?: MahShamsiOrderByWithRelationInput | MahShamsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MahShamsis.
     */
    cursor?: MahShamsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MahShamsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MahShamsis.
     */
    skip?: number
    distinct?: MahShamsiScalarFieldEnum | MahShamsiScalarFieldEnum[]
  }

  /**
   * MahShamsi create
   */
  export type MahShamsiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * The data needed to create a MahShamsi.
     */
    data: XOR<MahShamsiCreateInput, MahShamsiUncheckedCreateInput>
  }

  /**
   * MahShamsi createMany
   */
  export type MahShamsiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MahShamsis.
     */
    data: MahShamsiCreateManyInput | MahShamsiCreateManyInput[]
  }

  /**
   * MahShamsi update
   */
  export type MahShamsiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * The data needed to update a MahShamsi.
     */
    data: XOR<MahShamsiUpdateInput, MahShamsiUncheckedUpdateInput>
    /**
     * Choose, which MahShamsi to update.
     */
    where: MahShamsiWhereUniqueInput
  }

  /**
   * MahShamsi updateMany
   */
  export type MahShamsiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MahShamsis.
     */
    data: XOR<MahShamsiUpdateManyMutationInput, MahShamsiUncheckedUpdateManyInput>
    /**
     * Filter which MahShamsis to update
     */
    where?: MahShamsiWhereInput
    /**
     * Limit how many MahShamsis to update.
     */
    limit?: number
  }

  /**
   * MahShamsi upsert
   */
  export type MahShamsiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * The filter to search for the MahShamsi to update in case it exists.
     */
    where: MahShamsiWhereUniqueInput
    /**
     * In case the MahShamsi found by the `where` argument doesn't exist, create a new MahShamsi with this data.
     */
    create: XOR<MahShamsiCreateInput, MahShamsiUncheckedCreateInput>
    /**
     * In case the MahShamsi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MahShamsiUpdateInput, MahShamsiUncheckedUpdateInput>
  }

  /**
   * MahShamsi delete
   */
  export type MahShamsiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
    /**
     * Filter which MahShamsi to delete.
     */
    where: MahShamsiWhereUniqueInput
  }

  /**
   * MahShamsi deleteMany
   */
  export type MahShamsiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MahShamsis to delete
     */
    where?: MahShamsiWhereInput
    /**
     * Limit how many MahShamsis to delete.
     */
    limit?: number
  }

  /**
   * MahShamsi.BareshMotaleat
   */
  export type MahShamsi$BareshMotaleatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BareshMotaleatInclude<ExtArgs> | null
    where?: BareshMotaleatWhereInput
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    cursor?: BareshMotaleatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * MahShamsi.TrikhDoreKesht
   */
  export type MahShamsi$TrikhDoreKeshtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrikhDoreKeshtInclude<ExtArgs> | null
    where?: TrikhDoreKeshtWhereInput
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    cursor?: TrikhDoreKeshtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * MahShamsi without action
   */
  export type MahShamsiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahShamsi
     */
    select?: MahShamsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MahShamsi
     */
    omit?: MahShamsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahShamsiInclude<ExtArgs> | null
  }


  /**
   * Model ShabakeDoreKesht
   */

  export type AggregateShabakeDoreKesht = {
    _count: ShabakeDoreKeshtCountAggregateOutputType | null
    _avg: ShabakeDoreKeshtAvgAggregateOutputType | null
    _sum: ShabakeDoreKeshtSumAggregateOutputType | null
    _min: ShabakeDoreKeshtMinAggregateOutputType | null
    _max: ShabakeDoreKeshtMaxAggregateOutputType | null
  }

  export type ShabakeDoreKeshtAvgAggregateOutputType = {
    IdShDo: number | null
    FIdNet: number | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type ShabakeDoreKeshtSumAggregateOutputType = {
    IdShDo: number | null
    FIdNet: number | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type ShabakeDoreKeshtMinAggregateOutputType = {
    IdShDo: number | null
    FIdNet: number | null
    TrikhShorooe: Date | null
    TrikhPayan: Date | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type ShabakeDoreKeshtMaxAggregateOutputType = {
    IdShDo: number | null
    FIdNet: number | null
    TrikhShorooe: Date | null
    TrikhPayan: Date | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type ShabakeDoreKeshtCountAggregateOutputType = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: number
    TrikhPayan: number
    FIdSal: number
    FIdDore: number
    _all: number
  }


  export type ShabakeDoreKeshtAvgAggregateInputType = {
    IdShDo?: true
    FIdNet?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type ShabakeDoreKeshtSumAggregateInputType = {
    IdShDo?: true
    FIdNet?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type ShabakeDoreKeshtMinAggregateInputType = {
    IdShDo?: true
    FIdNet?: true
    TrikhShorooe?: true
    TrikhPayan?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type ShabakeDoreKeshtMaxAggregateInputType = {
    IdShDo?: true
    FIdNet?: true
    TrikhShorooe?: true
    TrikhPayan?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type ShabakeDoreKeshtCountAggregateInputType = {
    IdShDo?: true
    FIdNet?: true
    TrikhShorooe?: true
    TrikhPayan?: true
    FIdSal?: true
    FIdDore?: true
    _all?: true
  }

  export type ShabakeDoreKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShabakeDoreKesht to aggregate.
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShabakeDoreKeshts to fetch.
     */
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShabakeDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShabakeDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShabakeDoreKeshts
    **/
    _count?: true | ShabakeDoreKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShabakeDoreKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShabakeDoreKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShabakeDoreKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShabakeDoreKeshtMaxAggregateInputType
  }

  export type GetShabakeDoreKeshtAggregateType<T extends ShabakeDoreKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateShabakeDoreKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShabakeDoreKesht[P]>
      : GetScalarType<T[P], AggregateShabakeDoreKesht[P]>
  }




  export type ShabakeDoreKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShabakeDoreKeshtWhereInput
    orderBy?: ShabakeDoreKeshtOrderByWithAggregationInput | ShabakeDoreKeshtOrderByWithAggregationInput[]
    by: ShabakeDoreKeshtScalarFieldEnum[] | ShabakeDoreKeshtScalarFieldEnum
    having?: ShabakeDoreKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShabakeDoreKeshtCountAggregateInputType | true
    _avg?: ShabakeDoreKeshtAvgAggregateInputType
    _sum?: ShabakeDoreKeshtSumAggregateInputType
    _min?: ShabakeDoreKeshtMinAggregateInputType
    _max?: ShabakeDoreKeshtMaxAggregateInputType
  }

  export type ShabakeDoreKeshtGroupByOutputType = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date
    TrikhPayan: Date
    FIdSal: number
    FIdDore: number
    _count: ShabakeDoreKeshtCountAggregateOutputType | null
    _avg: ShabakeDoreKeshtAvgAggregateOutputType | null
    _sum: ShabakeDoreKeshtSumAggregateOutputType | null
    _min: ShabakeDoreKeshtMinAggregateOutputType | null
    _max: ShabakeDoreKeshtMaxAggregateOutputType | null
  }

  type GetShabakeDoreKeshtGroupByPayload<T extends ShabakeDoreKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShabakeDoreKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShabakeDoreKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShabakeDoreKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], ShabakeDoreKeshtGroupByOutputType[P]>
        }
      >
    >


  export type ShabakeDoreKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdShDo?: boolean
    FIdNet?: boolean
    TrikhShorooe?: boolean
    TrikhPayan?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    BahrebardariKeshtDore?: boolean | ShabakeDoreKesht$BahrebardariKeshtDoreArgs<ExtArgs>
    DoreKesht?: boolean | DoreKeshtDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
    SaleZeraee?: boolean | SaleZeraeeDefaultArgs<ExtArgs>
    _count?: boolean | ShabakeDoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shabakeDoreKesht"]>



  export type ShabakeDoreKeshtSelectScalar = {
    IdShDo?: boolean
    FIdNet?: boolean
    TrikhShorooe?: boolean
    TrikhPayan?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
  }

  export type ShabakeDoreKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdShDo" | "FIdNet" | "TrikhShorooe" | "TrikhPayan" | "FIdSal" | "FIdDore", ExtArgs["result"]["shabakeDoreKesht"]>
  export type ShabakeDoreKeshtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BahrebardariKeshtDore?: boolean | ShabakeDoreKesht$BahrebardariKeshtDoreArgs<ExtArgs>
    DoreKesht?: boolean | DoreKeshtDefaultArgs<ExtArgs>
    Network?: boolean | NetworkDefaultArgs<ExtArgs>
    SaleZeraee?: boolean | SaleZeraeeDefaultArgs<ExtArgs>
    _count?: boolean | ShabakeDoreKeshtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShabakeDoreKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShabakeDoreKesht"
    objects: {
      BahrebardariKeshtDore: Prisma.$BahrebardariKeshtDorePayload<ExtArgs>[]
      DoreKesht: Prisma.$DoreKeshtPayload<ExtArgs>
      Network: Prisma.$NetworkPayload<ExtArgs>
      SaleZeraee: Prisma.$SaleZeraeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdShDo: number
      FIdNet: number
      TrikhShorooe: Date
      TrikhPayan: Date
      FIdSal: number
      FIdDore: number
    }, ExtArgs["result"]["shabakeDoreKesht"]>
    composites: {}
  }

  type ShabakeDoreKeshtGetPayload<S extends boolean | null | undefined | ShabakeDoreKeshtDefaultArgs> = $Result.GetResult<Prisma.$ShabakeDoreKeshtPayload, S>

  type ShabakeDoreKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShabakeDoreKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShabakeDoreKeshtCountAggregateInputType | true
    }

  export interface ShabakeDoreKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShabakeDoreKesht'], meta: { name: 'ShabakeDoreKesht' } }
    /**
     * Find zero or one ShabakeDoreKesht that matches the filter.
     * @param {ShabakeDoreKeshtFindUniqueArgs} args - Arguments to find a ShabakeDoreKesht
     * @example
     * // Get one ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShabakeDoreKeshtFindUniqueArgs>(args: SelectSubset<T, ShabakeDoreKeshtFindUniqueArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ShabakeDoreKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShabakeDoreKeshtFindUniqueOrThrowArgs} args - Arguments to find a ShabakeDoreKesht
     * @example
     * // Get one ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShabakeDoreKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, ShabakeDoreKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ShabakeDoreKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtFindFirstArgs} args - Arguments to find a ShabakeDoreKesht
     * @example
     * // Get one ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShabakeDoreKeshtFindFirstArgs>(args?: SelectSubset<T, ShabakeDoreKeshtFindFirstArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ShabakeDoreKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtFindFirstOrThrowArgs} args - Arguments to find a ShabakeDoreKesht
     * @example
     * // Get one ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShabakeDoreKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, ShabakeDoreKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ShabakeDoreKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShabakeDoreKeshts
     * const shabakeDoreKeshts = await prisma.shabakeDoreKesht.findMany()
     * 
     * // Get first 10 ShabakeDoreKeshts
     * const shabakeDoreKeshts = await prisma.shabakeDoreKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdShDo`
     * const shabakeDoreKeshtWithIdShDoOnly = await prisma.shabakeDoreKesht.findMany({ select: { IdShDo: true } })
     * 
     */
    findMany<T extends ShabakeDoreKeshtFindManyArgs>(args?: SelectSubset<T, ShabakeDoreKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ShabakeDoreKesht.
     * @param {ShabakeDoreKeshtCreateArgs} args - Arguments to create a ShabakeDoreKesht.
     * @example
     * // Create one ShabakeDoreKesht
     * const ShabakeDoreKesht = await prisma.shabakeDoreKesht.create({
     *   data: {
     *     // ... data to create a ShabakeDoreKesht
     *   }
     * })
     * 
     */
    create<T extends ShabakeDoreKeshtCreateArgs>(args: SelectSubset<T, ShabakeDoreKeshtCreateArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ShabakeDoreKeshts.
     * @param {ShabakeDoreKeshtCreateManyArgs} args - Arguments to create many ShabakeDoreKeshts.
     * @example
     * // Create many ShabakeDoreKeshts
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShabakeDoreKeshtCreateManyArgs>(args?: SelectSubset<T, ShabakeDoreKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShabakeDoreKesht.
     * @param {ShabakeDoreKeshtDeleteArgs} args - Arguments to delete one ShabakeDoreKesht.
     * @example
     * // Delete one ShabakeDoreKesht
     * const ShabakeDoreKesht = await prisma.shabakeDoreKesht.delete({
     *   where: {
     *     // ... filter to delete one ShabakeDoreKesht
     *   }
     * })
     * 
     */
    delete<T extends ShabakeDoreKeshtDeleteArgs>(args: SelectSubset<T, ShabakeDoreKeshtDeleteArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ShabakeDoreKesht.
     * @param {ShabakeDoreKeshtUpdateArgs} args - Arguments to update one ShabakeDoreKesht.
     * @example
     * // Update one ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShabakeDoreKeshtUpdateArgs>(args: SelectSubset<T, ShabakeDoreKeshtUpdateArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ShabakeDoreKeshts.
     * @param {ShabakeDoreKeshtDeleteManyArgs} args - Arguments to filter ShabakeDoreKeshts to delete.
     * @example
     * // Delete a few ShabakeDoreKeshts
     * const { count } = await prisma.shabakeDoreKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShabakeDoreKeshtDeleteManyArgs>(args?: SelectSubset<T, ShabakeDoreKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShabakeDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShabakeDoreKeshts
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShabakeDoreKeshtUpdateManyArgs>(args: SelectSubset<T, ShabakeDoreKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShabakeDoreKesht.
     * @param {ShabakeDoreKeshtUpsertArgs} args - Arguments to update or create a ShabakeDoreKesht.
     * @example
     * // Update or create a ShabakeDoreKesht
     * const shabakeDoreKesht = await prisma.shabakeDoreKesht.upsert({
     *   create: {
     *     // ... data to create a ShabakeDoreKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShabakeDoreKesht we want to update
     *   }
     * })
     */
    upsert<T extends ShabakeDoreKeshtUpsertArgs>(args: SelectSubset<T, ShabakeDoreKeshtUpsertArgs<ExtArgs>>): Prisma__ShabakeDoreKeshtClient<$Result.GetResult<Prisma.$ShabakeDoreKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ShabakeDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtCountArgs} args - Arguments to filter ShabakeDoreKeshts to count.
     * @example
     * // Count the number of ShabakeDoreKeshts
     * const count = await prisma.shabakeDoreKesht.count({
     *   where: {
     *     // ... the filter for the ShabakeDoreKeshts we want to count
     *   }
     * })
    **/
    count<T extends ShabakeDoreKeshtCountArgs>(
      args?: Subset<T, ShabakeDoreKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShabakeDoreKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShabakeDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShabakeDoreKeshtAggregateArgs>(args: Subset<T, ShabakeDoreKeshtAggregateArgs>): Prisma.PrismaPromise<GetShabakeDoreKeshtAggregateType<T>>

    /**
     * Group by ShabakeDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShabakeDoreKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShabakeDoreKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShabakeDoreKeshtGroupByArgs['orderBy'] }
        : { orderBy?: ShabakeDoreKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShabakeDoreKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShabakeDoreKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShabakeDoreKesht model
   */
  readonly fields: ShabakeDoreKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShabakeDoreKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShabakeDoreKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BahrebardariKeshtDore<T extends ShabakeDoreKesht$BahrebardariKeshtDoreArgs<ExtArgs> = {}>(args?: Subset<T, ShabakeDoreKesht$BahrebardariKeshtDoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DoreKesht<T extends DoreKeshtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoreKeshtDefaultArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Network<T extends NetworkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDefaultArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    SaleZeraee<T extends SaleZeraeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleZeraeeDefaultArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShabakeDoreKesht model
   */ 
  interface ShabakeDoreKeshtFieldRefs {
    readonly IdShDo: FieldRef<"ShabakeDoreKesht", 'Int'>
    readonly FIdNet: FieldRef<"ShabakeDoreKesht", 'Int'>
    readonly TrikhShorooe: FieldRef<"ShabakeDoreKesht", 'DateTime'>
    readonly TrikhPayan: FieldRef<"ShabakeDoreKesht", 'DateTime'>
    readonly FIdSal: FieldRef<"ShabakeDoreKesht", 'Int'>
    readonly FIdDore: FieldRef<"ShabakeDoreKesht", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ShabakeDoreKesht findUnique
   */
  export type ShabakeDoreKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which ShabakeDoreKesht to fetch.
     */
    where: ShabakeDoreKeshtWhereUniqueInput
  }

  /**
   * ShabakeDoreKesht findUniqueOrThrow
   */
  export type ShabakeDoreKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which ShabakeDoreKesht to fetch.
     */
    where: ShabakeDoreKeshtWhereUniqueInput
  }

  /**
   * ShabakeDoreKesht findFirst
   */
  export type ShabakeDoreKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which ShabakeDoreKesht to fetch.
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShabakeDoreKeshts to fetch.
     */
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShabakeDoreKeshts.
     */
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShabakeDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShabakeDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShabakeDoreKeshts.
     */
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * ShabakeDoreKesht findFirstOrThrow
   */
  export type ShabakeDoreKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which ShabakeDoreKesht to fetch.
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShabakeDoreKeshts to fetch.
     */
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShabakeDoreKeshts.
     */
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShabakeDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShabakeDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShabakeDoreKeshts.
     */
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * ShabakeDoreKesht findMany
   */
  export type ShabakeDoreKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter, which ShabakeDoreKeshts to fetch.
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShabakeDoreKeshts to fetch.
     */
    orderBy?: ShabakeDoreKeshtOrderByWithRelationInput | ShabakeDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShabakeDoreKeshts.
     */
    cursor?: ShabakeDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShabakeDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShabakeDoreKeshts.
     */
    skip?: number
    distinct?: ShabakeDoreKeshtScalarFieldEnum | ShabakeDoreKeshtScalarFieldEnum[]
  }

  /**
   * ShabakeDoreKesht create
   */
  export type ShabakeDoreKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to create a ShabakeDoreKesht.
     */
    data: XOR<ShabakeDoreKeshtCreateInput, ShabakeDoreKeshtUncheckedCreateInput>
  }

  /**
   * ShabakeDoreKesht createMany
   */
  export type ShabakeDoreKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShabakeDoreKeshts.
     */
    data: ShabakeDoreKeshtCreateManyInput | ShabakeDoreKeshtCreateManyInput[]
  }

  /**
   * ShabakeDoreKesht update
   */
  export type ShabakeDoreKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * The data needed to update a ShabakeDoreKesht.
     */
    data: XOR<ShabakeDoreKeshtUpdateInput, ShabakeDoreKeshtUncheckedUpdateInput>
    /**
     * Choose, which ShabakeDoreKesht to update.
     */
    where: ShabakeDoreKeshtWhereUniqueInput
  }

  /**
   * ShabakeDoreKesht updateMany
   */
  export type ShabakeDoreKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShabakeDoreKeshts.
     */
    data: XOR<ShabakeDoreKeshtUpdateManyMutationInput, ShabakeDoreKeshtUncheckedUpdateManyInput>
    /**
     * Filter which ShabakeDoreKeshts to update
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * Limit how many ShabakeDoreKeshts to update.
     */
    limit?: number
  }

  /**
   * ShabakeDoreKesht upsert
   */
  export type ShabakeDoreKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * The filter to search for the ShabakeDoreKesht to update in case it exists.
     */
    where: ShabakeDoreKeshtWhereUniqueInput
    /**
     * In case the ShabakeDoreKesht found by the `where` argument doesn't exist, create a new ShabakeDoreKesht with this data.
     */
    create: XOR<ShabakeDoreKeshtCreateInput, ShabakeDoreKeshtUncheckedCreateInput>
    /**
     * In case the ShabakeDoreKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShabakeDoreKeshtUpdateInput, ShabakeDoreKeshtUncheckedUpdateInput>
  }

  /**
   * ShabakeDoreKesht delete
   */
  export type ShabakeDoreKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
    /**
     * Filter which ShabakeDoreKesht to delete.
     */
    where: ShabakeDoreKeshtWhereUniqueInput
  }

  /**
   * ShabakeDoreKesht deleteMany
   */
  export type ShabakeDoreKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShabakeDoreKeshts to delete
     */
    where?: ShabakeDoreKeshtWhereInput
    /**
     * Limit how many ShabakeDoreKeshts to delete.
     */
    limit?: number
  }

  /**
   * ShabakeDoreKesht.BahrebardariKeshtDore
   */
  export type ShabakeDoreKesht$BahrebardariKeshtDoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BahrebardariKeshtDoreInclude<ExtArgs> | null
    where?: BahrebardariKeshtDoreWhereInput
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * ShabakeDoreKesht without action
   */
  export type ShabakeDoreKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShabakeDoreKesht
     */
    select?: ShabakeDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShabakeDoreKesht
     */
    omit?: ShabakeDoreKeshtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShabakeDoreKeshtInclude<ExtArgs> | null
  }


  /**
   * Model TaeedProgram
   */

  export type AggregateTaeedProgram = {
    _count: TaeedProgramCountAggregateOutputType | null
    _avg: TaeedProgramAvgAggregateOutputType | null
    _sum: TaeedProgramSumAggregateOutputType | null
    _min: TaeedProgramMinAggregateOutputType | null
    _max: TaeedProgramMaxAggregateOutputType | null
  }

  export type TaeedProgramAvgAggregateOutputType = {
    IdTaeedProgram: number | null
    FIdPumpSta: number | null
    FIdSal: number | null
    FIdDore: number | null
    Sal: number | null
    Mah: number | null
    Dahe: number | null
    FIdUserErsal: number | null
    FIdUserAbMantaghe: number | null
    FIdUserPeymankar: number | null
    FIdUserAbNiroo: number | null
    FIdUserTaeedNahaee: number | null
  }

  export type TaeedProgramSumAggregateOutputType = {
    IdTaeedProgram: number | null
    FIdPumpSta: number | null
    FIdSal: number | null
    FIdDore: number | null
    Sal: number | null
    Mah: number | null
    Dahe: number | null
    FIdUserErsal: number | null
    FIdUserAbMantaghe: number | null
    FIdUserPeymankar: number | null
    FIdUserAbNiroo: number | null
    FIdUserTaeedNahaee: number | null
  }

  export type TaeedProgramMinAggregateOutputType = {
    IdTaeedProgram: number | null
    FIdPumpSta: number | null
    FIdSal: number | null
    FIdDore: number | null
    Sal: number | null
    Mah: number | null
    Dahe: number | null
    FIdUserErsal: number | null
    FirstNErsal: string | null
    LastNErsal: string | null
    TozihErsal: string | null
    TarikhErsal: Date | null
    FIdUserAbMantaghe: number | null
    FirstNAbMantaghe: string | null
    LastNAbMantaghe: string | null
    TozihAbMantaghe: string | null
    TarikhAbMantaghe: Date | null
    TaedAbMantaghe: boolean | null
    FIdUserPeymankar: number | null
    FirstNPeymankar: string | null
    LastNPeymankar: string | null
    TozihPeymankar: string | null
    TarikhPeymankar: Date | null
    TaedPeymankar: boolean | null
    FIdUserAbNiroo: number | null
    FirstNAbNiroo: string | null
    LastNAbNiroo: string | null
    TozihAbNiroo: string | null
    TarikhAbNiroo: Date | null
    TaedAbNiroo: string | null
    FileNameNahaee: string | null
    FilePathNahaee: string | null
    TarikhFileNahee: Date | null
    FIdUserTaeedNahaee: number | null
    FirstNTaeedNahaee: string | null
    LastNTaeedNahaee: string | null
    TarikhTaeedNahaee: Date | null
    TaeedNahaee: boolean | null
  }

  export type TaeedProgramMaxAggregateOutputType = {
    IdTaeedProgram: number | null
    FIdPumpSta: number | null
    FIdSal: number | null
    FIdDore: number | null
    Sal: number | null
    Mah: number | null
    Dahe: number | null
    FIdUserErsal: number | null
    FirstNErsal: string | null
    LastNErsal: string | null
    TozihErsal: string | null
    TarikhErsal: Date | null
    FIdUserAbMantaghe: number | null
    FirstNAbMantaghe: string | null
    LastNAbMantaghe: string | null
    TozihAbMantaghe: string | null
    TarikhAbMantaghe: Date | null
    TaedAbMantaghe: boolean | null
    FIdUserPeymankar: number | null
    FirstNPeymankar: string | null
    LastNPeymankar: string | null
    TozihPeymankar: string | null
    TarikhPeymankar: Date | null
    TaedPeymankar: boolean | null
    FIdUserAbNiroo: number | null
    FirstNAbNiroo: string | null
    LastNAbNiroo: string | null
    TozihAbNiroo: string | null
    TarikhAbNiroo: Date | null
    TaedAbNiroo: string | null
    FileNameNahaee: string | null
    FilePathNahaee: string | null
    TarikhFileNahee: Date | null
    FIdUserTaeedNahaee: number | null
    FirstNTaeedNahaee: string | null
    LastNTaeedNahaee: string | null
    TarikhTaeedNahaee: Date | null
    TaeedNahaee: boolean | null
  }

  export type TaeedProgramCountAggregateOutputType = {
    IdTaeedProgram: number
    FIdPumpSta: number
    FIdSal: number
    FIdDore: number
    Sal: number
    Mah: number
    Dahe: number
    FIdUserErsal: number
    FirstNErsal: number
    LastNErsal: number
    TozihErsal: number
    TarikhErsal: number
    FIdUserAbMantaghe: number
    FirstNAbMantaghe: number
    LastNAbMantaghe: number
    TozihAbMantaghe: number
    TarikhAbMantaghe: number
    TaedAbMantaghe: number
    FIdUserPeymankar: number
    FirstNPeymankar: number
    LastNPeymankar: number
    TozihPeymankar: number
    TarikhPeymankar: number
    TaedPeymankar: number
    FIdUserAbNiroo: number
    FirstNAbNiroo: number
    LastNAbNiroo: number
    TozihAbNiroo: number
    TarikhAbNiroo: number
    TaedAbNiroo: number
    FileNameNahaee: number
    FilePathNahaee: number
    TarikhFileNahee: number
    FIdUserTaeedNahaee: number
    FirstNTaeedNahaee: number
    LastNTaeedNahaee: number
    TarikhTaeedNahaee: number
    TaeedNahaee: number
    _all: number
  }


  export type TaeedProgramAvgAggregateInputType = {
    IdTaeedProgram?: true
    FIdPumpSta?: true
    FIdSal?: true
    FIdDore?: true
    Sal?: true
    Mah?: true
    Dahe?: true
    FIdUserErsal?: true
    FIdUserAbMantaghe?: true
    FIdUserPeymankar?: true
    FIdUserAbNiroo?: true
    FIdUserTaeedNahaee?: true
  }

  export type TaeedProgramSumAggregateInputType = {
    IdTaeedProgram?: true
    FIdPumpSta?: true
    FIdSal?: true
    FIdDore?: true
    Sal?: true
    Mah?: true
    Dahe?: true
    FIdUserErsal?: true
    FIdUserAbMantaghe?: true
    FIdUserPeymankar?: true
    FIdUserAbNiroo?: true
    FIdUserTaeedNahaee?: true
  }

  export type TaeedProgramMinAggregateInputType = {
    IdTaeedProgram?: true
    FIdPumpSta?: true
    FIdSal?: true
    FIdDore?: true
    Sal?: true
    Mah?: true
    Dahe?: true
    FIdUserErsal?: true
    FirstNErsal?: true
    LastNErsal?: true
    TozihErsal?: true
    TarikhErsal?: true
    FIdUserAbMantaghe?: true
    FirstNAbMantaghe?: true
    LastNAbMantaghe?: true
    TozihAbMantaghe?: true
    TarikhAbMantaghe?: true
    TaedAbMantaghe?: true
    FIdUserPeymankar?: true
    FirstNPeymankar?: true
    LastNPeymankar?: true
    TozihPeymankar?: true
    TarikhPeymankar?: true
    TaedPeymankar?: true
    FIdUserAbNiroo?: true
    FirstNAbNiroo?: true
    LastNAbNiroo?: true
    TozihAbNiroo?: true
    TarikhAbNiroo?: true
    TaedAbNiroo?: true
    FileNameNahaee?: true
    FilePathNahaee?: true
    TarikhFileNahee?: true
    FIdUserTaeedNahaee?: true
    FirstNTaeedNahaee?: true
    LastNTaeedNahaee?: true
    TarikhTaeedNahaee?: true
    TaeedNahaee?: true
  }

  export type TaeedProgramMaxAggregateInputType = {
    IdTaeedProgram?: true
    FIdPumpSta?: true
    FIdSal?: true
    FIdDore?: true
    Sal?: true
    Mah?: true
    Dahe?: true
    FIdUserErsal?: true
    FirstNErsal?: true
    LastNErsal?: true
    TozihErsal?: true
    TarikhErsal?: true
    FIdUserAbMantaghe?: true
    FirstNAbMantaghe?: true
    LastNAbMantaghe?: true
    TozihAbMantaghe?: true
    TarikhAbMantaghe?: true
    TaedAbMantaghe?: true
    FIdUserPeymankar?: true
    FirstNPeymankar?: true
    LastNPeymankar?: true
    TozihPeymankar?: true
    TarikhPeymankar?: true
    TaedPeymankar?: true
    FIdUserAbNiroo?: true
    FirstNAbNiroo?: true
    LastNAbNiroo?: true
    TozihAbNiroo?: true
    TarikhAbNiroo?: true
    TaedAbNiroo?: true
    FileNameNahaee?: true
    FilePathNahaee?: true
    TarikhFileNahee?: true
    FIdUserTaeedNahaee?: true
    FirstNTaeedNahaee?: true
    LastNTaeedNahaee?: true
    TarikhTaeedNahaee?: true
    TaeedNahaee?: true
  }

  export type TaeedProgramCountAggregateInputType = {
    IdTaeedProgram?: true
    FIdPumpSta?: true
    FIdSal?: true
    FIdDore?: true
    Sal?: true
    Mah?: true
    Dahe?: true
    FIdUserErsal?: true
    FirstNErsal?: true
    LastNErsal?: true
    TozihErsal?: true
    TarikhErsal?: true
    FIdUserAbMantaghe?: true
    FirstNAbMantaghe?: true
    LastNAbMantaghe?: true
    TozihAbMantaghe?: true
    TarikhAbMantaghe?: true
    TaedAbMantaghe?: true
    FIdUserPeymankar?: true
    FirstNPeymankar?: true
    LastNPeymankar?: true
    TozihPeymankar?: true
    TarikhPeymankar?: true
    TaedPeymankar?: true
    FIdUserAbNiroo?: true
    FirstNAbNiroo?: true
    LastNAbNiroo?: true
    TozihAbNiroo?: true
    TarikhAbNiroo?: true
    TaedAbNiroo?: true
    FileNameNahaee?: true
    FilePathNahaee?: true
    TarikhFileNahee?: true
    FIdUserTaeedNahaee?: true
    FirstNTaeedNahaee?: true
    LastNTaeedNahaee?: true
    TarikhTaeedNahaee?: true
    TaeedNahaee?: true
    _all?: true
  }

  export type TaeedProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaeedProgram to aggregate.
     */
    where?: TaeedProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaeedPrograms to fetch.
     */
    orderBy?: TaeedProgramOrderByWithRelationInput | TaeedProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaeedProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaeedPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaeedPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaeedPrograms
    **/
    _count?: true | TaeedProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaeedProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaeedProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaeedProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaeedProgramMaxAggregateInputType
  }

  export type GetTaeedProgramAggregateType<T extends TaeedProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateTaeedProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaeedProgram[P]>
      : GetScalarType<T[P], AggregateTaeedProgram[P]>
  }




  export type TaeedProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaeedProgramWhereInput
    orderBy?: TaeedProgramOrderByWithAggregationInput | TaeedProgramOrderByWithAggregationInput[]
    by: TaeedProgramScalarFieldEnum[] | TaeedProgramScalarFieldEnum
    having?: TaeedProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaeedProgramCountAggregateInputType | true
    _avg?: TaeedProgramAvgAggregateInputType
    _sum?: TaeedProgramSumAggregateInputType
    _min?: TaeedProgramMinAggregateInputType
    _max?: TaeedProgramMaxAggregateInputType
  }

  export type TaeedProgramGroupByOutputType = {
    IdTaeedProgram: number
    FIdPumpSta: number
    FIdSal: number
    FIdDore: number
    Sal: number
    Mah: number
    Dahe: number
    FIdUserErsal: number | null
    FirstNErsal: string | null
    LastNErsal: string | null
    TozihErsal: string | null
    TarikhErsal: Date | null
    FIdUserAbMantaghe: number | null
    FirstNAbMantaghe: string | null
    LastNAbMantaghe: string | null
    TozihAbMantaghe: string | null
    TarikhAbMantaghe: Date | null
    TaedAbMantaghe: boolean | null
    FIdUserPeymankar: number | null
    FirstNPeymankar: string | null
    LastNPeymankar: string | null
    TozihPeymankar: string | null
    TarikhPeymankar: Date | null
    TaedPeymankar: boolean | null
    FIdUserAbNiroo: number | null
    FirstNAbNiroo: string | null
    LastNAbNiroo: string | null
    TozihAbNiroo: string | null
    TarikhAbNiroo: Date | null
    TaedAbNiroo: string | null
    FileNameNahaee: string | null
    FilePathNahaee: string | null
    TarikhFileNahee: Date | null
    FIdUserTaeedNahaee: number | null
    FirstNTaeedNahaee: string | null
    LastNTaeedNahaee: string | null
    TarikhTaeedNahaee: Date | null
    TaeedNahaee: boolean | null
    _count: TaeedProgramCountAggregateOutputType | null
    _avg: TaeedProgramAvgAggregateOutputType | null
    _sum: TaeedProgramSumAggregateOutputType | null
    _min: TaeedProgramMinAggregateOutputType | null
    _max: TaeedProgramMaxAggregateOutputType | null
  }

  type GetTaeedProgramGroupByPayload<T extends TaeedProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaeedProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaeedProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaeedProgramGroupByOutputType[P]>
            : GetScalarType<T[P], TaeedProgramGroupByOutputType[P]>
        }
      >
    >


  export type TaeedProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTaeedProgram?: boolean
    FIdPumpSta?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Sal?: boolean
    Mah?: boolean
    Dahe?: boolean
    FIdUserErsal?: boolean
    FirstNErsal?: boolean
    LastNErsal?: boolean
    TozihErsal?: boolean
    TarikhErsal?: boolean
    FIdUserAbMantaghe?: boolean
    FirstNAbMantaghe?: boolean
    LastNAbMantaghe?: boolean
    TozihAbMantaghe?: boolean
    TarikhAbMantaghe?: boolean
    TaedAbMantaghe?: boolean
    FIdUserPeymankar?: boolean
    FirstNPeymankar?: boolean
    LastNPeymankar?: boolean
    TozihPeymankar?: boolean
    TarikhPeymankar?: boolean
    TaedPeymankar?: boolean
    FIdUserAbNiroo?: boolean
    FirstNAbNiroo?: boolean
    LastNAbNiroo?: boolean
    TozihAbNiroo?: boolean
    TarikhAbNiroo?: boolean
    TaedAbNiroo?: boolean
    FileNameNahaee?: boolean
    FilePathNahaee?: boolean
    TarikhFileNahee?: boolean
    FIdUserTaeedNahaee?: boolean
    FirstNTaeedNahaee?: boolean
    LastNTaeedNahaee?: boolean
    TarikhTaeedNahaee?: boolean
    TaeedNahaee?: boolean
  }, ExtArgs["result"]["taeedProgram"]>



  export type TaeedProgramSelectScalar = {
    IdTaeedProgram?: boolean
    FIdPumpSta?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Sal?: boolean
    Mah?: boolean
    Dahe?: boolean
    FIdUserErsal?: boolean
    FirstNErsal?: boolean
    LastNErsal?: boolean
    TozihErsal?: boolean
    TarikhErsal?: boolean
    FIdUserAbMantaghe?: boolean
    FirstNAbMantaghe?: boolean
    LastNAbMantaghe?: boolean
    TozihAbMantaghe?: boolean
    TarikhAbMantaghe?: boolean
    TaedAbMantaghe?: boolean
    FIdUserPeymankar?: boolean
    FirstNPeymankar?: boolean
    LastNPeymankar?: boolean
    TozihPeymankar?: boolean
    TarikhPeymankar?: boolean
    TaedPeymankar?: boolean
    FIdUserAbNiroo?: boolean
    FirstNAbNiroo?: boolean
    LastNAbNiroo?: boolean
    TozihAbNiroo?: boolean
    TarikhAbNiroo?: boolean
    TaedAbNiroo?: boolean
    FileNameNahaee?: boolean
    FilePathNahaee?: boolean
    TarikhFileNahee?: boolean
    FIdUserTaeedNahaee?: boolean
    FirstNTaeedNahaee?: boolean
    LastNTaeedNahaee?: boolean
    TarikhTaeedNahaee?: boolean
    TaeedNahaee?: boolean
  }

  export type TaeedProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTaeedProgram" | "FIdPumpSta" | "FIdSal" | "FIdDore" | "Sal" | "Mah" | "Dahe" | "FIdUserErsal" | "FirstNErsal" | "LastNErsal" | "TozihErsal" | "TarikhErsal" | "FIdUserAbMantaghe" | "FirstNAbMantaghe" | "LastNAbMantaghe" | "TozihAbMantaghe" | "TarikhAbMantaghe" | "TaedAbMantaghe" | "FIdUserPeymankar" | "FirstNPeymankar" | "LastNPeymankar" | "TozihPeymankar" | "TarikhPeymankar" | "TaedPeymankar" | "FIdUserAbNiroo" | "FirstNAbNiroo" | "LastNAbNiroo" | "TozihAbNiroo" | "TarikhAbNiroo" | "TaedAbNiroo" | "FileNameNahaee" | "FilePathNahaee" | "TarikhFileNahee" | "FIdUserTaeedNahaee" | "FirstNTaeedNahaee" | "LastNTaeedNahaee" | "TarikhTaeedNahaee" | "TaeedNahaee", ExtArgs["result"]["taeedProgram"]>

  export type $TaeedProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaeedProgram"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTaeedProgram: number
      FIdPumpSta: number
      FIdSal: number
      FIdDore: number
      Sal: number
      Mah: number
      Dahe: number
      FIdUserErsal: number | null
      FirstNErsal: string | null
      LastNErsal: string | null
      TozihErsal: string | null
      TarikhErsal: Date | null
      FIdUserAbMantaghe: number | null
      FirstNAbMantaghe: string | null
      LastNAbMantaghe: string | null
      TozihAbMantaghe: string | null
      TarikhAbMantaghe: Date | null
      TaedAbMantaghe: boolean | null
      FIdUserPeymankar: number | null
      FirstNPeymankar: string | null
      LastNPeymankar: string | null
      TozihPeymankar: string | null
      TarikhPeymankar: Date | null
      TaedPeymankar: boolean | null
      FIdUserAbNiroo: number | null
      FirstNAbNiroo: string | null
      LastNAbNiroo: string | null
      TozihAbNiroo: string | null
      TarikhAbNiroo: Date | null
      TaedAbNiroo: string | null
      FileNameNahaee: string | null
      FilePathNahaee: string | null
      TarikhFileNahee: Date | null
      FIdUserTaeedNahaee: number | null
      FirstNTaeedNahaee: string | null
      LastNTaeedNahaee: string | null
      TarikhTaeedNahaee: Date | null
      TaeedNahaee: boolean | null
    }, ExtArgs["result"]["taeedProgram"]>
    composites: {}
  }

  type TaeedProgramGetPayload<S extends boolean | null | undefined | TaeedProgramDefaultArgs> = $Result.GetResult<Prisma.$TaeedProgramPayload, S>

  type TaeedProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaeedProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaeedProgramCountAggregateInputType | true
    }

  export interface TaeedProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaeedProgram'], meta: { name: 'TaeedProgram' } }
    /**
     * Find zero or one TaeedProgram that matches the filter.
     * @param {TaeedProgramFindUniqueArgs} args - Arguments to find a TaeedProgram
     * @example
     * // Get one TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaeedProgramFindUniqueArgs>(args: SelectSubset<T, TaeedProgramFindUniqueArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TaeedProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaeedProgramFindUniqueOrThrowArgs} args - Arguments to find a TaeedProgram
     * @example
     * // Get one TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaeedProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, TaeedProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TaeedProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramFindFirstArgs} args - Arguments to find a TaeedProgram
     * @example
     * // Get one TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaeedProgramFindFirstArgs>(args?: SelectSubset<T, TaeedProgramFindFirstArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TaeedProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramFindFirstOrThrowArgs} args - Arguments to find a TaeedProgram
     * @example
     * // Get one TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaeedProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, TaeedProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TaeedPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaeedPrograms
     * const taeedPrograms = await prisma.taeedProgram.findMany()
     * 
     * // Get first 10 TaeedPrograms
     * const taeedPrograms = await prisma.taeedProgram.findMany({ take: 10 })
     * 
     * // Only select the `IdTaeedProgram`
     * const taeedProgramWithIdTaeedProgramOnly = await prisma.taeedProgram.findMany({ select: { IdTaeedProgram: true } })
     * 
     */
    findMany<T extends TaeedProgramFindManyArgs>(args?: SelectSubset<T, TaeedProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TaeedProgram.
     * @param {TaeedProgramCreateArgs} args - Arguments to create a TaeedProgram.
     * @example
     * // Create one TaeedProgram
     * const TaeedProgram = await prisma.taeedProgram.create({
     *   data: {
     *     // ... data to create a TaeedProgram
     *   }
     * })
     * 
     */
    create<T extends TaeedProgramCreateArgs>(args: SelectSubset<T, TaeedProgramCreateArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TaeedPrograms.
     * @param {TaeedProgramCreateManyArgs} args - Arguments to create many TaeedPrograms.
     * @example
     * // Create many TaeedPrograms
     * const taeedProgram = await prisma.taeedProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaeedProgramCreateManyArgs>(args?: SelectSubset<T, TaeedProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaeedProgram.
     * @param {TaeedProgramDeleteArgs} args - Arguments to delete one TaeedProgram.
     * @example
     * // Delete one TaeedProgram
     * const TaeedProgram = await prisma.taeedProgram.delete({
     *   where: {
     *     // ... filter to delete one TaeedProgram
     *   }
     * })
     * 
     */
    delete<T extends TaeedProgramDeleteArgs>(args: SelectSubset<T, TaeedProgramDeleteArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TaeedProgram.
     * @param {TaeedProgramUpdateArgs} args - Arguments to update one TaeedProgram.
     * @example
     * // Update one TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaeedProgramUpdateArgs>(args: SelectSubset<T, TaeedProgramUpdateArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TaeedPrograms.
     * @param {TaeedProgramDeleteManyArgs} args - Arguments to filter TaeedPrograms to delete.
     * @example
     * // Delete a few TaeedPrograms
     * const { count } = await prisma.taeedProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaeedProgramDeleteManyArgs>(args?: SelectSubset<T, TaeedProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaeedPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaeedPrograms
     * const taeedProgram = await prisma.taeedProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaeedProgramUpdateManyArgs>(args: SelectSubset<T, TaeedProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaeedProgram.
     * @param {TaeedProgramUpsertArgs} args - Arguments to update or create a TaeedProgram.
     * @example
     * // Update or create a TaeedProgram
     * const taeedProgram = await prisma.taeedProgram.upsert({
     *   create: {
     *     // ... data to create a TaeedProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaeedProgram we want to update
     *   }
     * })
     */
    upsert<T extends TaeedProgramUpsertArgs>(args: SelectSubset<T, TaeedProgramUpsertArgs<ExtArgs>>): Prisma__TaeedProgramClient<$Result.GetResult<Prisma.$TaeedProgramPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TaeedPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramCountArgs} args - Arguments to filter TaeedPrograms to count.
     * @example
     * // Count the number of TaeedPrograms
     * const count = await prisma.taeedProgram.count({
     *   where: {
     *     // ... the filter for the TaeedPrograms we want to count
     *   }
     * })
    **/
    count<T extends TaeedProgramCountArgs>(
      args?: Subset<T, TaeedProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaeedProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaeedProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaeedProgramAggregateArgs>(args: Subset<T, TaeedProgramAggregateArgs>): Prisma.PrismaPromise<GetTaeedProgramAggregateType<T>>

    /**
     * Group by TaeedProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaeedProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaeedProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaeedProgramGroupByArgs['orderBy'] }
        : { orderBy?: TaeedProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaeedProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaeedProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaeedProgram model
   */
  readonly fields: TaeedProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaeedProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaeedProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaeedProgram model
   */ 
  interface TaeedProgramFieldRefs {
    readonly IdTaeedProgram: FieldRef<"TaeedProgram", 'Int'>
    readonly FIdPumpSta: FieldRef<"TaeedProgram", 'Int'>
    readonly FIdSal: FieldRef<"TaeedProgram", 'Int'>
    readonly FIdDore: FieldRef<"TaeedProgram", 'Int'>
    readonly Sal: FieldRef<"TaeedProgram", 'Int'>
    readonly Mah: FieldRef<"TaeedProgram", 'Int'>
    readonly Dahe: FieldRef<"TaeedProgram", 'Int'>
    readonly FIdUserErsal: FieldRef<"TaeedProgram", 'Int'>
    readonly FirstNErsal: FieldRef<"TaeedProgram", 'String'>
    readonly LastNErsal: FieldRef<"TaeedProgram", 'String'>
    readonly TozihErsal: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhErsal: FieldRef<"TaeedProgram", 'DateTime'>
    readonly FIdUserAbMantaghe: FieldRef<"TaeedProgram", 'Int'>
    readonly FirstNAbMantaghe: FieldRef<"TaeedProgram", 'String'>
    readonly LastNAbMantaghe: FieldRef<"TaeedProgram", 'String'>
    readonly TozihAbMantaghe: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhAbMantaghe: FieldRef<"TaeedProgram", 'DateTime'>
    readonly TaedAbMantaghe: FieldRef<"TaeedProgram", 'Boolean'>
    readonly FIdUserPeymankar: FieldRef<"TaeedProgram", 'Int'>
    readonly FirstNPeymankar: FieldRef<"TaeedProgram", 'String'>
    readonly LastNPeymankar: FieldRef<"TaeedProgram", 'String'>
    readonly TozihPeymankar: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhPeymankar: FieldRef<"TaeedProgram", 'DateTime'>
    readonly TaedPeymankar: FieldRef<"TaeedProgram", 'Boolean'>
    readonly FIdUserAbNiroo: FieldRef<"TaeedProgram", 'Int'>
    readonly FirstNAbNiroo: FieldRef<"TaeedProgram", 'String'>
    readonly LastNAbNiroo: FieldRef<"TaeedProgram", 'String'>
    readonly TozihAbNiroo: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhAbNiroo: FieldRef<"TaeedProgram", 'DateTime'>
    readonly TaedAbNiroo: FieldRef<"TaeedProgram", 'String'>
    readonly FileNameNahaee: FieldRef<"TaeedProgram", 'String'>
    readonly FilePathNahaee: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhFileNahee: FieldRef<"TaeedProgram", 'DateTime'>
    readonly FIdUserTaeedNahaee: FieldRef<"TaeedProgram", 'Int'>
    readonly FirstNTaeedNahaee: FieldRef<"TaeedProgram", 'String'>
    readonly LastNTaeedNahaee: FieldRef<"TaeedProgram", 'String'>
    readonly TarikhTaeedNahaee: FieldRef<"TaeedProgram", 'DateTime'>
    readonly TaeedNahaee: FieldRef<"TaeedProgram", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TaeedProgram findUnique
   */
  export type TaeedProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter, which TaeedProgram to fetch.
     */
    where: TaeedProgramWhereUniqueInput
  }

  /**
   * TaeedProgram findUniqueOrThrow
   */
  export type TaeedProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter, which TaeedProgram to fetch.
     */
    where: TaeedProgramWhereUniqueInput
  }

  /**
   * TaeedProgram findFirst
   */
  export type TaeedProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter, which TaeedProgram to fetch.
     */
    where?: TaeedProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaeedPrograms to fetch.
     */
    orderBy?: TaeedProgramOrderByWithRelationInput | TaeedProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaeedPrograms.
     */
    cursor?: TaeedProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaeedPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaeedPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaeedPrograms.
     */
    distinct?: TaeedProgramScalarFieldEnum | TaeedProgramScalarFieldEnum[]
  }

  /**
   * TaeedProgram findFirstOrThrow
   */
  export type TaeedProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter, which TaeedProgram to fetch.
     */
    where?: TaeedProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaeedPrograms to fetch.
     */
    orderBy?: TaeedProgramOrderByWithRelationInput | TaeedProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaeedPrograms.
     */
    cursor?: TaeedProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaeedPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaeedPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaeedPrograms.
     */
    distinct?: TaeedProgramScalarFieldEnum | TaeedProgramScalarFieldEnum[]
  }

  /**
   * TaeedProgram findMany
   */
  export type TaeedProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter, which TaeedPrograms to fetch.
     */
    where?: TaeedProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaeedPrograms to fetch.
     */
    orderBy?: TaeedProgramOrderByWithRelationInput | TaeedProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaeedPrograms.
     */
    cursor?: TaeedProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaeedPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaeedPrograms.
     */
    skip?: number
    distinct?: TaeedProgramScalarFieldEnum | TaeedProgramScalarFieldEnum[]
  }

  /**
   * TaeedProgram create
   */
  export type TaeedProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * The data needed to create a TaeedProgram.
     */
    data: XOR<TaeedProgramCreateInput, TaeedProgramUncheckedCreateInput>
  }

  /**
   * TaeedProgram createMany
   */
  export type TaeedProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaeedPrograms.
     */
    data: TaeedProgramCreateManyInput | TaeedProgramCreateManyInput[]
  }

  /**
   * TaeedProgram update
   */
  export type TaeedProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * The data needed to update a TaeedProgram.
     */
    data: XOR<TaeedProgramUpdateInput, TaeedProgramUncheckedUpdateInput>
    /**
     * Choose, which TaeedProgram to update.
     */
    where: TaeedProgramWhereUniqueInput
  }

  /**
   * TaeedProgram updateMany
   */
  export type TaeedProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaeedPrograms.
     */
    data: XOR<TaeedProgramUpdateManyMutationInput, TaeedProgramUncheckedUpdateManyInput>
    /**
     * Filter which TaeedPrograms to update
     */
    where?: TaeedProgramWhereInput
    /**
     * Limit how many TaeedPrograms to update.
     */
    limit?: number
  }

  /**
   * TaeedProgram upsert
   */
  export type TaeedProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * The filter to search for the TaeedProgram to update in case it exists.
     */
    where: TaeedProgramWhereUniqueInput
    /**
     * In case the TaeedProgram found by the `where` argument doesn't exist, create a new TaeedProgram with this data.
     */
    create: XOR<TaeedProgramCreateInput, TaeedProgramUncheckedCreateInput>
    /**
     * In case the TaeedProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaeedProgramUpdateInput, TaeedProgramUncheckedUpdateInput>
  }

  /**
   * TaeedProgram delete
   */
  export type TaeedProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
    /**
     * Filter which TaeedProgram to delete.
     */
    where: TaeedProgramWhereUniqueInput
  }

  /**
   * TaeedProgram deleteMany
   */
  export type TaeedProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaeedPrograms to delete
     */
    where?: TaeedProgramWhereInput
    /**
     * Limit how many TaeedPrograms to delete.
     */
    limit?: number
  }

  /**
   * TaeedProgram without action
   */
  export type TaeedProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaeedProgram
     */
    select?: TaeedProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaeedProgram
     */
    omit?: TaeedProgramOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AbadeMakhzanScalarFieldEnum: {
    IdMakhzan: 'IdMakhzan',
    TooleBala: 'TooleBala',
    ArzeBala: 'ArzeBala',
    TooleKaf: 'TooleKaf',
    ArzeKaf: 'ArzeKaf',
    Omgh: 'Omgh',
    HajmMohasebat: 'HajmMohasebat',
    HadeaghalHajm: 'HadeaghalHajm',
    NameStation: 'NameStation'
  };

  export type AbadeMakhzanScalarFieldEnum = (typeof AbadeMakhzanScalarFieldEnum)[keyof typeof AbadeMakhzanScalarFieldEnum]


  export const AbgirScalarFieldEnum: {
    IdKontor: 'IdKontor',
    FIdRanesh: 'FIdRanesh',
    Abgir: 'Abgir'
  };

  export type AbgirScalarFieldEnum = (typeof AbgirScalarFieldEnum)[keyof typeof AbgirScalarFieldEnum]


  export const BahrebardairProgramScalarFieldEnum: {
    IdProgram: 'IdProgram',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Tedad: 'Tedad',
    Shorooe: 'Shorooe',
    Paian: 'Paian'
  };

  export type BahrebardairProgramScalarFieldEnum = (typeof BahrebardairProgramScalarFieldEnum)[keyof typeof BahrebardairProgramScalarFieldEnum]


  export const BahrebardairProgramSeghliScalarFieldEnum: {
    IdProSrgl: 'IdProSrgl',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Zarfiat: 'Zarfiat',
    Shorooe: 'Shorooe',
    Paian: 'Paian'
  };

  export type BahrebardairProgramSeghliScalarFieldEnum = (typeof BahrebardairProgramSeghliScalarFieldEnum)[keyof typeof BahrebardairProgramSeghliScalarFieldEnum]


  export const BahrebardariKeshtDoreScalarFieldEnum: {
    IdBahDor: 'IdBahDor',
    FIdShDo: 'FIdShDo',
    FIdRanesh: 'FIdRanesh',
    FIdNoeM: 'FIdNoeM',
    Area: 'Area'
  };

  export type BahrebardariKeshtDoreScalarFieldEnum = (typeof BahrebardariKeshtDoreScalarFieldEnum)[keyof typeof BahrebardariKeshtDoreScalarFieldEnum]


  export const BahrebardariTaghvimScalarFieldEnum: {
    IdTag: 'IdTag',
    FIdTarDor: 'FIdTarDor',
    FIdRanesh: 'FIdRanesh',
    Taghvim: 'Taghvim'
  };

  export type BahrebardariTaghvimScalarFieldEnum = (typeof BahrebardariTaghvimScalarFieldEnum)[keyof typeof BahrebardariTaghvimScalarFieldEnum]


  export const BareshMotaleatScalarFieldEnum: {
    IdBarMot: 'IdBarMot',
    FIdNet: 'FIdNet',
    FIdMah: 'FIdMah',
    BareshMotaleat: 'BareshMotaleat'
  };

  export type BareshMotaleatScalarFieldEnum = (typeof BareshMotaleatScalarFieldEnum)[keyof typeof BareshMotaleatScalarFieldEnum]


  export const DarajePipeScalarFieldEnum: {
    IdDPipe: 'IdDPipe',
    DarajePipe: 'DarajePipe'
  };

  export type DarajePipeScalarFieldEnum = (typeof DarajePipeScalarFieldEnum)[keyof typeof DarajePipeScalarFieldEnum]


  export const DeliveryPointsScalarFieldEnum: {
    IdDp: 'IdDp',
    DeliveryPoint: 'DeliveryPoint'
  };

  export type DeliveryPointsScalarFieldEnum = (typeof DeliveryPointsScalarFieldEnum)[keyof typeof DeliveryPointsScalarFieldEnum]


  export const DarjeStationScalarFieldEnum: {
    IdDStation: 'IdDStation',
    DarajeStation: 'DarajeStation'
  };

  export type DarjeStationScalarFieldEnum = (typeof DarjeStationScalarFieldEnum)[keyof typeof DarjeStationScalarFieldEnum]


  export const DoreKeshtScalarFieldEnum: {
    IdDore: 'IdDore',
    Dore: 'Dore'
  };

  export type DoreKeshtScalarFieldEnum = (typeof DoreKeshtScalarFieldEnum)[keyof typeof DoreKeshtScalarFieldEnum]


  export const EshtebahAvamelScalarFieldEnum: {
    IdEsht: 'IdEsht',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Eshtebah: 'Eshtebah'
  };

  export type EshtebahAvamelScalarFieldEnum = (typeof EshtebahAvamelScalarFieldEnum)[keyof typeof EshtebahAvamelScalarFieldEnum]


  export const FlowBehboodScalarFieldEnum: {
    IdBehbood: 'IdBehbood',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Flow: 'Flow'
  };

  export type FlowBehboodScalarFieldEnum = (typeof FlowBehboodScalarFieldEnum)[keyof typeof FlowBehboodScalarFieldEnum]


  export const FlowmeterScalarFieldEnum: {
    IdFIT: 'IdFIT',
    FIdRanesh: 'FIdRanesh',
    FIdTrikh: 'FIdTrikh',
    Flowmeter: 'Flowmeter'
  };

  export type FlowmeterScalarFieldEnum = (typeof FlowmeterScalarFieldEnum)[keyof typeof FlowmeterScalarFieldEnum]


  export const KhatRaneshScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    RaneshName: 'RaneshName',
    FIdPumpSta: 'FIdPumpSta',
    FIdDPipe: 'FIdDPipe',
    FIdSePu: 'FIdSePu',
    FIdMeasuring: 'FIdMeasuring',
    Active: 'Active'
  };

  export type KhatRaneshScalarFieldEnum = (typeof KhatRaneshScalarFieldEnum)[keyof typeof KhatRaneshScalarFieldEnum]


  export const KhatRaneshAreaScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    FIdLand: 'FIdLand',
    FIdNet: 'FIdNet',
    Area: 'Area'
  };

  export type KhatRaneshAreaScalarFieldEnum = (typeof KhatRaneshAreaScalarFieldEnum)[keyof typeof KhatRaneshAreaScalarFieldEnum]


  export const KhatRaneshPumpScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    ModelPump: 'ModelPump',
    FIdPump: 'FIdPump',
    TedadPump: 'TedadPump',
    DebiPomp: 'DebiPomp',
    FesharPump: 'FesharPump',
    Randeman: 'Randeman',
    TavaneNami: 'TavaneNami',
    TavaneJazbi: 'TavaneJazbi',
    Voltazh: 'Voltazh',
    DoreMotor: 'DoreMotor',
    FeshareMakesh: 'FeshareMakesh',
    FeshareRanesh: 'FeshareRanesh',
    SizeMakesh: 'SizeMakesh',
    SizeRanesh: 'SizeRanesh',
    SizeKolektor: 'SizeKolektor',
    SizeShireKolektor: 'SizeShireKolektor'
  };

  export type KhatRaneshPumpScalarFieldEnum = (typeof KhatRaneshPumpScalarFieldEnum)[keyof typeof KhatRaneshPumpScalarFieldEnum]


  export const KhatRaneshSegliScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    Zarfiat: 'Zarfiat'
  };

  export type KhatRaneshSegliScalarFieldEnum = (typeof KhatRaneshSegliScalarFieldEnum)[keyof typeof KhatRaneshSegliScalarFieldEnum]


  export const KontorScalarFieldEnum: {
    IdKon: 'IdKon',
    FIdKontor: 'FIdKontor',
    FIdTarDor: 'FIdTarDor',
    Kontor: 'Kontor'
  };

  export type KontorScalarFieldEnum = (typeof KontorScalarFieldEnum)[keyof typeof KontorScalarFieldEnum]


  export const LandScalarFieldEnum: {
    IdLand: 'IdLand',
    Land: 'Land'
  };

  export type LandScalarFieldEnum = (typeof LandScalarFieldEnum)[keyof typeof LandScalarFieldEnum]


  export const MeasuringToolScalarFieldEnum: {
    IdMeasuring: 'IdMeasuring',
    MeasuringTool: 'MeasuringTool',
    Precision: 'Precision'
  };

  export type MeasuringToolScalarFieldEnum = (typeof MeasuringToolScalarFieldEnum)[keyof typeof MeasuringToolScalarFieldEnum]


  export const NashtShabakeScalarFieldEnum: {
    IdNasht: 'IdNasht',
    FIdRanesh: 'FIdRanesh',
    FIdTriDor: 'FIdTriDor',
    NashtShabake: 'NashtShabake'
  };

  export type NashtShabakeScalarFieldEnum = (typeof NashtShabakeScalarFieldEnum)[keyof typeof NashtShabakeScalarFieldEnum]


  export const NetworkScalarFieldEnum: {
    IdNet: 'IdNet',
    Network: 'Network',
    FIdSP: 'FIdSP'
  };

  export type NetworkScalarFieldEnum = (typeof NetworkScalarFieldEnum)[keyof typeof NetworkScalarFieldEnum]


  export const NoeKeshtScalarFieldEnum: {
    IdNoeK: 'IdNoeK',
    Kesht: 'Kesht'
  };

  export type NoeKeshtScalarFieldEnum = (typeof NoeKeshtScalarFieldEnum)[keyof typeof NoeKeshtScalarFieldEnum]


  export const NoeMahsoolScalarFieldEnum: {
    IdNoeM: 'IdNoeM',
    Mahsool: 'Mahsool',
    FIdNoeK: 'FIdNoeK'
  };

  export type NoeMahsoolScalarFieldEnum = (typeof NoeMahsoolScalarFieldEnum)[keyof typeof NoeMahsoolScalarFieldEnum]


  export const NonFITScalarFieldEnum: {
    IdNonFIT: 'IdNonFIT',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    VOLUM: 'VOLUM'
  };

  export type NonFITScalarFieldEnum = (typeof NonFITScalarFieldEnum)[keyof typeof NonFITScalarFieldEnum]


  export const PumpStationScalarFieldEnum: {
    IdPumpSta: 'IdPumpSta',
    NameStation: 'NameStation',
    KM: 'KM',
    FIdNet: 'FIdNet',
    FIdDStation: 'FIdDStation',
    FIdMakhzan: 'FIdMakhzan',
    FIdDP: 'FIdDP',
    Ready: 'Ready'
  };

  export type PumpStationScalarFieldEnum = (typeof PumpStationScalarFieldEnum)[keyof typeof PumpStationScalarFieldEnum]


  export const PumpTypeScalarFieldEnum: {
    IdPump: 'IdPump',
    PumpType: 'PumpType'
  };

  export type PumpTypeScalarFieldEnum = (typeof PumpTypeScalarFieldEnum)[keyof typeof PumpTypeScalarFieldEnum]


  export const RainfallStationScalarFieldEnum: {
    IdRaiSta: 'IdRaiSta',
    FIdWeaSta: 'FIdWeaSta',
    FIdTrikh: 'FIdTrikh',
    FIdRaiTy: 'FIdRaiTy',
    ErtefaeBaresh: 'ErtefaeBaresh'
  };

  export type RainfallStationScalarFieldEnum = (typeof RainfallStationScalarFieldEnum)[keyof typeof RainfallStationScalarFieldEnum]


  export const RainfallTypeScalarFieldEnum: {
    IdRaiTy: 'IdRaiTy',
    RainfallType: 'RainfallType'
  };

  export type RainfallTypeScalarFieldEnum = (typeof RainfallTypeScalarFieldEnum)[keyof typeof RainfallTypeScalarFieldEnum]


  export const SaleZeraeeScalarFieldEnum: {
    IdSal: 'IdSal',
    SaleZeraee: 'SaleZeraee'
  };

  export type SaleZeraeeScalarFieldEnum = (typeof SaleZeraeeScalarFieldEnum)[keyof typeof SaleZeraeeScalarFieldEnum]


  export const SeghliPumpScalarFieldEnum: {
    IdSePu: 'IdSePu',
    SeghliPump: 'SeghliPump'
  };

  export type SeghliPumpScalarFieldEnum = (typeof SeghliPumpScalarFieldEnum)[keyof typeof SeghliPumpScalarFieldEnum]


  export const SystemPartScalarFieldEnum: {
    IdSP: 'IdSP',
    Part: 'Part',
    KM: 'KM'
  };

  export type SystemPartScalarFieldEnum = (typeof SystemPartScalarFieldEnum)[keyof typeof SystemPartScalarFieldEnum]


  export const TakhlieMakhzanScalarFieldEnum: {
    IdTakhlie: 'IdTakhlie',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Takhlie: 'Takhlie'
  };

  export type TakhlieMakhzanScalarFieldEnum = (typeof TakhlieMakhzanScalarFieldEnum)[keyof typeof TakhlieMakhzanScalarFieldEnum]


  export const TestScalarFieldEnum: {
    IdTest: 'IdTest',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Test: 'Test'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TrikhDoreKeshtScalarFieldEnum: {
    IdTarDor: 'IdTarDor',
    FIdSal: 'FIdSal',
    FIdDore: 'FIdDore',
    Trikh: 'Trikh',
    TrikhKhorshidi: 'TrikhKhorshidi',
    Dahe: 'Dahe',
    Sal: 'Sal',
    Mah: 'Mah'
  };

  export type TrikhDoreKeshtScalarFieldEnum = (typeof TrikhDoreKeshtScalarFieldEnum)[keyof typeof TrikhDoreKeshtScalarFieldEnum]


  export const WeatherStationScalarFieldEnum: {
    IdWeaSta: 'IdWeaSta',
    Station: 'Station'
  };

  export type WeatherStationScalarFieldEnum = (typeof WeatherStationScalarFieldEnum)[keyof typeof WeatherStationScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const MahShamsiScalarFieldEnum: {
    IdMah: 'IdMah',
    Mah: 'Mah'
  };

  export type MahShamsiScalarFieldEnum = (typeof MahShamsiScalarFieldEnum)[keyof typeof MahShamsiScalarFieldEnum]


  export const ShabakeDoreKeshtScalarFieldEnum: {
    IdShDo: 'IdShDo',
    FIdNet: 'FIdNet',
    TrikhShorooe: 'TrikhShorooe',
    TrikhPayan: 'TrikhPayan',
    FIdSal: 'FIdSal',
    FIdDore: 'FIdDore'
  };

  export type ShabakeDoreKeshtScalarFieldEnum = (typeof ShabakeDoreKeshtScalarFieldEnum)[keyof typeof ShabakeDoreKeshtScalarFieldEnum]


  export const TaeedProgramScalarFieldEnum: {
    IdTaeedProgram: 'IdTaeedProgram',
    FIdPumpSta: 'FIdPumpSta',
    FIdSal: 'FIdSal',
    FIdDore: 'FIdDore',
    Sal: 'Sal',
    Mah: 'Mah',
    Dahe: 'Dahe',
    FIdUserErsal: 'FIdUserErsal',
    FirstNErsal: 'FirstNErsal',
    LastNErsal: 'LastNErsal',
    TozihErsal: 'TozihErsal',
    TarikhErsal: 'TarikhErsal',
    FIdUserAbMantaghe: 'FIdUserAbMantaghe',
    FirstNAbMantaghe: 'FirstNAbMantaghe',
    LastNAbMantaghe: 'LastNAbMantaghe',
    TozihAbMantaghe: 'TozihAbMantaghe',
    TarikhAbMantaghe: 'TarikhAbMantaghe',
    TaedAbMantaghe: 'TaedAbMantaghe',
    FIdUserPeymankar: 'FIdUserPeymankar',
    FirstNPeymankar: 'FirstNPeymankar',
    LastNPeymankar: 'LastNPeymankar',
    TozihPeymankar: 'TozihPeymankar',
    TarikhPeymankar: 'TarikhPeymankar',
    TaedPeymankar: 'TaedPeymankar',
    FIdUserAbNiroo: 'FIdUserAbNiroo',
    FirstNAbNiroo: 'FirstNAbNiroo',
    LastNAbNiroo: 'LastNAbNiroo',
    TozihAbNiroo: 'TozihAbNiroo',
    TarikhAbNiroo: 'TarikhAbNiroo',
    TaedAbNiroo: 'TaedAbNiroo',
    FileNameNahaee: 'FileNameNahaee',
    FilePathNahaee: 'FilePathNahaee',
    TarikhFileNahee: 'TarikhFileNahee',
    FIdUserTaeedNahaee: 'FIdUserTaeedNahaee',
    FirstNTaeedNahaee: 'FirstNTaeedNahaee',
    LastNTaeedNahaee: 'LastNTaeedNahaee',
    TarikhTaeedNahaee: 'TarikhTaeedNahaee',
    TaeedNahaee: 'TaeedNahaee'
  };

  export type TaeedProgramScalarFieldEnum = (typeof TaeedProgramScalarFieldEnum)[keyof typeof TaeedProgramScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type AbadeMakhzanWhereInput = {
    AND?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    OR?: AbadeMakhzanWhereInput[]
    NOT?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    IdMakhzan?: IntFilter<"AbadeMakhzan"> | number
    TooleBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringFilter<"AbadeMakhzan"> | string
    PumpStation?: PumpStationListRelationFilter
  }

  export type AbadeMakhzanOrderByWithRelationInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrderInput | SortOrder
    ArzeBala?: SortOrderInput | SortOrder
    TooleKaf?: SortOrderInput | SortOrder
    ArzeKaf?: SortOrderInput | SortOrder
    Omgh?: SortOrderInput | SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrderInput | SortOrder
    NameStation?: SortOrder
    PumpStation?: PumpStationOrderByRelationAggregateInput
  }

  export type AbadeMakhzanWhereUniqueInput = Prisma.AtLeast<{
    IdMakhzan?: number
    AND?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    OR?: AbadeMakhzanWhereInput[]
    NOT?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    TooleBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringFilter<"AbadeMakhzan"> | string
    PumpStation?: PumpStationListRelationFilter
  }, "IdMakhzan">

  export type AbadeMakhzanOrderByWithAggregationInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrderInput | SortOrder
    ArzeBala?: SortOrderInput | SortOrder
    TooleKaf?: SortOrderInput | SortOrder
    ArzeKaf?: SortOrderInput | SortOrder
    Omgh?: SortOrderInput | SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrderInput | SortOrder
    NameStation?: SortOrder
    _count?: AbadeMakhzanCountOrderByAggregateInput
    _avg?: AbadeMakhzanAvgOrderByAggregateInput
    _max?: AbadeMakhzanMaxOrderByAggregateInput
    _min?: AbadeMakhzanMinOrderByAggregateInput
    _sum?: AbadeMakhzanSumOrderByAggregateInput
  }

  export type AbadeMakhzanScalarWhereWithAggregatesInput = {
    AND?: AbadeMakhzanScalarWhereWithAggregatesInput | AbadeMakhzanScalarWhereWithAggregatesInput[]
    OR?: AbadeMakhzanScalarWhereWithAggregatesInput[]
    NOT?: AbadeMakhzanScalarWhereWithAggregatesInput | AbadeMakhzanScalarWhereWithAggregatesInput[]
    IdMakhzan?: IntWithAggregatesFilter<"AbadeMakhzan"> | number
    TooleBala?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableWithAggregatesFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringWithAggregatesFilter<"AbadeMakhzan"> | string
  }

  export type AbgirWhereInput = {
    AND?: AbgirWhereInput | AbgirWhereInput[]
    OR?: AbgirWhereInput[]
    NOT?: AbgirWhereInput | AbgirWhereInput[]
    IdKontor?: IntFilter<"Abgir"> | number
    FIdRanesh?: IntFilter<"Abgir"> | number
    Abgir?: StringFilter<"Abgir"> | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    Kontor?: KontorListRelationFilter
  }

  export type AbgirOrderByWithRelationInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    Kontor?: KontorOrderByRelationAggregateInput
  }

  export type AbgirWhereUniqueInput = Prisma.AtLeast<{
    IdKontor?: number
    AND?: AbgirWhereInput | AbgirWhereInput[]
    OR?: AbgirWhereInput[]
    NOT?: AbgirWhereInput | AbgirWhereInput[]
    FIdRanesh?: IntFilter<"Abgir"> | number
    Abgir?: StringFilter<"Abgir"> | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    Kontor?: KontorListRelationFilter
  }, "IdKontor">

  export type AbgirOrderByWithAggregationInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
    _count?: AbgirCountOrderByAggregateInput
    _avg?: AbgirAvgOrderByAggregateInput
    _max?: AbgirMaxOrderByAggregateInput
    _min?: AbgirMinOrderByAggregateInput
    _sum?: AbgirSumOrderByAggregateInput
  }

  export type AbgirScalarWhereWithAggregatesInput = {
    AND?: AbgirScalarWhereWithAggregatesInput | AbgirScalarWhereWithAggregatesInput[]
    OR?: AbgirScalarWhereWithAggregatesInput[]
    NOT?: AbgirScalarWhereWithAggregatesInput | AbgirScalarWhereWithAggregatesInput[]
    IdKontor?: IntWithAggregatesFilter<"Abgir"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Abgir"> | number
    Abgir?: StringWithAggregatesFilter<"Abgir"> | string
  }

  export type BahrebardairProgramWhereInput = {
    AND?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    OR?: BahrebardairProgramWhereInput[]
    NOT?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    IdProgram?: IntFilter<"BahrebardairProgram"> | number
    FIdRanesh?: IntFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgram"> | number
    Tedad?: IntFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type BahrebardairProgramOrderByWithRelationInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type BahrebardairProgramWhereUniqueInput = Prisma.AtLeast<{
    IdProgram?: number
    AND?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    OR?: BahrebardairProgramWhereInput[]
    NOT?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    FIdRanesh?: IntFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgram"> | number
    Tedad?: IntFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdProgram">

  export type BahrebardairProgramOrderByWithAggregationInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
    _count?: BahrebardairProgramCountOrderByAggregateInput
    _avg?: BahrebardairProgramAvgOrderByAggregateInput
    _max?: BahrebardairProgramMaxOrderByAggregateInput
    _min?: BahrebardairProgramMinOrderByAggregateInput
    _sum?: BahrebardairProgramSumOrderByAggregateInput
  }

  export type BahrebardairProgramScalarWhereWithAggregatesInput = {
    AND?: BahrebardairProgramScalarWhereWithAggregatesInput | BahrebardairProgramScalarWhereWithAggregatesInput[]
    OR?: BahrebardairProgramScalarWhereWithAggregatesInput[]
    NOT?: BahrebardairProgramScalarWhereWithAggregatesInput | BahrebardairProgramScalarWhereWithAggregatesInput[]
    IdProgram?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    Tedad?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgram"> | Date | string | null
  }

  export type BahrebardairProgramSeghliWhereInput = {
    AND?: BahrebardairProgramSeghliWhereInput | BahrebardairProgramSeghliWhereInput[]
    OR?: BahrebardairProgramSeghliWhereInput[]
    NOT?: BahrebardairProgramSeghliWhereInput | BahrebardairProgramSeghliWhereInput[]
    IdProSrgl?: IntFilter<"BahrebardairProgramSeghli"> | number
    FIdRanesh?: IntFilter<"BahrebardairProgramSeghli"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgramSeghli"> | number
    Zarfiat?: DecimalNullableFilter<"BahrebardairProgramSeghli"> | Decimal | DecimalJsLike | number | string | null
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type BahrebardairProgramSeghliOrderByWithRelationInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrderInput | SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type BahrebardairProgramSeghliWhereUniqueInput = Prisma.AtLeast<{
    IdProSrgl?: number
    AND?: BahrebardairProgramSeghliWhereInput | BahrebardairProgramSeghliWhereInput[]
    OR?: BahrebardairProgramSeghliWhereInput[]
    NOT?: BahrebardairProgramSeghliWhereInput | BahrebardairProgramSeghliWhereInput[]
    FIdRanesh?: IntFilter<"BahrebardairProgramSeghli"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgramSeghli"> | number
    Zarfiat?: DecimalNullableFilter<"BahrebardairProgramSeghli"> | Decimal | DecimalJsLike | number | string | null
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdProSrgl">

  export type BahrebardairProgramSeghliOrderByWithAggregationInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrderInput | SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
    _count?: BahrebardairProgramSeghliCountOrderByAggregateInput
    _avg?: BahrebardairProgramSeghliAvgOrderByAggregateInput
    _max?: BahrebardairProgramSeghliMaxOrderByAggregateInput
    _min?: BahrebardairProgramSeghliMinOrderByAggregateInput
    _sum?: BahrebardairProgramSeghliSumOrderByAggregateInput
  }

  export type BahrebardairProgramSeghliScalarWhereWithAggregatesInput = {
    AND?: BahrebardairProgramSeghliScalarWhereWithAggregatesInput | BahrebardairProgramSeghliScalarWhereWithAggregatesInput[]
    OR?: BahrebardairProgramSeghliScalarWhereWithAggregatesInput[]
    NOT?: BahrebardairProgramSeghliScalarWhereWithAggregatesInput | BahrebardairProgramSeghliScalarWhereWithAggregatesInput[]
    IdProSrgl?: IntWithAggregatesFilter<"BahrebardairProgramSeghli"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardairProgramSeghli"> | number
    FIdTarDor?: IntWithAggregatesFilter<"BahrebardairProgramSeghli"> | number
    Zarfiat?: DecimalNullableWithAggregatesFilter<"BahrebardairProgramSeghli"> | Decimal | DecimalJsLike | number | string | null
    Shorooe?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgramSeghli"> | Date | string | null
    Paian?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgramSeghli"> | Date | string | null
  }

  export type BahrebardariKeshtDoreWhereInput = {
    AND?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    OR?: BahrebardariKeshtDoreWhereInput[]
    NOT?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    IdBahDor?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdShDo?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    NoeMahsool?: XOR<NoeMahsoolScalarRelationFilter, NoeMahsoolWhereInput>
    ShabakeDoreKesht?: XOR<ShabakeDoreKeshtScalarRelationFilter, ShabakeDoreKeshtWhereInput>
  }

  export type BahrebardariKeshtDoreOrderByWithRelationInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    NoeMahsool?: NoeMahsoolOrderByWithRelationInput
    ShabakeDoreKesht?: ShabakeDoreKeshtOrderByWithRelationInput
  }

  export type BahrebardariKeshtDoreWhereUniqueInput = Prisma.AtLeast<{
    IdBahDor?: number
    AND?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    OR?: BahrebardariKeshtDoreWhereInput[]
    NOT?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    FIdShDo?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    NoeMahsool?: XOR<NoeMahsoolScalarRelationFilter, NoeMahsoolWhereInput>
    ShabakeDoreKesht?: XOR<ShabakeDoreKeshtScalarRelationFilter, ShabakeDoreKeshtWhereInput>
  }, "IdBahDor">

  export type BahrebardariKeshtDoreOrderByWithAggregationInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
    _count?: BahrebardariKeshtDoreCountOrderByAggregateInput
    _avg?: BahrebardariKeshtDoreAvgOrderByAggregateInput
    _max?: BahrebardariKeshtDoreMaxOrderByAggregateInput
    _min?: BahrebardariKeshtDoreMinOrderByAggregateInput
    _sum?: BahrebardariKeshtDoreSumOrderByAggregateInput
  }

  export type BahrebardariKeshtDoreScalarWhereWithAggregatesInput = {
    AND?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput | BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    OR?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    NOT?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput | BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    IdBahDor?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdShDo?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalWithAggregatesFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimWhereInput = {
    AND?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    OR?: BahrebardariTaghvimWhereInput[]
    NOT?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    IdTag?: IntFilter<"BahrebardariTaghvim"> | number
    FIdTarDor?: IntFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type BahrebardariTaghvimOrderByWithRelationInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type BahrebardariTaghvimWhereUniqueInput = Prisma.AtLeast<{
    IdTag?: number
    AND?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    OR?: BahrebardariTaghvimWhereInput[]
    NOT?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    FIdTarDor?: IntFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdTag">

  export type BahrebardariTaghvimOrderByWithAggregationInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
    _count?: BahrebardariTaghvimCountOrderByAggregateInput
    _avg?: BahrebardariTaghvimAvgOrderByAggregateInput
    _max?: BahrebardariTaghvimMaxOrderByAggregateInput
    _min?: BahrebardariTaghvimMinOrderByAggregateInput
    _sum?: BahrebardariTaghvimSumOrderByAggregateInput
  }

  export type BahrebardariTaghvimScalarWhereWithAggregatesInput = {
    AND?: BahrebardariTaghvimScalarWhereWithAggregatesInput | BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    OR?: BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    NOT?: BahrebardariTaghvimScalarWhereWithAggregatesInput | BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    IdTag?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    FIdTarDor?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalWithAggregatesFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatWhereInput = {
    AND?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    OR?: BareshMotaleatWhereInput[]
    NOT?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    IdBarMot?: IntFilter<"BareshMotaleat"> | number
    FIdNet?: IntFilter<"BareshMotaleat"> | number
    FIdMah?: IntFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
    Mah?: XOR<MahShamsiScalarRelationFilter, MahShamsiWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }

  export type BareshMotaleatOrderByWithRelationInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
    Mah?: MahShamsiOrderByWithRelationInput
    Network?: NetworkOrderByWithRelationInput
  }

  export type BareshMotaleatWhereUniqueInput = Prisma.AtLeast<{
    IdBarMot?: number
    AND?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    OR?: BareshMotaleatWhereInput[]
    NOT?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    FIdNet?: IntFilter<"BareshMotaleat"> | number
    FIdMah?: IntFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
    Mah?: XOR<MahShamsiScalarRelationFilter, MahShamsiWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }, "IdBarMot">

  export type BareshMotaleatOrderByWithAggregationInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
    _count?: BareshMotaleatCountOrderByAggregateInput
    _avg?: BareshMotaleatAvgOrderByAggregateInput
    _max?: BareshMotaleatMaxOrderByAggregateInput
    _min?: BareshMotaleatMinOrderByAggregateInput
    _sum?: BareshMotaleatSumOrderByAggregateInput
  }

  export type BareshMotaleatScalarWhereWithAggregatesInput = {
    AND?: BareshMotaleatScalarWhereWithAggregatesInput | BareshMotaleatScalarWhereWithAggregatesInput[]
    OR?: BareshMotaleatScalarWhereWithAggregatesInput[]
    NOT?: BareshMotaleatScalarWhereWithAggregatesInput | BareshMotaleatScalarWhereWithAggregatesInput[]
    IdBarMot?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    FIdNet?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    FIdMah?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalWithAggregatesFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
  }

  export type DarajePipeWhereInput = {
    AND?: DarajePipeWhereInput | DarajePipeWhereInput[]
    OR?: DarajePipeWhereInput[]
    NOT?: DarajePipeWhereInput | DarajePipeWhereInput[]
    IdDPipe?: IntFilter<"DarajePipe"> | number
    DarajePipe?: StringFilter<"DarajePipe"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }

  export type DarajePipeOrderByWithRelationInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
    KhatRanesh?: KhatRaneshOrderByRelationAggregateInput
  }

  export type DarajePipeWhereUniqueInput = Prisma.AtLeast<{
    IdDPipe?: number
    AND?: DarajePipeWhereInput | DarajePipeWhereInput[]
    OR?: DarajePipeWhereInput[]
    NOT?: DarajePipeWhereInput | DarajePipeWhereInput[]
    DarajePipe?: StringFilter<"DarajePipe"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }, "IdDPipe">

  export type DarajePipeOrderByWithAggregationInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
    _count?: DarajePipeCountOrderByAggregateInput
    _avg?: DarajePipeAvgOrderByAggregateInput
    _max?: DarajePipeMaxOrderByAggregateInput
    _min?: DarajePipeMinOrderByAggregateInput
    _sum?: DarajePipeSumOrderByAggregateInput
  }

  export type DarajePipeScalarWhereWithAggregatesInput = {
    AND?: DarajePipeScalarWhereWithAggregatesInput | DarajePipeScalarWhereWithAggregatesInput[]
    OR?: DarajePipeScalarWhereWithAggregatesInput[]
    NOT?: DarajePipeScalarWhereWithAggregatesInput | DarajePipeScalarWhereWithAggregatesInput[]
    IdDPipe?: IntWithAggregatesFilter<"DarajePipe"> | number
    DarajePipe?: StringWithAggregatesFilter<"DarajePipe"> | string
  }

  export type DeliveryPointsWhereInput = {
    AND?: DeliveryPointsWhereInput | DeliveryPointsWhereInput[]
    OR?: DeliveryPointsWhereInput[]
    NOT?: DeliveryPointsWhereInput | DeliveryPointsWhereInput[]
    IdDp?: IntFilter<"DeliveryPoints"> | number
    DeliveryPoint?: StringFilter<"DeliveryPoints"> | string
    PumpStations?: PumpStationListRelationFilter
  }

  export type DeliveryPointsOrderByWithRelationInput = {
    IdDp?: SortOrder
    DeliveryPoint?: SortOrder
    PumpStations?: PumpStationOrderByRelationAggregateInput
  }

  export type DeliveryPointsWhereUniqueInput = Prisma.AtLeast<{
    IdDp?: number
    AND?: DeliveryPointsWhereInput | DeliveryPointsWhereInput[]
    OR?: DeliveryPointsWhereInput[]
    NOT?: DeliveryPointsWhereInput | DeliveryPointsWhereInput[]
    DeliveryPoint?: StringFilter<"DeliveryPoints"> | string
    PumpStations?: PumpStationListRelationFilter
  }, "IdDp">

  export type DeliveryPointsOrderByWithAggregationInput = {
    IdDp?: SortOrder
    DeliveryPoint?: SortOrder
    _count?: DeliveryPointsCountOrderByAggregateInput
    _avg?: DeliveryPointsAvgOrderByAggregateInput
    _max?: DeliveryPointsMaxOrderByAggregateInput
    _min?: DeliveryPointsMinOrderByAggregateInput
    _sum?: DeliveryPointsSumOrderByAggregateInput
  }

  export type DeliveryPointsScalarWhereWithAggregatesInput = {
    AND?: DeliveryPointsScalarWhereWithAggregatesInput | DeliveryPointsScalarWhereWithAggregatesInput[]
    OR?: DeliveryPointsScalarWhereWithAggregatesInput[]
    NOT?: DeliveryPointsScalarWhereWithAggregatesInput | DeliveryPointsScalarWhereWithAggregatesInput[]
    IdDp?: IntWithAggregatesFilter<"DeliveryPoints"> | number
    DeliveryPoint?: StringWithAggregatesFilter<"DeliveryPoints"> | string
  }

  export type DarjeStationWhereInput = {
    AND?: DarjeStationWhereInput | DarjeStationWhereInput[]
    OR?: DarjeStationWhereInput[]
    NOT?: DarjeStationWhereInput | DarjeStationWhereInput[]
    IdDStation?: IntFilter<"DarjeStation"> | number
    DarajeStation?: StringFilter<"DarjeStation"> | string
    PumpStation?: PumpStationListRelationFilter
  }

  export type DarjeStationOrderByWithRelationInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
    PumpStation?: PumpStationOrderByRelationAggregateInput
  }

  export type DarjeStationWhereUniqueInput = Prisma.AtLeast<{
    IdDStation?: number
    AND?: DarjeStationWhereInput | DarjeStationWhereInput[]
    OR?: DarjeStationWhereInput[]
    NOT?: DarjeStationWhereInput | DarjeStationWhereInput[]
    DarajeStation?: StringFilter<"DarjeStation"> | string
    PumpStation?: PumpStationListRelationFilter
  }, "IdDStation">

  export type DarjeStationOrderByWithAggregationInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
    _count?: DarjeStationCountOrderByAggregateInput
    _avg?: DarjeStationAvgOrderByAggregateInput
    _max?: DarjeStationMaxOrderByAggregateInput
    _min?: DarjeStationMinOrderByAggregateInput
    _sum?: DarjeStationSumOrderByAggregateInput
  }

  export type DarjeStationScalarWhereWithAggregatesInput = {
    AND?: DarjeStationScalarWhereWithAggregatesInput | DarjeStationScalarWhereWithAggregatesInput[]
    OR?: DarjeStationScalarWhereWithAggregatesInput[]
    NOT?: DarjeStationScalarWhereWithAggregatesInput | DarjeStationScalarWhereWithAggregatesInput[]
    IdDStation?: IntWithAggregatesFilter<"DarjeStation"> | number
    DarajeStation?: StringWithAggregatesFilter<"DarjeStation"> | string
  }

  export type DoreKeshtWhereInput = {
    AND?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    OR?: DoreKeshtWhereInput[]
    NOT?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    IdDore?: IntFilter<"DoreKesht"> | number
    Dore?: StringFilter<"DoreKesht"> | string
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }

  export type DoreKeshtOrderByWithRelationInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
    ShabakeDoreKesht?: ShabakeDoreKeshtOrderByRelationAggregateInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByRelationAggregateInput
  }

  export type DoreKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdDore?: number
    AND?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    OR?: DoreKeshtWhereInput[]
    NOT?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    Dore?: StringFilter<"DoreKesht"> | string
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }, "IdDore">

  export type DoreKeshtOrderByWithAggregationInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
    _count?: DoreKeshtCountOrderByAggregateInput
    _avg?: DoreKeshtAvgOrderByAggregateInput
    _max?: DoreKeshtMaxOrderByAggregateInput
    _min?: DoreKeshtMinOrderByAggregateInput
    _sum?: DoreKeshtSumOrderByAggregateInput
  }

  export type DoreKeshtScalarWhereWithAggregatesInput = {
    AND?: DoreKeshtScalarWhereWithAggregatesInput | DoreKeshtScalarWhereWithAggregatesInput[]
    OR?: DoreKeshtScalarWhereWithAggregatesInput[]
    NOT?: DoreKeshtScalarWhereWithAggregatesInput | DoreKeshtScalarWhereWithAggregatesInput[]
    IdDore?: IntWithAggregatesFilter<"DoreKesht"> | number
    Dore?: StringWithAggregatesFilter<"DoreKesht"> | string
  }

  export type EshtebahAvamelWhereInput = {
    AND?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    OR?: EshtebahAvamelWhereInput[]
    NOT?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    IdEsht?: IntFilter<"EshtebahAvamel"> | number
    FIdRanesh?: IntFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntFilter<"EshtebahAvamel"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type EshtebahAvamelOrderByWithRelationInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type EshtebahAvamelWhereUniqueInput = Prisma.AtLeast<{
    IdEsht?: number
    AND?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    OR?: EshtebahAvamelWhereInput[]
    NOT?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    FIdRanesh?: IntFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntFilter<"EshtebahAvamel"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdEsht">

  export type EshtebahAvamelOrderByWithAggregationInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
    _count?: EshtebahAvamelCountOrderByAggregateInput
    _avg?: EshtebahAvamelAvgOrderByAggregateInput
    _max?: EshtebahAvamelMaxOrderByAggregateInput
    _min?: EshtebahAvamelMinOrderByAggregateInput
    _sum?: EshtebahAvamelSumOrderByAggregateInput
  }

  export type EshtebahAvamelScalarWhereWithAggregatesInput = {
    AND?: EshtebahAvamelScalarWhereWithAggregatesInput | EshtebahAvamelScalarWhereWithAggregatesInput[]
    OR?: EshtebahAvamelScalarWhereWithAggregatesInput[]
    NOT?: EshtebahAvamelScalarWhereWithAggregatesInput | EshtebahAvamelScalarWhereWithAggregatesInput[]
    IdEsht?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    FIdRanesh?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
  }

  export type FlowBehboodWhereInput = {
    AND?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    OR?: FlowBehboodWhereInput[]
    NOT?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    IdBehbood?: IntFilter<"FlowBehbood"> | number
    FIdRanesh?: IntFilter<"FlowBehbood"> | number
    FIdTarDor?: IntFilter<"FlowBehbood"> | number
    Flow?: IntFilter<"FlowBehbood"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type FlowBehboodOrderByWithRelationInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type FlowBehboodWhereUniqueInput = Prisma.AtLeast<{
    IdBehbood?: number
    AND?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    OR?: FlowBehboodWhereInput[]
    NOT?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    FIdRanesh?: IntFilter<"FlowBehbood"> | number
    FIdTarDor?: IntFilter<"FlowBehbood"> | number
    Flow?: IntFilter<"FlowBehbood"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdBehbood">

  export type FlowBehboodOrderByWithAggregationInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
    _count?: FlowBehboodCountOrderByAggregateInput
    _avg?: FlowBehboodAvgOrderByAggregateInput
    _max?: FlowBehboodMaxOrderByAggregateInput
    _min?: FlowBehboodMinOrderByAggregateInput
    _sum?: FlowBehboodSumOrderByAggregateInput
  }

  export type FlowBehboodScalarWhereWithAggregatesInput = {
    AND?: FlowBehboodScalarWhereWithAggregatesInput | FlowBehboodScalarWhereWithAggregatesInput[]
    OR?: FlowBehboodScalarWhereWithAggregatesInput[]
    NOT?: FlowBehboodScalarWhereWithAggregatesInput | FlowBehboodScalarWhereWithAggregatesInput[]
    IdBehbood?: IntWithAggregatesFilter<"FlowBehbood"> | number
    FIdRanesh?: IntWithAggregatesFilter<"FlowBehbood"> | number
    FIdTarDor?: IntWithAggregatesFilter<"FlowBehbood"> | number
    Flow?: IntWithAggregatesFilter<"FlowBehbood"> | number
  }

  export type FlowmeterWhereInput = {
    AND?: FlowmeterWhereInput | FlowmeterWhereInput[]
    OR?: FlowmeterWhereInput[]
    NOT?: FlowmeterWhereInput | FlowmeterWhereInput[]
    IdFIT?: IntFilter<"Flowmeter"> | number
    FIdRanesh?: IntFilter<"Flowmeter"> | number
    FIdTrikh?: IntFilter<"Flowmeter"> | number
    Flowmeter?: FloatFilter<"Flowmeter"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type FlowmeterOrderByWithRelationInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type FlowmeterWhereUniqueInput = Prisma.AtLeast<{
    IdFIT?: number
    AND?: FlowmeterWhereInput | FlowmeterWhereInput[]
    OR?: FlowmeterWhereInput[]
    NOT?: FlowmeterWhereInput | FlowmeterWhereInput[]
    FIdRanesh?: IntFilter<"Flowmeter"> | number
    FIdTrikh?: IntFilter<"Flowmeter"> | number
    Flowmeter?: FloatFilter<"Flowmeter"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdFIT">

  export type FlowmeterOrderByWithAggregationInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
    _count?: FlowmeterCountOrderByAggregateInput
    _avg?: FlowmeterAvgOrderByAggregateInput
    _max?: FlowmeterMaxOrderByAggregateInput
    _min?: FlowmeterMinOrderByAggregateInput
    _sum?: FlowmeterSumOrderByAggregateInput
  }

  export type FlowmeterScalarWhereWithAggregatesInput = {
    AND?: FlowmeterScalarWhereWithAggregatesInput | FlowmeterScalarWhereWithAggregatesInput[]
    OR?: FlowmeterScalarWhereWithAggregatesInput[]
    NOT?: FlowmeterScalarWhereWithAggregatesInput | FlowmeterScalarWhereWithAggregatesInput[]
    IdFIT?: IntWithAggregatesFilter<"Flowmeter"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Flowmeter"> | number
    FIdTrikh?: IntWithAggregatesFilter<"Flowmeter"> | number
    Flowmeter?: FloatWithAggregatesFilter<"Flowmeter"> | number
  }

  export type KhatRaneshWhereInput = {
    AND?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    OR?: KhatRaneshWhereInput[]
    NOT?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    IdRanesh?: IntFilter<"KhatRanesh"> | number
    RaneshName?: StringFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntFilter<"KhatRanesh"> | number
    FIdDPipe?: IntFilter<"KhatRanesh"> | number
    FIdSePu?: IntFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntFilter<"KhatRanesh"> | number
    Active?: BoolFilter<"KhatRanesh"> | boolean
    Abgir?: AbgirListRelationFilter
    BahrebardairProgram?: BahrebardairProgramListRelationFilter
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliListRelationFilter
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    BahrebardariTaghvim?: BahrebardariTaghvimListRelationFilter
    EshtebahAvamel?: EshtebahAvamelListRelationFilter
    FlowBehbood?: FlowBehboodListRelationFilter
    Flowmeter?: FlowmeterListRelationFilter
    DarajePipe?: XOR<DarajePipeScalarRelationFilter, DarajePipeWhereInput>
    MeasuringTool?: XOR<MeasuringToolScalarRelationFilter, MeasuringToolWhereInput>
    PumpStation?: XOR<PumpStationScalarRelationFilter, PumpStationWhereInput>
    SeghliPump?: XOR<SeghliPumpScalarRelationFilter, SeghliPumpWhereInput>
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
    KhatRaneshPump?: KhatRaneshPumpListRelationFilter
    KhatRaneshSegli?: KhatRaneshSegliListRelationFilter
    NashtShabake?: NashtShabakeListRelationFilter
    NonFIT?: NonFITListRelationFilter
    TakhlieMakhzan?: TakhlieMakhzanListRelationFilter
    Test?: TestListRelationFilter
  }

  export type KhatRaneshOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    Active?: SortOrder
    Abgir?: AbgirOrderByRelationAggregateInput
    BahrebardairProgram?: BahrebardairProgramOrderByRelationAggregateInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliOrderByRelationAggregateInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreOrderByRelationAggregateInput
    BahrebardariTaghvim?: BahrebardariTaghvimOrderByRelationAggregateInput
    EshtebahAvamel?: EshtebahAvamelOrderByRelationAggregateInput
    FlowBehbood?: FlowBehboodOrderByRelationAggregateInput
    Flowmeter?: FlowmeterOrderByRelationAggregateInput
    DarajePipe?: DarajePipeOrderByWithRelationInput
    MeasuringTool?: MeasuringToolOrderByWithRelationInput
    PumpStation?: PumpStationOrderByWithRelationInput
    SeghliPump?: SeghliPumpOrderByWithRelationInput
    KhatRaneshArea?: KhatRaneshAreaOrderByRelationAggregateInput
    KhatRaneshPump?: KhatRaneshPumpOrderByRelationAggregateInput
    KhatRaneshSegli?: KhatRaneshSegliOrderByRelationAggregateInput
    NashtShabake?: NashtShabakeOrderByRelationAggregateInput
    NonFIT?: NonFITOrderByRelationAggregateInput
    TakhlieMakhzan?: TakhlieMakhzanOrderByRelationAggregateInput
    Test?: TestOrderByRelationAggregateInput
  }

  export type KhatRaneshWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    OR?: KhatRaneshWhereInput[]
    NOT?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    RaneshName?: StringFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntFilter<"KhatRanesh"> | number
    FIdDPipe?: IntFilter<"KhatRanesh"> | number
    FIdSePu?: IntFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntFilter<"KhatRanesh"> | number
    Active?: BoolFilter<"KhatRanesh"> | boolean
    Abgir?: AbgirListRelationFilter
    BahrebardairProgram?: BahrebardairProgramListRelationFilter
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliListRelationFilter
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    BahrebardariTaghvim?: BahrebardariTaghvimListRelationFilter
    EshtebahAvamel?: EshtebahAvamelListRelationFilter
    FlowBehbood?: FlowBehboodListRelationFilter
    Flowmeter?: FlowmeterListRelationFilter
    DarajePipe?: XOR<DarajePipeScalarRelationFilter, DarajePipeWhereInput>
    MeasuringTool?: XOR<MeasuringToolScalarRelationFilter, MeasuringToolWhereInput>
    PumpStation?: XOR<PumpStationScalarRelationFilter, PumpStationWhereInput>
    SeghliPump?: XOR<SeghliPumpScalarRelationFilter, SeghliPumpWhereInput>
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
    KhatRaneshPump?: KhatRaneshPumpListRelationFilter
    KhatRaneshSegli?: KhatRaneshSegliListRelationFilter
    NashtShabake?: NashtShabakeListRelationFilter
    NonFIT?: NonFITListRelationFilter
    TakhlieMakhzan?: TakhlieMakhzanListRelationFilter
    Test?: TestListRelationFilter
  }, "IdRanesh">

  export type KhatRaneshOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    Active?: SortOrder
    _count?: KhatRaneshCountOrderByAggregateInput
    _avg?: KhatRaneshAvgOrderByAggregateInput
    _max?: KhatRaneshMaxOrderByAggregateInput
    _min?: KhatRaneshMinOrderByAggregateInput
    _sum?: KhatRaneshSumOrderByAggregateInput
  }

  export type KhatRaneshScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshScalarWhereWithAggregatesInput | KhatRaneshScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshScalarWhereWithAggregatesInput | KhatRaneshScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRanesh"> | number
    RaneshName?: StringWithAggregatesFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdDPipe?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdSePu?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntWithAggregatesFilter<"KhatRanesh"> | number
    Active?: BoolWithAggregatesFilter<"KhatRanesh"> | boolean
  }

  export type KhatRaneshAreaWhereInput = {
    AND?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    OR?: KhatRaneshAreaWhereInput[]
    NOT?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdLand?: IntFilter<"KhatRaneshArea"> | number
    FIdNet?: IntFilter<"KhatRaneshArea"> | number
    Area?: DecimalFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    Land?: XOR<LandScalarRelationFilter, LandWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }

  export type KhatRaneshAreaOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    Land?: LandOrderByWithRelationInput
    Network?: NetworkOrderByWithRelationInput
  }

  export type KhatRaneshAreaWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    OR?: KhatRaneshAreaWhereInput[]
    NOT?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdLand?: IntFilter<"KhatRaneshArea"> | number
    FIdNet?: IntFilter<"KhatRaneshArea"> | number
    Area?: DecimalFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    Land?: XOR<LandScalarRelationFilter, LandWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }, "IdRanesh">

  export type KhatRaneshAreaOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
    _count?: KhatRaneshAreaCountOrderByAggregateInput
    _avg?: KhatRaneshAreaAvgOrderByAggregateInput
    _max?: KhatRaneshAreaMaxOrderByAggregateInput
    _min?: KhatRaneshAreaMinOrderByAggregateInput
    _sum?: KhatRaneshAreaSumOrderByAggregateInput
  }

  export type KhatRaneshAreaScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshAreaScalarWhereWithAggregatesInput | KhatRaneshAreaScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshAreaScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshAreaScalarWhereWithAggregatesInput | KhatRaneshAreaScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdLand?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdNet?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    Area?: DecimalWithAggregatesFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpWhereInput = {
    AND?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    OR?: KhatRaneshPumpWhereInput[]
    NOT?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshPump"> | number
    FIdRanesh?: IntFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntFilter<"KhatRaneshPump"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    PumpType?: XOR<PumpTypeScalarRelationFilter, PumpTypeWhereInput>
  }

  export type KhatRaneshPumpOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrderInput | SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrderInput | SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    PumpType?: PumpTypeOrderByWithRelationInput
  }

  export type KhatRaneshPumpWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    OR?: KhatRaneshPumpWhereInput[]
    NOT?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntFilter<"KhatRaneshPump"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    PumpType?: XOR<PumpTypeScalarRelationFilter, PumpTypeWhereInput>
  }, "IdRanesh">

  export type KhatRaneshPumpOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrderInput | SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrderInput | SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
    _count?: KhatRaneshPumpCountOrderByAggregateInput
    _avg?: KhatRaneshPumpAvgOrderByAggregateInput
    _max?: KhatRaneshPumpMaxOrderByAggregateInput
    _min?: KhatRaneshPumpMinOrderByAggregateInput
    _sum?: KhatRaneshPumpSumOrderByAggregateInput
  }

  export type KhatRaneshPumpScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshPumpScalarWhereWithAggregatesInput | KhatRaneshPumpScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshPumpScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshPumpScalarWhereWithAggregatesInput | KhatRaneshPumpScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableWithAggregatesFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableWithAggregatesFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
  }

  export type KhatRaneshSegliWhereInput = {
    AND?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    OR?: KhatRaneshSegliWhereInput[]
    NOT?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    FIdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
  }

  export type KhatRaneshSegliOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
  }

  export type KhatRaneshSegliWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    OR?: KhatRaneshSegliWhereInput[]
    NOT?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
  }, "IdRanesh">

  export type KhatRaneshSegliOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
    _count?: KhatRaneshSegliCountOrderByAggregateInput
    _avg?: KhatRaneshSegliAvgOrderByAggregateInput
    _max?: KhatRaneshSegliMaxOrderByAggregateInput
    _min?: KhatRaneshSegliMinOrderByAggregateInput
    _sum?: KhatRaneshSegliSumOrderByAggregateInput
  }

  export type KhatRaneshSegliScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshSegliScalarWhereWithAggregatesInput | KhatRaneshSegliScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshSegliScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshSegliScalarWhereWithAggregatesInput | KhatRaneshSegliScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshSegli"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalWithAggregatesFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
  }

  export type KontorWhereInput = {
    AND?: KontorWhereInput | KontorWhereInput[]
    OR?: KontorWhereInput[]
    NOT?: KontorWhereInput | KontorWhereInput[]
    IdKon?: IntFilter<"Kontor"> | number
    FIdKontor?: IntFilter<"Kontor"> | number
    FIdTarDor?: IntFilter<"Kontor"> | number
    Kontor?: IntFilter<"Kontor"> | number
    Abgir?: XOR<AbgirScalarRelationFilter, AbgirWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type KontorOrderByWithRelationInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
    Abgir?: AbgirOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type KontorWhereUniqueInput = Prisma.AtLeast<{
    IdKon?: number
    AND?: KontorWhereInput | KontorWhereInput[]
    OR?: KontorWhereInput[]
    NOT?: KontorWhereInput | KontorWhereInput[]
    FIdKontor?: IntFilter<"Kontor"> | number
    FIdTarDor?: IntFilter<"Kontor"> | number
    Kontor?: IntFilter<"Kontor"> | number
    Abgir?: XOR<AbgirScalarRelationFilter, AbgirWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdKon">

  export type KontorOrderByWithAggregationInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
    _count?: KontorCountOrderByAggregateInput
    _avg?: KontorAvgOrderByAggregateInput
    _max?: KontorMaxOrderByAggregateInput
    _min?: KontorMinOrderByAggregateInput
    _sum?: KontorSumOrderByAggregateInput
  }

  export type KontorScalarWhereWithAggregatesInput = {
    AND?: KontorScalarWhereWithAggregatesInput | KontorScalarWhereWithAggregatesInput[]
    OR?: KontorScalarWhereWithAggregatesInput[]
    NOT?: KontorScalarWhereWithAggregatesInput | KontorScalarWhereWithAggregatesInput[]
    IdKon?: IntWithAggregatesFilter<"Kontor"> | number
    FIdKontor?: IntWithAggregatesFilter<"Kontor"> | number
    FIdTarDor?: IntWithAggregatesFilter<"Kontor"> | number
    Kontor?: IntWithAggregatesFilter<"Kontor"> | number
  }

  export type LandWhereInput = {
    AND?: LandWhereInput | LandWhereInput[]
    OR?: LandWhereInput[]
    NOT?: LandWhereInput | LandWhereInput[]
    IdLand?: IntFilter<"Land"> | number
    Land?: StringFilter<"Land"> | string
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
  }

  export type LandOrderByWithRelationInput = {
    IdLand?: SortOrder
    Land?: SortOrder
    KhatRaneshArea?: KhatRaneshAreaOrderByRelationAggregateInput
  }

  export type LandWhereUniqueInput = Prisma.AtLeast<{
    IdLand?: number
    AND?: LandWhereInput | LandWhereInput[]
    OR?: LandWhereInput[]
    NOT?: LandWhereInput | LandWhereInput[]
    Land?: StringFilter<"Land"> | string
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
  }, "IdLand">

  export type LandOrderByWithAggregationInput = {
    IdLand?: SortOrder
    Land?: SortOrder
    _count?: LandCountOrderByAggregateInput
    _avg?: LandAvgOrderByAggregateInput
    _max?: LandMaxOrderByAggregateInput
    _min?: LandMinOrderByAggregateInput
    _sum?: LandSumOrderByAggregateInput
  }

  export type LandScalarWhereWithAggregatesInput = {
    AND?: LandScalarWhereWithAggregatesInput | LandScalarWhereWithAggregatesInput[]
    OR?: LandScalarWhereWithAggregatesInput[]
    NOT?: LandScalarWhereWithAggregatesInput | LandScalarWhereWithAggregatesInput[]
    IdLand?: IntWithAggregatesFilter<"Land"> | number
    Land?: StringWithAggregatesFilter<"Land"> | string
  }

  export type MeasuringToolWhereInput = {
    AND?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    OR?: MeasuringToolWhereInput[]
    NOT?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    IdMeasuring?: IntFilter<"MeasuringTool"> | number
    MeasuringTool?: StringFilter<"MeasuringTool"> | string
    Precision?: StringFilter<"MeasuringTool"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }

  export type MeasuringToolOrderByWithRelationInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
    KhatRanesh?: KhatRaneshOrderByRelationAggregateInput
  }

  export type MeasuringToolWhereUniqueInput = Prisma.AtLeast<{
    IdMeasuring?: number
    AND?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    OR?: MeasuringToolWhereInput[]
    NOT?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    MeasuringTool?: StringFilter<"MeasuringTool"> | string
    Precision?: StringFilter<"MeasuringTool"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }, "IdMeasuring">

  export type MeasuringToolOrderByWithAggregationInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
    _count?: MeasuringToolCountOrderByAggregateInput
    _avg?: MeasuringToolAvgOrderByAggregateInput
    _max?: MeasuringToolMaxOrderByAggregateInput
    _min?: MeasuringToolMinOrderByAggregateInput
    _sum?: MeasuringToolSumOrderByAggregateInput
  }

  export type MeasuringToolScalarWhereWithAggregatesInput = {
    AND?: MeasuringToolScalarWhereWithAggregatesInput | MeasuringToolScalarWhereWithAggregatesInput[]
    OR?: MeasuringToolScalarWhereWithAggregatesInput[]
    NOT?: MeasuringToolScalarWhereWithAggregatesInput | MeasuringToolScalarWhereWithAggregatesInput[]
    IdMeasuring?: IntWithAggregatesFilter<"MeasuringTool"> | number
    MeasuringTool?: StringWithAggregatesFilter<"MeasuringTool"> | string
    Precision?: StringWithAggregatesFilter<"MeasuringTool"> | string
  }

  export type NashtShabakeWhereInput = {
    AND?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    OR?: NashtShabakeWhereInput[]
    NOT?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    IdNasht?: IntFilter<"NashtShabake"> | number
    FIdRanesh?: IntFilter<"NashtShabake"> | number
    FIdTriDor?: IntFilter<"NashtShabake"> | number
    NashtShabake?: IntFilter<"NashtShabake"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type NashtShabakeOrderByWithRelationInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type NashtShabakeWhereUniqueInput = Prisma.AtLeast<{
    IdNasht?: number
    AND?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    OR?: NashtShabakeWhereInput[]
    NOT?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    FIdRanesh?: IntFilter<"NashtShabake"> | number
    FIdTriDor?: IntFilter<"NashtShabake"> | number
    NashtShabake?: IntFilter<"NashtShabake"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdNasht">

  export type NashtShabakeOrderByWithAggregationInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
    _count?: NashtShabakeCountOrderByAggregateInput
    _avg?: NashtShabakeAvgOrderByAggregateInput
    _max?: NashtShabakeMaxOrderByAggregateInput
    _min?: NashtShabakeMinOrderByAggregateInput
    _sum?: NashtShabakeSumOrderByAggregateInput
  }

  export type NashtShabakeScalarWhereWithAggregatesInput = {
    AND?: NashtShabakeScalarWhereWithAggregatesInput | NashtShabakeScalarWhereWithAggregatesInput[]
    OR?: NashtShabakeScalarWhereWithAggregatesInput[]
    NOT?: NashtShabakeScalarWhereWithAggregatesInput | NashtShabakeScalarWhereWithAggregatesInput[]
    IdNasht?: IntWithAggregatesFilter<"NashtShabake"> | number
    FIdRanesh?: IntWithAggregatesFilter<"NashtShabake"> | number
    FIdTriDor?: IntWithAggregatesFilter<"NashtShabake"> | number
    NashtShabake?: IntWithAggregatesFilter<"NashtShabake"> | number
  }

  export type NetworkWhereInput = {
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    IdNet?: IntFilter<"Network"> | number
    Network?: StringFilter<"Network"> | string
    FIdSP?: IntFilter<"Network"> | number
    BareshMotaleat?: BareshMotaleatListRelationFilter
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
    SystemPart?: XOR<SystemPartScalarRelationFilter, SystemPartWhereInput>
    PumpStation?: PumpStationListRelationFilter
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
  }

  export type NetworkOrderByWithRelationInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
    BareshMotaleat?: BareshMotaleatOrderByRelationAggregateInput
    KhatRaneshArea?: KhatRaneshAreaOrderByRelationAggregateInput
    SystemPart?: SystemPartOrderByWithRelationInput
    PumpStation?: PumpStationOrderByRelationAggregateInput
    ShabakeDoreKesht?: ShabakeDoreKeshtOrderByRelationAggregateInput
  }

  export type NetworkWhereUniqueInput = Prisma.AtLeast<{
    IdNet?: number
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    Network?: StringFilter<"Network"> | string
    FIdSP?: IntFilter<"Network"> | number
    BareshMotaleat?: BareshMotaleatListRelationFilter
    KhatRaneshArea?: KhatRaneshAreaListRelationFilter
    SystemPart?: XOR<SystemPartScalarRelationFilter, SystemPartWhereInput>
    PumpStation?: PumpStationListRelationFilter
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
  }, "IdNet">

  export type NetworkOrderByWithAggregationInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
    _count?: NetworkCountOrderByAggregateInput
    _avg?: NetworkAvgOrderByAggregateInput
    _max?: NetworkMaxOrderByAggregateInput
    _min?: NetworkMinOrderByAggregateInput
    _sum?: NetworkSumOrderByAggregateInput
  }

  export type NetworkScalarWhereWithAggregatesInput = {
    AND?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    OR?: NetworkScalarWhereWithAggregatesInput[]
    NOT?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    IdNet?: IntWithAggregatesFilter<"Network"> | number
    Network?: StringWithAggregatesFilter<"Network"> | string
    FIdSP?: IntWithAggregatesFilter<"Network"> | number
  }

  export type NoeKeshtWhereInput = {
    AND?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    OR?: NoeKeshtWhereInput[]
    NOT?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    IdNoeK?: IntFilter<"NoeKesht"> | number
    Kesht?: StringFilter<"NoeKesht"> | string
    NoeMahsool?: NoeMahsoolListRelationFilter
  }

  export type NoeKeshtOrderByWithRelationInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
    NoeMahsool?: NoeMahsoolOrderByRelationAggregateInput
  }

  export type NoeKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdNoeK?: number
    AND?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    OR?: NoeKeshtWhereInput[]
    NOT?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    Kesht?: StringFilter<"NoeKesht"> | string
    NoeMahsool?: NoeMahsoolListRelationFilter
  }, "IdNoeK">

  export type NoeKeshtOrderByWithAggregationInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
    _count?: NoeKeshtCountOrderByAggregateInput
    _avg?: NoeKeshtAvgOrderByAggregateInput
    _max?: NoeKeshtMaxOrderByAggregateInput
    _min?: NoeKeshtMinOrderByAggregateInput
    _sum?: NoeKeshtSumOrderByAggregateInput
  }

  export type NoeKeshtScalarWhereWithAggregatesInput = {
    AND?: NoeKeshtScalarWhereWithAggregatesInput | NoeKeshtScalarWhereWithAggregatesInput[]
    OR?: NoeKeshtScalarWhereWithAggregatesInput[]
    NOT?: NoeKeshtScalarWhereWithAggregatesInput | NoeKeshtScalarWhereWithAggregatesInput[]
    IdNoeK?: IntWithAggregatesFilter<"NoeKesht"> | number
    Kesht?: StringWithAggregatesFilter<"NoeKesht"> | string
  }

  export type NoeMahsoolWhereInput = {
    AND?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    OR?: NoeMahsoolWhereInput[]
    NOT?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    IdNoeM?: IntFilter<"NoeMahsool"> | number
    Mahsool?: StringFilter<"NoeMahsool"> | string
    FIdNoeK?: IntFilter<"NoeMahsool"> | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    NoeKesht?: XOR<NoeKeshtScalarRelationFilter, NoeKeshtWhereInput>
  }

  export type NoeMahsoolOrderByWithRelationInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
    BahrebardariKeshtDore?: BahrebardariKeshtDoreOrderByRelationAggregateInput
    NoeKesht?: NoeKeshtOrderByWithRelationInput
  }

  export type NoeMahsoolWhereUniqueInput = Prisma.AtLeast<{
    IdNoeM?: number
    AND?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    OR?: NoeMahsoolWhereInput[]
    NOT?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    Mahsool?: StringFilter<"NoeMahsool"> | string
    FIdNoeK?: IntFilter<"NoeMahsool"> | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    NoeKesht?: XOR<NoeKeshtScalarRelationFilter, NoeKeshtWhereInput>
  }, "IdNoeM">

  export type NoeMahsoolOrderByWithAggregationInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
    _count?: NoeMahsoolCountOrderByAggregateInput
    _avg?: NoeMahsoolAvgOrderByAggregateInput
    _max?: NoeMahsoolMaxOrderByAggregateInput
    _min?: NoeMahsoolMinOrderByAggregateInput
    _sum?: NoeMahsoolSumOrderByAggregateInput
  }

  export type NoeMahsoolScalarWhereWithAggregatesInput = {
    AND?: NoeMahsoolScalarWhereWithAggregatesInput | NoeMahsoolScalarWhereWithAggregatesInput[]
    OR?: NoeMahsoolScalarWhereWithAggregatesInput[]
    NOT?: NoeMahsoolScalarWhereWithAggregatesInput | NoeMahsoolScalarWhereWithAggregatesInput[]
    IdNoeM?: IntWithAggregatesFilter<"NoeMahsool"> | number
    Mahsool?: StringWithAggregatesFilter<"NoeMahsool"> | string
    FIdNoeK?: IntWithAggregatesFilter<"NoeMahsool"> | number
  }

  export type NonFITWhereInput = {
    AND?: NonFITWhereInput | NonFITWhereInput[]
    OR?: NonFITWhereInput[]
    NOT?: NonFITWhereInput | NonFITWhereInput[]
    IdNonFIT?: IntFilter<"NonFIT"> | number
    FIdRanesh?: IntFilter<"NonFIT"> | number
    FIdTarDor?: IntFilter<"NonFIT"> | number
    VOLUM?: IntFilter<"NonFIT"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type NonFITOrderByWithRelationInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type NonFITWhereUniqueInput = Prisma.AtLeast<{
    IdNonFIT?: number
    AND?: NonFITWhereInput | NonFITWhereInput[]
    OR?: NonFITWhereInput[]
    NOT?: NonFITWhereInput | NonFITWhereInput[]
    FIdRanesh?: IntFilter<"NonFIT"> | number
    FIdTarDor?: IntFilter<"NonFIT"> | number
    VOLUM?: IntFilter<"NonFIT"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdNonFIT">

  export type NonFITOrderByWithAggregationInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
    _count?: NonFITCountOrderByAggregateInput
    _avg?: NonFITAvgOrderByAggregateInput
    _max?: NonFITMaxOrderByAggregateInput
    _min?: NonFITMinOrderByAggregateInput
    _sum?: NonFITSumOrderByAggregateInput
  }

  export type NonFITScalarWhereWithAggregatesInput = {
    AND?: NonFITScalarWhereWithAggregatesInput | NonFITScalarWhereWithAggregatesInput[]
    OR?: NonFITScalarWhereWithAggregatesInput[]
    NOT?: NonFITScalarWhereWithAggregatesInput | NonFITScalarWhereWithAggregatesInput[]
    IdNonFIT?: IntWithAggregatesFilter<"NonFIT"> | number
    FIdRanesh?: IntWithAggregatesFilter<"NonFIT"> | number
    FIdTarDor?: IntWithAggregatesFilter<"NonFIT"> | number
    VOLUM?: IntWithAggregatesFilter<"NonFIT"> | number
  }

  export type PumpStationWhereInput = {
    AND?: PumpStationWhereInput | PumpStationWhereInput[]
    OR?: PumpStationWhereInput[]
    NOT?: PumpStationWhereInput | PumpStationWhereInput[]
    IdPumpSta?: IntFilter<"PumpStation"> | number
    NameStation?: StringFilter<"PumpStation"> | string
    KM?: IntNullableFilter<"PumpStation"> | number | null
    FIdNet?: IntFilter<"PumpStation"> | number
    FIdDStation?: IntFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableFilter<"PumpStation"> | number | null
    FIdDP?: IntFilter<"PumpStation"> | number
    Ready?: BoolFilter<"PumpStation"> | boolean
    KhatRanesh?: KhatRaneshListRelationFilter
    AbadeMakhzan?: XOR<AbadeMakhzanNullableScalarRelationFilter, AbadeMakhzanWhereInput> | null
    DarjeStation?: XOR<DarjeStationScalarRelationFilter, DarjeStationWhereInput>
    DeliveryPoint?: XOR<DeliveryPointsScalarRelationFilter, DeliveryPointsWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }

  export type PumpStationOrderByWithRelationInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrderInput | SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrderInput | SortOrder
    FIdDP?: SortOrder
    Ready?: SortOrder
    KhatRanesh?: KhatRaneshOrderByRelationAggregateInput
    AbadeMakhzan?: AbadeMakhzanOrderByWithRelationInput
    DarjeStation?: DarjeStationOrderByWithRelationInput
    DeliveryPoint?: DeliveryPointsOrderByWithRelationInput
    Network?: NetworkOrderByWithRelationInput
  }

  export type PumpStationWhereUniqueInput = Prisma.AtLeast<{
    IdPumpSta?: number
    AND?: PumpStationWhereInput | PumpStationWhereInput[]
    OR?: PumpStationWhereInput[]
    NOT?: PumpStationWhereInput | PumpStationWhereInput[]
    NameStation?: StringFilter<"PumpStation"> | string
    KM?: IntNullableFilter<"PumpStation"> | number | null
    FIdNet?: IntFilter<"PumpStation"> | number
    FIdDStation?: IntFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableFilter<"PumpStation"> | number | null
    FIdDP?: IntFilter<"PumpStation"> | number
    Ready?: BoolFilter<"PumpStation"> | boolean
    KhatRanesh?: KhatRaneshListRelationFilter
    AbadeMakhzan?: XOR<AbadeMakhzanNullableScalarRelationFilter, AbadeMakhzanWhereInput> | null
    DarjeStation?: XOR<DarjeStationScalarRelationFilter, DarjeStationWhereInput>
    DeliveryPoint?: XOR<DeliveryPointsScalarRelationFilter, DeliveryPointsWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
  }, "IdPumpSta">

  export type PumpStationOrderByWithAggregationInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrderInput | SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrderInput | SortOrder
    FIdDP?: SortOrder
    Ready?: SortOrder
    _count?: PumpStationCountOrderByAggregateInput
    _avg?: PumpStationAvgOrderByAggregateInput
    _max?: PumpStationMaxOrderByAggregateInput
    _min?: PumpStationMinOrderByAggregateInput
    _sum?: PumpStationSumOrderByAggregateInput
  }

  export type PumpStationScalarWhereWithAggregatesInput = {
    AND?: PumpStationScalarWhereWithAggregatesInput | PumpStationScalarWhereWithAggregatesInput[]
    OR?: PumpStationScalarWhereWithAggregatesInput[]
    NOT?: PumpStationScalarWhereWithAggregatesInput | PumpStationScalarWhereWithAggregatesInput[]
    IdPumpSta?: IntWithAggregatesFilter<"PumpStation"> | number
    NameStation?: StringWithAggregatesFilter<"PumpStation"> | string
    KM?: IntNullableWithAggregatesFilter<"PumpStation"> | number | null
    FIdNet?: IntWithAggregatesFilter<"PumpStation"> | number
    FIdDStation?: IntWithAggregatesFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableWithAggregatesFilter<"PumpStation"> | number | null
    FIdDP?: IntWithAggregatesFilter<"PumpStation"> | number
    Ready?: BoolWithAggregatesFilter<"PumpStation"> | boolean
  }

  export type PumpTypeWhereInput = {
    AND?: PumpTypeWhereInput | PumpTypeWhereInput[]
    OR?: PumpTypeWhereInput[]
    NOT?: PumpTypeWhereInput | PumpTypeWhereInput[]
    IdPump?: IntFilter<"PumpType"> | number
    PumpType?: StringFilter<"PumpType"> | string
    KhatRaneshPump?: KhatRaneshPumpListRelationFilter
  }

  export type PumpTypeOrderByWithRelationInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
    KhatRaneshPump?: KhatRaneshPumpOrderByRelationAggregateInput
  }

  export type PumpTypeWhereUniqueInput = Prisma.AtLeast<{
    IdPump?: number
    AND?: PumpTypeWhereInput | PumpTypeWhereInput[]
    OR?: PumpTypeWhereInput[]
    NOT?: PumpTypeWhereInput | PumpTypeWhereInput[]
    PumpType?: StringFilter<"PumpType"> | string
    KhatRaneshPump?: KhatRaneshPumpListRelationFilter
  }, "IdPump">

  export type PumpTypeOrderByWithAggregationInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
    _count?: PumpTypeCountOrderByAggregateInput
    _avg?: PumpTypeAvgOrderByAggregateInput
    _max?: PumpTypeMaxOrderByAggregateInput
    _min?: PumpTypeMinOrderByAggregateInput
    _sum?: PumpTypeSumOrderByAggregateInput
  }

  export type PumpTypeScalarWhereWithAggregatesInput = {
    AND?: PumpTypeScalarWhereWithAggregatesInput | PumpTypeScalarWhereWithAggregatesInput[]
    OR?: PumpTypeScalarWhereWithAggregatesInput[]
    NOT?: PumpTypeScalarWhereWithAggregatesInput | PumpTypeScalarWhereWithAggregatesInput[]
    IdPump?: IntWithAggregatesFilter<"PumpType"> | number
    PumpType?: StringWithAggregatesFilter<"PumpType"> | string
  }

  export type RainfallStationWhereInput = {
    AND?: RainfallStationWhereInput | RainfallStationWhereInput[]
    OR?: RainfallStationWhereInput[]
    NOT?: RainfallStationWhereInput | RainfallStationWhereInput[]
    IdRaiSta?: IntFilter<"RainfallStation"> | number
    FIdWeaSta?: IntFilter<"RainfallStation"> | number
    FIdTrikh?: IntFilter<"RainfallStation"> | number
    FIdRaiTy?: IntFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
    RainfallType?: XOR<RainfallTypeScalarRelationFilter, RainfallTypeWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
    WeatherStation?: XOR<WeatherStationScalarRelationFilter, WeatherStationWhereInput>
  }

  export type RainfallStationOrderByWithRelationInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
    RainfallType?: RainfallTypeOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
    WeatherStation?: WeatherStationOrderByWithRelationInput
  }

  export type RainfallStationWhereUniqueInput = Prisma.AtLeast<{
    IdRaiSta?: number
    AND?: RainfallStationWhereInput | RainfallStationWhereInput[]
    OR?: RainfallStationWhereInput[]
    NOT?: RainfallStationWhereInput | RainfallStationWhereInput[]
    FIdWeaSta?: IntFilter<"RainfallStation"> | number
    FIdTrikh?: IntFilter<"RainfallStation"> | number
    FIdRaiTy?: IntFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
    RainfallType?: XOR<RainfallTypeScalarRelationFilter, RainfallTypeWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
    WeatherStation?: XOR<WeatherStationScalarRelationFilter, WeatherStationWhereInput>
  }, "IdRaiSta">

  export type RainfallStationOrderByWithAggregationInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
    _count?: RainfallStationCountOrderByAggregateInput
    _avg?: RainfallStationAvgOrderByAggregateInput
    _max?: RainfallStationMaxOrderByAggregateInput
    _min?: RainfallStationMinOrderByAggregateInput
    _sum?: RainfallStationSumOrderByAggregateInput
  }

  export type RainfallStationScalarWhereWithAggregatesInput = {
    AND?: RainfallStationScalarWhereWithAggregatesInput | RainfallStationScalarWhereWithAggregatesInput[]
    OR?: RainfallStationScalarWhereWithAggregatesInput[]
    NOT?: RainfallStationScalarWhereWithAggregatesInput | RainfallStationScalarWhereWithAggregatesInput[]
    IdRaiSta?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdWeaSta?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdTrikh?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdRaiTy?: IntWithAggregatesFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalWithAggregatesFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
  }

  export type RainfallTypeWhereInput = {
    AND?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    OR?: RainfallTypeWhereInput[]
    NOT?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    IdRaiTy?: IntFilter<"RainfallType"> | number
    RainfallType?: StringFilter<"RainfallType"> | string
    RainfallStation?: RainfallStationListRelationFilter
  }

  export type RainfallTypeOrderByWithRelationInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
    RainfallStation?: RainfallStationOrderByRelationAggregateInput
  }

  export type RainfallTypeWhereUniqueInput = Prisma.AtLeast<{
    IdRaiTy?: number
    AND?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    OR?: RainfallTypeWhereInput[]
    NOT?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    RainfallType?: StringFilter<"RainfallType"> | string
    RainfallStation?: RainfallStationListRelationFilter
  }, "IdRaiTy">

  export type RainfallTypeOrderByWithAggregationInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
    _count?: RainfallTypeCountOrderByAggregateInput
    _avg?: RainfallTypeAvgOrderByAggregateInput
    _max?: RainfallTypeMaxOrderByAggregateInput
    _min?: RainfallTypeMinOrderByAggregateInput
    _sum?: RainfallTypeSumOrderByAggregateInput
  }

  export type RainfallTypeScalarWhereWithAggregatesInput = {
    AND?: RainfallTypeScalarWhereWithAggregatesInput | RainfallTypeScalarWhereWithAggregatesInput[]
    OR?: RainfallTypeScalarWhereWithAggregatesInput[]
    NOT?: RainfallTypeScalarWhereWithAggregatesInput | RainfallTypeScalarWhereWithAggregatesInput[]
    IdRaiTy?: IntWithAggregatesFilter<"RainfallType"> | number
    RainfallType?: StringWithAggregatesFilter<"RainfallType"> | string
  }

  export type SaleZeraeeWhereInput = {
    AND?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    OR?: SaleZeraeeWhereInput[]
    NOT?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    IdSal?: IntFilter<"SaleZeraee"> | number
    SaleZeraee?: StringFilter<"SaleZeraee"> | string
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }

  export type SaleZeraeeOrderByWithRelationInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
    ShabakeDoreKesht?: ShabakeDoreKeshtOrderByRelationAggregateInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByRelationAggregateInput
  }

  export type SaleZeraeeWhereUniqueInput = Prisma.AtLeast<{
    IdSal?: number
    AND?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    OR?: SaleZeraeeWhereInput[]
    NOT?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    SaleZeraee?: StringFilter<"SaleZeraee"> | string
    ShabakeDoreKesht?: ShabakeDoreKeshtListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }, "IdSal">

  export type SaleZeraeeOrderByWithAggregationInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
    _count?: SaleZeraeeCountOrderByAggregateInput
    _avg?: SaleZeraeeAvgOrderByAggregateInput
    _max?: SaleZeraeeMaxOrderByAggregateInput
    _min?: SaleZeraeeMinOrderByAggregateInput
    _sum?: SaleZeraeeSumOrderByAggregateInput
  }

  export type SaleZeraeeScalarWhereWithAggregatesInput = {
    AND?: SaleZeraeeScalarWhereWithAggregatesInput | SaleZeraeeScalarWhereWithAggregatesInput[]
    OR?: SaleZeraeeScalarWhereWithAggregatesInput[]
    NOT?: SaleZeraeeScalarWhereWithAggregatesInput | SaleZeraeeScalarWhereWithAggregatesInput[]
    IdSal?: IntWithAggregatesFilter<"SaleZeraee"> | number
    SaleZeraee?: StringWithAggregatesFilter<"SaleZeraee"> | string
  }

  export type SeghliPumpWhereInput = {
    AND?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    OR?: SeghliPumpWhereInput[]
    NOT?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    IdSePu?: IntFilter<"SeghliPump"> | number
    SeghliPump?: StringFilter<"SeghliPump"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }

  export type SeghliPumpOrderByWithRelationInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
    KhatRanesh?: KhatRaneshOrderByRelationAggregateInput
  }

  export type SeghliPumpWhereUniqueInput = Prisma.AtLeast<{
    IdSePu?: number
    AND?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    OR?: SeghliPumpWhereInput[]
    NOT?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    SeghliPump?: StringFilter<"SeghliPump"> | string
    KhatRanesh?: KhatRaneshListRelationFilter
  }, "IdSePu">

  export type SeghliPumpOrderByWithAggregationInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
    _count?: SeghliPumpCountOrderByAggregateInput
    _avg?: SeghliPumpAvgOrderByAggregateInput
    _max?: SeghliPumpMaxOrderByAggregateInput
    _min?: SeghliPumpMinOrderByAggregateInput
    _sum?: SeghliPumpSumOrderByAggregateInput
  }

  export type SeghliPumpScalarWhereWithAggregatesInput = {
    AND?: SeghliPumpScalarWhereWithAggregatesInput | SeghliPumpScalarWhereWithAggregatesInput[]
    OR?: SeghliPumpScalarWhereWithAggregatesInput[]
    NOT?: SeghliPumpScalarWhereWithAggregatesInput | SeghliPumpScalarWhereWithAggregatesInput[]
    IdSePu?: IntWithAggregatesFilter<"SeghliPump"> | number
    SeghliPump?: StringWithAggregatesFilter<"SeghliPump"> | string
  }

  export type SystemPartWhereInput = {
    AND?: SystemPartWhereInput | SystemPartWhereInput[]
    OR?: SystemPartWhereInput[]
    NOT?: SystemPartWhereInput | SystemPartWhereInput[]
    IdSP?: IntFilter<"SystemPart"> | number
    Part?: StringFilter<"SystemPart"> | string
    KM?: IntFilter<"SystemPart"> | number
    Network?: NetworkListRelationFilter
  }

  export type SystemPartOrderByWithRelationInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
    Network?: NetworkOrderByRelationAggregateInput
  }

  export type SystemPartWhereUniqueInput = Prisma.AtLeast<{
    IdSP?: number
    AND?: SystemPartWhereInput | SystemPartWhereInput[]
    OR?: SystemPartWhereInput[]
    NOT?: SystemPartWhereInput | SystemPartWhereInput[]
    Part?: StringFilter<"SystemPart"> | string
    KM?: IntFilter<"SystemPart"> | number
    Network?: NetworkListRelationFilter
  }, "IdSP">

  export type SystemPartOrderByWithAggregationInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
    _count?: SystemPartCountOrderByAggregateInput
    _avg?: SystemPartAvgOrderByAggregateInput
    _max?: SystemPartMaxOrderByAggregateInput
    _min?: SystemPartMinOrderByAggregateInput
    _sum?: SystemPartSumOrderByAggregateInput
  }

  export type SystemPartScalarWhereWithAggregatesInput = {
    AND?: SystemPartScalarWhereWithAggregatesInput | SystemPartScalarWhereWithAggregatesInput[]
    OR?: SystemPartScalarWhereWithAggregatesInput[]
    NOT?: SystemPartScalarWhereWithAggregatesInput | SystemPartScalarWhereWithAggregatesInput[]
    IdSP?: IntWithAggregatesFilter<"SystemPart"> | number
    Part?: StringWithAggregatesFilter<"SystemPart"> | string
    KM?: IntWithAggregatesFilter<"SystemPart"> | number
  }

  export type TakhlieMakhzanWhereInput = {
    AND?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    OR?: TakhlieMakhzanWhereInput[]
    NOT?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    IdTakhlie?: IntFilter<"TakhlieMakhzan"> | number
    FIdRanesh?: IntFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntFilter<"TakhlieMakhzan"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type TakhlieMakhzanOrderByWithRelationInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type TakhlieMakhzanWhereUniqueInput = Prisma.AtLeast<{
    IdTakhlie?: number
    AND?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    OR?: TakhlieMakhzanWhereInput[]
    NOT?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    FIdRanesh?: IntFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntFilter<"TakhlieMakhzan"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdTakhlie">

  export type TakhlieMakhzanOrderByWithAggregationInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
    _count?: TakhlieMakhzanCountOrderByAggregateInput
    _avg?: TakhlieMakhzanAvgOrderByAggregateInput
    _max?: TakhlieMakhzanMaxOrderByAggregateInput
    _min?: TakhlieMakhzanMinOrderByAggregateInput
    _sum?: TakhlieMakhzanSumOrderByAggregateInput
  }

  export type TakhlieMakhzanScalarWhereWithAggregatesInput = {
    AND?: TakhlieMakhzanScalarWhereWithAggregatesInput | TakhlieMakhzanScalarWhereWithAggregatesInput[]
    OR?: TakhlieMakhzanScalarWhereWithAggregatesInput[]
    NOT?: TakhlieMakhzanScalarWhereWithAggregatesInput | TakhlieMakhzanScalarWhereWithAggregatesInput[]
    IdTakhlie?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    FIdRanesh?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    IdTest?: IntFilter<"Test"> | number
    FIdRanesh?: IntFilter<"Test"> | number
    FIdTarDor?: IntFilter<"Test"> | number
    Test?: IntFilter<"Test"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }

  export type TestOrderByWithRelationInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
    KhatRanesh?: KhatRaneshOrderByWithRelationInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByWithRelationInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    IdTest?: number
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    FIdRanesh?: IntFilter<"Test"> | number
    FIdTarDor?: IntFilter<"Test"> | number
    Test?: IntFilter<"Test"> | number
    KhatRanesh?: XOR<KhatRaneshScalarRelationFilter, KhatRaneshWhereInput>
    TrikhDoreKesht?: XOR<TrikhDoreKeshtScalarRelationFilter, TrikhDoreKeshtWhereInput>
  }, "IdTest">

  export type TestOrderByWithAggregationInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    IdTest?: IntWithAggregatesFilter<"Test"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Test"> | number
    FIdTarDor?: IntWithAggregatesFilter<"Test"> | number
    Test?: IntWithAggregatesFilter<"Test"> | number
  }

  export type TrikhDoreKeshtWhereInput = {
    AND?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    OR?: TrikhDoreKeshtWhereInput[]
    NOT?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    IdTarDor?: IntFilter<"TrikhDoreKesht"> | number
    FIdSal?: IntFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringFilter<"TrikhDoreKesht"> | string
    Dahe?: IntFilter<"TrikhDoreKesht"> | number
    Sal?: IntFilter<"TrikhDoreKesht"> | number
    Mah?: IntFilter<"TrikhDoreKesht"> | number
    BahrebardairProgram?: BahrebardairProgramListRelationFilter
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliListRelationFilter
    BahrebardariTaghvim?: BahrebardariTaghvimListRelationFilter
    EshtebahAvamel?: EshtebahAvamelListRelationFilter
    FlowBehbood?: FlowBehboodListRelationFilter
    Flowmeter?: FlowmeterListRelationFilter
    Kontor?: KontorListRelationFilter
    NashtShabake?: NashtShabakeListRelationFilter
    NonFIT?: NonFITListRelationFilter
    RainfallStation?: RainfallStationListRelationFilter
    TakhlieMakhzan?: TakhlieMakhzanListRelationFilter
    Test?: TestListRelationFilter
    DoreKesht?: XOR<DoreKeshtScalarRelationFilter, DoreKeshtWhereInput>
    MahShamsi?: XOR<MahShamsiScalarRelationFilter, MahShamsiWhereInput>
    SaleZeraee?: XOR<SaleZeraeeScalarRelationFilter, SaleZeraeeWhereInput>
  }

  export type TrikhDoreKeshtOrderByWithRelationInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    BahrebardairProgram?: BahrebardairProgramOrderByRelationAggregateInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliOrderByRelationAggregateInput
    BahrebardariTaghvim?: BahrebardariTaghvimOrderByRelationAggregateInput
    EshtebahAvamel?: EshtebahAvamelOrderByRelationAggregateInput
    FlowBehbood?: FlowBehboodOrderByRelationAggregateInput
    Flowmeter?: FlowmeterOrderByRelationAggregateInput
    Kontor?: KontorOrderByRelationAggregateInput
    NashtShabake?: NashtShabakeOrderByRelationAggregateInput
    NonFIT?: NonFITOrderByRelationAggregateInput
    RainfallStation?: RainfallStationOrderByRelationAggregateInput
    TakhlieMakhzan?: TakhlieMakhzanOrderByRelationAggregateInput
    Test?: TestOrderByRelationAggregateInput
    DoreKesht?: DoreKeshtOrderByWithRelationInput
    MahShamsi?: MahShamsiOrderByWithRelationInput
    SaleZeraee?: SaleZeraeeOrderByWithRelationInput
  }

  export type TrikhDoreKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdTarDor?: number
    AND?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    OR?: TrikhDoreKeshtWhereInput[]
    NOT?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    FIdSal?: IntFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringFilter<"TrikhDoreKesht"> | string
    Dahe?: IntFilter<"TrikhDoreKesht"> | number
    Sal?: IntFilter<"TrikhDoreKesht"> | number
    Mah?: IntFilter<"TrikhDoreKesht"> | number
    BahrebardairProgram?: BahrebardairProgramListRelationFilter
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliListRelationFilter
    BahrebardariTaghvim?: BahrebardariTaghvimListRelationFilter
    EshtebahAvamel?: EshtebahAvamelListRelationFilter
    FlowBehbood?: FlowBehboodListRelationFilter
    Flowmeter?: FlowmeterListRelationFilter
    Kontor?: KontorListRelationFilter
    NashtShabake?: NashtShabakeListRelationFilter
    NonFIT?: NonFITListRelationFilter
    RainfallStation?: RainfallStationListRelationFilter
    TakhlieMakhzan?: TakhlieMakhzanListRelationFilter
    Test?: TestListRelationFilter
    DoreKesht?: XOR<DoreKeshtScalarRelationFilter, DoreKeshtWhereInput>
    MahShamsi?: XOR<MahShamsiScalarRelationFilter, MahShamsiWhereInput>
    SaleZeraee?: XOR<SaleZeraeeScalarRelationFilter, SaleZeraeeWhereInput>
  }, "IdTarDor">

  export type TrikhDoreKeshtOrderByWithAggregationInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    _count?: TrikhDoreKeshtCountOrderByAggregateInput
    _avg?: TrikhDoreKeshtAvgOrderByAggregateInput
    _max?: TrikhDoreKeshtMaxOrderByAggregateInput
    _min?: TrikhDoreKeshtMinOrderByAggregateInput
    _sum?: TrikhDoreKeshtSumOrderByAggregateInput
  }

  export type TrikhDoreKeshtScalarWhereWithAggregatesInput = {
    AND?: TrikhDoreKeshtScalarWhereWithAggregatesInput | TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    OR?: TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    NOT?: TrikhDoreKeshtScalarWhereWithAggregatesInput | TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    IdTarDor?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    FIdSal?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeWithAggregatesFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringWithAggregatesFilter<"TrikhDoreKesht"> | string
    Dahe?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    Sal?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    Mah?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
  }

  export type WeatherStationWhereInput = {
    AND?: WeatherStationWhereInput | WeatherStationWhereInput[]
    OR?: WeatherStationWhereInput[]
    NOT?: WeatherStationWhereInput | WeatherStationWhereInput[]
    IdWeaSta?: IntFilter<"WeatherStation"> | number
    Station?: StringFilter<"WeatherStation"> | string
    RainfallStation?: RainfallStationListRelationFilter
  }

  export type WeatherStationOrderByWithRelationInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
    RainfallStation?: RainfallStationOrderByRelationAggregateInput
  }

  export type WeatherStationWhereUniqueInput = Prisma.AtLeast<{
    IdWeaSta?: number
    AND?: WeatherStationWhereInput | WeatherStationWhereInput[]
    OR?: WeatherStationWhereInput[]
    NOT?: WeatherStationWhereInput | WeatherStationWhereInput[]
    Station?: StringFilter<"WeatherStation"> | string
    RainfallStation?: RainfallStationListRelationFilter
  }, "IdWeaSta">

  export type WeatherStationOrderByWithAggregationInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
    _count?: WeatherStationCountOrderByAggregateInput
    _avg?: WeatherStationAvgOrderByAggregateInput
    _max?: WeatherStationMaxOrderByAggregateInput
    _min?: WeatherStationMinOrderByAggregateInput
    _sum?: WeatherStationSumOrderByAggregateInput
  }

  export type WeatherStationScalarWhereWithAggregatesInput = {
    AND?: WeatherStationScalarWhereWithAggregatesInput | WeatherStationScalarWhereWithAggregatesInput[]
    OR?: WeatherStationScalarWhereWithAggregatesInput[]
    NOT?: WeatherStationScalarWhereWithAggregatesInput | WeatherStationScalarWhereWithAggregatesInput[]
    IdWeaSta?: IntWithAggregatesFilter<"WeatherStation"> | number
    Station?: StringWithAggregatesFilter<"WeatherStation"> | string
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type MahShamsiWhereInput = {
    AND?: MahShamsiWhereInput | MahShamsiWhereInput[]
    OR?: MahShamsiWhereInput[]
    NOT?: MahShamsiWhereInput | MahShamsiWhereInput[]
    IdMah?: IntFilter<"MahShamsi"> | number
    Mah?: StringFilter<"MahShamsi"> | string
    BareshMotaleat?: BareshMotaleatListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }

  export type MahShamsiOrderByWithRelationInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
    BareshMotaleat?: BareshMotaleatOrderByRelationAggregateInput
    TrikhDoreKesht?: TrikhDoreKeshtOrderByRelationAggregateInput
  }

  export type MahShamsiWhereUniqueInput = Prisma.AtLeast<{
    IdMah?: number
    AND?: MahShamsiWhereInput | MahShamsiWhereInput[]
    OR?: MahShamsiWhereInput[]
    NOT?: MahShamsiWhereInput | MahShamsiWhereInput[]
    Mah?: StringFilter<"MahShamsi"> | string
    BareshMotaleat?: BareshMotaleatListRelationFilter
    TrikhDoreKesht?: TrikhDoreKeshtListRelationFilter
  }, "IdMah">

  export type MahShamsiOrderByWithAggregationInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
    _count?: MahShamsiCountOrderByAggregateInput
    _avg?: MahShamsiAvgOrderByAggregateInput
    _max?: MahShamsiMaxOrderByAggregateInput
    _min?: MahShamsiMinOrderByAggregateInput
    _sum?: MahShamsiSumOrderByAggregateInput
  }

  export type MahShamsiScalarWhereWithAggregatesInput = {
    AND?: MahShamsiScalarWhereWithAggregatesInput | MahShamsiScalarWhereWithAggregatesInput[]
    OR?: MahShamsiScalarWhereWithAggregatesInput[]
    NOT?: MahShamsiScalarWhereWithAggregatesInput | MahShamsiScalarWhereWithAggregatesInput[]
    IdMah?: IntWithAggregatesFilter<"MahShamsi"> | number
    Mah?: StringWithAggregatesFilter<"MahShamsi"> | string
  }

  export type ShabakeDoreKeshtWhereInput = {
    AND?: ShabakeDoreKeshtWhereInput | ShabakeDoreKeshtWhereInput[]
    OR?: ShabakeDoreKeshtWhereInput[]
    NOT?: ShabakeDoreKeshtWhereInput | ShabakeDoreKeshtWhereInput[]
    IdShDo?: IntFilter<"ShabakeDoreKesht"> | number
    FIdNet?: IntFilter<"ShabakeDoreKesht"> | number
    TrikhShorooe?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    TrikhPayan?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    FIdSal?: IntFilter<"ShabakeDoreKesht"> | number
    FIdDore?: IntFilter<"ShabakeDoreKesht"> | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    DoreKesht?: XOR<DoreKeshtScalarRelationFilter, DoreKeshtWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
    SaleZeraee?: XOR<SaleZeraeeScalarRelationFilter, SaleZeraeeWhereInput>
  }

  export type ShabakeDoreKeshtOrderByWithRelationInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    TrikhShorooe?: SortOrder
    TrikhPayan?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    BahrebardariKeshtDore?: BahrebardariKeshtDoreOrderByRelationAggregateInput
    DoreKesht?: DoreKeshtOrderByWithRelationInput
    Network?: NetworkOrderByWithRelationInput
    SaleZeraee?: SaleZeraeeOrderByWithRelationInput
  }

  export type ShabakeDoreKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdShDo?: number
    AND?: ShabakeDoreKeshtWhereInput | ShabakeDoreKeshtWhereInput[]
    OR?: ShabakeDoreKeshtWhereInput[]
    NOT?: ShabakeDoreKeshtWhereInput | ShabakeDoreKeshtWhereInput[]
    FIdNet?: IntFilter<"ShabakeDoreKesht"> | number
    TrikhShorooe?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    TrikhPayan?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    FIdSal?: IntFilter<"ShabakeDoreKesht"> | number
    FIdDore?: IntFilter<"ShabakeDoreKesht"> | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreListRelationFilter
    DoreKesht?: XOR<DoreKeshtScalarRelationFilter, DoreKeshtWhereInput>
    Network?: XOR<NetworkScalarRelationFilter, NetworkWhereInput>
    SaleZeraee?: XOR<SaleZeraeeScalarRelationFilter, SaleZeraeeWhereInput>
  }, "IdShDo">

  export type ShabakeDoreKeshtOrderByWithAggregationInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    TrikhShorooe?: SortOrder
    TrikhPayan?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    _count?: ShabakeDoreKeshtCountOrderByAggregateInput
    _avg?: ShabakeDoreKeshtAvgOrderByAggregateInput
    _max?: ShabakeDoreKeshtMaxOrderByAggregateInput
    _min?: ShabakeDoreKeshtMinOrderByAggregateInput
    _sum?: ShabakeDoreKeshtSumOrderByAggregateInput
  }

  export type ShabakeDoreKeshtScalarWhereWithAggregatesInput = {
    AND?: ShabakeDoreKeshtScalarWhereWithAggregatesInput | ShabakeDoreKeshtScalarWhereWithAggregatesInput[]
    OR?: ShabakeDoreKeshtScalarWhereWithAggregatesInput[]
    NOT?: ShabakeDoreKeshtScalarWhereWithAggregatesInput | ShabakeDoreKeshtScalarWhereWithAggregatesInput[]
    IdShDo?: IntWithAggregatesFilter<"ShabakeDoreKesht"> | number
    FIdNet?: IntWithAggregatesFilter<"ShabakeDoreKesht"> | number
    TrikhShorooe?: DateTimeWithAggregatesFilter<"ShabakeDoreKesht"> | Date | string
    TrikhPayan?: DateTimeWithAggregatesFilter<"ShabakeDoreKesht"> | Date | string
    FIdSal?: IntWithAggregatesFilter<"ShabakeDoreKesht"> | number
    FIdDore?: IntWithAggregatesFilter<"ShabakeDoreKesht"> | number
  }

  export type TaeedProgramWhereInput = {
    AND?: TaeedProgramWhereInput | TaeedProgramWhereInput[]
    OR?: TaeedProgramWhereInput[]
    NOT?: TaeedProgramWhereInput | TaeedProgramWhereInput[]
    IdTaeedProgram?: IntFilter<"TaeedProgram"> | number
    FIdPumpSta?: IntFilter<"TaeedProgram"> | number
    FIdSal?: IntFilter<"TaeedProgram"> | number
    FIdDore?: IntFilter<"TaeedProgram"> | number
    Sal?: IntFilter<"TaeedProgram"> | number
    Mah?: IntFilter<"TaeedProgram"> | number
    Dahe?: IntFilter<"TaeedProgram"> | number
    FIdUserErsal?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhErsal?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    FIdUserAbMantaghe?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhAbMantaghe?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedAbMantaghe?: BoolNullableFilter<"TaeedProgram"> | boolean | null
    FIdUserPeymankar?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhPeymankar?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedPeymankar?: BoolNullableFilter<"TaeedProgram"> | boolean | null
    FIdUserAbNiroo?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhAbNiroo?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    FileNameNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    FilePathNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhFileNahee?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    FIdUserTaeedNahaee?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNTaeedNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNTaeedNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhTaeedNahaee?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaeedNahaee?: BoolNullableFilter<"TaeedProgram"> | boolean | null
  }

  export type TaeedProgramOrderByWithRelationInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrderInput | SortOrder
    FirstNErsal?: SortOrderInput | SortOrder
    LastNErsal?: SortOrderInput | SortOrder
    TozihErsal?: SortOrderInput | SortOrder
    TarikhErsal?: SortOrderInput | SortOrder
    FIdUserAbMantaghe?: SortOrderInput | SortOrder
    FirstNAbMantaghe?: SortOrderInput | SortOrder
    LastNAbMantaghe?: SortOrderInput | SortOrder
    TozihAbMantaghe?: SortOrderInput | SortOrder
    TarikhAbMantaghe?: SortOrderInput | SortOrder
    TaedAbMantaghe?: SortOrderInput | SortOrder
    FIdUserPeymankar?: SortOrderInput | SortOrder
    FirstNPeymankar?: SortOrderInput | SortOrder
    LastNPeymankar?: SortOrderInput | SortOrder
    TozihPeymankar?: SortOrderInput | SortOrder
    TarikhPeymankar?: SortOrderInput | SortOrder
    TaedPeymankar?: SortOrderInput | SortOrder
    FIdUserAbNiroo?: SortOrderInput | SortOrder
    FirstNAbNiroo?: SortOrderInput | SortOrder
    LastNAbNiroo?: SortOrderInput | SortOrder
    TozihAbNiroo?: SortOrderInput | SortOrder
    TarikhAbNiroo?: SortOrderInput | SortOrder
    TaedAbNiroo?: SortOrderInput | SortOrder
    FileNameNahaee?: SortOrderInput | SortOrder
    FilePathNahaee?: SortOrderInput | SortOrder
    TarikhFileNahee?: SortOrderInput | SortOrder
    FIdUserTaeedNahaee?: SortOrderInput | SortOrder
    FirstNTaeedNahaee?: SortOrderInput | SortOrder
    LastNTaeedNahaee?: SortOrderInput | SortOrder
    TarikhTaeedNahaee?: SortOrderInput | SortOrder
    TaeedNahaee?: SortOrderInput | SortOrder
  }

  export type TaeedProgramWhereUniqueInput = Prisma.AtLeast<{
    IdTaeedProgram?: number
    AND?: TaeedProgramWhereInput | TaeedProgramWhereInput[]
    OR?: TaeedProgramWhereInput[]
    NOT?: TaeedProgramWhereInput | TaeedProgramWhereInput[]
    FIdPumpSta?: IntFilter<"TaeedProgram"> | number
    FIdSal?: IntFilter<"TaeedProgram"> | number
    FIdDore?: IntFilter<"TaeedProgram"> | number
    Sal?: IntFilter<"TaeedProgram"> | number
    Mah?: IntFilter<"TaeedProgram"> | number
    Dahe?: IntFilter<"TaeedProgram"> | number
    FIdUserErsal?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihErsal?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhErsal?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    FIdUserAbMantaghe?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihAbMantaghe?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhAbMantaghe?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedAbMantaghe?: BoolNullableFilter<"TaeedProgram"> | boolean | null
    FIdUserPeymankar?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihPeymankar?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhPeymankar?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedPeymankar?: BoolNullableFilter<"TaeedProgram"> | boolean | null
    FIdUserAbNiroo?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    TozihAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhAbNiroo?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaedAbNiroo?: StringNullableFilter<"TaeedProgram"> | string | null
    FileNameNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    FilePathNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhFileNahee?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    FIdUserTaeedNahaee?: IntNullableFilter<"TaeedProgram"> | number | null
    FirstNTaeedNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    LastNTaeedNahaee?: StringNullableFilter<"TaeedProgram"> | string | null
    TarikhTaeedNahaee?: DateTimeNullableFilter<"TaeedProgram"> | Date | string | null
    TaeedNahaee?: BoolNullableFilter<"TaeedProgram"> | boolean | null
  }, "IdTaeedProgram">

  export type TaeedProgramOrderByWithAggregationInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrderInput | SortOrder
    FirstNErsal?: SortOrderInput | SortOrder
    LastNErsal?: SortOrderInput | SortOrder
    TozihErsal?: SortOrderInput | SortOrder
    TarikhErsal?: SortOrderInput | SortOrder
    FIdUserAbMantaghe?: SortOrderInput | SortOrder
    FirstNAbMantaghe?: SortOrderInput | SortOrder
    LastNAbMantaghe?: SortOrderInput | SortOrder
    TozihAbMantaghe?: SortOrderInput | SortOrder
    TarikhAbMantaghe?: SortOrderInput | SortOrder
    TaedAbMantaghe?: SortOrderInput | SortOrder
    FIdUserPeymankar?: SortOrderInput | SortOrder
    FirstNPeymankar?: SortOrderInput | SortOrder
    LastNPeymankar?: SortOrderInput | SortOrder
    TozihPeymankar?: SortOrderInput | SortOrder
    TarikhPeymankar?: SortOrderInput | SortOrder
    TaedPeymankar?: SortOrderInput | SortOrder
    FIdUserAbNiroo?: SortOrderInput | SortOrder
    FirstNAbNiroo?: SortOrderInput | SortOrder
    LastNAbNiroo?: SortOrderInput | SortOrder
    TozihAbNiroo?: SortOrderInput | SortOrder
    TarikhAbNiroo?: SortOrderInput | SortOrder
    TaedAbNiroo?: SortOrderInput | SortOrder
    FileNameNahaee?: SortOrderInput | SortOrder
    FilePathNahaee?: SortOrderInput | SortOrder
    TarikhFileNahee?: SortOrderInput | SortOrder
    FIdUserTaeedNahaee?: SortOrderInput | SortOrder
    FirstNTaeedNahaee?: SortOrderInput | SortOrder
    LastNTaeedNahaee?: SortOrderInput | SortOrder
    TarikhTaeedNahaee?: SortOrderInput | SortOrder
    TaeedNahaee?: SortOrderInput | SortOrder
    _count?: TaeedProgramCountOrderByAggregateInput
    _avg?: TaeedProgramAvgOrderByAggregateInput
    _max?: TaeedProgramMaxOrderByAggregateInput
    _min?: TaeedProgramMinOrderByAggregateInput
    _sum?: TaeedProgramSumOrderByAggregateInput
  }

  export type TaeedProgramScalarWhereWithAggregatesInput = {
    AND?: TaeedProgramScalarWhereWithAggregatesInput | TaeedProgramScalarWhereWithAggregatesInput[]
    OR?: TaeedProgramScalarWhereWithAggregatesInput[]
    NOT?: TaeedProgramScalarWhereWithAggregatesInput | TaeedProgramScalarWhereWithAggregatesInput[]
    IdTaeedProgram?: IntWithAggregatesFilter<"TaeedProgram"> | number
    FIdPumpSta?: IntWithAggregatesFilter<"TaeedProgram"> | number
    FIdSal?: IntWithAggregatesFilter<"TaeedProgram"> | number
    FIdDore?: IntWithAggregatesFilter<"TaeedProgram"> | number
    Sal?: IntWithAggregatesFilter<"TaeedProgram"> | number
    Mah?: IntWithAggregatesFilter<"TaeedProgram"> | number
    Dahe?: IntWithAggregatesFilter<"TaeedProgram"> | number
    FIdUserErsal?: IntNullableWithAggregatesFilter<"TaeedProgram"> | number | null
    FirstNErsal?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    LastNErsal?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TozihErsal?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhErsal?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    FIdUserAbMantaghe?: IntNullableWithAggregatesFilter<"TaeedProgram"> | number | null
    FirstNAbMantaghe?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    LastNAbMantaghe?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TozihAbMantaghe?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhAbMantaghe?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    TaedAbMantaghe?: BoolNullableWithAggregatesFilter<"TaeedProgram"> | boolean | null
    FIdUserPeymankar?: IntNullableWithAggregatesFilter<"TaeedProgram"> | number | null
    FirstNPeymankar?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    LastNPeymankar?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TozihPeymankar?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhPeymankar?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    TaedPeymankar?: BoolNullableWithAggregatesFilter<"TaeedProgram"> | boolean | null
    FIdUserAbNiroo?: IntNullableWithAggregatesFilter<"TaeedProgram"> | number | null
    FirstNAbNiroo?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    LastNAbNiroo?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TozihAbNiroo?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhAbNiroo?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    TaedAbNiroo?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    FileNameNahaee?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    FilePathNahaee?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhFileNahee?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    FIdUserTaeedNahaee?: IntNullableWithAggregatesFilter<"TaeedProgram"> | number | null
    FirstNTaeedNahaee?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    LastNTaeedNahaee?: StringNullableWithAggregatesFilter<"TaeedProgram"> | string | null
    TarikhTaeedNahaee?: DateTimeNullableWithAggregatesFilter<"TaeedProgram"> | Date | string | null
    TaeedNahaee?: BoolNullableWithAggregatesFilter<"TaeedProgram"> | boolean | null
  }

  export type AbadeMakhzanCreateInput = {
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
    PumpStation?: PumpStationCreateNestedManyWithoutAbadeMakhzanInput
  }

  export type AbadeMakhzanUncheckedCreateInput = {
    IdMakhzan?: number
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutAbadeMakhzanInput
  }

  export type AbadeMakhzanUpdateInput = {
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
    PumpStation?: PumpStationUpdateManyWithoutAbadeMakhzanNestedInput
  }

  export type AbadeMakhzanUncheckedUpdateInput = {
    IdMakhzan?: IntFieldUpdateOperationsInput | number
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
    PumpStation?: PumpStationUncheckedUpdateManyWithoutAbadeMakhzanNestedInput
  }

  export type AbadeMakhzanCreateManyInput = {
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanUpdateManyMutationInput = {
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbadeMakhzanUncheckedUpdateManyInput = {
    IdMakhzan?: IntFieldUpdateOperationsInput | number
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirCreateInput = {
    Abgir: string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutAbgirInput
    Kontor?: KontorCreateNestedManyWithoutAbgirInput
  }

  export type AbgirUncheckedCreateInput = {
    IdKontor?: number
    FIdRanesh: number
    Abgir: string
    Kontor?: KontorUncheckedCreateNestedManyWithoutAbgirInput
  }

  export type AbgirUpdateInput = {
    Abgir?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutAbgirNestedInput
    Kontor?: KontorUpdateManyWithoutAbgirNestedInput
  }

  export type AbgirUncheckedUpdateInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
    Kontor?: KontorUncheckedUpdateManyWithoutAbgirNestedInput
  }

  export type AbgirCreateManyInput = {
    FIdRanesh: number
    Abgir: string
  }

  export type AbgirUpdateManyMutationInput = {
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirUncheckedUpdateManyInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type BahrebardairProgramCreateInput = {
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardairProgramInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramInput
  }

  export type BahrebardairProgramUncheckedCreateInput = {
    IdProgram?: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramUpdateInput = {
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramNestedInput
  }

  export type BahrebardairProgramUncheckedUpdateInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramUpdateManyMutationInput = {
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramUncheckedUpdateManyInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliCreateInput = {
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardairProgramSeghliInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramSeghliInput
  }

  export type BahrebardairProgramSeghliUncheckedCreateInput = {
    IdProSrgl?: number
    FIdRanesh: number
    FIdTarDor: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliUpdateInput = {
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput
  }

  export type BahrebardairProgramSeghliUncheckedUpdateInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliUpdateManyMutationInput = {
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliUncheckedUpdateManyInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardariKeshtDoreCreateInput = {
    IdBahDor: number
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardariKeshtDoreInput
    NoeMahsool: NoeMahsoolCreateNestedOneWithoutBahrebardariKeshtDoreInput
    ShabakeDoreKesht: ShabakeDoreKeshtCreateNestedOneWithoutBahrebardariKeshtDoreInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateInput = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
    NoeMahsool?: NoeMahsoolUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
  }

  export type BahrebardariKeshtDoreUncheckedUpdateInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreCreateManyInput = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateManyMutationInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateInput = {
    Taghvim: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardariTaghvimInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardariTaghvimInput
  }

  export type BahrebardariTaghvimUncheckedCreateInput = {
    IdTag?: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpdateInput = {
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput
  }

  export type BahrebardariTaghvimUncheckedUpdateInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateManyInput = {
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpdateManyMutationInput = {
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedUpdateManyInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateInput = {
    BareshMotaleat: Decimal | DecimalJsLike | number | string
    Mah: MahShamsiCreateNestedOneWithoutBareshMotaleatInput
    Network: NetworkCreateNestedOneWithoutBareshMotaleatInput
  }

  export type BareshMotaleatUncheckedCreateInput = {
    IdBarMot?: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUpdateInput = {
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Mah?: MahShamsiUpdateOneRequiredWithoutBareshMotaleatNestedInput
    Network?: NetworkUpdateOneRequiredWithoutBareshMotaleatNestedInput
  }

  export type BareshMotaleatUncheckedUpdateInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateManyInput = {
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUpdateManyMutationInput = {
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedUpdateManyInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DarajePipeCreateInput = {
    DarajePipe: string
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutDarajePipeInput
  }

  export type DarajePipeUncheckedCreateInput = {
    IdDPipe?: number
    DarajePipe: string
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutDarajePipeInput
  }

  export type DarajePipeUpdateInput = {
    DarajePipe?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUpdateManyWithoutDarajePipeNestedInput
  }

  export type DarajePipeUncheckedUpdateInput = {
    IdDPipe?: IntFieldUpdateOperationsInput | number
    DarajePipe?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutDarajePipeNestedInput
  }

  export type DarajePipeCreateManyInput = {
    DarajePipe: string
  }

  export type DarajePipeUpdateManyMutationInput = {
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarajePipeUncheckedUpdateManyInput = {
    IdDPipe?: IntFieldUpdateOperationsInput | number
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryPointsCreateInput = {
    DeliveryPoint: string
    PumpStations?: PumpStationCreateNestedManyWithoutDeliveryPointInput
  }

  export type DeliveryPointsUncheckedCreateInput = {
    IdDp?: number
    DeliveryPoint: string
    PumpStations?: PumpStationUncheckedCreateNestedManyWithoutDeliveryPointInput
  }

  export type DeliveryPointsUpdateInput = {
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
    PumpStations?: PumpStationUpdateManyWithoutDeliveryPointNestedInput
  }

  export type DeliveryPointsUncheckedUpdateInput = {
    IdDp?: IntFieldUpdateOperationsInput | number
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
    PumpStations?: PumpStationUncheckedUpdateManyWithoutDeliveryPointNestedInput
  }

  export type DeliveryPointsCreateManyInput = {
    DeliveryPoint: string
  }

  export type DeliveryPointsUpdateManyMutationInput = {
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryPointsUncheckedUpdateManyInput = {
    IdDp?: IntFieldUpdateOperationsInput | number
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationCreateInput = {
    DarajeStation: string
    PumpStation?: PumpStationCreateNestedManyWithoutDarjeStationInput
  }

  export type DarjeStationUncheckedCreateInput = {
    IdDStation?: number
    DarajeStation: string
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutDarjeStationInput
  }

  export type DarjeStationUpdateInput = {
    DarajeStation?: StringFieldUpdateOperationsInput | string
    PumpStation?: PumpStationUpdateManyWithoutDarjeStationNestedInput
  }

  export type DarjeStationUncheckedUpdateInput = {
    IdDStation?: IntFieldUpdateOperationsInput | number
    DarajeStation?: StringFieldUpdateOperationsInput | string
    PumpStation?: PumpStationUncheckedUpdateManyWithoutDarjeStationNestedInput
  }

  export type DarjeStationCreateManyInput = {
    DarajeStation: string
  }

  export type DarjeStationUpdateManyMutationInput = {
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationUncheckedUpdateManyInput = {
    IdDStation?: IntFieldUpdateOperationsInput | number
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtCreateInput = {
    Dore: string
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutDoreKeshtInput
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtUncheckedCreateInput = {
    IdDore?: number
    Dore: string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtUpdateInput = {
    Dore?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutDoreKeshtNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutDoreKeshtNestedInput
  }

  export type DoreKeshtUncheckedUpdateInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput
  }

  export type DoreKeshtCreateManyInput = {
    Dore: string
  }

  export type DoreKeshtUpdateManyMutationInput = {
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtUncheckedUpdateManyInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type EshtebahAvamelCreateInput = {
    IdEsht: number
    Eshtebah: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutEshtebahAvamelInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutEshtebahAvamelInput
  }

  export type EshtebahAvamelUncheckedCreateInput = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelUpdateInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutEshtebahAvamelNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutEshtebahAvamelNestedInput
  }

  export type EshtebahAvamelUncheckedUpdateInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelCreateManyInput = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelUpdateManyMutationInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelUncheckedUpdateManyInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodCreateInput = {
    Flow: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutFlowBehboodInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutFlowBehboodInput
  }

  export type FlowBehboodUncheckedCreateInput = {
    IdBehbood?: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodUpdateInput = {
    Flow?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutFlowBehboodNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutFlowBehboodNestedInput
  }

  export type FlowBehboodUncheckedUpdateInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodUpdateManyMutationInput = {
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUncheckedUpdateManyInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowmeterCreateInput = {
    IdFIT: number
    Flowmeter: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutFlowmeterInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutFlowmeterInput
  }

  export type FlowmeterUncheckedCreateInput = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterUpdateInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutFlowmeterNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutFlowmeterNestedInput
  }

  export type FlowmeterUncheckedUpdateInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterCreateManyInput = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterUpdateManyMutationInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterUncheckedUpdateManyInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUpdateInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshCreateManyInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
  }

  export type KhatRaneshUpdateManyMutationInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KhatRaneshUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KhatRaneshAreaCreateInput = {
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshAreaInput
    Land: LandCreateNestedOneWithoutKhatRaneshAreaInput
    Network: NetworkCreateNestedOneWithoutKhatRaneshAreaInput
  }

  export type KhatRaneshAreaUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateInput = {
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
    Land?: LandUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
    Network?: NetworkUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
  }

  export type KhatRaneshAreaUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateManyInput = {
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateManyMutationInput = {
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpCreateInput = {
    ModelPump?: string | null
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshPumpInput
    PumpType: PumpTypeCreateNestedOneWithoutKhatRaneshPumpInput
  }

  export type KhatRaneshPumpUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUpdateInput = {
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshPumpNestedInput
    PumpType?: PumpTypeUpdateOneRequiredWithoutKhatRaneshPumpNestedInput
  }

  export type KhatRaneshPumpUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpCreateManyInput = {
    FIdRanesh: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUpdateManyMutationInput = {
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshSegliCreateInput = {
    Zarfiat: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshSegliInput
  }

  export type KhatRaneshSegliUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUpdateInput = {
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshSegliNestedInput
  }

  export type KhatRaneshSegliUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliCreateManyInput = {
    FIdRanesh: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUpdateManyMutationInput = {
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KontorCreateInput = {
    Kontor: number
    Abgir: AbgirCreateNestedOneWithoutKontorInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutKontorInput
  }

  export type KontorUncheckedCreateInput = {
    IdKon?: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUpdateInput = {
    Kontor?: IntFieldUpdateOperationsInput | number
    Abgir?: AbgirUpdateOneRequiredWithoutKontorNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutKontorNestedInput
  }

  export type KontorUncheckedUpdateInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorCreateManyInput = {
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUpdateManyMutationInput = {
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorUncheckedUpdateManyInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type LandCreateInput = {
    IdLand: number
    Land: string
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutLandInput
  }

  export type LandUncheckedCreateInput = {
    IdLand: number
    Land: string
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutLandInput
  }

  export type LandUpdateInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutLandNestedInput
  }

  export type LandUncheckedUpdateInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutLandNestedInput
  }

  export type LandCreateManyInput = {
    IdLand: number
    Land: string
  }

  export type LandUpdateManyMutationInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type LandUncheckedUpdateManyInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolCreateInput = {
    MeasuringTool: string
    Precision: string
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutMeasuringToolInput
  }

  export type MeasuringToolUncheckedCreateInput = {
    IdMeasuring?: number
    MeasuringTool: string
    Precision: string
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutMeasuringToolInput
  }

  export type MeasuringToolUpdateInput = {
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUpdateManyWithoutMeasuringToolNestedInput
  }

  export type MeasuringToolUncheckedUpdateInput = {
    IdMeasuring?: IntFieldUpdateOperationsInput | number
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutMeasuringToolNestedInput
  }

  export type MeasuringToolCreateManyInput = {
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolUpdateManyMutationInput = {
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolUncheckedUpdateManyInput = {
    IdMeasuring?: IntFieldUpdateOperationsInput | number
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type NashtShabakeCreateInput = {
    NashtShabake: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutNashtShabakeInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutNashtShabakeInput
  }

  export type NashtShabakeUncheckedCreateInput = {
    IdNasht?: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeUpdateInput = {
    NashtShabake?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutNashtShabakeNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutNashtShabakeNestedInput
  }

  export type NashtShabakeUncheckedUpdateInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeCreateManyInput = {
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeUpdateManyMutationInput = {
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUncheckedUpdateManyInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkCreateInput = {
    Network: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutNetworkInput
    SystemPart: SystemPartCreateNestedOneWithoutNetworkInput
    PumpStation?: PumpStationCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateInput = {
    IdNet?: number
    Network: string
    FIdSP: number
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUpdateInput = {
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutNetworkNestedInput
    SystemPart?: SystemPartUpdateOneRequiredWithoutNetworkNestedInput
    PumpStation?: PumpStationUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUncheckedUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkCreateManyInput = {
    Network: string
    FIdSP: number
  }

  export type NetworkUpdateManyMutationInput = {
    Network?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkUncheckedUpdateManyInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
  }

  export type NoeKeshtCreateInput = {
    Kesht: string
    NoeMahsool?: NoeMahsoolCreateNestedManyWithoutNoeKeshtInput
  }

  export type NoeKeshtUncheckedCreateInput = {
    IdNoeK?: number
    Kesht: string
    NoeMahsool?: NoeMahsoolUncheckedCreateNestedManyWithoutNoeKeshtInput
  }

  export type NoeKeshtUpdateInput = {
    Kesht?: StringFieldUpdateOperationsInput | string
    NoeMahsool?: NoeMahsoolUpdateManyWithoutNoeKeshtNestedInput
  }

  export type NoeKeshtUncheckedUpdateInput = {
    IdNoeK?: IntFieldUpdateOperationsInput | number
    Kesht?: StringFieldUpdateOperationsInput | string
    NoeMahsool?: NoeMahsoolUncheckedUpdateManyWithoutNoeKeshtNestedInput
  }

  export type NoeKeshtCreateManyInput = {
    Kesht: string
  }

  export type NoeKeshtUpdateManyMutationInput = {
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeKeshtUncheckedUpdateManyInput = {
    IdNoeK?: IntFieldUpdateOperationsInput | number
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeMahsoolCreateInput = {
    Mahsool: string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutNoeMahsoolInput
    NoeKesht: NoeKeshtCreateNestedOneWithoutNoeMahsoolInput
  }

  export type NoeMahsoolUncheckedCreateInput = {
    IdNoeM?: number
    Mahsool: string
    FIdNoeK: number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutNoeMahsoolInput
  }

  export type NoeMahsoolUpdateInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutNoeMahsoolNestedInput
    NoeKesht?: NoeKeshtUpdateOneRequiredWithoutNoeMahsoolNestedInput
  }

  export type NoeMahsoolUncheckedUpdateInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutNoeMahsoolNestedInput
  }

  export type NoeMahsoolCreateManyInput = {
    Mahsool: string
    FIdNoeK: number
  }

  export type NoeMahsoolUpdateManyMutationInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
  }

  export type NoeMahsoolUncheckedUpdateManyInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITCreateInput = {
    IdNonFIT: number
    VOLUM: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutNonFITInput
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedOneWithoutNonFITInput
  }

  export type NonFITUncheckedCreateInput = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor?: number
    VOLUM: number
  }

  export type NonFITUpdateInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutNonFITNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutNonFITNestedInput
  }

  export type NonFITUncheckedUpdateInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITCreateManyInput = {
    IdNonFIT: number
    FIdRanesh: number
    VOLUM: number
  }

  export type NonFITUpdateManyMutationInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUncheckedUpdateManyInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type PumpStationCreateInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutPumpStationInput
    AbadeMakhzan?: AbadeMakhzanCreateNestedOneWithoutPumpStationInput
    DarjeStation: DarjeStationCreateNestedOneWithoutPumpStationInput
    DeliveryPoint: DeliveryPointsCreateNestedOneWithoutPumpStationsInput
    Network: NetworkCreateNestedOneWithoutPumpStationInput
  }

  export type PumpStationUncheckedCreateInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput
  }

  export type PumpStationUpdateInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUpdateManyWithoutPumpStationNestedInput
    AbadeMakhzan?: AbadeMakhzanUpdateOneWithoutPumpStationNestedInput
    DarjeStation?: DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput
    DeliveryPoint?: DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput
    Network?: NetworkUpdateOneRequiredWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput
  }

  export type PumpStationCreateManyInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
  }

  export type PumpStationUpdateManyMutationInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PumpStationUncheckedUpdateManyInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PumpTypeCreateInput = {
    PumpType: string
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutPumpTypeInput
  }

  export type PumpTypeUncheckedCreateInput = {
    IdPump?: number
    PumpType: string
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutPumpTypeInput
  }

  export type PumpTypeUpdateInput = {
    PumpType?: StringFieldUpdateOperationsInput | string
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutPumpTypeNestedInput
  }

  export type PumpTypeUncheckedUpdateInput = {
    IdPump?: IntFieldUpdateOperationsInput | number
    PumpType?: StringFieldUpdateOperationsInput | string
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutPumpTypeNestedInput
  }

  export type PumpTypeCreateManyInput = {
    PumpType: string
  }

  export type PumpTypeUpdateManyMutationInput = {
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type PumpTypeUncheckedUpdateManyInput = {
    IdPump?: IntFieldUpdateOperationsInput | number
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallStationCreateInput = {
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
    RainfallType: RainfallTypeCreateNestedOneWithoutRainfallStationInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutRainfallStationInput
    WeatherStation: WeatherStationCreateNestedOneWithoutRainfallStationInput
  }

  export type RainfallStationUncheckedCreateInput = {
    IdRaiSta?: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateInput = {
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    RainfallType?: RainfallTypeUpdateOneRequiredWithoutRainfallStationNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutRainfallStationNestedInput
    WeatherStation?: WeatherStationUpdateOneRequiredWithoutRainfallStationNestedInput
  }

  export type RainfallStationUncheckedUpdateInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationCreateManyInput = {
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateManyMutationInput = {
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateManyInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallTypeCreateInput = {
    RainfallType: string
    RainfallStation?: RainfallStationCreateNestedManyWithoutRainfallTypeInput
  }

  export type RainfallTypeUncheckedCreateInput = {
    IdRaiTy?: number
    RainfallType: string
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutRainfallTypeInput
  }

  export type RainfallTypeUpdateInput = {
    RainfallType?: StringFieldUpdateOperationsInput | string
    RainfallStation?: RainfallStationUpdateManyWithoutRainfallTypeNestedInput
  }

  export type RainfallTypeUncheckedUpdateInput = {
    IdRaiTy?: IntFieldUpdateOperationsInput | number
    RainfallType?: StringFieldUpdateOperationsInput | string
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutRainfallTypeNestedInput
  }

  export type RainfallTypeCreateManyInput = {
    RainfallType: string
  }

  export type RainfallTypeUpdateManyMutationInput = {
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallTypeUncheckedUpdateManyInput = {
    IdRaiTy?: IntFieldUpdateOperationsInput | number
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeCreateInput = {
    SaleZeraee: string
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutSaleZeraeeInput
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeUncheckedCreateInput = {
    IdSal?: number
    SaleZeraee: string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeUpdateInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type SaleZeraeeUncheckedUpdateInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type SaleZeraeeCreateManyInput = {
    SaleZeraee: string
  }

  export type SaleZeraeeUpdateManyMutationInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeUncheckedUpdateManyInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpCreateInput = {
    SeghliPump: string
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutSeghliPumpInput
  }

  export type SeghliPumpUncheckedCreateInput = {
    IdSePu?: number
    SeghliPump: string
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutSeghliPumpInput
  }

  export type SeghliPumpUpdateInput = {
    SeghliPump?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUpdateManyWithoutSeghliPumpNestedInput
  }

  export type SeghliPumpUncheckedUpdateInput = {
    IdSePu?: IntFieldUpdateOperationsInput | number
    SeghliPump?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutSeghliPumpNestedInput
  }

  export type SeghliPumpCreateManyInput = {
    SeghliPump: string
  }

  export type SeghliPumpUpdateManyMutationInput = {
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpUncheckedUpdateManyInput = {
    IdSePu?: IntFieldUpdateOperationsInput | number
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SystemPartCreateInput = {
    Part: string
    KM: number
    Network?: NetworkCreateNestedManyWithoutSystemPartInput
  }

  export type SystemPartUncheckedCreateInput = {
    IdSP?: number
    Part: string
    KM: number
    Network?: NetworkUncheckedCreateNestedManyWithoutSystemPartInput
  }

  export type SystemPartUpdateInput = {
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
    Network?: NetworkUpdateManyWithoutSystemPartNestedInput
  }

  export type SystemPartUncheckedUpdateInput = {
    IdSP?: IntFieldUpdateOperationsInput | number
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
    Network?: NetworkUncheckedUpdateManyWithoutSystemPartNestedInput
  }

  export type SystemPartCreateManyInput = {
    Part: string
    KM: number
  }

  export type SystemPartUpdateManyMutationInput = {
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type SystemPartUncheckedUpdateManyInput = {
    IdSP?: IntFieldUpdateOperationsInput | number
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanCreateInput = {
    Takhlie: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutTakhlieMakhzanInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutTakhlieMakhzanInput
  }

  export type TakhlieMakhzanUncheckedCreateInput = {
    IdTakhlie?: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanUpdateInput = {
    Takhlie?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutTakhlieMakhzanNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutTakhlieMakhzanNestedInput
  }

  export type TakhlieMakhzanUncheckedUpdateInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanUpdateManyMutationInput = {
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUncheckedUpdateManyInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    Test: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutTestInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    IdTest?: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
  }

  export type TestUpdateInput = {
    Test?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutTestNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Test: number
  }

  export type TestUpdateManyMutationInput = {
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestUncheckedUpdateManyInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TrikhDoreKeshtCreateInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUpdateInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtCreateManyInput = {
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
  }

  export type TrikhDoreKeshtUpdateManyMutationInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
  }

  export type TrikhDoreKeshtUncheckedUpdateManyInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherStationCreateInput = {
    Station: string
    RainfallStation?: RainfallStationCreateNestedManyWithoutWeatherStationInput
  }

  export type WeatherStationUncheckedCreateInput = {
    IdWeaSta?: number
    Station: string
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutWeatherStationInput
  }

  export type WeatherStationUpdateInput = {
    Station?: StringFieldUpdateOperationsInput | string
    RainfallStation?: RainfallStationUpdateManyWithoutWeatherStationNestedInput
  }

  export type WeatherStationUncheckedUpdateInput = {
    IdWeaSta?: IntFieldUpdateOperationsInput | number
    Station?: StringFieldUpdateOperationsInput | string
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutWeatherStationNestedInput
  }

  export type WeatherStationCreateManyInput = {
    Station: string
  }

  export type WeatherStationUpdateManyMutationInput = {
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationUncheckedUpdateManyInput = {
    IdWeaSta?: IntFieldUpdateOperationsInput | number
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type MahShamsiCreateInput = {
    IdMah: number
    Mah: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutMahInput
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutMahShamsiInput
  }

  export type MahShamsiUncheckedCreateInput = {
    IdMah: number
    Mah: string
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutMahInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutMahShamsiInput
  }

  export type MahShamsiUpdateInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutMahNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutMahShamsiNestedInput
  }

  export type MahShamsiUncheckedUpdateInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutMahNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutMahShamsiNestedInput
  }

  export type MahShamsiCreateManyInput = {
    IdMah: number
    Mah: string
  }

  export type MahShamsiUpdateManyMutationInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type MahShamsiUncheckedUpdateManyInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type ShabakeDoreKeshtCreateInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutShabakeDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutShabakeDoreKeshtInput
    Network: NetworkCreateNestedOneWithoutShabakeDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUncheckedCreateInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    FIdDore: number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUpdateInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutShabakeDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    Network?: NetworkUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtCreateManyInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    FIdDore: number
  }

  export type ShabakeDoreKeshtUpdateManyMutationInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
  }

  export type TaeedProgramCreateInput = {
    FIdPumpSta: number
    FIdSal: number
    FIdDore: number
    Sal: number
    Mah: number
    Dahe: number
    FIdUserErsal?: number | null
    FirstNErsal?: string | null
    LastNErsal?: string | null
    TozihErsal?: string | null
    TarikhErsal?: Date | string | null
    FIdUserAbMantaghe?: number | null
    FirstNAbMantaghe?: string | null
    LastNAbMantaghe?: string | null
    TozihAbMantaghe?: string | null
    TarikhAbMantaghe?: Date | string | null
    TaedAbMantaghe?: boolean | null
    FIdUserPeymankar?: number | null
    FirstNPeymankar?: string | null
    LastNPeymankar?: string | null
    TozihPeymankar?: string | null
    TarikhPeymankar?: Date | string | null
    TaedPeymankar?: boolean | null
    FIdUserAbNiroo?: number | null
    FirstNAbNiroo?: string | null
    LastNAbNiroo?: string | null
    TozihAbNiroo?: string | null
    TarikhAbNiroo?: Date | string | null
    TaedAbNiroo?: string | null
    FileNameNahaee?: string | null
    FilePathNahaee?: string | null
    TarikhFileNahee?: Date | string | null
    FIdUserTaeedNahaee?: number | null
    FirstNTaeedNahaee?: string | null
    LastNTaeedNahaee?: string | null
    TarikhTaeedNahaee?: Date | string | null
    TaeedNahaee?: boolean | null
  }

  export type TaeedProgramUncheckedCreateInput = {
    IdTaeedProgram?: number
    FIdPumpSta: number
    FIdSal: number
    FIdDore: number
    Sal: number
    Mah: number
    Dahe: number
    FIdUserErsal?: number | null
    FirstNErsal?: string | null
    LastNErsal?: string | null
    TozihErsal?: string | null
    TarikhErsal?: Date | string | null
    FIdUserAbMantaghe?: number | null
    FirstNAbMantaghe?: string | null
    LastNAbMantaghe?: string | null
    TozihAbMantaghe?: string | null
    TarikhAbMantaghe?: Date | string | null
    TaedAbMantaghe?: boolean | null
    FIdUserPeymankar?: number | null
    FirstNPeymankar?: string | null
    LastNPeymankar?: string | null
    TozihPeymankar?: string | null
    TarikhPeymankar?: Date | string | null
    TaedPeymankar?: boolean | null
    FIdUserAbNiroo?: number | null
    FirstNAbNiroo?: string | null
    LastNAbNiroo?: string | null
    TozihAbNiroo?: string | null
    TarikhAbNiroo?: Date | string | null
    TaedAbNiroo?: string | null
    FileNameNahaee?: string | null
    FilePathNahaee?: string | null
    TarikhFileNahee?: Date | string | null
    FIdUserTaeedNahaee?: number | null
    FirstNTaeedNahaee?: string | null
    LastNTaeedNahaee?: string | null
    TarikhTaeedNahaee?: Date | string | null
    TaeedNahaee?: boolean | null
  }

  export type TaeedProgramUpdateInput = {
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    Dahe?: IntFieldUpdateOperationsInput | number
    FIdUserErsal?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    LastNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TozihErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhErsal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserAbMantaghe?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbMantaghe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbMantaghe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserPeymankar?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    LastNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TozihPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhPeymankar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedPeymankar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserAbNiroo?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbNiroo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    FileNameNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    FilePathNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhFileNahee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserTaeedNahaee?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    LastNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhTaeedNahaee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaeedNahaee?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaeedProgramUncheckedUpdateInput = {
    IdTaeedProgram?: IntFieldUpdateOperationsInput | number
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    Dahe?: IntFieldUpdateOperationsInput | number
    FIdUserErsal?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    LastNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TozihErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhErsal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserAbMantaghe?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbMantaghe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbMantaghe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserPeymankar?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    LastNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TozihPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhPeymankar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedPeymankar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserAbNiroo?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbNiroo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    FileNameNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    FilePathNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhFileNahee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserTaeedNahaee?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    LastNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhTaeedNahaee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaeedNahaee?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaeedProgramCreateManyInput = {
    FIdPumpSta: number
    FIdSal: number
    FIdDore: number
    Sal: number
    Mah: number
    Dahe: number
    FIdUserErsal?: number | null
    FirstNErsal?: string | null
    LastNErsal?: string | null
    TozihErsal?: string | null
    TarikhErsal?: Date | string | null
    FIdUserAbMantaghe?: number | null
    FirstNAbMantaghe?: string | null
    LastNAbMantaghe?: string | null
    TozihAbMantaghe?: string | null
    TarikhAbMantaghe?: Date | string | null
    TaedAbMantaghe?: boolean | null
    FIdUserPeymankar?: number | null
    FirstNPeymankar?: string | null
    LastNPeymankar?: string | null
    TozihPeymankar?: string | null
    TarikhPeymankar?: Date | string | null
    TaedPeymankar?: boolean | null
    FIdUserAbNiroo?: number | null
    FirstNAbNiroo?: string | null
    LastNAbNiroo?: string | null
    TozihAbNiroo?: string | null
    TarikhAbNiroo?: Date | string | null
    TaedAbNiroo?: string | null
    FileNameNahaee?: string | null
    FilePathNahaee?: string | null
    TarikhFileNahee?: Date | string | null
    FIdUserTaeedNahaee?: number | null
    FirstNTaeedNahaee?: string | null
    LastNTaeedNahaee?: string | null
    TarikhTaeedNahaee?: Date | string | null
    TaeedNahaee?: boolean | null
  }

  export type TaeedProgramUpdateManyMutationInput = {
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    Dahe?: IntFieldUpdateOperationsInput | number
    FIdUserErsal?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    LastNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TozihErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhErsal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserAbMantaghe?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbMantaghe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbMantaghe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserPeymankar?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    LastNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TozihPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhPeymankar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedPeymankar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserAbNiroo?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbNiroo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    FileNameNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    FilePathNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhFileNahee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserTaeedNahaee?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    LastNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhTaeedNahaee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaeedNahaee?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaeedProgramUncheckedUpdateManyInput = {
    IdTaeedProgram?: IntFieldUpdateOperationsInput | number
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    Dahe?: IntFieldUpdateOperationsInput | number
    FIdUserErsal?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    LastNErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TozihErsal?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhErsal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserAbMantaghe?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbMantaghe?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbMantaghe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbMantaghe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserPeymankar?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    LastNPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TozihPeymankar?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhPeymankar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedPeymankar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FIdUserAbNiroo?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    LastNAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TozihAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhAbNiroo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaedAbNiroo?: NullableStringFieldUpdateOperationsInput | string | null
    FileNameNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    FilePathNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhFileNahee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FIdUserTaeedNahaee?: NullableIntFieldUpdateOperationsInput | number | null
    FirstNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    LastNTaeedNahaee?: NullableStringFieldUpdateOperationsInput | string | null
    TarikhTaeedNahaee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TaeedNahaee?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PumpStationListRelationFilter = {
    every?: PumpStationWhereInput
    some?: PumpStationWhereInput
    none?: PumpStationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PumpStationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbadeMakhzanCountOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanAvgOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
  }

  export type AbadeMakhzanMaxOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanMinOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanSumOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type KhatRaneshScalarRelationFilter = {
    is?: KhatRaneshWhereInput
    isNot?: KhatRaneshWhereInput
  }

  export type KontorListRelationFilter = {
    every?: KontorWhereInput
    some?: KontorWhereInput
    none?: KontorWhereInput
  }

  export type KontorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbgirCountOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirAvgOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
  }

  export type AbgirMaxOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirMinOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirSumOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TrikhDoreKeshtScalarRelationFilter = {
    is?: TrikhDoreKeshtWhereInput
    isNot?: TrikhDoreKeshtWhereInput
  }

  export type BahrebardairProgramCountOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramAvgOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
  }

  export type BahrebardairProgramMaxOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramMinOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramSumOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BahrebardairProgramSeghliCountOrderByAggregateInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramSeghliAvgOrderByAggregateInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrder
  }

  export type BahrebardairProgramSeghliMaxOrderByAggregateInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramSeghliMinOrderByAggregateInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramSeghliSumOrderByAggregateInput = {
    IdProSrgl?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Zarfiat?: SortOrder
  }

  export type NoeMahsoolScalarRelationFilter = {
    is?: NoeMahsoolWhereInput
    isNot?: NoeMahsoolWhereInput
  }

  export type ShabakeDoreKeshtScalarRelationFilter = {
    is?: ShabakeDoreKeshtWhereInput
    isNot?: ShabakeDoreKeshtWhereInput
  }

  export type BahrebardariKeshtDoreCountOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreAvgOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreMaxOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreMinOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreSumOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdShDo?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariTaghvimCountOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimAvgOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimMaxOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimMinOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimSumOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type MahShamsiScalarRelationFilter = {
    is?: MahShamsiWhereInput
    isNot?: MahShamsiWhereInput
  }

  export type NetworkScalarRelationFilter = {
    is?: NetworkWhereInput
    isNot?: NetworkWhereInput
  }

  export type BareshMotaleatCountOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatAvgOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatMaxOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatMinOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatSumOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type KhatRaneshListRelationFilter = {
    every?: KhatRaneshWhereInput
    some?: KhatRaneshWhereInput
    none?: KhatRaneshWhereInput
  }

  export type KhatRaneshOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DarajePipeCountOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeAvgOrderByAggregateInput = {
    IdDPipe?: SortOrder
  }

  export type DarajePipeMaxOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeMinOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeSumOrderByAggregateInput = {
    IdDPipe?: SortOrder
  }

  export type DeliveryPointsCountOrderByAggregateInput = {
    IdDp?: SortOrder
    DeliveryPoint?: SortOrder
  }

  export type DeliveryPointsAvgOrderByAggregateInput = {
    IdDp?: SortOrder
  }

  export type DeliveryPointsMaxOrderByAggregateInput = {
    IdDp?: SortOrder
    DeliveryPoint?: SortOrder
  }

  export type DeliveryPointsMinOrderByAggregateInput = {
    IdDp?: SortOrder
    DeliveryPoint?: SortOrder
  }

  export type DeliveryPointsSumOrderByAggregateInput = {
    IdDp?: SortOrder
  }

  export type DarjeStationCountOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationAvgOrderByAggregateInput = {
    IdDStation?: SortOrder
  }

  export type DarjeStationMaxOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationMinOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationSumOrderByAggregateInput = {
    IdDStation?: SortOrder
  }

  export type ShabakeDoreKeshtListRelationFilter = {
    every?: ShabakeDoreKeshtWhereInput
    some?: ShabakeDoreKeshtWhereInput
    none?: ShabakeDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtListRelationFilter = {
    every?: TrikhDoreKeshtWhereInput
    some?: TrikhDoreKeshtWhereInput
    none?: TrikhDoreKeshtWhereInput
  }

  export type ShabakeDoreKeshtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrikhDoreKeshtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoreKeshtCountOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtAvgOrderByAggregateInput = {
    IdDore?: SortOrder
  }

  export type DoreKeshtMaxOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtMinOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtSumOrderByAggregateInput = {
    IdDore?: SortOrder
  }

  export type EshtebahAvamelCountOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelAvgOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelMaxOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelMinOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelSumOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type FlowBehboodCountOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodAvgOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodMaxOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodMinOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodSumOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FlowmeterCountOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterAvgOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterMaxOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterMinOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterSumOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AbgirListRelationFilter = {
    every?: AbgirWhereInput
    some?: AbgirWhereInput
    none?: AbgirWhereInput
  }

  export type BahrebardairProgramListRelationFilter = {
    every?: BahrebardairProgramWhereInput
    some?: BahrebardairProgramWhereInput
    none?: BahrebardairProgramWhereInput
  }

  export type BahrebardairProgramSeghliListRelationFilter = {
    every?: BahrebardairProgramSeghliWhereInput
    some?: BahrebardairProgramSeghliWhereInput
    none?: BahrebardairProgramSeghliWhereInput
  }

  export type BahrebardariKeshtDoreListRelationFilter = {
    every?: BahrebardariKeshtDoreWhereInput
    some?: BahrebardariKeshtDoreWhereInput
    none?: BahrebardariKeshtDoreWhereInput
  }

  export type BahrebardariTaghvimListRelationFilter = {
    every?: BahrebardariTaghvimWhereInput
    some?: BahrebardariTaghvimWhereInput
    none?: BahrebardariTaghvimWhereInput
  }

  export type EshtebahAvamelListRelationFilter = {
    every?: EshtebahAvamelWhereInput
    some?: EshtebahAvamelWhereInput
    none?: EshtebahAvamelWhereInput
  }

  export type FlowBehboodListRelationFilter = {
    every?: FlowBehboodWhereInput
    some?: FlowBehboodWhereInput
    none?: FlowBehboodWhereInput
  }

  export type FlowmeterListRelationFilter = {
    every?: FlowmeterWhereInput
    some?: FlowmeterWhereInput
    none?: FlowmeterWhereInput
  }

  export type DarajePipeScalarRelationFilter = {
    is?: DarajePipeWhereInput
    isNot?: DarajePipeWhereInput
  }

  export type MeasuringToolScalarRelationFilter = {
    is?: MeasuringToolWhereInput
    isNot?: MeasuringToolWhereInput
  }

  export type PumpStationScalarRelationFilter = {
    is?: PumpStationWhereInput
    isNot?: PumpStationWhereInput
  }

  export type SeghliPumpScalarRelationFilter = {
    is?: SeghliPumpWhereInput
    isNot?: SeghliPumpWhereInput
  }

  export type KhatRaneshAreaListRelationFilter = {
    every?: KhatRaneshAreaWhereInput
    some?: KhatRaneshAreaWhereInput
    none?: KhatRaneshAreaWhereInput
  }

  export type KhatRaneshPumpListRelationFilter = {
    every?: KhatRaneshPumpWhereInput
    some?: KhatRaneshPumpWhereInput
    none?: KhatRaneshPumpWhereInput
  }

  export type KhatRaneshSegliListRelationFilter = {
    every?: KhatRaneshSegliWhereInput
    some?: KhatRaneshSegliWhereInput
    none?: KhatRaneshSegliWhereInput
  }

  export type NashtShabakeListRelationFilter = {
    every?: NashtShabakeWhereInput
    some?: NashtShabakeWhereInput
    none?: NashtShabakeWhereInput
  }

  export type NonFITListRelationFilter = {
    every?: NonFITWhereInput
    some?: NonFITWhereInput
    none?: NonFITWhereInput
  }

  export type TakhlieMakhzanListRelationFilter = {
    every?: TakhlieMakhzanWhereInput
    some?: TakhlieMakhzanWhereInput
    none?: TakhlieMakhzanWhereInput
  }

  export type TestListRelationFilter = {
    every?: TestWhereInput
    some?: TestWhereInput
    none?: TestWhereInput
  }

  export type AbgirOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BahrebardairProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BahrebardairProgramSeghliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BahrebardariKeshtDoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BahrebardariTaghvimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EshtebahAvamelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowBehboodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowmeterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KhatRaneshAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KhatRaneshPumpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KhatRaneshSegliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NashtShabakeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NonFITOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TakhlieMakhzanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KhatRaneshCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    Active?: SortOrder
  }

  export type KhatRaneshAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    Active?: SortOrder
  }

  export type KhatRaneshMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    Active?: SortOrder
  }

  export type KhatRaneshSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LandScalarRelationFilter = {
    is?: LandWhereInput
    isNot?: LandWhereInput
  }

  export type KhatRaneshAreaCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PumpTypeScalarRelationFilter = {
    is?: PumpTypeWhereInput
    isNot?: PumpTypeWhereInput
  }

  export type KhatRaneshPumpCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type KhatRaneshSegliCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type AbgirScalarRelationFilter = {
    is?: AbgirWhereInput
    isNot?: AbgirWhereInput
  }

  export type KontorCountOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorAvgOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorMaxOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorMinOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorSumOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type LandCountOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandAvgOrderByAggregateInput = {
    IdLand?: SortOrder
  }

  export type LandMaxOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandMinOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandSumOrderByAggregateInput = {
    IdLand?: SortOrder
  }

  export type MeasuringToolCountOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolAvgOrderByAggregateInput = {
    IdMeasuring?: SortOrder
  }

  export type MeasuringToolMaxOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolMinOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolSumOrderByAggregateInput = {
    IdMeasuring?: SortOrder
  }

  export type NashtShabakeCountOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeAvgOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeMaxOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeMinOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeSumOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type BareshMotaleatListRelationFilter = {
    every?: BareshMotaleatWhereInput
    some?: BareshMotaleatWhereInput
    none?: BareshMotaleatWhereInput
  }

  export type SystemPartScalarRelationFilter = {
    is?: SystemPartWhereInput
    isNot?: SystemPartWhereInput
  }

  export type BareshMotaleatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkCountOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkAvgOrderByAggregateInput = {
    IdNet?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkMaxOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkMinOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkSumOrderByAggregateInput = {
    IdNet?: SortOrder
    FIdSP?: SortOrder
  }

  export type NoeMahsoolListRelationFilter = {
    every?: NoeMahsoolWhereInput
    some?: NoeMahsoolWhereInput
    none?: NoeMahsoolWhereInput
  }

  export type NoeMahsoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoeKeshtCountOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtAvgOrderByAggregateInput = {
    IdNoeK?: SortOrder
  }

  export type NoeKeshtMaxOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtMinOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtSumOrderByAggregateInput = {
    IdNoeK?: SortOrder
  }

  export type NoeKeshtScalarRelationFilter = {
    is?: NoeKeshtWhereInput
    isNot?: NoeKeshtWhereInput
  }

  export type NoeMahsoolCountOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolAvgOrderByAggregateInput = {
    IdNoeM?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolMaxOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolMinOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolSumOrderByAggregateInput = {
    IdNoeM?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NonFITCountOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITAvgOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITMaxOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITMinOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITSumOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type AbadeMakhzanNullableScalarRelationFilter = {
    is?: AbadeMakhzanWhereInput | null
    isNot?: AbadeMakhzanWhereInput | null
  }

  export type DarjeStationScalarRelationFilter = {
    is?: DarjeStationWhereInput
    isNot?: DarjeStationWhereInput
  }

  export type DeliveryPointsScalarRelationFilter = {
    is?: DeliveryPointsWhereInput
    isNot?: DeliveryPointsWhereInput
  }

  export type PumpStationCountOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
    FIdDP?: SortOrder
    Ready?: SortOrder
  }

  export type PumpStationAvgOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
    FIdDP?: SortOrder
  }

  export type PumpStationMaxOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
    FIdDP?: SortOrder
    Ready?: SortOrder
  }

  export type PumpStationMinOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
    FIdDP?: SortOrder
    Ready?: SortOrder
  }

  export type PumpStationSumOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
    FIdDP?: SortOrder
  }

  export type PumpTypeCountOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeAvgOrderByAggregateInput = {
    IdPump?: SortOrder
  }

  export type PumpTypeMaxOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeMinOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeSumOrderByAggregateInput = {
    IdPump?: SortOrder
  }

  export type RainfallTypeScalarRelationFilter = {
    is?: RainfallTypeWhereInput
    isNot?: RainfallTypeWhereInput
  }

  export type WeatherStationScalarRelationFilter = {
    is?: WeatherStationWhereInput
    isNot?: WeatherStationWhereInput
  }

  export type RainfallStationCountOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationAvgOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationMaxOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationMinOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationSumOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationListRelationFilter = {
    every?: RainfallStationWhereInput
    some?: RainfallStationWhereInput
    none?: RainfallStationWhereInput
  }

  export type RainfallStationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainfallTypeCountOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeAvgOrderByAggregateInput = {
    IdRaiTy?: SortOrder
  }

  export type RainfallTypeMaxOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeMinOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeSumOrderByAggregateInput = {
    IdRaiTy?: SortOrder
  }

  export type SaleZeraeeCountOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeAvgOrderByAggregateInput = {
    IdSal?: SortOrder
  }

  export type SaleZeraeeMaxOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeMinOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeSumOrderByAggregateInput = {
    IdSal?: SortOrder
  }

  export type SeghliPumpCountOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpAvgOrderByAggregateInput = {
    IdSePu?: SortOrder
  }

  export type SeghliPumpMaxOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpMinOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpSumOrderByAggregateInput = {
    IdSePu?: SortOrder
  }

  export type NetworkListRelationFilter = {
    every?: NetworkWhereInput
    some?: NetworkWhereInput
    none?: NetworkWhereInput
  }

  export type NetworkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemPartCountOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartAvgOrderByAggregateInput = {
    IdSP?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartMaxOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartMinOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartSumOrderByAggregateInput = {
    IdSP?: SortOrder
    KM?: SortOrder
  }

  export type TakhlieMakhzanCountOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanAvgOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanMaxOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanMinOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanSumOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TestCountOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DoreKeshtScalarRelationFilter = {
    is?: DoreKeshtWhereInput
    isNot?: DoreKeshtWhereInput
  }

  export type SaleZeraeeScalarRelationFilter = {
    is?: SaleZeraeeWhereInput
    isNot?: SaleZeraeeWhereInput
  }

  export type TrikhDoreKeshtCountOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
  }

  export type TrikhDoreKeshtAvgOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
  }

  export type TrikhDoreKeshtMaxOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
  }

  export type TrikhDoreKeshtMinOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
  }

  export type TrikhDoreKeshtSumOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Dahe?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WeatherStationCountOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationAvgOrderByAggregateInput = {
    IdWeaSta?: SortOrder
  }

  export type WeatherStationMaxOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationMinOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationSumOrderByAggregateInput = {
    IdWeaSta?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type MahShamsiCountOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahShamsiAvgOrderByAggregateInput = {
    IdMah?: SortOrder
  }

  export type MahShamsiMaxOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahShamsiMinOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahShamsiSumOrderByAggregateInput = {
    IdMah?: SortOrder
  }

  export type ShabakeDoreKeshtCountOrderByAggregateInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    TrikhShorooe?: SortOrder
    TrikhPayan?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type ShabakeDoreKeshtAvgOrderByAggregateInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type ShabakeDoreKeshtMaxOrderByAggregateInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    TrikhShorooe?: SortOrder
    TrikhPayan?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type ShabakeDoreKeshtMinOrderByAggregateInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    TrikhShorooe?: SortOrder
    TrikhPayan?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type ShabakeDoreKeshtSumOrderByAggregateInput = {
    IdShDo?: SortOrder
    FIdNet?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TaeedProgramCountOrderByAggregateInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrder
    FirstNErsal?: SortOrder
    LastNErsal?: SortOrder
    TozihErsal?: SortOrder
    TarikhErsal?: SortOrder
    FIdUserAbMantaghe?: SortOrder
    FirstNAbMantaghe?: SortOrder
    LastNAbMantaghe?: SortOrder
    TozihAbMantaghe?: SortOrder
    TarikhAbMantaghe?: SortOrder
    TaedAbMantaghe?: SortOrder
    FIdUserPeymankar?: SortOrder
    FirstNPeymankar?: SortOrder
    LastNPeymankar?: SortOrder
    TozihPeymankar?: SortOrder
    TarikhPeymankar?: SortOrder
    TaedPeymankar?: SortOrder
    FIdUserAbNiroo?: SortOrder
    FirstNAbNiroo?: SortOrder
    LastNAbNiroo?: SortOrder
    TozihAbNiroo?: SortOrder
    TarikhAbNiroo?: SortOrder
    TaedAbNiroo?: SortOrder
    FileNameNahaee?: SortOrder
    FilePathNahaee?: SortOrder
    TarikhFileNahee?: SortOrder
    FIdUserTaeedNahaee?: SortOrder
    FirstNTaeedNahaee?: SortOrder
    LastNTaeedNahaee?: SortOrder
    TarikhTaeedNahaee?: SortOrder
    TaeedNahaee?: SortOrder
  }

  export type TaeedProgramAvgOrderByAggregateInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrder
    FIdUserAbMantaghe?: SortOrder
    FIdUserPeymankar?: SortOrder
    FIdUserAbNiroo?: SortOrder
    FIdUserTaeedNahaee?: SortOrder
  }

  export type TaeedProgramMaxOrderByAggregateInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrder
    FirstNErsal?: SortOrder
    LastNErsal?: SortOrder
    TozihErsal?: SortOrder
    TarikhErsal?: SortOrder
    FIdUserAbMantaghe?: SortOrder
    FirstNAbMantaghe?: SortOrder
    LastNAbMantaghe?: SortOrder
    TozihAbMantaghe?: SortOrder
    TarikhAbMantaghe?: SortOrder
    TaedAbMantaghe?: SortOrder
    FIdUserPeymankar?: SortOrder
    FirstNPeymankar?: SortOrder
    LastNPeymankar?: SortOrder
    TozihPeymankar?: SortOrder
    TarikhPeymankar?: SortOrder
    TaedPeymankar?: SortOrder
    FIdUserAbNiroo?: SortOrder
    FirstNAbNiroo?: SortOrder
    LastNAbNiroo?: SortOrder
    TozihAbNiroo?: SortOrder
    TarikhAbNiroo?: SortOrder
    TaedAbNiroo?: SortOrder
    FileNameNahaee?: SortOrder
    FilePathNahaee?: SortOrder
    TarikhFileNahee?: SortOrder
    FIdUserTaeedNahaee?: SortOrder
    FirstNTaeedNahaee?: SortOrder
    LastNTaeedNahaee?: SortOrder
    TarikhTaeedNahaee?: SortOrder
    TaeedNahaee?: SortOrder
  }

  export type TaeedProgramMinOrderByAggregateInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrder
    FirstNErsal?: SortOrder
    LastNErsal?: SortOrder
    TozihErsal?: SortOrder
    TarikhErsal?: SortOrder
    FIdUserAbMantaghe?: SortOrder
    FirstNAbMantaghe?: SortOrder
    LastNAbMantaghe?: SortOrder
    TozihAbMantaghe?: SortOrder
    TarikhAbMantaghe?: SortOrder
    TaedAbMantaghe?: SortOrder
    FIdUserPeymankar?: SortOrder
    FirstNPeymankar?: SortOrder
    LastNPeymankar?: SortOrder
    TozihPeymankar?: SortOrder
    TarikhPeymankar?: SortOrder
    TaedPeymankar?: SortOrder
    FIdUserAbNiroo?: SortOrder
    FirstNAbNiroo?: SortOrder
    LastNAbNiroo?: SortOrder
    TozihAbNiroo?: SortOrder
    TarikhAbNiroo?: SortOrder
    TaedAbNiroo?: SortOrder
    FileNameNahaee?: SortOrder
    FilePathNahaee?: SortOrder
    TarikhFileNahee?: SortOrder
    FIdUserTaeedNahaee?: SortOrder
    FirstNTaeedNahaee?: SortOrder
    LastNTaeedNahaee?: SortOrder
    TarikhTaeedNahaee?: SortOrder
    TaeedNahaee?: SortOrder
  }

  export type TaeedProgramSumOrderByAggregateInput = {
    IdTaeedProgram?: SortOrder
    FIdPumpSta?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Sal?: SortOrder
    Mah?: SortOrder
    Dahe?: SortOrder
    FIdUserErsal?: SortOrder
    FIdUserAbMantaghe?: SortOrder
    FIdUserPeymankar?: SortOrder
    FIdUserAbNiroo?: SortOrder
    FIdUserTaeedNahaee?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PumpStationCreateNestedManyWithoutAbadeMakhzanInput = {
    create?: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput> | PumpStationCreateWithoutAbadeMakhzanInput[] | PumpStationUncheckedCreateWithoutAbadeMakhzanInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutAbadeMakhzanInput | PumpStationCreateOrConnectWithoutAbadeMakhzanInput[]
    createMany?: PumpStationCreateManyAbadeMakhzanInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type PumpStationUncheckedCreateNestedManyWithoutAbadeMakhzanInput = {
    create?: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput> | PumpStationCreateWithoutAbadeMakhzanInput[] | PumpStationUncheckedCreateWithoutAbadeMakhzanInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutAbadeMakhzanInput | PumpStationCreateOrConnectWithoutAbadeMakhzanInput[]
    createMany?: PumpStationCreateManyAbadeMakhzanInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PumpStationUpdateManyWithoutAbadeMakhzanNestedInput = {
    create?: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput> | PumpStationCreateWithoutAbadeMakhzanInput[] | PumpStationUncheckedCreateWithoutAbadeMakhzanInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutAbadeMakhzanInput | PumpStationCreateOrConnectWithoutAbadeMakhzanInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutAbadeMakhzanInput | PumpStationUpsertWithWhereUniqueWithoutAbadeMakhzanInput[]
    createMany?: PumpStationCreateManyAbadeMakhzanInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutAbadeMakhzanInput | PumpStationUpdateWithWhereUniqueWithoutAbadeMakhzanInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutAbadeMakhzanInput | PumpStationUpdateManyWithWhereWithoutAbadeMakhzanInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PumpStationUncheckedUpdateManyWithoutAbadeMakhzanNestedInput = {
    create?: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput> | PumpStationCreateWithoutAbadeMakhzanInput[] | PumpStationUncheckedCreateWithoutAbadeMakhzanInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutAbadeMakhzanInput | PumpStationCreateOrConnectWithoutAbadeMakhzanInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutAbadeMakhzanInput | PumpStationUpsertWithWhereUniqueWithoutAbadeMakhzanInput[]
    createMany?: PumpStationCreateManyAbadeMakhzanInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutAbadeMakhzanInput | PumpStationUpdateWithWhereUniqueWithoutAbadeMakhzanInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutAbadeMakhzanInput | PumpStationUpdateManyWithWhereWithoutAbadeMakhzanInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutAbgirInput = {
    create?: XOR<KhatRaneshCreateWithoutAbgirInput, KhatRaneshUncheckedCreateWithoutAbgirInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutAbgirInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type KontorCreateNestedManyWithoutAbgirInput = {
    create?: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput> | KontorCreateWithoutAbgirInput[] | KontorUncheckedCreateWithoutAbgirInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutAbgirInput | KontorCreateOrConnectWithoutAbgirInput[]
    createMany?: KontorCreateManyAbgirInputEnvelope
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
  }

  export type KontorUncheckedCreateNestedManyWithoutAbgirInput = {
    create?: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput> | KontorCreateWithoutAbgirInput[] | KontorUncheckedCreateWithoutAbgirInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutAbgirInput | KontorCreateOrConnectWithoutAbgirInput[]
    createMany?: KontorCreateManyAbgirInputEnvelope
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
  }

  export type KhatRaneshUpdateOneRequiredWithoutAbgirNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutAbgirInput, KhatRaneshUncheckedCreateWithoutAbgirInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutAbgirInput
    upsert?: KhatRaneshUpsertWithoutAbgirInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutAbgirInput, KhatRaneshUpdateWithoutAbgirInput>, KhatRaneshUncheckedUpdateWithoutAbgirInput>
  }

  export type KontorUpdateManyWithoutAbgirNestedInput = {
    create?: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput> | KontorCreateWithoutAbgirInput[] | KontorUncheckedCreateWithoutAbgirInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutAbgirInput | KontorCreateOrConnectWithoutAbgirInput[]
    upsert?: KontorUpsertWithWhereUniqueWithoutAbgirInput | KontorUpsertWithWhereUniqueWithoutAbgirInput[]
    createMany?: KontorCreateManyAbgirInputEnvelope
    set?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    disconnect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    delete?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    update?: KontorUpdateWithWhereUniqueWithoutAbgirInput | KontorUpdateWithWhereUniqueWithoutAbgirInput[]
    updateMany?: KontorUpdateManyWithWhereWithoutAbgirInput | KontorUpdateManyWithWhereWithoutAbgirInput[]
    deleteMany?: KontorScalarWhereInput | KontorScalarWhereInput[]
  }

  export type KontorUncheckedUpdateManyWithoutAbgirNestedInput = {
    create?: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput> | KontorCreateWithoutAbgirInput[] | KontorUncheckedCreateWithoutAbgirInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutAbgirInput | KontorCreateOrConnectWithoutAbgirInput[]
    upsert?: KontorUpsertWithWhereUniqueWithoutAbgirInput | KontorUpsertWithWhereUniqueWithoutAbgirInput[]
    createMany?: KontorCreateManyAbgirInputEnvelope
    set?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    disconnect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    delete?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    update?: KontorUpdateWithWhereUniqueWithoutAbgirInput | KontorUpdateWithWhereUniqueWithoutAbgirInput[]
    updateMany?: KontorUpdateManyWithWhereWithoutAbgirInput | KontorUpdateManyWithWhereWithoutAbgirInput[]
    deleteMany?: KontorScalarWhereInput | KontorScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutBahrebardairProgramInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardairProgramInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardairProgramInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardairProgramInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardairProgramInput
    upsert?: KhatRaneshUpsertWithoutBahrebardairProgramInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutBahrebardairProgramInput, KhatRaneshUpdateWithoutBahrebardairProgramInput>, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramInput
    upsert?: TrikhDoreKeshtUpsertWithoutBahrebardairProgramInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardairProgramInput, TrikhDoreKeshtUpdateWithoutBahrebardairProgramInput>, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramInput>
  }

  export type KhatRaneshCreateNestedOneWithoutBahrebardairProgramSeghliInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardairProgramSeghliInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramSeghliInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramSeghliInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardairProgramSeghliInput
    upsert?: KhatRaneshUpsertWithoutBahrebardairProgramSeghliInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutBahrebardairProgramSeghliInput, KhatRaneshUpdateWithoutBahrebardairProgramSeghliInput>, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramSeghliInput
    upsert?: TrikhDoreKeshtUpsertWithoutBahrebardairProgramSeghliInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUpdateWithoutBahrebardairProgramSeghliInput>, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
  }

  export type KhatRaneshCreateNestedOneWithoutBahrebardariKeshtDoreInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardariKeshtDoreInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type NoeMahsoolCreateNestedOneWithoutBahrebardariKeshtDoreInput = {
    create?: XOR<NoeMahsoolCreateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutBahrebardariKeshtDoreInput
    connect?: NoeMahsoolWhereUniqueInput
  }

  export type ShabakeDoreKeshtCreateNestedOneWithoutBahrebardariKeshtDoreInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutBahrebardariKeshtDoreInput
    connect?: ShabakeDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardariKeshtDoreInput
    upsert?: KhatRaneshUpsertWithoutBahrebardariKeshtDoreInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput, KhatRaneshUpdateWithoutBahrebardariKeshtDoreInput>, KhatRaneshUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type NoeMahsoolUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput = {
    create?: XOR<NoeMahsoolCreateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutBahrebardariKeshtDoreInput
    upsert?: NoeMahsoolUpsertWithoutBahrebardariKeshtDoreInput
    connect?: NoeMahsoolWhereUniqueInput
    update?: XOR<XOR<NoeMahsoolUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput, NoeMahsoolUpdateWithoutBahrebardariKeshtDoreInput>, NoeMahsoolUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type ShabakeDoreKeshtUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutBahrebardariKeshtDoreInput
    upsert?: ShabakeDoreKeshtUpsertWithoutBahrebardariKeshtDoreInput
    connect?: ShabakeDoreKeshtWhereUniqueInput
    update?: XOR<XOR<ShabakeDoreKeshtUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUpdateWithoutBahrebardariKeshtDoreInput>, ShabakeDoreKeshtUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type KhatRaneshCreateNestedOneWithoutBahrebardariTaghvimInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedCreateWithoutBahrebardariTaghvimInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardariTaghvimInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutBahrebardariTaghvimInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardariTaghvimInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardariTaghvimInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedCreateWithoutBahrebardariTaghvimInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutBahrebardariTaghvimInput
    upsert?: KhatRaneshUpsertWithoutBahrebardariTaghvimInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutBahrebardariTaghvimInput, KhatRaneshUpdateWithoutBahrebardariTaghvimInput>, KhatRaneshUncheckedUpdateWithoutBahrebardariTaghvimInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardariTaghvimInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutBahrebardariTaghvimInput
    upsert?: TrikhDoreKeshtUpsertWithoutBahrebardariTaghvimInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUpdateWithoutBahrebardariTaghvimInput>, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardariTaghvimInput>
  }

  export type MahShamsiCreateNestedOneWithoutBareshMotaleatInput = {
    create?: XOR<MahShamsiCreateWithoutBareshMotaleatInput, MahShamsiUncheckedCreateWithoutBareshMotaleatInput>
    connectOrCreate?: MahShamsiCreateOrConnectWithoutBareshMotaleatInput
    connect?: MahShamsiWhereUniqueInput
  }

  export type NetworkCreateNestedOneWithoutBareshMotaleatInput = {
    create?: XOR<NetworkCreateWithoutBareshMotaleatInput, NetworkUncheckedCreateWithoutBareshMotaleatInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutBareshMotaleatInput
    connect?: NetworkWhereUniqueInput
  }

  export type MahShamsiUpdateOneRequiredWithoutBareshMotaleatNestedInput = {
    create?: XOR<MahShamsiCreateWithoutBareshMotaleatInput, MahShamsiUncheckedCreateWithoutBareshMotaleatInput>
    connectOrCreate?: MahShamsiCreateOrConnectWithoutBareshMotaleatInput
    upsert?: MahShamsiUpsertWithoutBareshMotaleatInput
    connect?: MahShamsiWhereUniqueInput
    update?: XOR<XOR<MahShamsiUpdateToOneWithWhereWithoutBareshMotaleatInput, MahShamsiUpdateWithoutBareshMotaleatInput>, MahShamsiUncheckedUpdateWithoutBareshMotaleatInput>
  }

  export type NetworkUpdateOneRequiredWithoutBareshMotaleatNestedInput = {
    create?: XOR<NetworkCreateWithoutBareshMotaleatInput, NetworkUncheckedCreateWithoutBareshMotaleatInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutBareshMotaleatInput
    upsert?: NetworkUpsertWithoutBareshMotaleatInput
    connect?: NetworkWhereUniqueInput
    update?: XOR<XOR<NetworkUpdateToOneWithWhereWithoutBareshMotaleatInput, NetworkUpdateWithoutBareshMotaleatInput>, NetworkUncheckedUpdateWithoutBareshMotaleatInput>
  }

  export type KhatRaneshCreateNestedManyWithoutDarajePipeInput = {
    create?: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput> | KhatRaneshCreateWithoutDarajePipeInput[] | KhatRaneshUncheckedCreateWithoutDarajePipeInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutDarajePipeInput | KhatRaneshCreateOrConnectWithoutDarajePipeInput[]
    createMany?: KhatRaneshCreateManyDarajePipeInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUncheckedCreateNestedManyWithoutDarajePipeInput = {
    create?: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput> | KhatRaneshCreateWithoutDarajePipeInput[] | KhatRaneshUncheckedCreateWithoutDarajePipeInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutDarajePipeInput | KhatRaneshCreateOrConnectWithoutDarajePipeInput[]
    createMany?: KhatRaneshCreateManyDarajePipeInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUpdateManyWithoutDarajePipeNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput> | KhatRaneshCreateWithoutDarajePipeInput[] | KhatRaneshUncheckedCreateWithoutDarajePipeInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutDarajePipeInput | KhatRaneshCreateOrConnectWithoutDarajePipeInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutDarajePipeInput | KhatRaneshUpsertWithWhereUniqueWithoutDarajePipeInput[]
    createMany?: KhatRaneshCreateManyDarajePipeInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutDarajePipeInput | KhatRaneshUpdateWithWhereUniqueWithoutDarajePipeInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutDarajePipeInput | KhatRaneshUpdateManyWithWhereWithoutDarajePipeInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type KhatRaneshUncheckedUpdateManyWithoutDarajePipeNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput> | KhatRaneshCreateWithoutDarajePipeInput[] | KhatRaneshUncheckedCreateWithoutDarajePipeInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutDarajePipeInput | KhatRaneshCreateOrConnectWithoutDarajePipeInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutDarajePipeInput | KhatRaneshUpsertWithWhereUniqueWithoutDarajePipeInput[]
    createMany?: KhatRaneshCreateManyDarajePipeInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutDarajePipeInput | KhatRaneshUpdateWithWhereUniqueWithoutDarajePipeInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutDarajePipeInput | KhatRaneshUpdateManyWithWhereWithoutDarajePipeInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type PumpStationCreateNestedManyWithoutDeliveryPointInput = {
    create?: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput> | PumpStationCreateWithoutDeliveryPointInput[] | PumpStationUncheckedCreateWithoutDeliveryPointInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDeliveryPointInput | PumpStationCreateOrConnectWithoutDeliveryPointInput[]
    createMany?: PumpStationCreateManyDeliveryPointInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type PumpStationUncheckedCreateNestedManyWithoutDeliveryPointInput = {
    create?: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput> | PumpStationCreateWithoutDeliveryPointInput[] | PumpStationUncheckedCreateWithoutDeliveryPointInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDeliveryPointInput | PumpStationCreateOrConnectWithoutDeliveryPointInput[]
    createMany?: PumpStationCreateManyDeliveryPointInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type PumpStationUpdateManyWithoutDeliveryPointNestedInput = {
    create?: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput> | PumpStationCreateWithoutDeliveryPointInput[] | PumpStationUncheckedCreateWithoutDeliveryPointInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDeliveryPointInput | PumpStationCreateOrConnectWithoutDeliveryPointInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutDeliveryPointInput | PumpStationUpsertWithWhereUniqueWithoutDeliveryPointInput[]
    createMany?: PumpStationCreateManyDeliveryPointInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutDeliveryPointInput | PumpStationUpdateWithWhereUniqueWithoutDeliveryPointInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutDeliveryPointInput | PumpStationUpdateManyWithWhereWithoutDeliveryPointInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type PumpStationUncheckedUpdateManyWithoutDeliveryPointNestedInput = {
    create?: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput> | PumpStationCreateWithoutDeliveryPointInput[] | PumpStationUncheckedCreateWithoutDeliveryPointInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDeliveryPointInput | PumpStationCreateOrConnectWithoutDeliveryPointInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutDeliveryPointInput | PumpStationUpsertWithWhereUniqueWithoutDeliveryPointInput[]
    createMany?: PumpStationCreateManyDeliveryPointInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutDeliveryPointInput | PumpStationUpdateWithWhereUniqueWithoutDeliveryPointInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutDeliveryPointInput | PumpStationUpdateManyWithWhereWithoutDeliveryPointInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type PumpStationCreateNestedManyWithoutDarjeStationInput = {
    create?: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput> | PumpStationCreateWithoutDarjeStationInput[] | PumpStationUncheckedCreateWithoutDarjeStationInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDarjeStationInput | PumpStationCreateOrConnectWithoutDarjeStationInput[]
    createMany?: PumpStationCreateManyDarjeStationInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type PumpStationUncheckedCreateNestedManyWithoutDarjeStationInput = {
    create?: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput> | PumpStationCreateWithoutDarjeStationInput[] | PumpStationUncheckedCreateWithoutDarjeStationInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDarjeStationInput | PumpStationCreateOrConnectWithoutDarjeStationInput[]
    createMany?: PumpStationCreateManyDarjeStationInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type PumpStationUpdateManyWithoutDarjeStationNestedInput = {
    create?: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput> | PumpStationCreateWithoutDarjeStationInput[] | PumpStationUncheckedCreateWithoutDarjeStationInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDarjeStationInput | PumpStationCreateOrConnectWithoutDarjeStationInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutDarjeStationInput | PumpStationUpsertWithWhereUniqueWithoutDarjeStationInput[]
    createMany?: PumpStationCreateManyDarjeStationInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutDarjeStationInput | PumpStationUpdateWithWhereUniqueWithoutDarjeStationInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutDarjeStationInput | PumpStationUpdateManyWithWhereWithoutDarjeStationInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type PumpStationUncheckedUpdateManyWithoutDarjeStationNestedInput = {
    create?: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput> | PumpStationCreateWithoutDarjeStationInput[] | PumpStationUncheckedCreateWithoutDarjeStationInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutDarjeStationInput | PumpStationCreateOrConnectWithoutDarjeStationInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutDarjeStationInput | PumpStationUpsertWithWhereUniqueWithoutDarjeStationInput[]
    createMany?: PumpStationCreateManyDarjeStationInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutDarjeStationInput | PumpStationUpdateWithWhereUniqueWithoutDarjeStationInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutDarjeStationInput | PumpStationUpdateManyWithWhereWithoutDarjeStationInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type ShabakeDoreKeshtCreateNestedManyWithoutDoreKeshtInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | ShabakeDoreKeshtCreateWithoutDoreKeshtInput[] | ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput | ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    createMany?: ShabakeDoreKeshtCreateManyDoreKeshtInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type TrikhDoreKeshtCreateNestedManyWithoutDoreKeshtInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | TrikhDoreKeshtCreateWithoutDoreKeshtInput[] | TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput | TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    createMany?: TrikhDoreKeshtCreateManyDoreKeshtInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | ShabakeDoreKeshtCreateWithoutDoreKeshtInput[] | ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput | ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    createMany?: ShabakeDoreKeshtCreateManyDoreKeshtInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type TrikhDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | TrikhDoreKeshtCreateWithoutDoreKeshtInput[] | TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput | TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    createMany?: TrikhDoreKeshtCreateManyDoreKeshtInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtUpdateManyWithoutDoreKeshtNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | ShabakeDoreKeshtCreateWithoutDoreKeshtInput[] | ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput | ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput[]
    createMany?: ShabakeDoreKeshtCreateManyDoreKeshtInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type TrikhDoreKeshtUpdateManyWithoutDoreKeshtNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | TrikhDoreKeshtCreateWithoutDoreKeshtInput[] | TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput | TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput[]
    createMany?: TrikhDoreKeshtCreateManyDoreKeshtInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput | TrikhDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | ShabakeDoreKeshtCreateWithoutDoreKeshtInput[] | ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput | ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput[]
    createMany?: ShabakeDoreKeshtCreateManyDoreKeshtInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput> | TrikhDoreKeshtCreateWithoutDoreKeshtInput[] | TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput | TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput[]
    createMany?: TrikhDoreKeshtCreateManyDoreKeshtInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput | TrikhDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutEshtebahAvamelInput = {
    create?: XOR<KhatRaneshCreateWithoutEshtebahAvamelInput, KhatRaneshUncheckedCreateWithoutEshtebahAvamelInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutEshtebahAvamelInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutEshtebahAvamelInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedCreateWithoutEshtebahAvamelInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutEshtebahAvamelInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutEshtebahAvamelNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutEshtebahAvamelInput, KhatRaneshUncheckedCreateWithoutEshtebahAvamelInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutEshtebahAvamelInput
    upsert?: KhatRaneshUpsertWithoutEshtebahAvamelInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutEshtebahAvamelInput, KhatRaneshUpdateWithoutEshtebahAvamelInput>, KhatRaneshUncheckedUpdateWithoutEshtebahAvamelInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutEshtebahAvamelNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedCreateWithoutEshtebahAvamelInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutEshtebahAvamelInput
    upsert?: TrikhDoreKeshtUpsertWithoutEshtebahAvamelInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutEshtebahAvamelInput, TrikhDoreKeshtUpdateWithoutEshtebahAvamelInput>, TrikhDoreKeshtUncheckedUpdateWithoutEshtebahAvamelInput>
  }

  export type KhatRaneshCreateNestedOneWithoutFlowBehboodInput = {
    create?: XOR<KhatRaneshCreateWithoutFlowBehboodInput, KhatRaneshUncheckedCreateWithoutFlowBehboodInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutFlowBehboodInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutFlowBehboodInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedCreateWithoutFlowBehboodInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutFlowBehboodInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutFlowBehboodNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutFlowBehboodInput, KhatRaneshUncheckedCreateWithoutFlowBehboodInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutFlowBehboodInput
    upsert?: KhatRaneshUpsertWithoutFlowBehboodInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutFlowBehboodInput, KhatRaneshUpdateWithoutFlowBehboodInput>, KhatRaneshUncheckedUpdateWithoutFlowBehboodInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutFlowBehboodNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedCreateWithoutFlowBehboodInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutFlowBehboodInput
    upsert?: TrikhDoreKeshtUpsertWithoutFlowBehboodInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutFlowBehboodInput, TrikhDoreKeshtUpdateWithoutFlowBehboodInput>, TrikhDoreKeshtUncheckedUpdateWithoutFlowBehboodInput>
  }

  export type KhatRaneshCreateNestedOneWithoutFlowmeterInput = {
    create?: XOR<KhatRaneshCreateWithoutFlowmeterInput, KhatRaneshUncheckedCreateWithoutFlowmeterInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutFlowmeterInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutFlowmeterInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedCreateWithoutFlowmeterInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutFlowmeterInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KhatRaneshUpdateOneRequiredWithoutFlowmeterNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutFlowmeterInput, KhatRaneshUncheckedCreateWithoutFlowmeterInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutFlowmeterInput
    upsert?: KhatRaneshUpsertWithoutFlowmeterInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutFlowmeterInput, KhatRaneshUpdateWithoutFlowmeterInput>, KhatRaneshUncheckedUpdateWithoutFlowmeterInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutFlowmeterNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedCreateWithoutFlowmeterInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutFlowmeterInput
    upsert?: TrikhDoreKeshtUpsertWithoutFlowmeterInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutFlowmeterInput, TrikhDoreKeshtUpdateWithoutFlowmeterInput>, TrikhDoreKeshtUncheckedUpdateWithoutFlowmeterInput>
  }

  export type AbgirCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput> | AbgirCreateWithoutKhatRaneshInput[] | AbgirUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: AbgirCreateOrConnectWithoutKhatRaneshInput | AbgirCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: AbgirCreateManyKhatRaneshInputEnvelope
    connect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
  }

  export type BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramCreateWithoutKhatRaneshInput[] | BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
  }

  export type BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramSeghliCreateWithoutKhatRaneshInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramSeghliCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
  }

  export type BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput> | BahrebardariKeshtDoreCreateWithoutKhatRaneshInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput | BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardariKeshtDoreCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput> | BahrebardariTaghvimCreateWithoutKhatRaneshInput[] | BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput | BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardariTaghvimCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
  }

  export type EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput> | EshtebahAvamelCreateWithoutKhatRaneshInput[] | EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput | EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: EshtebahAvamelCreateManyKhatRaneshInputEnvelope
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
  }

  export type FlowBehboodCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput> | FlowBehboodCreateWithoutKhatRaneshInput[] | FlowBehboodUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutKhatRaneshInput | FlowBehboodCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: FlowBehboodCreateManyKhatRaneshInputEnvelope
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
  }

  export type FlowmeterCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput> | FlowmeterCreateWithoutKhatRaneshInput[] | FlowmeterUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutKhatRaneshInput | FlowmeterCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: FlowmeterCreateManyKhatRaneshInputEnvelope
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
  }

  export type DarajePipeCreateNestedOneWithoutKhatRaneshInput = {
    create?: XOR<DarajePipeCreateWithoutKhatRaneshInput, DarajePipeUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: DarajePipeCreateOrConnectWithoutKhatRaneshInput
    connect?: DarajePipeWhereUniqueInput
  }

  export type MeasuringToolCreateNestedOneWithoutKhatRaneshInput = {
    create?: XOR<MeasuringToolCreateWithoutKhatRaneshInput, MeasuringToolUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: MeasuringToolCreateOrConnectWithoutKhatRaneshInput
    connect?: MeasuringToolWhereUniqueInput
  }

  export type PumpStationCreateNestedOneWithoutKhatRaneshInput = {
    create?: XOR<PumpStationCreateWithoutKhatRaneshInput, PumpStationUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: PumpStationCreateOrConnectWithoutKhatRaneshInput
    connect?: PumpStationWhereUniqueInput
  }

  export type SeghliPumpCreateNestedOneWithoutKhatRaneshInput = {
    create?: XOR<SeghliPumpCreateWithoutKhatRaneshInput, SeghliPumpUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: SeghliPumpCreateOrConnectWithoutKhatRaneshInput
    connect?: SeghliPumpWhereUniqueInput
  }

  export type KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshAreaCreateWithoutKhatRaneshInput[] | KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput | KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshAreaCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshPumpCreateWithoutKhatRaneshInput[] | KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput | KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshPumpCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
  }

  export type KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshSegliCreateWithoutKhatRaneshInput[] | KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput | KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshSegliCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
  }

  export type NashtShabakeCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput> | NashtShabakeCreateWithoutKhatRaneshInput[] | NashtShabakeUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutKhatRaneshInput | NashtShabakeCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: NashtShabakeCreateManyKhatRaneshInputEnvelope
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
  }

  export type NonFITCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput> | NonFITCreateWithoutKhatRaneshInput[] | NonFITUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutKhatRaneshInput | NonFITCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: NonFITCreateManyKhatRaneshInputEnvelope
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
  }

  export type TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput> | TakhlieMakhzanCreateWithoutKhatRaneshInput[] | TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput | TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: TakhlieMakhzanCreateManyKhatRaneshInputEnvelope
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
  }

  export type TestCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput> | TestCreateWithoutKhatRaneshInput[] | TestUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TestCreateOrConnectWithoutKhatRaneshInput | TestCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: TestCreateManyKhatRaneshInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput> | AbgirCreateWithoutKhatRaneshInput[] | AbgirUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: AbgirCreateOrConnectWithoutKhatRaneshInput | AbgirCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: AbgirCreateManyKhatRaneshInputEnvelope
    connect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
  }

  export type BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramCreateWithoutKhatRaneshInput[] | BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
  }

  export type BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramSeghliCreateWithoutKhatRaneshInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramSeghliCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
  }

  export type BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput> | BahrebardariKeshtDoreCreateWithoutKhatRaneshInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput | BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardariKeshtDoreCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput> | BahrebardariTaghvimCreateWithoutKhatRaneshInput[] | BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput | BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: BahrebardariTaghvimCreateManyKhatRaneshInputEnvelope
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
  }

  export type EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput> | EshtebahAvamelCreateWithoutKhatRaneshInput[] | EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput | EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: EshtebahAvamelCreateManyKhatRaneshInputEnvelope
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
  }

  export type FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput> | FlowBehboodCreateWithoutKhatRaneshInput[] | FlowBehboodUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutKhatRaneshInput | FlowBehboodCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: FlowBehboodCreateManyKhatRaneshInputEnvelope
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
  }

  export type FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput> | FlowmeterCreateWithoutKhatRaneshInput[] | FlowmeterUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutKhatRaneshInput | FlowmeterCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: FlowmeterCreateManyKhatRaneshInputEnvelope
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
  }

  export type KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshAreaCreateWithoutKhatRaneshInput[] | KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput | KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshAreaCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshPumpCreateWithoutKhatRaneshInput[] | KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput | KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshPumpCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
  }

  export type KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshSegliCreateWithoutKhatRaneshInput[] | KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput | KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: KhatRaneshSegliCreateManyKhatRaneshInputEnvelope
    connect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
  }

  export type NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput> | NashtShabakeCreateWithoutKhatRaneshInput[] | NashtShabakeUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutKhatRaneshInput | NashtShabakeCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: NashtShabakeCreateManyKhatRaneshInputEnvelope
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
  }

  export type NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput> | NonFITCreateWithoutKhatRaneshInput[] | NonFITUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutKhatRaneshInput | NonFITCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: NonFITCreateManyKhatRaneshInputEnvelope
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
  }

  export type TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput> | TakhlieMakhzanCreateWithoutKhatRaneshInput[] | TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput | TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: TakhlieMakhzanCreateManyKhatRaneshInputEnvelope
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
  }

  export type TestUncheckedCreateNestedManyWithoutKhatRaneshInput = {
    create?: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput> | TestCreateWithoutKhatRaneshInput[] | TestUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TestCreateOrConnectWithoutKhatRaneshInput | TestCreateOrConnectWithoutKhatRaneshInput[]
    createMany?: TestCreateManyKhatRaneshInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AbgirUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput> | AbgirCreateWithoutKhatRaneshInput[] | AbgirUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: AbgirCreateOrConnectWithoutKhatRaneshInput | AbgirCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: AbgirUpsertWithWhereUniqueWithoutKhatRaneshInput | AbgirUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: AbgirCreateManyKhatRaneshInputEnvelope
    set?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    disconnect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    delete?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    connect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    update?: AbgirUpdateWithWhereUniqueWithoutKhatRaneshInput | AbgirUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: AbgirUpdateManyWithWhereWithoutKhatRaneshInput | AbgirUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: AbgirScalarWhereInput | AbgirScalarWhereInput[]
  }

  export type BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramCreateWithoutKhatRaneshInput[] | BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardairProgramUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramCreateManyKhatRaneshInputEnvelope
    set?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    disconnect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    delete?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    update?: BahrebardairProgramUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardairProgramUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardairProgramUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
  }

  export type BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramSeghliCreateWithoutKhatRaneshInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramSeghliCreateManyKhatRaneshInputEnvelope
    set?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    disconnect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    delete?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    update?: BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardairProgramSeghliUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardairProgramSeghliUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
  }

  export type BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput> | BahrebardariKeshtDoreCreateWithoutKhatRaneshInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput | BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardariKeshtDoreCreateManyKhatRaneshInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput> | BahrebardariTaghvimCreateWithoutKhatRaneshInput[] | BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput | BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardariTaghvimUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardariTaghvimUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardariTaghvimCreateManyKhatRaneshInputEnvelope
    set?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    disconnect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    delete?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    update?: BahrebardariTaghvimUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardariTaghvimUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardariTaghvimUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardariTaghvimUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
  }

  export type EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput> | EshtebahAvamelCreateWithoutKhatRaneshInput[] | EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput | EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: EshtebahAvamelUpsertWithWhereUniqueWithoutKhatRaneshInput | EshtebahAvamelUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: EshtebahAvamelCreateManyKhatRaneshInputEnvelope
    set?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    disconnect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    delete?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    update?: EshtebahAvamelUpdateWithWhereUniqueWithoutKhatRaneshInput | EshtebahAvamelUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: EshtebahAvamelUpdateManyWithWhereWithoutKhatRaneshInput | EshtebahAvamelUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
  }

  export type FlowBehboodUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput> | FlowBehboodCreateWithoutKhatRaneshInput[] | FlowBehboodUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutKhatRaneshInput | FlowBehboodCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: FlowBehboodUpsertWithWhereUniqueWithoutKhatRaneshInput | FlowBehboodUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: FlowBehboodCreateManyKhatRaneshInputEnvelope
    set?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    disconnect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    delete?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    update?: FlowBehboodUpdateWithWhereUniqueWithoutKhatRaneshInput | FlowBehboodUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: FlowBehboodUpdateManyWithWhereWithoutKhatRaneshInput | FlowBehboodUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
  }

  export type FlowmeterUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput> | FlowmeterCreateWithoutKhatRaneshInput[] | FlowmeterUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutKhatRaneshInput | FlowmeterCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: FlowmeterUpsertWithWhereUniqueWithoutKhatRaneshInput | FlowmeterUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: FlowmeterCreateManyKhatRaneshInputEnvelope
    set?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    disconnect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    delete?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    update?: FlowmeterUpdateWithWhereUniqueWithoutKhatRaneshInput | FlowmeterUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: FlowmeterUpdateManyWithWhereWithoutKhatRaneshInput | FlowmeterUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
  }

  export type DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput = {
    create?: XOR<DarajePipeCreateWithoutKhatRaneshInput, DarajePipeUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: DarajePipeCreateOrConnectWithoutKhatRaneshInput
    upsert?: DarajePipeUpsertWithoutKhatRaneshInput
    connect?: DarajePipeWhereUniqueInput
    update?: XOR<XOR<DarajePipeUpdateToOneWithWhereWithoutKhatRaneshInput, DarajePipeUpdateWithoutKhatRaneshInput>, DarajePipeUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput = {
    create?: XOR<MeasuringToolCreateWithoutKhatRaneshInput, MeasuringToolUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: MeasuringToolCreateOrConnectWithoutKhatRaneshInput
    upsert?: MeasuringToolUpsertWithoutKhatRaneshInput
    connect?: MeasuringToolWhereUniqueInput
    update?: XOR<XOR<MeasuringToolUpdateToOneWithWhereWithoutKhatRaneshInput, MeasuringToolUpdateWithoutKhatRaneshInput>, MeasuringToolUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput = {
    create?: XOR<PumpStationCreateWithoutKhatRaneshInput, PumpStationUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: PumpStationCreateOrConnectWithoutKhatRaneshInput
    upsert?: PumpStationUpsertWithoutKhatRaneshInput
    connect?: PumpStationWhereUniqueInput
    update?: XOR<XOR<PumpStationUpdateToOneWithWhereWithoutKhatRaneshInput, PumpStationUpdateWithoutKhatRaneshInput>, PumpStationUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput = {
    create?: XOR<SeghliPumpCreateWithoutKhatRaneshInput, SeghliPumpUncheckedCreateWithoutKhatRaneshInput>
    connectOrCreate?: SeghliPumpCreateOrConnectWithoutKhatRaneshInput
    upsert?: SeghliPumpUpsertWithoutKhatRaneshInput
    connect?: SeghliPumpWhereUniqueInput
    update?: XOR<XOR<SeghliPumpUpdateToOneWithWhereWithoutKhatRaneshInput, SeghliPumpUpdateWithoutKhatRaneshInput>, SeghliPumpUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshAreaCreateWithoutKhatRaneshInput[] | KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput | KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshAreaCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshAreaUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshPumpCreateWithoutKhatRaneshInput[] | KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput | KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshPumpUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshPumpUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshPumpCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    disconnect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    delete?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    update?: KhatRaneshPumpUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshPumpUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshPumpUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshPumpUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
  }

  export type KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshSegliCreateWithoutKhatRaneshInput[] | KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput | KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshSegliUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshSegliUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshSegliCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    disconnect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    delete?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    connect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    update?: KhatRaneshSegliUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshSegliUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshSegliUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshSegliUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshSegliScalarWhereInput | KhatRaneshSegliScalarWhereInput[]
  }

  export type NashtShabakeUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput> | NashtShabakeCreateWithoutKhatRaneshInput[] | NashtShabakeUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutKhatRaneshInput | NashtShabakeCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: NashtShabakeUpsertWithWhereUniqueWithoutKhatRaneshInput | NashtShabakeUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: NashtShabakeCreateManyKhatRaneshInputEnvelope
    set?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    disconnect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    delete?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    update?: NashtShabakeUpdateWithWhereUniqueWithoutKhatRaneshInput | NashtShabakeUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: NashtShabakeUpdateManyWithWhereWithoutKhatRaneshInput | NashtShabakeUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
  }

  export type NonFITUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput> | NonFITCreateWithoutKhatRaneshInput[] | NonFITUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutKhatRaneshInput | NonFITCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: NonFITUpsertWithWhereUniqueWithoutKhatRaneshInput | NonFITUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: NonFITCreateManyKhatRaneshInputEnvelope
    set?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    disconnect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    delete?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    update?: NonFITUpdateWithWhereUniqueWithoutKhatRaneshInput | NonFITUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: NonFITUpdateManyWithWhereWithoutKhatRaneshInput | NonFITUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
  }

  export type TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput> | TakhlieMakhzanCreateWithoutKhatRaneshInput[] | TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput | TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: TakhlieMakhzanUpsertWithWhereUniqueWithoutKhatRaneshInput | TakhlieMakhzanUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: TakhlieMakhzanCreateManyKhatRaneshInputEnvelope
    set?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    disconnect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    delete?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    update?: TakhlieMakhzanUpdateWithWhereUniqueWithoutKhatRaneshInput | TakhlieMakhzanUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: TakhlieMakhzanUpdateManyWithWhereWithoutKhatRaneshInput | TakhlieMakhzanUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
  }

  export type TestUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput> | TestCreateWithoutKhatRaneshInput[] | TestUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TestCreateOrConnectWithoutKhatRaneshInput | TestCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutKhatRaneshInput | TestUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: TestCreateManyKhatRaneshInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutKhatRaneshInput | TestUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: TestUpdateManyWithWhereWithoutKhatRaneshInput | TestUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput> | AbgirCreateWithoutKhatRaneshInput[] | AbgirUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: AbgirCreateOrConnectWithoutKhatRaneshInput | AbgirCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: AbgirUpsertWithWhereUniqueWithoutKhatRaneshInput | AbgirUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: AbgirCreateManyKhatRaneshInputEnvelope
    set?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    disconnect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    delete?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    connect?: AbgirWhereUniqueInput | AbgirWhereUniqueInput[]
    update?: AbgirUpdateWithWhereUniqueWithoutKhatRaneshInput | AbgirUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: AbgirUpdateManyWithWhereWithoutKhatRaneshInput | AbgirUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: AbgirScalarWhereInput | AbgirScalarWhereInput[]
  }

  export type BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramCreateWithoutKhatRaneshInput[] | BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardairProgramUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramCreateManyKhatRaneshInputEnvelope
    set?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    disconnect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    delete?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    update?: BahrebardairProgramUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardairProgramUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardairProgramUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
  }

  export type BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput> | BahrebardairProgramSeghliCreateWithoutKhatRaneshInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput | BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardairProgramSeghliCreateManyKhatRaneshInputEnvelope
    set?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    disconnect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    delete?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    update?: BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardairProgramSeghliUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardairProgramSeghliUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput> | BahrebardariKeshtDoreCreateWithoutKhatRaneshInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput | BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardariKeshtDoreCreateManyKhatRaneshInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput> | BahrebardariTaghvimCreateWithoutKhatRaneshInput[] | BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput | BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: BahrebardariTaghvimUpsertWithWhereUniqueWithoutKhatRaneshInput | BahrebardariTaghvimUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: BahrebardariTaghvimCreateManyKhatRaneshInputEnvelope
    set?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    disconnect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    delete?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    update?: BahrebardariTaghvimUpdateWithWhereUniqueWithoutKhatRaneshInput | BahrebardariTaghvimUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: BahrebardariTaghvimUpdateManyWithWhereWithoutKhatRaneshInput | BahrebardariTaghvimUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
  }

  export type EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput> | EshtebahAvamelCreateWithoutKhatRaneshInput[] | EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput | EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: EshtebahAvamelUpsertWithWhereUniqueWithoutKhatRaneshInput | EshtebahAvamelUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: EshtebahAvamelCreateManyKhatRaneshInputEnvelope
    set?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    disconnect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    delete?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    update?: EshtebahAvamelUpdateWithWhereUniqueWithoutKhatRaneshInput | EshtebahAvamelUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: EshtebahAvamelUpdateManyWithWhereWithoutKhatRaneshInput | EshtebahAvamelUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
  }

  export type FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput> | FlowBehboodCreateWithoutKhatRaneshInput[] | FlowBehboodUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutKhatRaneshInput | FlowBehboodCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: FlowBehboodUpsertWithWhereUniqueWithoutKhatRaneshInput | FlowBehboodUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: FlowBehboodCreateManyKhatRaneshInputEnvelope
    set?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    disconnect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    delete?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    update?: FlowBehboodUpdateWithWhereUniqueWithoutKhatRaneshInput | FlowBehboodUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: FlowBehboodUpdateManyWithWhereWithoutKhatRaneshInput | FlowBehboodUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
  }

  export type FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput> | FlowmeterCreateWithoutKhatRaneshInput[] | FlowmeterUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutKhatRaneshInput | FlowmeterCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: FlowmeterUpsertWithWhereUniqueWithoutKhatRaneshInput | FlowmeterUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: FlowmeterCreateManyKhatRaneshInputEnvelope
    set?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    disconnect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    delete?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    update?: FlowmeterUpdateWithWhereUniqueWithoutKhatRaneshInput | FlowmeterUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: FlowmeterUpdateManyWithWhereWithoutKhatRaneshInput | FlowmeterUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshAreaCreateWithoutKhatRaneshInput[] | KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput | KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshAreaCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshAreaUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshPumpCreateWithoutKhatRaneshInput[] | KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput | KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshPumpUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshPumpUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshPumpCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    disconnect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    delete?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    update?: KhatRaneshPumpUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshPumpUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshPumpUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshPumpUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
  }

  export type KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput> | KhatRaneshSegliCreateWithoutKhatRaneshInput[] | KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput | KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: KhatRaneshSegliUpsertWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshSegliUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: KhatRaneshSegliCreateManyKhatRaneshInputEnvelope
    set?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    disconnect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    delete?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    connect?: KhatRaneshSegliWhereUniqueInput | KhatRaneshSegliWhereUniqueInput[]
    update?: KhatRaneshSegliUpdateWithWhereUniqueWithoutKhatRaneshInput | KhatRaneshSegliUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: KhatRaneshSegliUpdateManyWithWhereWithoutKhatRaneshInput | KhatRaneshSegliUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: KhatRaneshSegliScalarWhereInput | KhatRaneshSegliScalarWhereInput[]
  }

  export type NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput> | NashtShabakeCreateWithoutKhatRaneshInput[] | NashtShabakeUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutKhatRaneshInput | NashtShabakeCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: NashtShabakeUpsertWithWhereUniqueWithoutKhatRaneshInput | NashtShabakeUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: NashtShabakeCreateManyKhatRaneshInputEnvelope
    set?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    disconnect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    delete?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    update?: NashtShabakeUpdateWithWhereUniqueWithoutKhatRaneshInput | NashtShabakeUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: NashtShabakeUpdateManyWithWhereWithoutKhatRaneshInput | NashtShabakeUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
  }

  export type NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput> | NonFITCreateWithoutKhatRaneshInput[] | NonFITUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutKhatRaneshInput | NonFITCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: NonFITUpsertWithWhereUniqueWithoutKhatRaneshInput | NonFITUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: NonFITCreateManyKhatRaneshInputEnvelope
    set?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    disconnect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    delete?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    update?: NonFITUpdateWithWhereUniqueWithoutKhatRaneshInput | NonFITUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: NonFITUpdateManyWithWhereWithoutKhatRaneshInput | NonFITUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
  }

  export type TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput> | TakhlieMakhzanCreateWithoutKhatRaneshInput[] | TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput | TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: TakhlieMakhzanUpsertWithWhereUniqueWithoutKhatRaneshInput | TakhlieMakhzanUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: TakhlieMakhzanCreateManyKhatRaneshInputEnvelope
    set?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    disconnect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    delete?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    update?: TakhlieMakhzanUpdateWithWhereUniqueWithoutKhatRaneshInput | TakhlieMakhzanUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: TakhlieMakhzanUpdateManyWithWhereWithoutKhatRaneshInput | TakhlieMakhzanUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
  }

  export type TestUncheckedUpdateManyWithoutKhatRaneshNestedInput = {
    create?: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput> | TestCreateWithoutKhatRaneshInput[] | TestUncheckedCreateWithoutKhatRaneshInput[]
    connectOrCreate?: TestCreateOrConnectWithoutKhatRaneshInput | TestCreateOrConnectWithoutKhatRaneshInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutKhatRaneshInput | TestUpsertWithWhereUniqueWithoutKhatRaneshInput[]
    createMany?: TestCreateManyKhatRaneshInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutKhatRaneshInput | TestUpdateWithWhereUniqueWithoutKhatRaneshInput[]
    updateMany?: TestUpdateManyWithWhereWithoutKhatRaneshInput | TestUpdateManyWithWhereWithoutKhatRaneshInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutKhatRaneshAreaInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshAreaInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type LandCreateNestedOneWithoutKhatRaneshAreaInput = {
    create?: XOR<LandCreateWithoutKhatRaneshAreaInput, LandUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: LandCreateOrConnectWithoutKhatRaneshAreaInput
    connect?: LandWhereUniqueInput
  }

  export type NetworkCreateNestedOneWithoutKhatRaneshAreaInput = {
    create?: XOR<NetworkCreateWithoutKhatRaneshAreaInput, NetworkUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutKhatRaneshAreaInput
    connect?: NetworkWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutKhatRaneshAreaNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshAreaInput
    upsert?: KhatRaneshUpsertWithoutKhatRaneshAreaInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshAreaInput, KhatRaneshUpdateWithoutKhatRaneshAreaInput>, KhatRaneshUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type LandUpdateOneRequiredWithoutKhatRaneshAreaNestedInput = {
    create?: XOR<LandCreateWithoutKhatRaneshAreaInput, LandUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: LandCreateOrConnectWithoutKhatRaneshAreaInput
    upsert?: LandUpsertWithoutKhatRaneshAreaInput
    connect?: LandWhereUniqueInput
    update?: XOR<XOR<LandUpdateToOneWithWhereWithoutKhatRaneshAreaInput, LandUpdateWithoutKhatRaneshAreaInput>, LandUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type NetworkUpdateOneRequiredWithoutKhatRaneshAreaNestedInput = {
    create?: XOR<NetworkCreateWithoutKhatRaneshAreaInput, NetworkUncheckedCreateWithoutKhatRaneshAreaInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutKhatRaneshAreaInput
    upsert?: NetworkUpsertWithoutKhatRaneshAreaInput
    connect?: NetworkWhereUniqueInput
    update?: XOR<XOR<NetworkUpdateToOneWithWhereWithoutKhatRaneshAreaInput, NetworkUpdateWithoutKhatRaneshAreaInput>, NetworkUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type KhatRaneshCreateNestedOneWithoutKhatRaneshPumpInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedCreateWithoutKhatRaneshPumpInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshPumpInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type PumpTypeCreateNestedOneWithoutKhatRaneshPumpInput = {
    create?: XOR<PumpTypeCreateWithoutKhatRaneshPumpInput, PumpTypeUncheckedCreateWithoutKhatRaneshPumpInput>
    connectOrCreate?: PumpTypeCreateOrConnectWithoutKhatRaneshPumpInput
    connect?: PumpTypeWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type KhatRaneshUpdateOneRequiredWithoutKhatRaneshPumpNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedCreateWithoutKhatRaneshPumpInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshPumpInput
    upsert?: KhatRaneshUpsertWithoutKhatRaneshPumpInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshPumpInput, KhatRaneshUpdateWithoutKhatRaneshPumpInput>, KhatRaneshUncheckedUpdateWithoutKhatRaneshPumpInput>
  }

  export type PumpTypeUpdateOneRequiredWithoutKhatRaneshPumpNestedInput = {
    create?: XOR<PumpTypeCreateWithoutKhatRaneshPumpInput, PumpTypeUncheckedCreateWithoutKhatRaneshPumpInput>
    connectOrCreate?: PumpTypeCreateOrConnectWithoutKhatRaneshPumpInput
    upsert?: PumpTypeUpsertWithoutKhatRaneshPumpInput
    connect?: PumpTypeWhereUniqueInput
    update?: XOR<XOR<PumpTypeUpdateToOneWithWhereWithoutKhatRaneshPumpInput, PumpTypeUpdateWithoutKhatRaneshPumpInput>, PumpTypeUncheckedUpdateWithoutKhatRaneshPumpInput>
  }

  export type KhatRaneshCreateNestedOneWithoutKhatRaneshSegliInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedCreateWithoutKhatRaneshSegliInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshSegliInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutKhatRaneshSegliNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedCreateWithoutKhatRaneshSegliInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutKhatRaneshSegliInput
    upsert?: KhatRaneshUpsertWithoutKhatRaneshSegliInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshSegliInput, KhatRaneshUpdateWithoutKhatRaneshSegliInput>, KhatRaneshUncheckedUpdateWithoutKhatRaneshSegliInput>
  }

  export type AbgirCreateNestedOneWithoutKontorInput = {
    create?: XOR<AbgirCreateWithoutKontorInput, AbgirUncheckedCreateWithoutKontorInput>
    connectOrCreate?: AbgirCreateOrConnectWithoutKontorInput
    connect?: AbgirWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutKontorInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutKontorInput, TrikhDoreKeshtUncheckedCreateWithoutKontorInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutKontorInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type AbgirUpdateOneRequiredWithoutKontorNestedInput = {
    create?: XOR<AbgirCreateWithoutKontorInput, AbgirUncheckedCreateWithoutKontorInput>
    connectOrCreate?: AbgirCreateOrConnectWithoutKontorInput
    upsert?: AbgirUpsertWithoutKontorInput
    connect?: AbgirWhereUniqueInput
    update?: XOR<XOR<AbgirUpdateToOneWithWhereWithoutKontorInput, AbgirUpdateWithoutKontorInput>, AbgirUncheckedUpdateWithoutKontorInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutKontorNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutKontorInput, TrikhDoreKeshtUncheckedCreateWithoutKontorInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutKontorInput
    upsert?: TrikhDoreKeshtUpsertWithoutKontorInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutKontorInput, TrikhDoreKeshtUpdateWithoutKontorInput>, TrikhDoreKeshtUncheckedUpdateWithoutKontorInput>
  }

  export type KhatRaneshAreaCreateNestedManyWithoutLandInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput> | KhatRaneshAreaCreateWithoutLandInput[] | KhatRaneshAreaUncheckedCreateWithoutLandInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutLandInput | KhatRaneshAreaCreateOrConnectWithoutLandInput[]
    createMany?: KhatRaneshAreaCreateManyLandInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type KhatRaneshAreaUncheckedCreateNestedManyWithoutLandInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput> | KhatRaneshAreaCreateWithoutLandInput[] | KhatRaneshAreaUncheckedCreateWithoutLandInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutLandInput | KhatRaneshAreaCreateOrConnectWithoutLandInput[]
    createMany?: KhatRaneshAreaCreateManyLandInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type KhatRaneshAreaUpdateManyWithoutLandNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput> | KhatRaneshAreaCreateWithoutLandInput[] | KhatRaneshAreaUncheckedCreateWithoutLandInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutLandInput | KhatRaneshAreaCreateOrConnectWithoutLandInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutLandInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutLandInput[]
    createMany?: KhatRaneshAreaCreateManyLandInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutLandInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutLandInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutLandInput | KhatRaneshAreaUpdateManyWithWhereWithoutLandInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutLandNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput> | KhatRaneshAreaCreateWithoutLandInput[] | KhatRaneshAreaUncheckedCreateWithoutLandInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutLandInput | KhatRaneshAreaCreateOrConnectWithoutLandInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutLandInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutLandInput[]
    createMany?: KhatRaneshAreaCreateManyLandInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutLandInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutLandInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutLandInput | KhatRaneshAreaUpdateManyWithWhereWithoutLandInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedManyWithoutMeasuringToolInput = {
    create?: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput> | KhatRaneshCreateWithoutMeasuringToolInput[] | KhatRaneshUncheckedCreateWithoutMeasuringToolInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutMeasuringToolInput | KhatRaneshCreateOrConnectWithoutMeasuringToolInput[]
    createMany?: KhatRaneshCreateManyMeasuringToolInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUncheckedCreateNestedManyWithoutMeasuringToolInput = {
    create?: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput> | KhatRaneshCreateWithoutMeasuringToolInput[] | KhatRaneshUncheckedCreateWithoutMeasuringToolInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutMeasuringToolInput | KhatRaneshCreateOrConnectWithoutMeasuringToolInput[]
    createMany?: KhatRaneshCreateManyMeasuringToolInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUpdateManyWithoutMeasuringToolNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput> | KhatRaneshCreateWithoutMeasuringToolInput[] | KhatRaneshUncheckedCreateWithoutMeasuringToolInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutMeasuringToolInput | KhatRaneshCreateOrConnectWithoutMeasuringToolInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutMeasuringToolInput | KhatRaneshUpsertWithWhereUniqueWithoutMeasuringToolInput[]
    createMany?: KhatRaneshCreateManyMeasuringToolInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutMeasuringToolInput | KhatRaneshUpdateWithWhereUniqueWithoutMeasuringToolInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutMeasuringToolInput | KhatRaneshUpdateManyWithWhereWithoutMeasuringToolInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type KhatRaneshUncheckedUpdateManyWithoutMeasuringToolNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput> | KhatRaneshCreateWithoutMeasuringToolInput[] | KhatRaneshUncheckedCreateWithoutMeasuringToolInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutMeasuringToolInput | KhatRaneshCreateOrConnectWithoutMeasuringToolInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutMeasuringToolInput | KhatRaneshUpsertWithWhereUniqueWithoutMeasuringToolInput[]
    createMany?: KhatRaneshCreateManyMeasuringToolInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutMeasuringToolInput | KhatRaneshUpdateWithWhereUniqueWithoutMeasuringToolInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutMeasuringToolInput | KhatRaneshUpdateManyWithWhereWithoutMeasuringToolInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutNashtShabakeInput = {
    create?: XOR<KhatRaneshCreateWithoutNashtShabakeInput, KhatRaneshUncheckedCreateWithoutNashtShabakeInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutNashtShabakeInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutNashtShabakeInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedCreateWithoutNashtShabakeInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutNashtShabakeInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutNashtShabakeNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutNashtShabakeInput, KhatRaneshUncheckedCreateWithoutNashtShabakeInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutNashtShabakeInput
    upsert?: KhatRaneshUpsertWithoutNashtShabakeInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutNashtShabakeInput, KhatRaneshUpdateWithoutNashtShabakeInput>, KhatRaneshUncheckedUpdateWithoutNashtShabakeInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutNashtShabakeNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedCreateWithoutNashtShabakeInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutNashtShabakeInput
    upsert?: TrikhDoreKeshtUpsertWithoutNashtShabakeInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutNashtShabakeInput, TrikhDoreKeshtUpdateWithoutNashtShabakeInput>, TrikhDoreKeshtUncheckedUpdateWithoutNashtShabakeInput>
  }

  export type BareshMotaleatCreateNestedManyWithoutNetworkInput = {
    create?: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput> | BareshMotaleatCreateWithoutNetworkInput[] | BareshMotaleatUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutNetworkInput | BareshMotaleatCreateOrConnectWithoutNetworkInput[]
    createMany?: BareshMotaleatCreateManyNetworkInputEnvelope
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
  }

  export type KhatRaneshAreaCreateNestedManyWithoutNetworkInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput> | KhatRaneshAreaCreateWithoutNetworkInput[] | KhatRaneshAreaUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutNetworkInput | KhatRaneshAreaCreateOrConnectWithoutNetworkInput[]
    createMany?: KhatRaneshAreaCreateManyNetworkInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type SystemPartCreateNestedOneWithoutNetworkInput = {
    create?: XOR<SystemPartCreateWithoutNetworkInput, SystemPartUncheckedCreateWithoutNetworkInput>
    connectOrCreate?: SystemPartCreateOrConnectWithoutNetworkInput
    connect?: SystemPartWhereUniqueInput
  }

  export type PumpStationCreateNestedManyWithoutNetworkInput = {
    create?: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput> | PumpStationCreateWithoutNetworkInput[] | PumpStationUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutNetworkInput | PumpStationCreateOrConnectWithoutNetworkInput[]
    createMany?: PumpStationCreateManyNetworkInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput> | ShabakeDoreKeshtCreateWithoutNetworkInput[] | ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput | ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput[]
    createMany?: ShabakeDoreKeshtCreateManyNetworkInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput = {
    create?: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput> | BareshMotaleatCreateWithoutNetworkInput[] | BareshMotaleatUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutNetworkInput | BareshMotaleatCreateOrConnectWithoutNetworkInput[]
    createMany?: BareshMotaleatCreateManyNetworkInputEnvelope
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
  }

  export type KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput> | KhatRaneshAreaCreateWithoutNetworkInput[] | KhatRaneshAreaUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutNetworkInput | KhatRaneshAreaCreateOrConnectWithoutNetworkInput[]
    createMany?: KhatRaneshAreaCreateManyNetworkInputEnvelope
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
  }

  export type PumpStationUncheckedCreateNestedManyWithoutNetworkInput = {
    create?: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput> | PumpStationCreateWithoutNetworkInput[] | PumpStationUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutNetworkInput | PumpStationCreateOrConnectWithoutNetworkInput[]
    createMany?: PumpStationCreateManyNetworkInputEnvelope
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput> | ShabakeDoreKeshtCreateWithoutNetworkInput[] | ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput | ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput[]
    createMany?: ShabakeDoreKeshtCreateManyNetworkInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type BareshMotaleatUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput> | BareshMotaleatCreateWithoutNetworkInput[] | BareshMotaleatUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutNetworkInput | BareshMotaleatCreateOrConnectWithoutNetworkInput[]
    upsert?: BareshMotaleatUpsertWithWhereUniqueWithoutNetworkInput | BareshMotaleatUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: BareshMotaleatCreateManyNetworkInputEnvelope
    set?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    disconnect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    delete?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    update?: BareshMotaleatUpdateWithWhereUniqueWithoutNetworkInput | BareshMotaleatUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: BareshMotaleatUpdateManyWithWhereWithoutNetworkInput | BareshMotaleatUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
  }

  export type KhatRaneshAreaUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput> | KhatRaneshAreaCreateWithoutNetworkInput[] | KhatRaneshAreaUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutNetworkInput | KhatRaneshAreaCreateOrConnectWithoutNetworkInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutNetworkInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: KhatRaneshAreaCreateManyNetworkInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutNetworkInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutNetworkInput | KhatRaneshAreaUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type SystemPartUpdateOneRequiredWithoutNetworkNestedInput = {
    create?: XOR<SystemPartCreateWithoutNetworkInput, SystemPartUncheckedCreateWithoutNetworkInput>
    connectOrCreate?: SystemPartCreateOrConnectWithoutNetworkInput
    upsert?: SystemPartUpsertWithoutNetworkInput
    connect?: SystemPartWhereUniqueInput
    update?: XOR<XOR<SystemPartUpdateToOneWithWhereWithoutNetworkInput, SystemPartUpdateWithoutNetworkInput>, SystemPartUncheckedUpdateWithoutNetworkInput>
  }

  export type PumpStationUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput> | PumpStationCreateWithoutNetworkInput[] | PumpStationUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutNetworkInput | PumpStationCreateOrConnectWithoutNetworkInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutNetworkInput | PumpStationUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: PumpStationCreateManyNetworkInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutNetworkInput | PumpStationUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutNetworkInput | PumpStationUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput> | ShabakeDoreKeshtCreateWithoutNetworkInput[] | ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput | ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutNetworkInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: ShabakeDoreKeshtCreateManyNetworkInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutNetworkInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutNetworkInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput> | BareshMotaleatCreateWithoutNetworkInput[] | BareshMotaleatUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutNetworkInput | BareshMotaleatCreateOrConnectWithoutNetworkInput[]
    upsert?: BareshMotaleatUpsertWithWhereUniqueWithoutNetworkInput | BareshMotaleatUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: BareshMotaleatCreateManyNetworkInputEnvelope
    set?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    disconnect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    delete?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    update?: BareshMotaleatUpdateWithWhereUniqueWithoutNetworkInput | BareshMotaleatUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: BareshMotaleatUpdateManyWithWhereWithoutNetworkInput | BareshMotaleatUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput> | KhatRaneshAreaCreateWithoutNetworkInput[] | KhatRaneshAreaUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: KhatRaneshAreaCreateOrConnectWithoutNetworkInput | KhatRaneshAreaCreateOrConnectWithoutNetworkInput[]
    upsert?: KhatRaneshAreaUpsertWithWhereUniqueWithoutNetworkInput | KhatRaneshAreaUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: KhatRaneshAreaCreateManyNetworkInputEnvelope
    set?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    disconnect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    delete?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    connect?: KhatRaneshAreaWhereUniqueInput | KhatRaneshAreaWhereUniqueInput[]
    update?: KhatRaneshAreaUpdateWithWhereUniqueWithoutNetworkInput | KhatRaneshAreaUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: KhatRaneshAreaUpdateManyWithWhereWithoutNetworkInput | KhatRaneshAreaUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
  }

  export type PumpStationUncheckedUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput> | PumpStationCreateWithoutNetworkInput[] | PumpStationUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: PumpStationCreateOrConnectWithoutNetworkInput | PumpStationCreateOrConnectWithoutNetworkInput[]
    upsert?: PumpStationUpsertWithWhereUniqueWithoutNetworkInput | PumpStationUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: PumpStationCreateManyNetworkInputEnvelope
    set?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    disconnect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    delete?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    connect?: PumpStationWhereUniqueInput | PumpStationWhereUniqueInput[]
    update?: PumpStationUpdateWithWhereUniqueWithoutNetworkInput | PumpStationUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: PumpStationUpdateManyWithWhereWithoutNetworkInput | PumpStationUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput> | ShabakeDoreKeshtCreateWithoutNetworkInput[] | ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput | ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutNetworkInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: ShabakeDoreKeshtCreateManyNetworkInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutNetworkInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutNetworkInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type NoeMahsoolCreateNestedManyWithoutNoeKeshtInput = {
    create?: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput> | NoeMahsoolCreateWithoutNoeKeshtInput[] | NoeMahsoolUncheckedCreateWithoutNoeKeshtInput[]
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutNoeKeshtInput | NoeMahsoolCreateOrConnectWithoutNoeKeshtInput[]
    createMany?: NoeMahsoolCreateManyNoeKeshtInputEnvelope
    connect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
  }

  export type NoeMahsoolUncheckedCreateNestedManyWithoutNoeKeshtInput = {
    create?: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput> | NoeMahsoolCreateWithoutNoeKeshtInput[] | NoeMahsoolUncheckedCreateWithoutNoeKeshtInput[]
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutNoeKeshtInput | NoeMahsoolCreateOrConnectWithoutNoeKeshtInput[]
    createMany?: NoeMahsoolCreateManyNoeKeshtInputEnvelope
    connect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
  }

  export type NoeMahsoolUpdateManyWithoutNoeKeshtNestedInput = {
    create?: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput> | NoeMahsoolCreateWithoutNoeKeshtInput[] | NoeMahsoolUncheckedCreateWithoutNoeKeshtInput[]
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutNoeKeshtInput | NoeMahsoolCreateOrConnectWithoutNoeKeshtInput[]
    upsert?: NoeMahsoolUpsertWithWhereUniqueWithoutNoeKeshtInput | NoeMahsoolUpsertWithWhereUniqueWithoutNoeKeshtInput[]
    createMany?: NoeMahsoolCreateManyNoeKeshtInputEnvelope
    set?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    disconnect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    delete?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    connect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    update?: NoeMahsoolUpdateWithWhereUniqueWithoutNoeKeshtInput | NoeMahsoolUpdateWithWhereUniqueWithoutNoeKeshtInput[]
    updateMany?: NoeMahsoolUpdateManyWithWhereWithoutNoeKeshtInput | NoeMahsoolUpdateManyWithWhereWithoutNoeKeshtInput[]
    deleteMany?: NoeMahsoolScalarWhereInput | NoeMahsoolScalarWhereInput[]
  }

  export type NoeMahsoolUncheckedUpdateManyWithoutNoeKeshtNestedInput = {
    create?: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput> | NoeMahsoolCreateWithoutNoeKeshtInput[] | NoeMahsoolUncheckedCreateWithoutNoeKeshtInput[]
    connectOrCreate?: NoeMahsoolCreateOrConnectWithoutNoeKeshtInput | NoeMahsoolCreateOrConnectWithoutNoeKeshtInput[]
    upsert?: NoeMahsoolUpsertWithWhereUniqueWithoutNoeKeshtInput | NoeMahsoolUpsertWithWhereUniqueWithoutNoeKeshtInput[]
    createMany?: NoeMahsoolCreateManyNoeKeshtInputEnvelope
    set?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    disconnect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    delete?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    connect?: NoeMahsoolWhereUniqueInput | NoeMahsoolWhereUniqueInput[]
    update?: NoeMahsoolUpdateWithWhereUniqueWithoutNoeKeshtInput | NoeMahsoolUpdateWithWhereUniqueWithoutNoeKeshtInput[]
    updateMany?: NoeMahsoolUpdateManyWithWhereWithoutNoeKeshtInput | NoeMahsoolUpdateManyWithWhereWithoutNoeKeshtInput[]
    deleteMany?: NoeMahsoolScalarWhereInput | NoeMahsoolScalarWhereInput[]
  }

  export type BahrebardariKeshtDoreCreateNestedManyWithoutNoeMahsoolInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput> | BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput | BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput[]
    createMany?: BahrebardariKeshtDoreCreateManyNoeMahsoolInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type NoeKeshtCreateNestedOneWithoutNoeMahsoolInput = {
    create?: XOR<NoeKeshtCreateWithoutNoeMahsoolInput, NoeKeshtUncheckedCreateWithoutNoeMahsoolInput>
    connectOrCreate?: NoeKeshtCreateOrConnectWithoutNoeMahsoolInput
    connect?: NoeKeshtWhereUniqueInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutNoeMahsoolInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput> | BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput | BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput[]
    createMany?: BahrebardariKeshtDoreCreateManyNoeMahsoolInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type BahrebardariKeshtDoreUpdateManyWithoutNoeMahsoolNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput> | BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput | BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutNoeMahsoolInput[]
    createMany?: BahrebardariKeshtDoreCreateManyNoeMahsoolInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutNoeMahsoolInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutNoeMahsoolInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type NoeKeshtUpdateOneRequiredWithoutNoeMahsoolNestedInput = {
    create?: XOR<NoeKeshtCreateWithoutNoeMahsoolInput, NoeKeshtUncheckedCreateWithoutNoeMahsoolInput>
    connectOrCreate?: NoeKeshtCreateOrConnectWithoutNoeMahsoolInput
    upsert?: NoeKeshtUpsertWithoutNoeMahsoolInput
    connect?: NoeKeshtWhereUniqueInput
    update?: XOR<XOR<NoeKeshtUpdateToOneWithWhereWithoutNoeMahsoolInput, NoeKeshtUpdateWithoutNoeMahsoolInput>, NoeKeshtUncheckedUpdateWithoutNoeMahsoolInput>
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutNoeMahsoolNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput> | BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput | BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutNoeMahsoolInput[]
    createMany?: BahrebardariKeshtDoreCreateManyNoeMahsoolInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutNoeMahsoolInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutNoeMahsoolInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutNoeMahsoolInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutNonFITInput = {
    create?: XOR<KhatRaneshCreateWithoutNonFITInput, KhatRaneshUncheckedCreateWithoutNonFITInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutNonFITInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutNonFITInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutNonFITInput, TrikhDoreKeshtUncheckedCreateWithoutNonFITInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutNonFITInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutNonFITNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutNonFITInput, KhatRaneshUncheckedCreateWithoutNonFITInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutNonFITInput
    upsert?: KhatRaneshUpsertWithoutNonFITInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutNonFITInput, KhatRaneshUpdateWithoutNonFITInput>, KhatRaneshUncheckedUpdateWithoutNonFITInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutNonFITNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutNonFITInput, TrikhDoreKeshtUncheckedCreateWithoutNonFITInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutNonFITInput
    upsert?: TrikhDoreKeshtUpsertWithoutNonFITInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutNonFITInput, TrikhDoreKeshtUpdateWithoutNonFITInput>, TrikhDoreKeshtUncheckedUpdateWithoutNonFITInput>
  }

  export type KhatRaneshCreateNestedManyWithoutPumpStationInput = {
    create?: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput> | KhatRaneshCreateWithoutPumpStationInput[] | KhatRaneshUncheckedCreateWithoutPumpStationInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutPumpStationInput | KhatRaneshCreateOrConnectWithoutPumpStationInput[]
    createMany?: KhatRaneshCreateManyPumpStationInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type AbadeMakhzanCreateNestedOneWithoutPumpStationInput = {
    create?: XOR<AbadeMakhzanCreateWithoutPumpStationInput, AbadeMakhzanUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: AbadeMakhzanCreateOrConnectWithoutPumpStationInput
    connect?: AbadeMakhzanWhereUniqueInput
  }

  export type DarjeStationCreateNestedOneWithoutPumpStationInput = {
    create?: XOR<DarjeStationCreateWithoutPumpStationInput, DarjeStationUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: DarjeStationCreateOrConnectWithoutPumpStationInput
    connect?: DarjeStationWhereUniqueInput
  }

  export type DeliveryPointsCreateNestedOneWithoutPumpStationsInput = {
    create?: XOR<DeliveryPointsCreateWithoutPumpStationsInput, DeliveryPointsUncheckedCreateWithoutPumpStationsInput>
    connectOrCreate?: DeliveryPointsCreateOrConnectWithoutPumpStationsInput
    connect?: DeliveryPointsWhereUniqueInput
  }

  export type NetworkCreateNestedOneWithoutPumpStationInput = {
    create?: XOR<NetworkCreateWithoutPumpStationInput, NetworkUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutPumpStationInput
    connect?: NetworkWhereUniqueInput
  }

  export type KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput = {
    create?: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput> | KhatRaneshCreateWithoutPumpStationInput[] | KhatRaneshUncheckedCreateWithoutPumpStationInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutPumpStationInput | KhatRaneshCreateOrConnectWithoutPumpStationInput[]
    createMany?: KhatRaneshCreateManyPumpStationInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUpdateManyWithoutPumpStationNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput> | KhatRaneshCreateWithoutPumpStationInput[] | KhatRaneshUncheckedCreateWithoutPumpStationInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutPumpStationInput | KhatRaneshCreateOrConnectWithoutPumpStationInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutPumpStationInput | KhatRaneshUpsertWithWhereUniqueWithoutPumpStationInput[]
    createMany?: KhatRaneshCreateManyPumpStationInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutPumpStationInput | KhatRaneshUpdateWithWhereUniqueWithoutPumpStationInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutPumpStationInput | KhatRaneshUpdateManyWithWhereWithoutPumpStationInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type AbadeMakhzanUpdateOneWithoutPumpStationNestedInput = {
    create?: XOR<AbadeMakhzanCreateWithoutPumpStationInput, AbadeMakhzanUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: AbadeMakhzanCreateOrConnectWithoutPumpStationInput
    upsert?: AbadeMakhzanUpsertWithoutPumpStationInput
    disconnect?: AbadeMakhzanWhereInput | boolean
    delete?: AbadeMakhzanWhereInput | boolean
    connect?: AbadeMakhzanWhereUniqueInput
    update?: XOR<XOR<AbadeMakhzanUpdateToOneWithWhereWithoutPumpStationInput, AbadeMakhzanUpdateWithoutPumpStationInput>, AbadeMakhzanUncheckedUpdateWithoutPumpStationInput>
  }

  export type DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput = {
    create?: XOR<DarjeStationCreateWithoutPumpStationInput, DarjeStationUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: DarjeStationCreateOrConnectWithoutPumpStationInput
    upsert?: DarjeStationUpsertWithoutPumpStationInput
    connect?: DarjeStationWhereUniqueInput
    update?: XOR<XOR<DarjeStationUpdateToOneWithWhereWithoutPumpStationInput, DarjeStationUpdateWithoutPumpStationInput>, DarjeStationUncheckedUpdateWithoutPumpStationInput>
  }

  export type DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput = {
    create?: XOR<DeliveryPointsCreateWithoutPumpStationsInput, DeliveryPointsUncheckedCreateWithoutPumpStationsInput>
    connectOrCreate?: DeliveryPointsCreateOrConnectWithoutPumpStationsInput
    upsert?: DeliveryPointsUpsertWithoutPumpStationsInput
    connect?: DeliveryPointsWhereUniqueInput
    update?: XOR<XOR<DeliveryPointsUpdateToOneWithWhereWithoutPumpStationsInput, DeliveryPointsUpdateWithoutPumpStationsInput>, DeliveryPointsUncheckedUpdateWithoutPumpStationsInput>
  }

  export type NetworkUpdateOneRequiredWithoutPumpStationNestedInput = {
    create?: XOR<NetworkCreateWithoutPumpStationInput, NetworkUncheckedCreateWithoutPumpStationInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutPumpStationInput
    upsert?: NetworkUpsertWithoutPumpStationInput
    connect?: NetworkWhereUniqueInput
    update?: XOR<XOR<NetworkUpdateToOneWithWhereWithoutPumpStationInput, NetworkUpdateWithoutPumpStationInput>, NetworkUncheckedUpdateWithoutPumpStationInput>
  }

  export type KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput> | KhatRaneshCreateWithoutPumpStationInput[] | KhatRaneshUncheckedCreateWithoutPumpStationInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutPumpStationInput | KhatRaneshCreateOrConnectWithoutPumpStationInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutPumpStationInput | KhatRaneshUpsertWithWhereUniqueWithoutPumpStationInput[]
    createMany?: KhatRaneshCreateManyPumpStationInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutPumpStationInput | KhatRaneshUpdateWithWhereUniqueWithoutPumpStationInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutPumpStationInput | KhatRaneshUpdateManyWithWhereWithoutPumpStationInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type KhatRaneshPumpCreateNestedManyWithoutPumpTypeInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput> | KhatRaneshPumpCreateWithoutPumpTypeInput[] | KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput | KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput[]
    createMany?: KhatRaneshPumpCreateManyPumpTypeInputEnvelope
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
  }

  export type KhatRaneshPumpUncheckedCreateNestedManyWithoutPumpTypeInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput> | KhatRaneshPumpCreateWithoutPumpTypeInput[] | KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput | KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput[]
    createMany?: KhatRaneshPumpCreateManyPumpTypeInputEnvelope
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
  }

  export type KhatRaneshPumpUpdateManyWithoutPumpTypeNestedInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput> | KhatRaneshPumpCreateWithoutPumpTypeInput[] | KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput | KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput[]
    upsert?: KhatRaneshPumpUpsertWithWhereUniqueWithoutPumpTypeInput | KhatRaneshPumpUpsertWithWhereUniqueWithoutPumpTypeInput[]
    createMany?: KhatRaneshPumpCreateManyPumpTypeInputEnvelope
    set?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    disconnect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    delete?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    update?: KhatRaneshPumpUpdateWithWhereUniqueWithoutPumpTypeInput | KhatRaneshPumpUpdateWithWhereUniqueWithoutPumpTypeInput[]
    updateMany?: KhatRaneshPumpUpdateManyWithWhereWithoutPumpTypeInput | KhatRaneshPumpUpdateManyWithWhereWithoutPumpTypeInput[]
    deleteMany?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
  }

  export type KhatRaneshPumpUncheckedUpdateManyWithoutPumpTypeNestedInput = {
    create?: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput> | KhatRaneshPumpCreateWithoutPumpTypeInput[] | KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput[]
    connectOrCreate?: KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput | KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput[]
    upsert?: KhatRaneshPumpUpsertWithWhereUniqueWithoutPumpTypeInput | KhatRaneshPumpUpsertWithWhereUniqueWithoutPumpTypeInput[]
    createMany?: KhatRaneshPumpCreateManyPumpTypeInputEnvelope
    set?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    disconnect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    delete?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    connect?: KhatRaneshPumpWhereUniqueInput | KhatRaneshPumpWhereUniqueInput[]
    update?: KhatRaneshPumpUpdateWithWhereUniqueWithoutPumpTypeInput | KhatRaneshPumpUpdateWithWhereUniqueWithoutPumpTypeInput[]
    updateMany?: KhatRaneshPumpUpdateManyWithWhereWithoutPumpTypeInput | KhatRaneshPumpUpdateManyWithWhereWithoutPumpTypeInput[]
    deleteMany?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
  }

  export type RainfallTypeCreateNestedOneWithoutRainfallStationInput = {
    create?: XOR<RainfallTypeCreateWithoutRainfallStationInput, RainfallTypeUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: RainfallTypeCreateOrConnectWithoutRainfallStationInput
    connect?: RainfallTypeWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutRainfallStationInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutRainfallStationInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type WeatherStationCreateNestedOneWithoutRainfallStationInput = {
    create?: XOR<WeatherStationCreateWithoutRainfallStationInput, WeatherStationUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: WeatherStationCreateOrConnectWithoutRainfallStationInput
    connect?: WeatherStationWhereUniqueInput
  }

  export type RainfallTypeUpdateOneRequiredWithoutRainfallStationNestedInput = {
    create?: XOR<RainfallTypeCreateWithoutRainfallStationInput, RainfallTypeUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: RainfallTypeCreateOrConnectWithoutRainfallStationInput
    upsert?: RainfallTypeUpsertWithoutRainfallStationInput
    connect?: RainfallTypeWhereUniqueInput
    update?: XOR<XOR<RainfallTypeUpdateToOneWithWhereWithoutRainfallStationInput, RainfallTypeUpdateWithoutRainfallStationInput>, RainfallTypeUncheckedUpdateWithoutRainfallStationInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutRainfallStationNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutRainfallStationInput
    upsert?: TrikhDoreKeshtUpsertWithoutRainfallStationInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutRainfallStationInput, TrikhDoreKeshtUpdateWithoutRainfallStationInput>, TrikhDoreKeshtUncheckedUpdateWithoutRainfallStationInput>
  }

  export type WeatherStationUpdateOneRequiredWithoutRainfallStationNestedInput = {
    create?: XOR<WeatherStationCreateWithoutRainfallStationInput, WeatherStationUncheckedCreateWithoutRainfallStationInput>
    connectOrCreate?: WeatherStationCreateOrConnectWithoutRainfallStationInput
    upsert?: WeatherStationUpsertWithoutRainfallStationInput
    connect?: WeatherStationWhereUniqueInput
    update?: XOR<XOR<WeatherStationUpdateToOneWithWhereWithoutRainfallStationInput, WeatherStationUpdateWithoutRainfallStationInput>, WeatherStationUncheckedUpdateWithoutRainfallStationInput>
  }

  export type RainfallStationCreateNestedManyWithoutRainfallTypeInput = {
    create?: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput> | RainfallStationCreateWithoutRainfallTypeInput[] | RainfallStationUncheckedCreateWithoutRainfallTypeInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutRainfallTypeInput | RainfallStationCreateOrConnectWithoutRainfallTypeInput[]
    createMany?: RainfallStationCreateManyRainfallTypeInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type RainfallStationUncheckedCreateNestedManyWithoutRainfallTypeInput = {
    create?: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput> | RainfallStationCreateWithoutRainfallTypeInput[] | RainfallStationUncheckedCreateWithoutRainfallTypeInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutRainfallTypeInput | RainfallStationCreateOrConnectWithoutRainfallTypeInput[]
    createMany?: RainfallStationCreateManyRainfallTypeInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type RainfallStationUpdateManyWithoutRainfallTypeNestedInput = {
    create?: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput> | RainfallStationCreateWithoutRainfallTypeInput[] | RainfallStationUncheckedCreateWithoutRainfallTypeInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutRainfallTypeInput | RainfallStationCreateOrConnectWithoutRainfallTypeInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutRainfallTypeInput | RainfallStationUpsertWithWhereUniqueWithoutRainfallTypeInput[]
    createMany?: RainfallStationCreateManyRainfallTypeInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutRainfallTypeInput | RainfallStationUpdateWithWhereUniqueWithoutRainfallTypeInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutRainfallTypeInput | RainfallStationUpdateManyWithWhereWithoutRainfallTypeInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type RainfallStationUncheckedUpdateManyWithoutRainfallTypeNestedInput = {
    create?: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput> | RainfallStationCreateWithoutRainfallTypeInput[] | RainfallStationUncheckedCreateWithoutRainfallTypeInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutRainfallTypeInput | RainfallStationCreateOrConnectWithoutRainfallTypeInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutRainfallTypeInput | RainfallStationUpsertWithWhereUniqueWithoutRainfallTypeInput[]
    createMany?: RainfallStationCreateManyRainfallTypeInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutRainfallTypeInput | RainfallStationUpdateWithWhereUniqueWithoutRainfallTypeInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutRainfallTypeInput | RainfallStationUpdateManyWithWhereWithoutRainfallTypeInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type ShabakeDoreKeshtCreateNestedManyWithoutSaleZeraeeInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | ShabakeDoreKeshtCreateWithoutSaleZeraeeInput[] | ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    createMany?: ShabakeDoreKeshtCreateManySaleZeraeeInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type TrikhDoreKeshtCreateNestedManyWithoutSaleZeraeeInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | TrikhDoreKeshtCreateWithoutSaleZeraeeInput[] | TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    createMany?: TrikhDoreKeshtCreateManySaleZeraeeInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | ShabakeDoreKeshtCreateWithoutSaleZeraeeInput[] | ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    createMany?: ShabakeDoreKeshtCreateManySaleZeraeeInputEnvelope
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
  }

  export type TrikhDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | TrikhDoreKeshtCreateWithoutSaleZeraeeInput[] | TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    createMany?: TrikhDoreKeshtCreateManySaleZeraeeInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type ShabakeDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | ShabakeDoreKeshtCreateWithoutSaleZeraeeInput[] | ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput[]
    createMany?: ShabakeDoreKeshtCreateManySaleZeraeeInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type TrikhDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | TrikhDoreKeshtCreateWithoutSaleZeraeeInput[] | TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput[]
    createMany?: TrikhDoreKeshtCreateManySaleZeraeeInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput | TrikhDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput = {
    create?: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | ShabakeDoreKeshtCreateWithoutSaleZeraeeInput[] | ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    upsert?: ShabakeDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput | ShabakeDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput[]
    createMany?: ShabakeDoreKeshtCreateManySaleZeraeeInputEnvelope
    set?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    disconnect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    delete?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    connect?: ShabakeDoreKeshtWhereUniqueInput | ShabakeDoreKeshtWhereUniqueInput[]
    update?: ShabakeDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput | ShabakeDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput[]
    updateMany?: ShabakeDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput | ShabakeDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput[]
    deleteMany?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput> | TrikhDoreKeshtCreateWithoutSaleZeraeeInput[] | TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput | TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput[]
    createMany?: TrikhDoreKeshtCreateManySaleZeraeeInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput | TrikhDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedManyWithoutSeghliPumpInput = {
    create?: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput> | KhatRaneshCreateWithoutSeghliPumpInput[] | KhatRaneshUncheckedCreateWithoutSeghliPumpInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutSeghliPumpInput | KhatRaneshCreateOrConnectWithoutSeghliPumpInput[]
    createMany?: KhatRaneshCreateManySeghliPumpInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUncheckedCreateNestedManyWithoutSeghliPumpInput = {
    create?: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput> | KhatRaneshCreateWithoutSeghliPumpInput[] | KhatRaneshUncheckedCreateWithoutSeghliPumpInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutSeghliPumpInput | KhatRaneshCreateOrConnectWithoutSeghliPumpInput[]
    createMany?: KhatRaneshCreateManySeghliPumpInputEnvelope
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
  }

  export type KhatRaneshUpdateManyWithoutSeghliPumpNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput> | KhatRaneshCreateWithoutSeghliPumpInput[] | KhatRaneshUncheckedCreateWithoutSeghliPumpInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutSeghliPumpInput | KhatRaneshCreateOrConnectWithoutSeghliPumpInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutSeghliPumpInput | KhatRaneshUpsertWithWhereUniqueWithoutSeghliPumpInput[]
    createMany?: KhatRaneshCreateManySeghliPumpInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutSeghliPumpInput | KhatRaneshUpdateWithWhereUniqueWithoutSeghliPumpInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutSeghliPumpInput | KhatRaneshUpdateManyWithWhereWithoutSeghliPumpInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type KhatRaneshUncheckedUpdateManyWithoutSeghliPumpNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput> | KhatRaneshCreateWithoutSeghliPumpInput[] | KhatRaneshUncheckedCreateWithoutSeghliPumpInput[]
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutSeghliPumpInput | KhatRaneshCreateOrConnectWithoutSeghliPumpInput[]
    upsert?: KhatRaneshUpsertWithWhereUniqueWithoutSeghliPumpInput | KhatRaneshUpsertWithWhereUniqueWithoutSeghliPumpInput[]
    createMany?: KhatRaneshCreateManySeghliPumpInputEnvelope
    set?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    disconnect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    delete?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    connect?: KhatRaneshWhereUniqueInput | KhatRaneshWhereUniqueInput[]
    update?: KhatRaneshUpdateWithWhereUniqueWithoutSeghliPumpInput | KhatRaneshUpdateWithWhereUniqueWithoutSeghliPumpInput[]
    updateMany?: KhatRaneshUpdateManyWithWhereWithoutSeghliPumpInput | KhatRaneshUpdateManyWithWhereWithoutSeghliPumpInput[]
    deleteMany?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
  }

  export type NetworkCreateNestedManyWithoutSystemPartInput = {
    create?: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput> | NetworkCreateWithoutSystemPartInput[] | NetworkUncheckedCreateWithoutSystemPartInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutSystemPartInput | NetworkCreateOrConnectWithoutSystemPartInput[]
    createMany?: NetworkCreateManySystemPartInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkUncheckedCreateNestedManyWithoutSystemPartInput = {
    create?: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput> | NetworkCreateWithoutSystemPartInput[] | NetworkUncheckedCreateWithoutSystemPartInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutSystemPartInput | NetworkCreateOrConnectWithoutSystemPartInput[]
    createMany?: NetworkCreateManySystemPartInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkUpdateManyWithoutSystemPartNestedInput = {
    create?: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput> | NetworkCreateWithoutSystemPartInput[] | NetworkUncheckedCreateWithoutSystemPartInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutSystemPartInput | NetworkCreateOrConnectWithoutSystemPartInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutSystemPartInput | NetworkUpsertWithWhereUniqueWithoutSystemPartInput[]
    createMany?: NetworkCreateManySystemPartInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutSystemPartInput | NetworkUpdateWithWhereUniqueWithoutSystemPartInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutSystemPartInput | NetworkUpdateManyWithWhereWithoutSystemPartInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type NetworkUncheckedUpdateManyWithoutSystemPartNestedInput = {
    create?: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput> | NetworkCreateWithoutSystemPartInput[] | NetworkUncheckedCreateWithoutSystemPartInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutSystemPartInput | NetworkCreateOrConnectWithoutSystemPartInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutSystemPartInput | NetworkUpsertWithWhereUniqueWithoutSystemPartInput[]
    createMany?: NetworkCreateManySystemPartInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutSystemPartInput | NetworkUpdateWithWhereUniqueWithoutSystemPartInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutSystemPartInput | NetworkUpdateManyWithWhereWithoutSystemPartInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type KhatRaneshCreateNestedOneWithoutTakhlieMakhzanInput = {
    create?: XOR<KhatRaneshCreateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedCreateWithoutTakhlieMakhzanInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutTakhlieMakhzanInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutTakhlieMakhzanInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedCreateWithoutTakhlieMakhzanInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutTakhlieMakhzanInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutTakhlieMakhzanNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedCreateWithoutTakhlieMakhzanInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutTakhlieMakhzanInput
    upsert?: KhatRaneshUpsertWithoutTakhlieMakhzanInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutTakhlieMakhzanInput, KhatRaneshUpdateWithoutTakhlieMakhzanInput>, KhatRaneshUncheckedUpdateWithoutTakhlieMakhzanInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutTakhlieMakhzanNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedCreateWithoutTakhlieMakhzanInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutTakhlieMakhzanInput
    upsert?: TrikhDoreKeshtUpsertWithoutTakhlieMakhzanInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutTakhlieMakhzanInput, TrikhDoreKeshtUpdateWithoutTakhlieMakhzanInput>, TrikhDoreKeshtUncheckedUpdateWithoutTakhlieMakhzanInput>
  }

  export type KhatRaneshCreateNestedOneWithoutTestInput = {
    create?: XOR<KhatRaneshCreateWithoutTestInput, KhatRaneshUncheckedCreateWithoutTestInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutTestInput
    connect?: KhatRaneshWhereUniqueInput
  }

  export type TrikhDoreKeshtCreateNestedOneWithoutTestInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutTestInput, TrikhDoreKeshtUncheckedCreateWithoutTestInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutTestInput
    connect?: TrikhDoreKeshtWhereUniqueInput
  }

  export type KhatRaneshUpdateOneRequiredWithoutTestNestedInput = {
    create?: XOR<KhatRaneshCreateWithoutTestInput, KhatRaneshUncheckedCreateWithoutTestInput>
    connectOrCreate?: KhatRaneshCreateOrConnectWithoutTestInput
    upsert?: KhatRaneshUpsertWithoutTestInput
    connect?: KhatRaneshWhereUniqueInput
    update?: XOR<XOR<KhatRaneshUpdateToOneWithWhereWithoutTestInput, KhatRaneshUpdateWithoutTestInput>, KhatRaneshUncheckedUpdateWithoutTestInput>
  }

  export type TrikhDoreKeshtUpdateOneRequiredWithoutTestNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutTestInput, TrikhDoreKeshtUncheckedCreateWithoutTestInput>
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutTestInput
    upsert?: TrikhDoreKeshtUpsertWithoutTestInput
    connect?: TrikhDoreKeshtWhereUniqueInput
    update?: XOR<XOR<TrikhDoreKeshtUpdateToOneWithWhereWithoutTestInput, TrikhDoreKeshtUpdateWithoutTestInput>, TrikhDoreKeshtUncheckedUpdateWithoutTestInput>
  }

  export type BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
  }

  export type BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
  }

  export type BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput[] | BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardariTaghvimCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
  }

  export type EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput> | EshtebahAvamelCreateWithoutTrikhDoreKeshtInput[] | EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput | EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: EshtebahAvamelCreateManyTrikhDoreKeshtInputEnvelope
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
  }

  export type FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowBehboodCreateWithoutTrikhDoreKeshtInput[] | FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput | FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: FlowBehboodCreateManyTrikhDoreKeshtInputEnvelope
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
  }

  export type FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowmeterCreateWithoutTrikhDoreKeshtInput[] | FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput | FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: FlowmeterCreateManyTrikhDoreKeshtInputEnvelope
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
  }

  export type KontorCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput> | KontorCreateWithoutTrikhDoreKeshtInput[] | KontorUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutTrikhDoreKeshtInput | KontorCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: KontorCreateManyTrikhDoreKeshtInputEnvelope
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
  }

  export type NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput> | NashtShabakeCreateWithoutTrikhDoreKeshtInput[] | NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput | NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: NashtShabakeCreateManyTrikhDoreKeshtInputEnvelope
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
  }

  export type NonFITCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput> | NonFITCreateWithoutTrikhDoreKeshtInput[] | NonFITUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutTrikhDoreKeshtInput | NonFITCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: NonFITCreateManyTrikhDoreKeshtInputEnvelope
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
  }

  export type RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput> | RainfallStationCreateWithoutTrikhDoreKeshtInput[] | RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput | RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: RainfallStationCreateManyTrikhDoreKeshtInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput> | TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput[] | TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput | TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: TakhlieMakhzanCreateManyTrikhDoreKeshtInputEnvelope
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
  }

  export type TestCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput> | TestCreateWithoutTrikhDoreKeshtInput[] | TestUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TestCreateOrConnectWithoutTrikhDoreKeshtInput | TestCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: TestCreateManyTrikhDoreKeshtInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput = {
    create?: XOR<DoreKeshtCreateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: DoreKeshtCreateOrConnectWithoutTrikhDoreKeshtInput
    connect?: DoreKeshtWhereUniqueInput
  }

  export type MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput = {
    create?: XOR<MahShamsiCreateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: MahShamsiCreateOrConnectWithoutTrikhDoreKeshtInput
    connect?: MahShamsiWhereUniqueInput
  }

  export type SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput = {
    create?: XOR<SaleZeraeeCreateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: SaleZeraeeCreateOrConnectWithoutTrikhDoreKeshtInput
    connect?: SaleZeraeeWhereUniqueInput
  }

  export type BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
  }

  export type BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
  }

  export type BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput[] | BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardariTaghvimCreateManyTrikhDoreKeshtInputEnvelope
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
  }

  export type EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput> | EshtebahAvamelCreateWithoutTrikhDoreKeshtInput[] | EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput | EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: EshtebahAvamelCreateManyTrikhDoreKeshtInputEnvelope
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
  }

  export type FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowBehboodCreateWithoutTrikhDoreKeshtInput[] | FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput | FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: FlowBehboodCreateManyTrikhDoreKeshtInputEnvelope
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
  }

  export type FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowmeterCreateWithoutTrikhDoreKeshtInput[] | FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput | FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: FlowmeterCreateManyTrikhDoreKeshtInputEnvelope
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
  }

  export type KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput> | KontorCreateWithoutTrikhDoreKeshtInput[] | KontorUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutTrikhDoreKeshtInput | KontorCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: KontorCreateManyTrikhDoreKeshtInputEnvelope
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
  }

  export type NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput> | NashtShabakeCreateWithoutTrikhDoreKeshtInput[] | NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput | NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: NashtShabakeCreateManyTrikhDoreKeshtInputEnvelope
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
  }

  export type NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput> | NonFITCreateWithoutTrikhDoreKeshtInput[] | NonFITUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutTrikhDoreKeshtInput | NonFITCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: NonFITCreateManyTrikhDoreKeshtInputEnvelope
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
  }

  export type RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput> | RainfallStationCreateWithoutTrikhDoreKeshtInput[] | RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput | RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: RainfallStationCreateManyTrikhDoreKeshtInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput> | TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput[] | TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput | TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: TakhlieMakhzanCreateManyTrikhDoreKeshtInputEnvelope
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
  }

  export type TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput = {
    create?: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput> | TestCreateWithoutTrikhDoreKeshtInput[] | TestUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TestCreateOrConnectWithoutTrikhDoreKeshtInput | TestCreateOrConnectWithoutTrikhDoreKeshtInput[]
    createMany?: TestCreateManyTrikhDoreKeshtInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardairProgramUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    disconnect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    delete?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    update?: BahrebardairProgramUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardairProgramUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardairProgramUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
  }

  export type BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    disconnect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    delete?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    update?: BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardairProgramSeghliUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
  }

  export type BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput[] | BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardariTaghvimUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardariTaghvimCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    disconnect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    delete?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    update?: BahrebardariTaghvimUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardariTaghvimUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
  }

  export type EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput> | EshtebahAvamelCreateWithoutTrikhDoreKeshtInput[] | EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput | EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: EshtebahAvamelUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | EshtebahAvamelUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: EshtebahAvamelCreateManyTrikhDoreKeshtInputEnvelope
    set?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    disconnect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    delete?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    update?: EshtebahAvamelUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | EshtebahAvamelUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: EshtebahAvamelUpdateManyWithWhereWithoutTrikhDoreKeshtInput | EshtebahAvamelUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
  }

  export type FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowBehboodCreateWithoutTrikhDoreKeshtInput[] | FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput | FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: FlowBehboodUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowBehboodUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: FlowBehboodCreateManyTrikhDoreKeshtInputEnvelope
    set?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    disconnect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    delete?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    update?: FlowBehboodUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowBehboodUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: FlowBehboodUpdateManyWithWhereWithoutTrikhDoreKeshtInput | FlowBehboodUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
  }

  export type FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowmeterCreateWithoutTrikhDoreKeshtInput[] | FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput | FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: FlowmeterUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowmeterUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: FlowmeterCreateManyTrikhDoreKeshtInputEnvelope
    set?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    disconnect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    delete?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    update?: FlowmeterUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowmeterUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: FlowmeterUpdateManyWithWhereWithoutTrikhDoreKeshtInput | FlowmeterUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
  }

  export type KontorUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput> | KontorCreateWithoutTrikhDoreKeshtInput[] | KontorUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutTrikhDoreKeshtInput | KontorCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: KontorUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | KontorUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: KontorCreateManyTrikhDoreKeshtInputEnvelope
    set?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    disconnect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    delete?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    update?: KontorUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | KontorUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: KontorUpdateManyWithWhereWithoutTrikhDoreKeshtInput | KontorUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: KontorScalarWhereInput | KontorScalarWhereInput[]
  }

  export type NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput> | NashtShabakeCreateWithoutTrikhDoreKeshtInput[] | NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput | NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: NashtShabakeUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | NashtShabakeUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: NashtShabakeCreateManyTrikhDoreKeshtInputEnvelope
    set?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    disconnect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    delete?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    update?: NashtShabakeUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | NashtShabakeUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: NashtShabakeUpdateManyWithWhereWithoutTrikhDoreKeshtInput | NashtShabakeUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
  }

  export type NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput> | NonFITCreateWithoutTrikhDoreKeshtInput[] | NonFITUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutTrikhDoreKeshtInput | NonFITCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: NonFITUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | NonFITUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: NonFITCreateManyTrikhDoreKeshtInputEnvelope
    set?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    disconnect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    delete?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    update?: NonFITUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | NonFITUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: NonFITUpdateManyWithWhereWithoutTrikhDoreKeshtInput | NonFITUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
  }

  export type RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput> | RainfallStationCreateWithoutTrikhDoreKeshtInput[] | RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput | RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | RainfallStationUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: RainfallStationCreateManyTrikhDoreKeshtInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | RainfallStationUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutTrikhDoreKeshtInput | RainfallStationUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput> | TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput[] | TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput | TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: TakhlieMakhzanUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: TakhlieMakhzanCreateManyTrikhDoreKeshtInputEnvelope
    set?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    disconnect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    delete?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    update?: TakhlieMakhzanUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: TakhlieMakhzanUpdateManyWithWhereWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
  }

  export type TestUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput> | TestCreateWithoutTrikhDoreKeshtInput[] | TestUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TestCreateOrConnectWithoutTrikhDoreKeshtInput | TestCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | TestUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: TestCreateManyTrikhDoreKeshtInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | TestUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: TestUpdateManyWithWhereWithoutTrikhDoreKeshtInput | TestUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<DoreKeshtCreateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: DoreKeshtCreateOrConnectWithoutTrikhDoreKeshtInput
    upsert?: DoreKeshtUpsertWithoutTrikhDoreKeshtInput
    connect?: DoreKeshtWhereUniqueInput
    update?: XOR<XOR<DoreKeshtUpdateToOneWithWhereWithoutTrikhDoreKeshtInput, DoreKeshtUpdateWithoutTrikhDoreKeshtInput>, DoreKeshtUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<MahShamsiCreateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: MahShamsiCreateOrConnectWithoutTrikhDoreKeshtInput
    upsert?: MahShamsiUpsertWithoutTrikhDoreKeshtInput
    connect?: MahShamsiWhereUniqueInput
    update?: XOR<XOR<MahShamsiUpdateToOneWithWhereWithoutTrikhDoreKeshtInput, MahShamsiUpdateWithoutTrikhDoreKeshtInput>, MahShamsiUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<SaleZeraeeCreateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutTrikhDoreKeshtInput>
    connectOrCreate?: SaleZeraeeCreateOrConnectWithoutTrikhDoreKeshtInput
    upsert?: SaleZeraeeUpsertWithoutTrikhDoreKeshtInput
    connect?: SaleZeraeeWhereUniqueInput
    update?: XOR<XOR<SaleZeraeeUpdateToOneWithWhereWithoutTrikhDoreKeshtInput, SaleZeraeeUpdateWithoutTrikhDoreKeshtInput>, SaleZeraeeUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardairProgramUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    disconnect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    delete?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    connect?: BahrebardairProgramWhereUniqueInput | BahrebardairProgramWhereUniqueInput[]
    update?: BahrebardairProgramUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardairProgramUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardairProgramUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
  }

  export type BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput[] | BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    disconnect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    delete?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    connect?: BahrebardairProgramSeghliWhereUniqueInput | BahrebardairProgramSeghliWhereUniqueInput[]
    update?: BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardairProgramSeghliUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardairProgramSeghliUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
  }

  export type BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput> | BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput[] | BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput | BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: BahrebardariTaghvimUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: BahrebardariTaghvimCreateManyTrikhDoreKeshtInputEnvelope
    set?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    disconnect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    delete?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    connect?: BahrebardariTaghvimWhereUniqueInput | BahrebardariTaghvimWhereUniqueInput[]
    update?: BahrebardariTaghvimUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: BahrebardariTaghvimUpdateManyWithWhereWithoutTrikhDoreKeshtInput | BahrebardariTaghvimUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
  }

  export type EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput> | EshtebahAvamelCreateWithoutTrikhDoreKeshtInput[] | EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput | EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: EshtebahAvamelUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | EshtebahAvamelUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: EshtebahAvamelCreateManyTrikhDoreKeshtInputEnvelope
    set?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    disconnect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    delete?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    connect?: EshtebahAvamelWhereUniqueInput | EshtebahAvamelWhereUniqueInput[]
    update?: EshtebahAvamelUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | EshtebahAvamelUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: EshtebahAvamelUpdateManyWithWhereWithoutTrikhDoreKeshtInput | EshtebahAvamelUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
  }

  export type FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowBehboodCreateWithoutTrikhDoreKeshtInput[] | FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput | FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: FlowBehboodUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowBehboodUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: FlowBehboodCreateManyTrikhDoreKeshtInputEnvelope
    set?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    disconnect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    delete?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    connect?: FlowBehboodWhereUniqueInput | FlowBehboodWhereUniqueInput[]
    update?: FlowBehboodUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowBehboodUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: FlowBehboodUpdateManyWithWhereWithoutTrikhDoreKeshtInput | FlowBehboodUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
  }

  export type FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput> | FlowmeterCreateWithoutTrikhDoreKeshtInput[] | FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput | FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: FlowmeterUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowmeterUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: FlowmeterCreateManyTrikhDoreKeshtInputEnvelope
    set?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    disconnect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    delete?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    connect?: FlowmeterWhereUniqueInput | FlowmeterWhereUniqueInput[]
    update?: FlowmeterUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | FlowmeterUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: FlowmeterUpdateManyWithWhereWithoutTrikhDoreKeshtInput | FlowmeterUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
  }

  export type KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput> | KontorCreateWithoutTrikhDoreKeshtInput[] | KontorUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: KontorCreateOrConnectWithoutTrikhDoreKeshtInput | KontorCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: KontorUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | KontorUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: KontorCreateManyTrikhDoreKeshtInputEnvelope
    set?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    disconnect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    delete?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    connect?: KontorWhereUniqueInput | KontorWhereUniqueInput[]
    update?: KontorUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | KontorUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: KontorUpdateManyWithWhereWithoutTrikhDoreKeshtInput | KontorUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: KontorScalarWhereInput | KontorScalarWhereInput[]
  }

  export type NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput> | NashtShabakeCreateWithoutTrikhDoreKeshtInput[] | NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput | NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: NashtShabakeUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | NashtShabakeUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: NashtShabakeCreateManyTrikhDoreKeshtInputEnvelope
    set?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    disconnect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    delete?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    connect?: NashtShabakeWhereUniqueInput | NashtShabakeWhereUniqueInput[]
    update?: NashtShabakeUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | NashtShabakeUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: NashtShabakeUpdateManyWithWhereWithoutTrikhDoreKeshtInput | NashtShabakeUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
  }

  export type NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput> | NonFITCreateWithoutTrikhDoreKeshtInput[] | NonFITUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: NonFITCreateOrConnectWithoutTrikhDoreKeshtInput | NonFITCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: NonFITUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | NonFITUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: NonFITCreateManyTrikhDoreKeshtInputEnvelope
    set?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    disconnect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    delete?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    connect?: NonFITWhereUniqueInput | NonFITWhereUniqueInput[]
    update?: NonFITUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | NonFITUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: NonFITUpdateManyWithWhereWithoutTrikhDoreKeshtInput | NonFITUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
  }

  export type RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput> | RainfallStationCreateWithoutTrikhDoreKeshtInput[] | RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput | RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | RainfallStationUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: RainfallStationCreateManyTrikhDoreKeshtInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | RainfallStationUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutTrikhDoreKeshtInput | RainfallStationUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput> | TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput[] | TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput | TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: TakhlieMakhzanUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: TakhlieMakhzanCreateManyTrikhDoreKeshtInputEnvelope
    set?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    disconnect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    delete?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    connect?: TakhlieMakhzanWhereUniqueInput | TakhlieMakhzanWhereUniqueInput[]
    update?: TakhlieMakhzanUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: TakhlieMakhzanUpdateManyWithWhereWithoutTrikhDoreKeshtInput | TakhlieMakhzanUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
  }

  export type TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput = {
    create?: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput> | TestCreateWithoutTrikhDoreKeshtInput[] | TestUncheckedCreateWithoutTrikhDoreKeshtInput[]
    connectOrCreate?: TestCreateOrConnectWithoutTrikhDoreKeshtInput | TestCreateOrConnectWithoutTrikhDoreKeshtInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput | TestUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    createMany?: TestCreateManyTrikhDoreKeshtInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput | TestUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput[]
    updateMany?: TestUpdateManyWithWhereWithoutTrikhDoreKeshtInput | TestUpdateManyWithWhereWithoutTrikhDoreKeshtInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type RainfallStationCreateNestedManyWithoutWeatherStationInput = {
    create?: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput> | RainfallStationCreateWithoutWeatherStationInput[] | RainfallStationUncheckedCreateWithoutWeatherStationInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutWeatherStationInput | RainfallStationCreateOrConnectWithoutWeatherStationInput[]
    createMany?: RainfallStationCreateManyWeatherStationInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type RainfallStationUncheckedCreateNestedManyWithoutWeatherStationInput = {
    create?: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput> | RainfallStationCreateWithoutWeatherStationInput[] | RainfallStationUncheckedCreateWithoutWeatherStationInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutWeatherStationInput | RainfallStationCreateOrConnectWithoutWeatherStationInput[]
    createMany?: RainfallStationCreateManyWeatherStationInputEnvelope
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
  }

  export type RainfallStationUpdateManyWithoutWeatherStationNestedInput = {
    create?: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput> | RainfallStationCreateWithoutWeatherStationInput[] | RainfallStationUncheckedCreateWithoutWeatherStationInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutWeatherStationInput | RainfallStationCreateOrConnectWithoutWeatherStationInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutWeatherStationInput | RainfallStationUpsertWithWhereUniqueWithoutWeatherStationInput[]
    createMany?: RainfallStationCreateManyWeatherStationInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutWeatherStationInput | RainfallStationUpdateWithWhereUniqueWithoutWeatherStationInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutWeatherStationInput | RainfallStationUpdateManyWithWhereWithoutWeatherStationInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type RainfallStationUncheckedUpdateManyWithoutWeatherStationNestedInput = {
    create?: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput> | RainfallStationCreateWithoutWeatherStationInput[] | RainfallStationUncheckedCreateWithoutWeatherStationInput[]
    connectOrCreate?: RainfallStationCreateOrConnectWithoutWeatherStationInput | RainfallStationCreateOrConnectWithoutWeatherStationInput[]
    upsert?: RainfallStationUpsertWithWhereUniqueWithoutWeatherStationInput | RainfallStationUpsertWithWhereUniqueWithoutWeatherStationInput[]
    createMany?: RainfallStationCreateManyWeatherStationInputEnvelope
    set?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    disconnect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    delete?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    connect?: RainfallStationWhereUniqueInput | RainfallStationWhereUniqueInput[]
    update?: RainfallStationUpdateWithWhereUniqueWithoutWeatherStationInput | RainfallStationUpdateWithWhereUniqueWithoutWeatherStationInput[]
    updateMany?: RainfallStationUpdateManyWithWhereWithoutWeatherStationInput | RainfallStationUpdateManyWithWhereWithoutWeatherStationInput[]
    deleteMany?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type BareshMotaleatCreateNestedManyWithoutMahInput = {
    create?: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput> | BareshMotaleatCreateWithoutMahInput[] | BareshMotaleatUncheckedCreateWithoutMahInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutMahInput | BareshMotaleatCreateOrConnectWithoutMahInput[]
    createMany?: BareshMotaleatCreateManyMahInputEnvelope
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
  }

  export type TrikhDoreKeshtCreateNestedManyWithoutMahShamsiInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput> | TrikhDoreKeshtCreateWithoutMahShamsiInput[] | TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput | TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput[]
    createMany?: TrikhDoreKeshtCreateManyMahShamsiInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type BareshMotaleatUncheckedCreateNestedManyWithoutMahInput = {
    create?: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput> | BareshMotaleatCreateWithoutMahInput[] | BareshMotaleatUncheckedCreateWithoutMahInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutMahInput | BareshMotaleatCreateOrConnectWithoutMahInput[]
    createMany?: BareshMotaleatCreateManyMahInputEnvelope
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
  }

  export type TrikhDoreKeshtUncheckedCreateNestedManyWithoutMahShamsiInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput> | TrikhDoreKeshtCreateWithoutMahShamsiInput[] | TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput | TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput[]
    createMany?: TrikhDoreKeshtCreateManyMahShamsiInputEnvelope
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
  }

  export type BareshMotaleatUpdateManyWithoutMahNestedInput = {
    create?: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput> | BareshMotaleatCreateWithoutMahInput[] | BareshMotaleatUncheckedCreateWithoutMahInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutMahInput | BareshMotaleatCreateOrConnectWithoutMahInput[]
    upsert?: BareshMotaleatUpsertWithWhereUniqueWithoutMahInput | BareshMotaleatUpsertWithWhereUniqueWithoutMahInput[]
    createMany?: BareshMotaleatCreateManyMahInputEnvelope
    set?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    disconnect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    delete?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    update?: BareshMotaleatUpdateWithWhereUniqueWithoutMahInput | BareshMotaleatUpdateWithWhereUniqueWithoutMahInput[]
    updateMany?: BareshMotaleatUpdateManyWithWhereWithoutMahInput | BareshMotaleatUpdateManyWithWhereWithoutMahInput[]
    deleteMany?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
  }

  export type TrikhDoreKeshtUpdateManyWithoutMahShamsiNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput> | TrikhDoreKeshtCreateWithoutMahShamsiInput[] | TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput | TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutMahShamsiInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutMahShamsiInput[]
    createMany?: TrikhDoreKeshtCreateManyMahShamsiInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutMahShamsiInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutMahShamsiInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutMahShamsiInput | TrikhDoreKeshtUpdateManyWithWhereWithoutMahShamsiInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type BareshMotaleatUncheckedUpdateManyWithoutMahNestedInput = {
    create?: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput> | BareshMotaleatCreateWithoutMahInput[] | BareshMotaleatUncheckedCreateWithoutMahInput[]
    connectOrCreate?: BareshMotaleatCreateOrConnectWithoutMahInput | BareshMotaleatCreateOrConnectWithoutMahInput[]
    upsert?: BareshMotaleatUpsertWithWhereUniqueWithoutMahInput | BareshMotaleatUpsertWithWhereUniqueWithoutMahInput[]
    createMany?: BareshMotaleatCreateManyMahInputEnvelope
    set?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    disconnect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    delete?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    connect?: BareshMotaleatWhereUniqueInput | BareshMotaleatWhereUniqueInput[]
    update?: BareshMotaleatUpdateWithWhereUniqueWithoutMahInput | BareshMotaleatUpdateWithWhereUniqueWithoutMahInput[]
    updateMany?: BareshMotaleatUpdateManyWithWhereWithoutMahInput | BareshMotaleatUpdateManyWithWhereWithoutMahInput[]
    deleteMany?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutMahShamsiNestedInput = {
    create?: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput> | TrikhDoreKeshtCreateWithoutMahShamsiInput[] | TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput[]
    connectOrCreate?: TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput | TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput[]
    upsert?: TrikhDoreKeshtUpsertWithWhereUniqueWithoutMahShamsiInput | TrikhDoreKeshtUpsertWithWhereUniqueWithoutMahShamsiInput[]
    createMany?: TrikhDoreKeshtCreateManyMahShamsiInputEnvelope
    set?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    disconnect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    delete?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    connect?: TrikhDoreKeshtWhereUniqueInput | TrikhDoreKeshtWhereUniqueInput[]
    update?: TrikhDoreKeshtUpdateWithWhereUniqueWithoutMahShamsiInput | TrikhDoreKeshtUpdateWithWhereUniqueWithoutMahShamsiInput[]
    updateMany?: TrikhDoreKeshtUpdateManyWithWhereWithoutMahShamsiInput | TrikhDoreKeshtUpdateManyWithWhereWithoutMahShamsiInput[]
    deleteMany?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
  }

  export type BahrebardariKeshtDoreCreateNestedManyWithoutShabakeDoreKeshtInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput> | BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput[]
    createMany?: BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type DoreKeshtCreateNestedOneWithoutShabakeDoreKeshtInput = {
    create?: XOR<DoreKeshtCreateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: DoreKeshtCreateOrConnectWithoutShabakeDoreKeshtInput
    connect?: DoreKeshtWhereUniqueInput
  }

  export type NetworkCreateNestedOneWithoutShabakeDoreKeshtInput = {
    create?: XOR<NetworkCreateWithoutShabakeDoreKeshtInput, NetworkUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutShabakeDoreKeshtInput
    connect?: NetworkWhereUniqueInput
  }

  export type SaleZeraeeCreateNestedOneWithoutShabakeDoreKeshtInput = {
    create?: XOR<SaleZeraeeCreateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: SaleZeraeeCreateOrConnectWithoutShabakeDoreKeshtInput
    connect?: SaleZeraeeWhereUniqueInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutShabakeDoreKeshtInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput> | BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput[]
    createMany?: BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInputEnvelope
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
  }

  export type BahrebardariKeshtDoreUpdateManyWithoutShabakeDoreKeshtNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput> | BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutShabakeDoreKeshtInput[]
    createMany?: BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutShabakeDoreKeshtInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutShabakeDoreKeshtInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type DoreKeshtUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput = {
    create?: XOR<DoreKeshtCreateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: DoreKeshtCreateOrConnectWithoutShabakeDoreKeshtInput
    upsert?: DoreKeshtUpsertWithoutShabakeDoreKeshtInput
    connect?: DoreKeshtWhereUniqueInput
    update?: XOR<XOR<DoreKeshtUpdateToOneWithWhereWithoutShabakeDoreKeshtInput, DoreKeshtUpdateWithoutShabakeDoreKeshtInput>, DoreKeshtUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type NetworkUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput = {
    create?: XOR<NetworkCreateWithoutShabakeDoreKeshtInput, NetworkUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: NetworkCreateOrConnectWithoutShabakeDoreKeshtInput
    upsert?: NetworkUpsertWithoutShabakeDoreKeshtInput
    connect?: NetworkWhereUniqueInput
    update?: XOR<XOR<NetworkUpdateToOneWithWhereWithoutShabakeDoreKeshtInput, NetworkUpdateWithoutShabakeDoreKeshtInput>, NetworkUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type SaleZeraeeUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput = {
    create?: XOR<SaleZeraeeCreateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutShabakeDoreKeshtInput>
    connectOrCreate?: SaleZeraeeCreateOrConnectWithoutShabakeDoreKeshtInput
    upsert?: SaleZeraeeUpsertWithoutShabakeDoreKeshtInput
    connect?: SaleZeraeeWhereUniqueInput
    update?: XOR<XOR<SaleZeraeeUpdateToOneWithWhereWithoutShabakeDoreKeshtInput, SaleZeraeeUpdateWithoutShabakeDoreKeshtInput>, SaleZeraeeUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtNestedInput = {
    create?: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput> | BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput[] | BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput[]
    connectOrCreate?: BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput[]
    upsert?: BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutShabakeDoreKeshtInput[]
    createMany?: BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInputEnvelope
    set?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    disconnect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    delete?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    connect?: BahrebardariKeshtDoreWhereUniqueInput | BahrebardariKeshtDoreWhereUniqueInput[]
    update?: BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutShabakeDoreKeshtInput[]
    updateMany?: BahrebardariKeshtDoreUpdateManyWithWhereWithoutShabakeDoreKeshtInput | BahrebardariKeshtDoreUpdateManyWithWhereWithoutShabakeDoreKeshtInput[]
    deleteMany?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PumpStationCreateWithoutAbadeMakhzanInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutPumpStationInput
    DarjeStation: DarjeStationCreateNestedOneWithoutPumpStationInput
    DeliveryPoint: DeliveryPointsCreateNestedOneWithoutPumpStationsInput
    Network: NetworkCreateNestedOneWithoutPumpStationInput
  }

  export type PumpStationUncheckedCreateWithoutAbadeMakhzanInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdDP: number
    Ready?: boolean
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput
  }

  export type PumpStationCreateOrConnectWithoutAbadeMakhzanInput = {
    where: PumpStationWhereUniqueInput
    create: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput>
  }

  export type PumpStationCreateManyAbadeMakhzanInputEnvelope = {
    data: PumpStationCreateManyAbadeMakhzanInput | PumpStationCreateManyAbadeMakhzanInput[]
  }

  export type PumpStationUpsertWithWhereUniqueWithoutAbadeMakhzanInput = {
    where: PumpStationWhereUniqueInput
    update: XOR<PumpStationUpdateWithoutAbadeMakhzanInput, PumpStationUncheckedUpdateWithoutAbadeMakhzanInput>
    create: XOR<PumpStationCreateWithoutAbadeMakhzanInput, PumpStationUncheckedCreateWithoutAbadeMakhzanInput>
  }

  export type PumpStationUpdateWithWhereUniqueWithoutAbadeMakhzanInput = {
    where: PumpStationWhereUniqueInput
    data: XOR<PumpStationUpdateWithoutAbadeMakhzanInput, PumpStationUncheckedUpdateWithoutAbadeMakhzanInput>
  }

  export type PumpStationUpdateManyWithWhereWithoutAbadeMakhzanInput = {
    where: PumpStationScalarWhereInput
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyWithoutAbadeMakhzanInput>
  }

  export type PumpStationScalarWhereInput = {
    AND?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
    OR?: PumpStationScalarWhereInput[]
    NOT?: PumpStationScalarWhereInput | PumpStationScalarWhereInput[]
    IdPumpSta?: IntFilter<"PumpStation"> | number
    NameStation?: StringFilter<"PumpStation"> | string
    KM?: IntNullableFilter<"PumpStation"> | number | null
    FIdNet?: IntFilter<"PumpStation"> | number
    FIdDStation?: IntFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableFilter<"PumpStation"> | number | null
    FIdDP?: IntFilter<"PumpStation"> | number
    Ready?: BoolFilter<"PumpStation"> | boolean
  }

  export type KhatRaneshCreateWithoutAbgirInput = {
    RaneshName: string
    Active?: boolean
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutAbgirInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutAbgirInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutAbgirInput, KhatRaneshUncheckedCreateWithoutAbgirInput>
  }

  export type KontorCreateWithoutAbgirInput = {
    Kontor: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutKontorInput
  }

  export type KontorUncheckedCreateWithoutAbgirInput = {
    IdKon?: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorCreateOrConnectWithoutAbgirInput = {
    where: KontorWhereUniqueInput
    create: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput>
  }

  export type KontorCreateManyAbgirInputEnvelope = {
    data: KontorCreateManyAbgirInput | KontorCreateManyAbgirInput[]
  }

  export type KhatRaneshUpsertWithoutAbgirInput = {
    update: XOR<KhatRaneshUpdateWithoutAbgirInput, KhatRaneshUncheckedUpdateWithoutAbgirInput>
    create: XOR<KhatRaneshCreateWithoutAbgirInput, KhatRaneshUncheckedCreateWithoutAbgirInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutAbgirInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutAbgirInput, KhatRaneshUncheckedUpdateWithoutAbgirInput>
  }

  export type KhatRaneshUpdateWithoutAbgirInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutAbgirInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KontorUpsertWithWhereUniqueWithoutAbgirInput = {
    where: KontorWhereUniqueInput
    update: XOR<KontorUpdateWithoutAbgirInput, KontorUncheckedUpdateWithoutAbgirInput>
    create: XOR<KontorCreateWithoutAbgirInput, KontorUncheckedCreateWithoutAbgirInput>
  }

  export type KontorUpdateWithWhereUniqueWithoutAbgirInput = {
    where: KontorWhereUniqueInput
    data: XOR<KontorUpdateWithoutAbgirInput, KontorUncheckedUpdateWithoutAbgirInput>
  }

  export type KontorUpdateManyWithWhereWithoutAbgirInput = {
    where: KontorScalarWhereInput
    data: XOR<KontorUpdateManyMutationInput, KontorUncheckedUpdateManyWithoutAbgirInput>
  }

  export type KontorScalarWhereInput = {
    AND?: KontorScalarWhereInput | KontorScalarWhereInput[]
    OR?: KontorScalarWhereInput[]
    NOT?: KontorScalarWhereInput | KontorScalarWhereInput[]
    IdKon?: IntFilter<"Kontor"> | number
    FIdKontor?: IntFilter<"Kontor"> | number
    FIdTarDor?: IntFilter<"Kontor"> | number
    Kontor?: IntFilter<"Kontor"> | number
  }

  export type KhatRaneshCreateWithoutBahrebardairProgramInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutBahrebardairProgramInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutBahrebardairProgramInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutBahrebardairProgramInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramInput>
  }

  export type TrikhDoreKeshtCreateWithoutBahrebardairProgramInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramInput>
  }

  export type KhatRaneshUpsertWithoutBahrebardairProgramInput = {
    update: XOR<KhatRaneshUpdateWithoutBahrebardairProgramInput, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramInput>
    create: XOR<KhatRaneshCreateWithoutBahrebardairProgramInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutBahrebardairProgramInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutBahrebardairProgramInput, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramInput>
  }

  export type KhatRaneshUpdateWithoutBahrebardairProgramInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutBahrebardairProgramInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutBahrebardairProgramInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramInput>
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardairProgramInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutBahrebardairProgramInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramInput>
  }

  export type TrikhDoreKeshtUpdateWithoutBahrebardairProgramInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutBahrebardairProgramSeghliInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutBahrebardairProgramSeghliInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutBahrebardairProgramSeghliInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramSeghliInput>
  }

  export type TrikhDoreKeshtCreateWithoutBahrebardairProgramSeghliInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramSeghliInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutBahrebardairProgramSeghliInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramSeghliInput>
  }

  export type KhatRaneshUpsertWithoutBahrebardairProgramSeghliInput = {
    update: XOR<KhatRaneshUpdateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
    create: XOR<KhatRaneshCreateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutBahrebardairProgramSeghliInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutBahrebardairProgramSeghliInput, KhatRaneshUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
  }

  export type KhatRaneshUpdateWithoutBahrebardairProgramSeghliInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutBahrebardairProgramSeghliInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutBahrebardairProgramSeghliInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardairProgramSeghliInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardairProgramSeghliInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutBahrebardairProgramSeghliInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramSeghliInput>
  }

  export type TrikhDoreKeshtUpdateWithoutBahrebardairProgramSeghliInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutBahrebardairProgramSeghliInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutBahrebardariKeshtDoreInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutBahrebardariKeshtDoreInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutBahrebardariKeshtDoreInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedCreateWithoutBahrebardariKeshtDoreInput>
  }

  export type NoeMahsoolCreateWithoutBahrebardariKeshtDoreInput = {
    Mahsool: string
    NoeKesht: NoeKeshtCreateNestedOneWithoutNoeMahsoolInput
  }

  export type NoeMahsoolUncheckedCreateWithoutBahrebardariKeshtDoreInput = {
    IdNoeM?: number
    Mahsool: string
    FIdNoeK: number
  }

  export type NoeMahsoolCreateOrConnectWithoutBahrebardariKeshtDoreInput = {
    where: NoeMahsoolWhereUniqueInput
    create: XOR<NoeMahsoolCreateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedCreateWithoutBahrebardariKeshtDoreInput>
  }

  export type ShabakeDoreKeshtCreateWithoutBahrebardariKeshtDoreInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    DoreKesht: DoreKeshtCreateNestedOneWithoutShabakeDoreKeshtInput
    Network: NetworkCreateNestedOneWithoutShabakeDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUncheckedCreateWithoutBahrebardariKeshtDoreInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    FIdDore: number
  }

  export type ShabakeDoreKeshtCreateOrConnectWithoutBahrebardariKeshtDoreInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    create: XOR<ShabakeDoreKeshtCreateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedCreateWithoutBahrebardariKeshtDoreInput>
  }

  export type KhatRaneshUpsertWithoutBahrebardariKeshtDoreInput = {
    update: XOR<KhatRaneshUpdateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
    create: XOR<KhatRaneshCreateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutBahrebardariKeshtDoreInput, KhatRaneshUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type KhatRaneshUpdateWithoutBahrebardariKeshtDoreInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutBahrebardariKeshtDoreInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type NoeMahsoolUpsertWithoutBahrebardariKeshtDoreInput = {
    update: XOR<NoeMahsoolUpdateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
    create: XOR<NoeMahsoolCreateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    where?: NoeMahsoolWhereInput
  }

  export type NoeMahsoolUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput = {
    where?: NoeMahsoolWhereInput
    data: XOR<NoeMahsoolUpdateWithoutBahrebardariKeshtDoreInput, NoeMahsoolUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type NoeMahsoolUpdateWithoutBahrebardariKeshtDoreInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
    NoeKesht?: NoeKeshtUpdateOneRequiredWithoutNoeMahsoolNestedInput
  }

  export type NoeMahsoolUncheckedUpdateWithoutBahrebardariKeshtDoreInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type ShabakeDoreKeshtUpsertWithoutBahrebardariKeshtDoreInput = {
    update: XOR<ShabakeDoreKeshtUpdateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
    create: XOR<ShabakeDoreKeshtCreateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedCreateWithoutBahrebardariKeshtDoreInput>
    where?: ShabakeDoreKeshtWhereInput
  }

  export type ShabakeDoreKeshtUpdateToOneWithWhereWithoutBahrebardariKeshtDoreInput = {
    where?: ShabakeDoreKeshtWhereInput
    data: XOR<ShabakeDoreKeshtUpdateWithoutBahrebardariKeshtDoreInput, ShabakeDoreKeshtUncheckedUpdateWithoutBahrebardariKeshtDoreInput>
  }

  export type ShabakeDoreKeshtUpdateWithoutBahrebardariKeshtDoreInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    Network?: NetworkUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateWithoutBahrebardariKeshtDoreInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateWithoutBahrebardariTaghvimInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutBahrebardariTaghvimInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutBahrebardariTaghvimInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedCreateWithoutBahrebardariTaghvimInput>
  }

  export type TrikhDoreKeshtCreateWithoutBahrebardariTaghvimInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutBahrebardariTaghvimInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutBahrebardariTaghvimInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardariTaghvimInput>
  }

  export type KhatRaneshUpsertWithoutBahrebardariTaghvimInput = {
    update: XOR<KhatRaneshUpdateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedUpdateWithoutBahrebardariTaghvimInput>
    create: XOR<KhatRaneshCreateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedCreateWithoutBahrebardariTaghvimInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutBahrebardariTaghvimInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutBahrebardariTaghvimInput, KhatRaneshUncheckedUpdateWithoutBahrebardariTaghvimInput>
  }

  export type KhatRaneshUpdateWithoutBahrebardariTaghvimInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutBahrebardariTaghvimInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutBahrebardariTaghvimInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardariTaghvimInput>
    create: XOR<TrikhDoreKeshtCreateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedCreateWithoutBahrebardariTaghvimInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutBahrebardariTaghvimInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutBahrebardariTaghvimInput, TrikhDoreKeshtUncheckedUpdateWithoutBahrebardariTaghvimInput>
  }

  export type TrikhDoreKeshtUpdateWithoutBahrebardariTaghvimInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutBahrebardariTaghvimInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type MahShamsiCreateWithoutBareshMotaleatInput = {
    IdMah: number
    Mah: string
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutMahShamsiInput
  }

  export type MahShamsiUncheckedCreateWithoutBareshMotaleatInput = {
    IdMah: number
    Mah: string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutMahShamsiInput
  }

  export type MahShamsiCreateOrConnectWithoutBareshMotaleatInput = {
    where: MahShamsiWhereUniqueInput
    create: XOR<MahShamsiCreateWithoutBareshMotaleatInput, MahShamsiUncheckedCreateWithoutBareshMotaleatInput>
  }

  export type NetworkCreateWithoutBareshMotaleatInput = {
    Network: string
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutNetworkInput
    SystemPart: SystemPartCreateNestedOneWithoutNetworkInput
    PumpStation?: PumpStationCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateWithoutBareshMotaleatInput = {
    IdNet?: number
    Network: string
    FIdSP: number
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkCreateOrConnectWithoutBareshMotaleatInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutBareshMotaleatInput, NetworkUncheckedCreateWithoutBareshMotaleatInput>
  }

  export type MahShamsiUpsertWithoutBareshMotaleatInput = {
    update: XOR<MahShamsiUpdateWithoutBareshMotaleatInput, MahShamsiUncheckedUpdateWithoutBareshMotaleatInput>
    create: XOR<MahShamsiCreateWithoutBareshMotaleatInput, MahShamsiUncheckedCreateWithoutBareshMotaleatInput>
    where?: MahShamsiWhereInput
  }

  export type MahShamsiUpdateToOneWithWhereWithoutBareshMotaleatInput = {
    where?: MahShamsiWhereInput
    data: XOR<MahShamsiUpdateWithoutBareshMotaleatInput, MahShamsiUncheckedUpdateWithoutBareshMotaleatInput>
  }

  export type MahShamsiUpdateWithoutBareshMotaleatInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutMahShamsiNestedInput
  }

  export type MahShamsiUncheckedUpdateWithoutBareshMotaleatInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutMahShamsiNestedInput
  }

  export type NetworkUpsertWithoutBareshMotaleatInput = {
    update: XOR<NetworkUpdateWithoutBareshMotaleatInput, NetworkUncheckedUpdateWithoutBareshMotaleatInput>
    create: XOR<NetworkCreateWithoutBareshMotaleatInput, NetworkUncheckedCreateWithoutBareshMotaleatInput>
    where?: NetworkWhereInput
  }

  export type NetworkUpdateToOneWithWhereWithoutBareshMotaleatInput = {
    where?: NetworkWhereInput
    data: XOR<NetworkUpdateWithoutBareshMotaleatInput, NetworkUncheckedUpdateWithoutBareshMotaleatInput>
  }

  export type NetworkUpdateWithoutBareshMotaleatInput = {
    Network?: StringFieldUpdateOperationsInput | string
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutNetworkNestedInput
    SystemPart?: SystemPartUpdateOneRequiredWithoutNetworkNestedInput
    PumpStation?: PumpStationUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateWithoutBareshMotaleatInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUncheckedUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type KhatRaneshCreateWithoutDarajePipeInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutDarajePipeInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutDarajePipeInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput>
  }

  export type KhatRaneshCreateManyDarajePipeInputEnvelope = {
    data: KhatRaneshCreateManyDarajePipeInput | KhatRaneshCreateManyDarajePipeInput[]
  }

  export type KhatRaneshUpsertWithWhereUniqueWithoutDarajePipeInput = {
    where: KhatRaneshWhereUniqueInput
    update: XOR<KhatRaneshUpdateWithoutDarajePipeInput, KhatRaneshUncheckedUpdateWithoutDarajePipeInput>
    create: XOR<KhatRaneshCreateWithoutDarajePipeInput, KhatRaneshUncheckedCreateWithoutDarajePipeInput>
  }

  export type KhatRaneshUpdateWithWhereUniqueWithoutDarajePipeInput = {
    where: KhatRaneshWhereUniqueInput
    data: XOR<KhatRaneshUpdateWithoutDarajePipeInput, KhatRaneshUncheckedUpdateWithoutDarajePipeInput>
  }

  export type KhatRaneshUpdateManyWithWhereWithoutDarajePipeInput = {
    where: KhatRaneshScalarWhereInput
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyWithoutDarajePipeInput>
  }

  export type KhatRaneshScalarWhereInput = {
    AND?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
    OR?: KhatRaneshScalarWhereInput[]
    NOT?: KhatRaneshScalarWhereInput | KhatRaneshScalarWhereInput[]
    IdRanesh?: IntFilter<"KhatRanesh"> | number
    RaneshName?: StringFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntFilter<"KhatRanesh"> | number
    FIdDPipe?: IntFilter<"KhatRanesh"> | number
    FIdSePu?: IntFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntFilter<"KhatRanesh"> | number
    Active?: BoolFilter<"KhatRanesh"> | boolean
  }

  export type PumpStationCreateWithoutDeliveryPointInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutPumpStationInput
    AbadeMakhzan?: AbadeMakhzanCreateNestedOneWithoutPumpStationInput
    DarjeStation: DarjeStationCreateNestedOneWithoutPumpStationInput
    Network: NetworkCreateNestedOneWithoutPumpStationInput
  }

  export type PumpStationUncheckedCreateWithoutDeliveryPointInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput
  }

  export type PumpStationCreateOrConnectWithoutDeliveryPointInput = {
    where: PumpStationWhereUniqueInput
    create: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput>
  }

  export type PumpStationCreateManyDeliveryPointInputEnvelope = {
    data: PumpStationCreateManyDeliveryPointInput | PumpStationCreateManyDeliveryPointInput[]
  }

  export type PumpStationUpsertWithWhereUniqueWithoutDeliveryPointInput = {
    where: PumpStationWhereUniqueInput
    update: XOR<PumpStationUpdateWithoutDeliveryPointInput, PumpStationUncheckedUpdateWithoutDeliveryPointInput>
    create: XOR<PumpStationCreateWithoutDeliveryPointInput, PumpStationUncheckedCreateWithoutDeliveryPointInput>
  }

  export type PumpStationUpdateWithWhereUniqueWithoutDeliveryPointInput = {
    where: PumpStationWhereUniqueInput
    data: XOR<PumpStationUpdateWithoutDeliveryPointInput, PumpStationUncheckedUpdateWithoutDeliveryPointInput>
  }

  export type PumpStationUpdateManyWithWhereWithoutDeliveryPointInput = {
    where: PumpStationScalarWhereInput
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyWithoutDeliveryPointInput>
  }

  export type PumpStationCreateWithoutDarjeStationInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutPumpStationInput
    AbadeMakhzan?: AbadeMakhzanCreateNestedOneWithoutPumpStationInput
    DeliveryPoint: DeliveryPointsCreateNestedOneWithoutPumpStationsInput
    Network: NetworkCreateNestedOneWithoutPumpStationInput
  }

  export type PumpStationUncheckedCreateWithoutDarjeStationInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput
  }

  export type PumpStationCreateOrConnectWithoutDarjeStationInput = {
    where: PumpStationWhereUniqueInput
    create: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput>
  }

  export type PumpStationCreateManyDarjeStationInputEnvelope = {
    data: PumpStationCreateManyDarjeStationInput | PumpStationCreateManyDarjeStationInput[]
  }

  export type PumpStationUpsertWithWhereUniqueWithoutDarjeStationInput = {
    where: PumpStationWhereUniqueInput
    update: XOR<PumpStationUpdateWithoutDarjeStationInput, PumpStationUncheckedUpdateWithoutDarjeStationInput>
    create: XOR<PumpStationCreateWithoutDarjeStationInput, PumpStationUncheckedCreateWithoutDarjeStationInput>
  }

  export type PumpStationUpdateWithWhereUniqueWithoutDarjeStationInput = {
    where: PumpStationWhereUniqueInput
    data: XOR<PumpStationUpdateWithoutDarjeStationInput, PumpStationUncheckedUpdateWithoutDarjeStationInput>
  }

  export type PumpStationUpdateManyWithWhereWithoutDarjeStationInput = {
    where: PumpStationScalarWhereInput
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyWithoutDarjeStationInput>
  }

  export type ShabakeDoreKeshtCreateWithoutDoreKeshtInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutShabakeDoreKeshtInput
    Network: NetworkCreateNestedOneWithoutShabakeDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtCreateOrConnectWithoutDoreKeshtInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    create: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput>
  }

  export type ShabakeDoreKeshtCreateManyDoreKeshtInputEnvelope = {
    data: ShabakeDoreKeshtCreateManyDoreKeshtInput | ShabakeDoreKeshtCreateManyDoreKeshtInput[]
  }

  export type TrikhDoreKeshtCreateWithoutDoreKeshtInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput = {
    IdTarDor?: number
    FIdSal: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutDoreKeshtInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput>
  }

  export type TrikhDoreKeshtCreateManyDoreKeshtInputEnvelope = {
    data: TrikhDoreKeshtCreateManyDoreKeshtInput | TrikhDoreKeshtCreateManyDoreKeshtInput[]
  }

  export type ShabakeDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    update: XOR<ShabakeDoreKeshtUpdateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedUpdateWithoutDoreKeshtInput>
    create: XOR<ShabakeDoreKeshtCreateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedCreateWithoutDoreKeshtInput>
  }

  export type ShabakeDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    data: XOR<ShabakeDoreKeshtUpdateWithoutDoreKeshtInput, ShabakeDoreKeshtUncheckedUpdateWithoutDoreKeshtInput>
  }

  export type ShabakeDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput = {
    where: ShabakeDoreKeshtScalarWhereInput
    data: XOR<ShabakeDoreKeshtUpdateManyMutationInput, ShabakeDoreKeshtUncheckedUpdateManyWithoutDoreKeshtInput>
  }

  export type ShabakeDoreKeshtScalarWhereInput = {
    AND?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
    OR?: ShabakeDoreKeshtScalarWhereInput[]
    NOT?: ShabakeDoreKeshtScalarWhereInput | ShabakeDoreKeshtScalarWhereInput[]
    IdShDo?: IntFilter<"ShabakeDoreKesht"> | number
    FIdNet?: IntFilter<"ShabakeDoreKesht"> | number
    TrikhShorooe?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    TrikhPayan?: DateTimeFilter<"ShabakeDoreKesht"> | Date | string
    FIdSal?: IntFilter<"ShabakeDoreKesht"> | number
    FIdDore?: IntFilter<"ShabakeDoreKesht"> | number
  }

  export type TrikhDoreKeshtUpsertWithWhereUniqueWithoutDoreKeshtInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    update: XOR<TrikhDoreKeshtUpdateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedUpdateWithoutDoreKeshtInput>
    create: XOR<TrikhDoreKeshtCreateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedCreateWithoutDoreKeshtInput>
  }

  export type TrikhDoreKeshtUpdateWithWhereUniqueWithoutDoreKeshtInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    data: XOR<TrikhDoreKeshtUpdateWithoutDoreKeshtInput, TrikhDoreKeshtUncheckedUpdateWithoutDoreKeshtInput>
  }

  export type TrikhDoreKeshtUpdateManyWithWhereWithoutDoreKeshtInput = {
    where: TrikhDoreKeshtScalarWhereInput
    data: XOR<TrikhDoreKeshtUpdateManyMutationInput, TrikhDoreKeshtUncheckedUpdateManyWithoutDoreKeshtInput>
  }

  export type TrikhDoreKeshtScalarWhereInput = {
    AND?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
    OR?: TrikhDoreKeshtScalarWhereInput[]
    NOT?: TrikhDoreKeshtScalarWhereInput | TrikhDoreKeshtScalarWhereInput[]
    IdTarDor?: IntFilter<"TrikhDoreKesht"> | number
    FIdSal?: IntFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringFilter<"TrikhDoreKesht"> | string
    Dahe?: IntFilter<"TrikhDoreKesht"> | number
    Sal?: IntFilter<"TrikhDoreKesht"> | number
    Mah?: IntFilter<"TrikhDoreKesht"> | number
  }

  export type KhatRaneshCreateWithoutEshtebahAvamelInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutEshtebahAvamelInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutEshtebahAvamelInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutEshtebahAvamelInput, KhatRaneshUncheckedCreateWithoutEshtebahAvamelInput>
  }

  export type TrikhDoreKeshtCreateWithoutEshtebahAvamelInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutEshtebahAvamelInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutEshtebahAvamelInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedCreateWithoutEshtebahAvamelInput>
  }

  export type KhatRaneshUpsertWithoutEshtebahAvamelInput = {
    update: XOR<KhatRaneshUpdateWithoutEshtebahAvamelInput, KhatRaneshUncheckedUpdateWithoutEshtebahAvamelInput>
    create: XOR<KhatRaneshCreateWithoutEshtebahAvamelInput, KhatRaneshUncheckedCreateWithoutEshtebahAvamelInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutEshtebahAvamelInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutEshtebahAvamelInput, KhatRaneshUncheckedUpdateWithoutEshtebahAvamelInput>
  }

  export type KhatRaneshUpdateWithoutEshtebahAvamelInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutEshtebahAvamelInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutEshtebahAvamelInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedUpdateWithoutEshtebahAvamelInput>
    create: XOR<TrikhDoreKeshtCreateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedCreateWithoutEshtebahAvamelInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutEshtebahAvamelInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutEshtebahAvamelInput, TrikhDoreKeshtUncheckedUpdateWithoutEshtebahAvamelInput>
  }

  export type TrikhDoreKeshtUpdateWithoutEshtebahAvamelInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutEshtebahAvamelInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutFlowBehboodInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutFlowBehboodInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutFlowBehboodInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutFlowBehboodInput, KhatRaneshUncheckedCreateWithoutFlowBehboodInput>
  }

  export type TrikhDoreKeshtCreateWithoutFlowBehboodInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutFlowBehboodInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutFlowBehboodInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedCreateWithoutFlowBehboodInput>
  }

  export type KhatRaneshUpsertWithoutFlowBehboodInput = {
    update: XOR<KhatRaneshUpdateWithoutFlowBehboodInput, KhatRaneshUncheckedUpdateWithoutFlowBehboodInput>
    create: XOR<KhatRaneshCreateWithoutFlowBehboodInput, KhatRaneshUncheckedCreateWithoutFlowBehboodInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutFlowBehboodInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutFlowBehboodInput, KhatRaneshUncheckedUpdateWithoutFlowBehboodInput>
  }

  export type KhatRaneshUpdateWithoutFlowBehboodInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutFlowBehboodInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutFlowBehboodInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedUpdateWithoutFlowBehboodInput>
    create: XOR<TrikhDoreKeshtCreateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedCreateWithoutFlowBehboodInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutFlowBehboodInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutFlowBehboodInput, TrikhDoreKeshtUncheckedUpdateWithoutFlowBehboodInput>
  }

  export type TrikhDoreKeshtUpdateWithoutFlowBehboodInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutFlowBehboodInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutFlowmeterInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutFlowmeterInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutFlowmeterInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutFlowmeterInput, KhatRaneshUncheckedCreateWithoutFlowmeterInput>
  }

  export type TrikhDoreKeshtCreateWithoutFlowmeterInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutFlowmeterInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutFlowmeterInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedCreateWithoutFlowmeterInput>
  }

  export type KhatRaneshUpsertWithoutFlowmeterInput = {
    update: XOR<KhatRaneshUpdateWithoutFlowmeterInput, KhatRaneshUncheckedUpdateWithoutFlowmeterInput>
    create: XOR<KhatRaneshCreateWithoutFlowmeterInput, KhatRaneshUncheckedCreateWithoutFlowmeterInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutFlowmeterInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutFlowmeterInput, KhatRaneshUncheckedUpdateWithoutFlowmeterInput>
  }

  export type KhatRaneshUpdateWithoutFlowmeterInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutFlowmeterInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutFlowmeterInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedUpdateWithoutFlowmeterInput>
    create: XOR<TrikhDoreKeshtCreateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedCreateWithoutFlowmeterInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutFlowmeterInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutFlowmeterInput, TrikhDoreKeshtUncheckedUpdateWithoutFlowmeterInput>
  }

  export type TrikhDoreKeshtUpdateWithoutFlowmeterInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutFlowmeterInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type AbgirCreateWithoutKhatRaneshInput = {
    Abgir: string
    Kontor?: KontorCreateNestedManyWithoutAbgirInput
  }

  export type AbgirUncheckedCreateWithoutKhatRaneshInput = {
    IdKontor?: number
    Abgir: string
    Kontor?: KontorUncheckedCreateNestedManyWithoutAbgirInput
  }

  export type AbgirCreateOrConnectWithoutKhatRaneshInput = {
    where: AbgirWhereUniqueInput
    create: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput>
  }

  export type AbgirCreateManyKhatRaneshInputEnvelope = {
    data: AbgirCreateManyKhatRaneshInput | AbgirCreateManyKhatRaneshInput[]
  }

  export type BahrebardairProgramCreateWithoutKhatRaneshInput = {
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramInput
  }

  export type BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput = {
    IdProgram?: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramCreateOrConnectWithoutKhatRaneshInput = {
    where: BahrebardairProgramWhereUniqueInput
    create: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramCreateManyKhatRaneshInputEnvelope = {
    data: BahrebardairProgramCreateManyKhatRaneshInput | BahrebardairProgramCreateManyKhatRaneshInput[]
  }

  export type BahrebardairProgramSeghliCreateWithoutKhatRaneshInput = {
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardairProgramSeghliInput
  }

  export type BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput = {
    IdProSrgl?: number
    FIdTarDor: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliCreateOrConnectWithoutKhatRaneshInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    create: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramSeghliCreateManyKhatRaneshInputEnvelope = {
    data: BahrebardairProgramSeghliCreateManyKhatRaneshInput | BahrebardairProgramSeghliCreateManyKhatRaneshInput[]
  }

  export type BahrebardariKeshtDoreCreateWithoutKhatRaneshInput = {
    IdBahDor: number
    Area: Decimal | DecimalJsLike | number | string
    NoeMahsool: NoeMahsoolCreateNestedOneWithoutBahrebardariKeshtDoreInput
    ShabakeDoreKesht: ShabakeDoreKeshtCreateNestedOneWithoutBahrebardariKeshtDoreInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput = {
    IdBahDor: number
    FIdShDo: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreCreateOrConnectWithoutKhatRaneshInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    create: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardariKeshtDoreCreateManyKhatRaneshInputEnvelope = {
    data: BahrebardariKeshtDoreCreateManyKhatRaneshInput | BahrebardariKeshtDoreCreateManyKhatRaneshInput[]
  }

  export type BahrebardariTaghvimCreateWithoutKhatRaneshInput = {
    Taghvim: Decimal | DecimalJsLike | number | string
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutBahrebardariTaghvimInput
  }

  export type BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput = {
    IdTag?: number
    FIdTarDor: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateOrConnectWithoutKhatRaneshInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    create: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardariTaghvimCreateManyKhatRaneshInputEnvelope = {
    data: BahrebardariTaghvimCreateManyKhatRaneshInput | BahrebardariTaghvimCreateManyKhatRaneshInput[]
  }

  export type EshtebahAvamelCreateWithoutKhatRaneshInput = {
    IdEsht: number
    Eshtebah: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutEshtebahAvamelInput
  }

  export type EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput = {
    IdEsht: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelCreateOrConnectWithoutKhatRaneshInput = {
    where: EshtebahAvamelWhereUniqueInput
    create: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput>
  }

  export type EshtebahAvamelCreateManyKhatRaneshInputEnvelope = {
    data: EshtebahAvamelCreateManyKhatRaneshInput | EshtebahAvamelCreateManyKhatRaneshInput[]
  }

  export type FlowBehboodCreateWithoutKhatRaneshInput = {
    Flow: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutFlowBehboodInput
  }

  export type FlowBehboodUncheckedCreateWithoutKhatRaneshInput = {
    IdBehbood?: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodCreateOrConnectWithoutKhatRaneshInput = {
    where: FlowBehboodWhereUniqueInput
    create: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput>
  }

  export type FlowBehboodCreateManyKhatRaneshInputEnvelope = {
    data: FlowBehboodCreateManyKhatRaneshInput | FlowBehboodCreateManyKhatRaneshInput[]
  }

  export type FlowmeterCreateWithoutKhatRaneshInput = {
    IdFIT: number
    Flowmeter: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutFlowmeterInput
  }

  export type FlowmeterUncheckedCreateWithoutKhatRaneshInput = {
    IdFIT: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterCreateOrConnectWithoutKhatRaneshInput = {
    where: FlowmeterWhereUniqueInput
    create: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput>
  }

  export type FlowmeterCreateManyKhatRaneshInputEnvelope = {
    data: FlowmeterCreateManyKhatRaneshInput | FlowmeterCreateManyKhatRaneshInput[]
  }

  export type DarajePipeCreateWithoutKhatRaneshInput = {
    DarajePipe: string
  }

  export type DarajePipeUncheckedCreateWithoutKhatRaneshInput = {
    IdDPipe?: number
    DarajePipe: string
  }

  export type DarajePipeCreateOrConnectWithoutKhatRaneshInput = {
    where: DarajePipeWhereUniqueInput
    create: XOR<DarajePipeCreateWithoutKhatRaneshInput, DarajePipeUncheckedCreateWithoutKhatRaneshInput>
  }

  export type MeasuringToolCreateWithoutKhatRaneshInput = {
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolUncheckedCreateWithoutKhatRaneshInput = {
    IdMeasuring?: number
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolCreateOrConnectWithoutKhatRaneshInput = {
    where: MeasuringToolWhereUniqueInput
    create: XOR<MeasuringToolCreateWithoutKhatRaneshInput, MeasuringToolUncheckedCreateWithoutKhatRaneshInput>
  }

  export type PumpStationCreateWithoutKhatRaneshInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    AbadeMakhzan?: AbadeMakhzanCreateNestedOneWithoutPumpStationInput
    DarjeStation: DarjeStationCreateNestedOneWithoutPumpStationInput
    DeliveryPoint: DeliveryPointsCreateNestedOneWithoutPumpStationsInput
    Network: NetworkCreateNestedOneWithoutPumpStationInput
  }

  export type PumpStationUncheckedCreateWithoutKhatRaneshInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
  }

  export type PumpStationCreateOrConnectWithoutKhatRaneshInput = {
    where: PumpStationWhereUniqueInput
    create: XOR<PumpStationCreateWithoutKhatRaneshInput, PumpStationUncheckedCreateWithoutKhatRaneshInput>
  }

  export type SeghliPumpCreateWithoutKhatRaneshInput = {
    SeghliPump: string
  }

  export type SeghliPumpUncheckedCreateWithoutKhatRaneshInput = {
    IdSePu?: number
    SeghliPump: string
  }

  export type SeghliPumpCreateOrConnectWithoutKhatRaneshInput = {
    where: SeghliPumpWhereUniqueInput
    create: XOR<SeghliPumpCreateWithoutKhatRaneshInput, SeghliPumpUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaCreateWithoutKhatRaneshInput = {
    Area: Decimal | DecimalJsLike | number | string
    Land: LandCreateNestedOneWithoutKhatRaneshAreaInput
    Network: NetworkCreateNestedOneWithoutKhatRaneshAreaInput
  }

  export type KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput = {
    IdRanesh?: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateOrConnectWithoutKhatRaneshInput = {
    where: KhatRaneshAreaWhereUniqueInput
    create: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaCreateManyKhatRaneshInputEnvelope = {
    data: KhatRaneshAreaCreateManyKhatRaneshInput | KhatRaneshAreaCreateManyKhatRaneshInput[]
  }

  export type KhatRaneshPumpCreateWithoutKhatRaneshInput = {
    ModelPump?: string | null
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    PumpType: PumpTypeCreateNestedOneWithoutKhatRaneshPumpInput
  }

  export type KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput = {
    IdRanesh?: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpCreateOrConnectWithoutKhatRaneshInput = {
    where: KhatRaneshPumpWhereUniqueInput
    create: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshPumpCreateManyKhatRaneshInputEnvelope = {
    data: KhatRaneshPumpCreateManyKhatRaneshInput | KhatRaneshPumpCreateManyKhatRaneshInput[]
  }

  export type KhatRaneshSegliCreateWithoutKhatRaneshInput = {
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput = {
    IdRanesh?: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliCreateOrConnectWithoutKhatRaneshInput = {
    where: KhatRaneshSegliWhereUniqueInput
    create: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshSegliCreateManyKhatRaneshInputEnvelope = {
    data: KhatRaneshSegliCreateManyKhatRaneshInput | KhatRaneshSegliCreateManyKhatRaneshInput[]
  }

  export type NashtShabakeCreateWithoutKhatRaneshInput = {
    NashtShabake: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutNashtShabakeInput
  }

  export type NashtShabakeUncheckedCreateWithoutKhatRaneshInput = {
    IdNasht?: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeCreateOrConnectWithoutKhatRaneshInput = {
    where: NashtShabakeWhereUniqueInput
    create: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput>
  }

  export type NashtShabakeCreateManyKhatRaneshInputEnvelope = {
    data: NashtShabakeCreateManyKhatRaneshInput | NashtShabakeCreateManyKhatRaneshInput[]
  }

  export type NonFITCreateWithoutKhatRaneshInput = {
    IdNonFIT: number
    VOLUM: number
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedOneWithoutNonFITInput
  }

  export type NonFITUncheckedCreateWithoutKhatRaneshInput = {
    IdNonFIT: number
    FIdTarDor?: number
    VOLUM: number
  }

  export type NonFITCreateOrConnectWithoutKhatRaneshInput = {
    where: NonFITWhereUniqueInput
    create: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput>
  }

  export type NonFITCreateManyKhatRaneshInputEnvelope = {
    data: NonFITCreateManyKhatRaneshInput | NonFITCreateManyKhatRaneshInput[]
  }

  export type TakhlieMakhzanCreateWithoutKhatRaneshInput = {
    Takhlie: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutTakhlieMakhzanInput
  }

  export type TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput = {
    IdTakhlie?: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanCreateOrConnectWithoutKhatRaneshInput = {
    where: TakhlieMakhzanWhereUniqueInput
    create: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput>
  }

  export type TakhlieMakhzanCreateManyKhatRaneshInputEnvelope = {
    data: TakhlieMakhzanCreateManyKhatRaneshInput | TakhlieMakhzanCreateManyKhatRaneshInput[]
  }

  export type TestCreateWithoutKhatRaneshInput = {
    Test: number
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutTestInput
  }

  export type TestUncheckedCreateWithoutKhatRaneshInput = {
    IdTest?: number
    FIdTarDor: number
    Test: number
  }

  export type TestCreateOrConnectWithoutKhatRaneshInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput>
  }

  export type TestCreateManyKhatRaneshInputEnvelope = {
    data: TestCreateManyKhatRaneshInput | TestCreateManyKhatRaneshInput[]
  }

  export type AbgirUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: AbgirWhereUniqueInput
    update: XOR<AbgirUpdateWithoutKhatRaneshInput, AbgirUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<AbgirCreateWithoutKhatRaneshInput, AbgirUncheckedCreateWithoutKhatRaneshInput>
  }

  export type AbgirUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: AbgirWhereUniqueInput
    data: XOR<AbgirUpdateWithoutKhatRaneshInput, AbgirUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type AbgirUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: AbgirScalarWhereInput
    data: XOR<AbgirUpdateManyMutationInput, AbgirUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type AbgirScalarWhereInput = {
    AND?: AbgirScalarWhereInput | AbgirScalarWhereInput[]
    OR?: AbgirScalarWhereInput[]
    NOT?: AbgirScalarWhereInput | AbgirScalarWhereInput[]
    IdKontor?: IntFilter<"Abgir"> | number
    FIdRanesh?: IntFilter<"Abgir"> | number
    Abgir?: StringFilter<"Abgir"> | string
  }

  export type BahrebardairProgramUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardairProgramWhereUniqueInput
    update: XOR<BahrebardairProgramUpdateWithoutKhatRaneshInput, BahrebardairProgramUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<BahrebardairProgramCreateWithoutKhatRaneshInput, BahrebardairProgramUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardairProgramWhereUniqueInput
    data: XOR<BahrebardairProgramUpdateWithoutKhatRaneshInput, BahrebardairProgramUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: BahrebardairProgramScalarWhereInput
    data: XOR<BahrebardairProgramUpdateManyMutationInput, BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramScalarWhereInput = {
    AND?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
    OR?: BahrebardairProgramScalarWhereInput[]
    NOT?: BahrebardairProgramScalarWhereInput | BahrebardairProgramScalarWhereInput[]
    IdProgram?: IntFilter<"BahrebardairProgram"> | number
    FIdRanesh?: IntFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgram"> | number
    Tedad?: IntFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
  }

  export type BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    update: XOR<BahrebardairProgramSeghliUpdateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<BahrebardairProgramSeghliCreateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    data: XOR<BahrebardairProgramSeghliUpdateWithoutKhatRaneshInput, BahrebardairProgramSeghliUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramSeghliUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: BahrebardairProgramSeghliScalarWhereInput
    data: XOR<BahrebardairProgramSeghliUpdateManyMutationInput, BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type BahrebardairProgramSeghliScalarWhereInput = {
    AND?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
    OR?: BahrebardairProgramSeghliScalarWhereInput[]
    NOT?: BahrebardairProgramSeghliScalarWhereInput | BahrebardairProgramSeghliScalarWhereInput[]
    IdProSrgl?: IntFilter<"BahrebardairProgramSeghli"> | number
    FIdRanesh?: IntFilter<"BahrebardairProgramSeghli"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgramSeghli"> | number
    Zarfiat?: DecimalNullableFilter<"BahrebardairProgramSeghli"> | Decimal | DecimalJsLike | number | string | null
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgramSeghli"> | Date | string | null
  }

  export type BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    update: XOR<BahrebardariKeshtDoreUpdateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<BahrebardariKeshtDoreCreateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    data: XOR<BahrebardariKeshtDoreUpdateWithoutKhatRaneshInput, BahrebardariKeshtDoreUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type BahrebardariKeshtDoreUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: BahrebardariKeshtDoreScalarWhereInput
    data: XOR<BahrebardariKeshtDoreUpdateManyMutationInput, BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type BahrebardariKeshtDoreScalarWhereInput = {
    AND?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
    OR?: BahrebardariKeshtDoreScalarWhereInput[]
    NOT?: BahrebardariKeshtDoreScalarWhereInput | BahrebardariKeshtDoreScalarWhereInput[]
    IdBahDor?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdShDo?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    update: XOR<BahrebardariTaghvimUpdateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<BahrebardariTaghvimCreateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedCreateWithoutKhatRaneshInput>
  }

  export type BahrebardariTaghvimUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    data: XOR<BahrebardariTaghvimUpdateWithoutKhatRaneshInput, BahrebardariTaghvimUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type BahrebardariTaghvimUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: BahrebardariTaghvimScalarWhereInput
    data: XOR<BahrebardariTaghvimUpdateManyMutationInput, BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type BahrebardariTaghvimScalarWhereInput = {
    AND?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
    OR?: BahrebardariTaghvimScalarWhereInput[]
    NOT?: BahrebardariTaghvimScalarWhereInput | BahrebardariTaghvimScalarWhereInput[]
    IdTag?: IntFilter<"BahrebardariTaghvim"> | number
    FIdTarDor?: IntFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
  }

  export type EshtebahAvamelUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: EshtebahAvamelWhereUniqueInput
    update: XOR<EshtebahAvamelUpdateWithoutKhatRaneshInput, EshtebahAvamelUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<EshtebahAvamelCreateWithoutKhatRaneshInput, EshtebahAvamelUncheckedCreateWithoutKhatRaneshInput>
  }

  export type EshtebahAvamelUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: EshtebahAvamelWhereUniqueInput
    data: XOR<EshtebahAvamelUpdateWithoutKhatRaneshInput, EshtebahAvamelUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type EshtebahAvamelUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: EshtebahAvamelScalarWhereInput
    data: XOR<EshtebahAvamelUpdateManyMutationInput, EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type EshtebahAvamelScalarWhereInput = {
    AND?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
    OR?: EshtebahAvamelScalarWhereInput[]
    NOT?: EshtebahAvamelScalarWhereInput | EshtebahAvamelScalarWhereInput[]
    IdEsht?: IntFilter<"EshtebahAvamel"> | number
    FIdRanesh?: IntFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntFilter<"EshtebahAvamel"> | number
  }

  export type FlowBehboodUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: FlowBehboodWhereUniqueInput
    update: XOR<FlowBehboodUpdateWithoutKhatRaneshInput, FlowBehboodUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<FlowBehboodCreateWithoutKhatRaneshInput, FlowBehboodUncheckedCreateWithoutKhatRaneshInput>
  }

  export type FlowBehboodUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: FlowBehboodWhereUniqueInput
    data: XOR<FlowBehboodUpdateWithoutKhatRaneshInput, FlowBehboodUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type FlowBehboodUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: FlowBehboodScalarWhereInput
    data: XOR<FlowBehboodUpdateManyMutationInput, FlowBehboodUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type FlowBehboodScalarWhereInput = {
    AND?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
    OR?: FlowBehboodScalarWhereInput[]
    NOT?: FlowBehboodScalarWhereInput | FlowBehboodScalarWhereInput[]
    IdBehbood?: IntFilter<"FlowBehbood"> | number
    FIdRanesh?: IntFilter<"FlowBehbood"> | number
    FIdTarDor?: IntFilter<"FlowBehbood"> | number
    Flow?: IntFilter<"FlowBehbood"> | number
  }

  export type FlowmeterUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: FlowmeterWhereUniqueInput
    update: XOR<FlowmeterUpdateWithoutKhatRaneshInput, FlowmeterUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<FlowmeterCreateWithoutKhatRaneshInput, FlowmeterUncheckedCreateWithoutKhatRaneshInput>
  }

  export type FlowmeterUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: FlowmeterWhereUniqueInput
    data: XOR<FlowmeterUpdateWithoutKhatRaneshInput, FlowmeterUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type FlowmeterUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: FlowmeterScalarWhereInput
    data: XOR<FlowmeterUpdateManyMutationInput, FlowmeterUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type FlowmeterScalarWhereInput = {
    AND?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
    OR?: FlowmeterScalarWhereInput[]
    NOT?: FlowmeterScalarWhereInput | FlowmeterScalarWhereInput[]
    IdFIT?: IntFilter<"Flowmeter"> | number
    FIdRanesh?: IntFilter<"Flowmeter"> | number
    FIdTrikh?: IntFilter<"Flowmeter"> | number
    Flowmeter?: FloatFilter<"Flowmeter"> | number
  }

  export type DarajePipeUpsertWithoutKhatRaneshInput = {
    update: XOR<DarajePipeUpdateWithoutKhatRaneshInput, DarajePipeUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<DarajePipeCreateWithoutKhatRaneshInput, DarajePipeUncheckedCreateWithoutKhatRaneshInput>
    where?: DarajePipeWhereInput
  }

  export type DarajePipeUpdateToOneWithWhereWithoutKhatRaneshInput = {
    where?: DarajePipeWhereInput
    data: XOR<DarajePipeUpdateWithoutKhatRaneshInput, DarajePipeUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type DarajePipeUpdateWithoutKhatRaneshInput = {
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarajePipeUncheckedUpdateWithoutKhatRaneshInput = {
    IdDPipe?: IntFieldUpdateOperationsInput | number
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolUpsertWithoutKhatRaneshInput = {
    update: XOR<MeasuringToolUpdateWithoutKhatRaneshInput, MeasuringToolUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<MeasuringToolCreateWithoutKhatRaneshInput, MeasuringToolUncheckedCreateWithoutKhatRaneshInput>
    where?: MeasuringToolWhereInput
  }

  export type MeasuringToolUpdateToOneWithWhereWithoutKhatRaneshInput = {
    where?: MeasuringToolWhereInput
    data: XOR<MeasuringToolUpdateWithoutKhatRaneshInput, MeasuringToolUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type MeasuringToolUpdateWithoutKhatRaneshInput = {
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolUncheckedUpdateWithoutKhatRaneshInput = {
    IdMeasuring?: IntFieldUpdateOperationsInput | number
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type PumpStationUpsertWithoutKhatRaneshInput = {
    update: XOR<PumpStationUpdateWithoutKhatRaneshInput, PumpStationUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<PumpStationCreateWithoutKhatRaneshInput, PumpStationUncheckedCreateWithoutKhatRaneshInput>
    where?: PumpStationWhereInput
  }

  export type PumpStationUpdateToOneWithWhereWithoutKhatRaneshInput = {
    where?: PumpStationWhereInput
    data: XOR<PumpStationUpdateWithoutKhatRaneshInput, PumpStationUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type PumpStationUpdateWithoutKhatRaneshInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    AbadeMakhzan?: AbadeMakhzanUpdateOneWithoutPumpStationNestedInput
    DarjeStation?: DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput
    DeliveryPoint?: DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput
    Network?: NetworkUpdateOneRequiredWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateWithoutKhatRaneshInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeghliPumpUpsertWithoutKhatRaneshInput = {
    update: XOR<SeghliPumpUpdateWithoutKhatRaneshInput, SeghliPumpUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<SeghliPumpCreateWithoutKhatRaneshInput, SeghliPumpUncheckedCreateWithoutKhatRaneshInput>
    where?: SeghliPumpWhereInput
  }

  export type SeghliPumpUpdateToOneWithWhereWithoutKhatRaneshInput = {
    where?: SeghliPumpWhereInput
    data: XOR<SeghliPumpUpdateWithoutKhatRaneshInput, SeghliPumpUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type SeghliPumpUpdateWithoutKhatRaneshInput = {
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpUncheckedUpdateWithoutKhatRaneshInput = {
    IdSePu?: IntFieldUpdateOperationsInput | number
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type KhatRaneshAreaUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshAreaWhereUniqueInput
    update: XOR<KhatRaneshAreaUpdateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<KhatRaneshAreaCreateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshAreaWhereUniqueInput
    data: XOR<KhatRaneshAreaUpdateWithoutKhatRaneshInput, KhatRaneshAreaUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: KhatRaneshAreaScalarWhereInput
    data: XOR<KhatRaneshAreaUpdateManyMutationInput, KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type KhatRaneshAreaScalarWhereInput = {
    AND?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
    OR?: KhatRaneshAreaScalarWhereInput[]
    NOT?: KhatRaneshAreaScalarWhereInput | KhatRaneshAreaScalarWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdLand?: IntFilter<"KhatRaneshArea"> | number
    FIdNet?: IntFilter<"KhatRaneshArea"> | number
    Area?: DecimalFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshPumpWhereUniqueInput
    update: XOR<KhatRaneshPumpUpdateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<KhatRaneshPumpCreateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshPumpUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshPumpWhereUniqueInput
    data: XOR<KhatRaneshPumpUpdateWithoutKhatRaneshInput, KhatRaneshPumpUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type KhatRaneshPumpUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: KhatRaneshPumpScalarWhereInput
    data: XOR<KhatRaneshPumpUpdateManyMutationInput, KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type KhatRaneshPumpScalarWhereInput = {
    AND?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
    OR?: KhatRaneshPumpScalarWhereInput[]
    NOT?: KhatRaneshPumpScalarWhereInput | KhatRaneshPumpScalarWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshPump"> | number
    FIdRanesh?: IntFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntFilter<"KhatRaneshPump"> | number
  }

  export type KhatRaneshSegliUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshSegliWhereUniqueInput
    update: XOR<KhatRaneshSegliUpdateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<KhatRaneshSegliCreateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedCreateWithoutKhatRaneshInput>
  }

  export type KhatRaneshSegliUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: KhatRaneshSegliWhereUniqueInput
    data: XOR<KhatRaneshSegliUpdateWithoutKhatRaneshInput, KhatRaneshSegliUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type KhatRaneshSegliUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: KhatRaneshSegliScalarWhereInput
    data: XOR<KhatRaneshSegliUpdateManyMutationInput, KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type KhatRaneshSegliScalarWhereInput = {
    AND?: KhatRaneshSegliScalarWhereInput | KhatRaneshSegliScalarWhereInput[]
    OR?: KhatRaneshSegliScalarWhereInput[]
    NOT?: KhatRaneshSegliScalarWhereInput | KhatRaneshSegliScalarWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    FIdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
  }

  export type NashtShabakeUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: NashtShabakeWhereUniqueInput
    update: XOR<NashtShabakeUpdateWithoutKhatRaneshInput, NashtShabakeUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<NashtShabakeCreateWithoutKhatRaneshInput, NashtShabakeUncheckedCreateWithoutKhatRaneshInput>
  }

  export type NashtShabakeUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: NashtShabakeWhereUniqueInput
    data: XOR<NashtShabakeUpdateWithoutKhatRaneshInput, NashtShabakeUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type NashtShabakeUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: NashtShabakeScalarWhereInput
    data: XOR<NashtShabakeUpdateManyMutationInput, NashtShabakeUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type NashtShabakeScalarWhereInput = {
    AND?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
    OR?: NashtShabakeScalarWhereInput[]
    NOT?: NashtShabakeScalarWhereInput | NashtShabakeScalarWhereInput[]
    IdNasht?: IntFilter<"NashtShabake"> | number
    FIdRanesh?: IntFilter<"NashtShabake"> | number
    FIdTriDor?: IntFilter<"NashtShabake"> | number
    NashtShabake?: IntFilter<"NashtShabake"> | number
  }

  export type NonFITUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: NonFITWhereUniqueInput
    update: XOR<NonFITUpdateWithoutKhatRaneshInput, NonFITUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<NonFITCreateWithoutKhatRaneshInput, NonFITUncheckedCreateWithoutKhatRaneshInput>
  }

  export type NonFITUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: NonFITWhereUniqueInput
    data: XOR<NonFITUpdateWithoutKhatRaneshInput, NonFITUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type NonFITUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: NonFITScalarWhereInput
    data: XOR<NonFITUpdateManyMutationInput, NonFITUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type NonFITScalarWhereInput = {
    AND?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
    OR?: NonFITScalarWhereInput[]
    NOT?: NonFITScalarWhereInput | NonFITScalarWhereInput[]
    IdNonFIT?: IntFilter<"NonFIT"> | number
    FIdRanesh?: IntFilter<"NonFIT"> | number
    FIdTarDor?: IntFilter<"NonFIT"> | number
    VOLUM?: IntFilter<"NonFIT"> | number
  }

  export type TakhlieMakhzanUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: TakhlieMakhzanWhereUniqueInput
    update: XOR<TakhlieMakhzanUpdateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<TakhlieMakhzanCreateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedCreateWithoutKhatRaneshInput>
  }

  export type TakhlieMakhzanUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: TakhlieMakhzanWhereUniqueInput
    data: XOR<TakhlieMakhzanUpdateWithoutKhatRaneshInput, TakhlieMakhzanUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type TakhlieMakhzanUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: TakhlieMakhzanScalarWhereInput
    data: XOR<TakhlieMakhzanUpdateManyMutationInput, TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type TakhlieMakhzanScalarWhereInput = {
    AND?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
    OR?: TakhlieMakhzanScalarWhereInput[]
    NOT?: TakhlieMakhzanScalarWhereInput | TakhlieMakhzanScalarWhereInput[]
    IdTakhlie?: IntFilter<"TakhlieMakhzan"> | number
    FIdRanesh?: IntFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntFilter<"TakhlieMakhzan"> | number
  }

  export type TestUpsertWithWhereUniqueWithoutKhatRaneshInput = {
    where: TestWhereUniqueInput
    update: XOR<TestUpdateWithoutKhatRaneshInput, TestUncheckedUpdateWithoutKhatRaneshInput>
    create: XOR<TestCreateWithoutKhatRaneshInput, TestUncheckedCreateWithoutKhatRaneshInput>
  }

  export type TestUpdateWithWhereUniqueWithoutKhatRaneshInput = {
    where: TestWhereUniqueInput
    data: XOR<TestUpdateWithoutKhatRaneshInput, TestUncheckedUpdateWithoutKhatRaneshInput>
  }

  export type TestUpdateManyWithWhereWithoutKhatRaneshInput = {
    where: TestScalarWhereInput
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyWithoutKhatRaneshInput>
  }

  export type TestScalarWhereInput = {
    AND?: TestScalarWhereInput | TestScalarWhereInput[]
    OR?: TestScalarWhereInput[]
    NOT?: TestScalarWhereInput | TestScalarWhereInput[]
    IdTest?: IntFilter<"Test"> | number
    FIdRanesh?: IntFilter<"Test"> | number
    FIdTarDor?: IntFilter<"Test"> | number
    Test?: IntFilter<"Test"> | number
  }

  export type KhatRaneshCreateWithoutKhatRaneshAreaInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutKhatRaneshAreaInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutKhatRaneshAreaInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedCreateWithoutKhatRaneshAreaInput>
  }

  export type LandCreateWithoutKhatRaneshAreaInput = {
    IdLand: number
    Land: string
  }

  export type LandUncheckedCreateWithoutKhatRaneshAreaInput = {
    IdLand: number
    Land: string
  }

  export type LandCreateOrConnectWithoutKhatRaneshAreaInput = {
    where: LandWhereUniqueInput
    create: XOR<LandCreateWithoutKhatRaneshAreaInput, LandUncheckedCreateWithoutKhatRaneshAreaInput>
  }

  export type NetworkCreateWithoutKhatRaneshAreaInput = {
    Network: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutNetworkInput
    SystemPart: SystemPartCreateNestedOneWithoutNetworkInput
    PumpStation?: PumpStationCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateWithoutKhatRaneshAreaInput = {
    IdNet?: number
    Network: string
    FIdSP: number
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkCreateOrConnectWithoutKhatRaneshAreaInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutKhatRaneshAreaInput, NetworkUncheckedCreateWithoutKhatRaneshAreaInput>
  }

  export type KhatRaneshUpsertWithoutKhatRaneshAreaInput = {
    update: XOR<KhatRaneshUpdateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshAreaInput>
    create: XOR<KhatRaneshCreateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedCreateWithoutKhatRaneshAreaInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshAreaInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutKhatRaneshAreaInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type KhatRaneshUpdateWithoutKhatRaneshAreaInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutKhatRaneshAreaInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type LandUpsertWithoutKhatRaneshAreaInput = {
    update: XOR<LandUpdateWithoutKhatRaneshAreaInput, LandUncheckedUpdateWithoutKhatRaneshAreaInput>
    create: XOR<LandCreateWithoutKhatRaneshAreaInput, LandUncheckedCreateWithoutKhatRaneshAreaInput>
    where?: LandWhereInput
  }

  export type LandUpdateToOneWithWhereWithoutKhatRaneshAreaInput = {
    where?: LandWhereInput
    data: XOR<LandUpdateWithoutKhatRaneshAreaInput, LandUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type LandUpdateWithoutKhatRaneshAreaInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type LandUncheckedUpdateWithoutKhatRaneshAreaInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkUpsertWithoutKhatRaneshAreaInput = {
    update: XOR<NetworkUpdateWithoutKhatRaneshAreaInput, NetworkUncheckedUpdateWithoutKhatRaneshAreaInput>
    create: XOR<NetworkCreateWithoutKhatRaneshAreaInput, NetworkUncheckedCreateWithoutKhatRaneshAreaInput>
    where?: NetworkWhereInput
  }

  export type NetworkUpdateToOneWithWhereWithoutKhatRaneshAreaInput = {
    where?: NetworkWhereInput
    data: XOR<NetworkUpdateWithoutKhatRaneshAreaInput, NetworkUncheckedUpdateWithoutKhatRaneshAreaInput>
  }

  export type NetworkUpdateWithoutKhatRaneshAreaInput = {
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutNetworkNestedInput
    SystemPart?: SystemPartUpdateOneRequiredWithoutNetworkNestedInput
    PumpStation?: PumpStationUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateWithoutKhatRaneshAreaInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUncheckedUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type KhatRaneshCreateWithoutKhatRaneshPumpInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutKhatRaneshPumpInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutKhatRaneshPumpInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedCreateWithoutKhatRaneshPumpInput>
  }

  export type PumpTypeCreateWithoutKhatRaneshPumpInput = {
    PumpType: string
  }

  export type PumpTypeUncheckedCreateWithoutKhatRaneshPumpInput = {
    IdPump?: number
    PumpType: string
  }

  export type PumpTypeCreateOrConnectWithoutKhatRaneshPumpInput = {
    where: PumpTypeWhereUniqueInput
    create: XOR<PumpTypeCreateWithoutKhatRaneshPumpInput, PumpTypeUncheckedCreateWithoutKhatRaneshPumpInput>
  }

  export type KhatRaneshUpsertWithoutKhatRaneshPumpInput = {
    update: XOR<KhatRaneshUpdateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshPumpInput>
    create: XOR<KhatRaneshCreateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedCreateWithoutKhatRaneshPumpInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshPumpInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutKhatRaneshPumpInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshPumpInput>
  }

  export type KhatRaneshUpdateWithoutKhatRaneshPumpInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutKhatRaneshPumpInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type PumpTypeUpsertWithoutKhatRaneshPumpInput = {
    update: XOR<PumpTypeUpdateWithoutKhatRaneshPumpInput, PumpTypeUncheckedUpdateWithoutKhatRaneshPumpInput>
    create: XOR<PumpTypeCreateWithoutKhatRaneshPumpInput, PumpTypeUncheckedCreateWithoutKhatRaneshPumpInput>
    where?: PumpTypeWhereInput
  }

  export type PumpTypeUpdateToOneWithWhereWithoutKhatRaneshPumpInput = {
    where?: PumpTypeWhereInput
    data: XOR<PumpTypeUpdateWithoutKhatRaneshPumpInput, PumpTypeUncheckedUpdateWithoutKhatRaneshPumpInput>
  }

  export type PumpTypeUpdateWithoutKhatRaneshPumpInput = {
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type PumpTypeUncheckedUpdateWithoutKhatRaneshPumpInput = {
    IdPump?: IntFieldUpdateOperationsInput | number
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type KhatRaneshCreateWithoutKhatRaneshSegliInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutKhatRaneshSegliInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutKhatRaneshSegliInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedCreateWithoutKhatRaneshSegliInput>
  }

  export type KhatRaneshUpsertWithoutKhatRaneshSegliInput = {
    update: XOR<KhatRaneshUpdateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshSegliInput>
    create: XOR<KhatRaneshCreateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedCreateWithoutKhatRaneshSegliInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutKhatRaneshSegliInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutKhatRaneshSegliInput, KhatRaneshUncheckedUpdateWithoutKhatRaneshSegliInput>
  }

  export type KhatRaneshUpdateWithoutKhatRaneshSegliInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutKhatRaneshSegliInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type AbgirCreateWithoutKontorInput = {
    Abgir: string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutAbgirInput
  }

  export type AbgirUncheckedCreateWithoutKontorInput = {
    IdKontor?: number
    FIdRanesh: number
    Abgir: string
  }

  export type AbgirCreateOrConnectWithoutKontorInput = {
    where: AbgirWhereUniqueInput
    create: XOR<AbgirCreateWithoutKontorInput, AbgirUncheckedCreateWithoutKontorInput>
  }

  export type TrikhDoreKeshtCreateWithoutKontorInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutKontorInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutKontorInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutKontorInput, TrikhDoreKeshtUncheckedCreateWithoutKontorInput>
  }

  export type AbgirUpsertWithoutKontorInput = {
    update: XOR<AbgirUpdateWithoutKontorInput, AbgirUncheckedUpdateWithoutKontorInput>
    create: XOR<AbgirCreateWithoutKontorInput, AbgirUncheckedCreateWithoutKontorInput>
    where?: AbgirWhereInput
  }

  export type AbgirUpdateToOneWithWhereWithoutKontorInput = {
    where?: AbgirWhereInput
    data: XOR<AbgirUpdateWithoutKontorInput, AbgirUncheckedUpdateWithoutKontorInput>
  }

  export type AbgirUpdateWithoutKontorInput = {
    Abgir?: StringFieldUpdateOperationsInput | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutAbgirNestedInput
  }

  export type AbgirUncheckedUpdateWithoutKontorInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type TrikhDoreKeshtUpsertWithoutKontorInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutKontorInput, TrikhDoreKeshtUncheckedUpdateWithoutKontorInput>
    create: XOR<TrikhDoreKeshtCreateWithoutKontorInput, TrikhDoreKeshtUncheckedCreateWithoutKontorInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutKontorInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutKontorInput, TrikhDoreKeshtUncheckedUpdateWithoutKontorInput>
  }

  export type TrikhDoreKeshtUpdateWithoutKontorInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutKontorInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshAreaCreateWithoutLandInput = {
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshAreaInput
    Network: NetworkCreateNestedOneWithoutKhatRaneshAreaInput
  }

  export type KhatRaneshAreaUncheckedCreateWithoutLandInput = {
    IdRanesh?: number
    FIdRanesh: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateOrConnectWithoutLandInput = {
    where: KhatRaneshAreaWhereUniqueInput
    create: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput>
  }

  export type KhatRaneshAreaCreateManyLandInputEnvelope = {
    data: KhatRaneshAreaCreateManyLandInput | KhatRaneshAreaCreateManyLandInput[]
  }

  export type KhatRaneshAreaUpsertWithWhereUniqueWithoutLandInput = {
    where: KhatRaneshAreaWhereUniqueInput
    update: XOR<KhatRaneshAreaUpdateWithoutLandInput, KhatRaneshAreaUncheckedUpdateWithoutLandInput>
    create: XOR<KhatRaneshAreaCreateWithoutLandInput, KhatRaneshAreaUncheckedCreateWithoutLandInput>
  }

  export type KhatRaneshAreaUpdateWithWhereUniqueWithoutLandInput = {
    where: KhatRaneshAreaWhereUniqueInput
    data: XOR<KhatRaneshAreaUpdateWithoutLandInput, KhatRaneshAreaUncheckedUpdateWithoutLandInput>
  }

  export type KhatRaneshAreaUpdateManyWithWhereWithoutLandInput = {
    where: KhatRaneshAreaScalarWhereInput
    data: XOR<KhatRaneshAreaUpdateManyMutationInput, KhatRaneshAreaUncheckedUpdateManyWithoutLandInput>
  }

  export type KhatRaneshCreateWithoutMeasuringToolInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutMeasuringToolInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutMeasuringToolInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput>
  }

  export type KhatRaneshCreateManyMeasuringToolInputEnvelope = {
    data: KhatRaneshCreateManyMeasuringToolInput | KhatRaneshCreateManyMeasuringToolInput[]
  }

  export type KhatRaneshUpsertWithWhereUniqueWithoutMeasuringToolInput = {
    where: KhatRaneshWhereUniqueInput
    update: XOR<KhatRaneshUpdateWithoutMeasuringToolInput, KhatRaneshUncheckedUpdateWithoutMeasuringToolInput>
    create: XOR<KhatRaneshCreateWithoutMeasuringToolInput, KhatRaneshUncheckedCreateWithoutMeasuringToolInput>
  }

  export type KhatRaneshUpdateWithWhereUniqueWithoutMeasuringToolInput = {
    where: KhatRaneshWhereUniqueInput
    data: XOR<KhatRaneshUpdateWithoutMeasuringToolInput, KhatRaneshUncheckedUpdateWithoutMeasuringToolInput>
  }

  export type KhatRaneshUpdateManyWithWhereWithoutMeasuringToolInput = {
    where: KhatRaneshScalarWhereInput
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyWithoutMeasuringToolInput>
  }

  export type KhatRaneshCreateWithoutNashtShabakeInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutNashtShabakeInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutNashtShabakeInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutNashtShabakeInput, KhatRaneshUncheckedCreateWithoutNashtShabakeInput>
  }

  export type TrikhDoreKeshtCreateWithoutNashtShabakeInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutNashtShabakeInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutNashtShabakeInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedCreateWithoutNashtShabakeInput>
  }

  export type KhatRaneshUpsertWithoutNashtShabakeInput = {
    update: XOR<KhatRaneshUpdateWithoutNashtShabakeInput, KhatRaneshUncheckedUpdateWithoutNashtShabakeInput>
    create: XOR<KhatRaneshCreateWithoutNashtShabakeInput, KhatRaneshUncheckedCreateWithoutNashtShabakeInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutNashtShabakeInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutNashtShabakeInput, KhatRaneshUncheckedUpdateWithoutNashtShabakeInput>
  }

  export type KhatRaneshUpdateWithoutNashtShabakeInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutNashtShabakeInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutNashtShabakeInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedUpdateWithoutNashtShabakeInput>
    create: XOR<TrikhDoreKeshtCreateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedCreateWithoutNashtShabakeInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutNashtShabakeInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutNashtShabakeInput, TrikhDoreKeshtUncheckedUpdateWithoutNashtShabakeInput>
  }

  export type TrikhDoreKeshtUpdateWithoutNashtShabakeInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutNashtShabakeInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type BareshMotaleatCreateWithoutNetworkInput = {
    BareshMotaleat: Decimal | DecimalJsLike | number | string
    Mah: MahShamsiCreateNestedOneWithoutBareshMotaleatInput
  }

  export type BareshMotaleatUncheckedCreateWithoutNetworkInput = {
    IdBarMot?: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateOrConnectWithoutNetworkInput = {
    where: BareshMotaleatWhereUniqueInput
    create: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput>
  }

  export type BareshMotaleatCreateManyNetworkInputEnvelope = {
    data: BareshMotaleatCreateManyNetworkInput | BareshMotaleatCreateManyNetworkInput[]
  }

  export type KhatRaneshAreaCreateWithoutNetworkInput = {
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshAreaInput
    Land: LandCreateNestedOneWithoutKhatRaneshAreaInput
  }

  export type KhatRaneshAreaUncheckedCreateWithoutNetworkInput = {
    IdRanesh?: number
    FIdRanesh: number
    FIdLand: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateOrConnectWithoutNetworkInput = {
    where: KhatRaneshAreaWhereUniqueInput
    create: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput>
  }

  export type KhatRaneshAreaCreateManyNetworkInputEnvelope = {
    data: KhatRaneshAreaCreateManyNetworkInput | KhatRaneshAreaCreateManyNetworkInput[]
  }

  export type SystemPartCreateWithoutNetworkInput = {
    Part: string
    KM: number
  }

  export type SystemPartUncheckedCreateWithoutNetworkInput = {
    IdSP?: number
    Part: string
    KM: number
  }

  export type SystemPartCreateOrConnectWithoutNetworkInput = {
    where: SystemPartWhereUniqueInput
    create: XOR<SystemPartCreateWithoutNetworkInput, SystemPartUncheckedCreateWithoutNetworkInput>
  }

  export type PumpStationCreateWithoutNetworkInput = {
    NameStation: string
    KM?: number | null
    Ready?: boolean
    KhatRanesh?: KhatRaneshCreateNestedManyWithoutPumpStationInput
    AbadeMakhzan?: AbadeMakhzanCreateNestedOneWithoutPumpStationInput
    DarjeStation: DarjeStationCreateNestedOneWithoutPumpStationInput
    DeliveryPoint: DeliveryPointsCreateNestedOneWithoutPumpStationsInput
  }

  export type PumpStationUncheckedCreateWithoutNetworkInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdDStation: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
    KhatRanesh?: KhatRaneshUncheckedCreateNestedManyWithoutPumpStationInput
  }

  export type PumpStationCreateOrConnectWithoutNetworkInput = {
    where: PumpStationWhereUniqueInput
    create: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput>
  }

  export type PumpStationCreateManyNetworkInputEnvelope = {
    data: PumpStationCreateManyNetworkInput | PumpStationCreateManyNetworkInput[]
  }

  export type ShabakeDoreKeshtCreateWithoutNetworkInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutShabakeDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutShabakeDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    FIdDore: number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtCreateOrConnectWithoutNetworkInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    create: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput>
  }

  export type ShabakeDoreKeshtCreateManyNetworkInputEnvelope = {
    data: ShabakeDoreKeshtCreateManyNetworkInput | ShabakeDoreKeshtCreateManyNetworkInput[]
  }

  export type BareshMotaleatUpsertWithWhereUniqueWithoutNetworkInput = {
    where: BareshMotaleatWhereUniqueInput
    update: XOR<BareshMotaleatUpdateWithoutNetworkInput, BareshMotaleatUncheckedUpdateWithoutNetworkInput>
    create: XOR<BareshMotaleatCreateWithoutNetworkInput, BareshMotaleatUncheckedCreateWithoutNetworkInput>
  }

  export type BareshMotaleatUpdateWithWhereUniqueWithoutNetworkInput = {
    where: BareshMotaleatWhereUniqueInput
    data: XOR<BareshMotaleatUpdateWithoutNetworkInput, BareshMotaleatUncheckedUpdateWithoutNetworkInput>
  }

  export type BareshMotaleatUpdateManyWithWhereWithoutNetworkInput = {
    where: BareshMotaleatScalarWhereInput
    data: XOR<BareshMotaleatUpdateManyMutationInput, BareshMotaleatUncheckedUpdateManyWithoutNetworkInput>
  }

  export type BareshMotaleatScalarWhereInput = {
    AND?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
    OR?: BareshMotaleatScalarWhereInput[]
    NOT?: BareshMotaleatScalarWhereInput | BareshMotaleatScalarWhereInput[]
    IdBarMot?: IntFilter<"BareshMotaleat"> | number
    FIdNet?: IntFilter<"BareshMotaleat"> | number
    FIdMah?: IntFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpsertWithWhereUniqueWithoutNetworkInput = {
    where: KhatRaneshAreaWhereUniqueInput
    update: XOR<KhatRaneshAreaUpdateWithoutNetworkInput, KhatRaneshAreaUncheckedUpdateWithoutNetworkInput>
    create: XOR<KhatRaneshAreaCreateWithoutNetworkInput, KhatRaneshAreaUncheckedCreateWithoutNetworkInput>
  }

  export type KhatRaneshAreaUpdateWithWhereUniqueWithoutNetworkInput = {
    where: KhatRaneshAreaWhereUniqueInput
    data: XOR<KhatRaneshAreaUpdateWithoutNetworkInput, KhatRaneshAreaUncheckedUpdateWithoutNetworkInput>
  }

  export type KhatRaneshAreaUpdateManyWithWhereWithoutNetworkInput = {
    where: KhatRaneshAreaScalarWhereInput
    data: XOR<KhatRaneshAreaUpdateManyMutationInput, KhatRaneshAreaUncheckedUpdateManyWithoutNetworkInput>
  }

  export type SystemPartUpsertWithoutNetworkInput = {
    update: XOR<SystemPartUpdateWithoutNetworkInput, SystemPartUncheckedUpdateWithoutNetworkInput>
    create: XOR<SystemPartCreateWithoutNetworkInput, SystemPartUncheckedCreateWithoutNetworkInput>
    where?: SystemPartWhereInput
  }

  export type SystemPartUpdateToOneWithWhereWithoutNetworkInput = {
    where?: SystemPartWhereInput
    data: XOR<SystemPartUpdateWithoutNetworkInput, SystemPartUncheckedUpdateWithoutNetworkInput>
  }

  export type SystemPartUpdateWithoutNetworkInput = {
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type SystemPartUncheckedUpdateWithoutNetworkInput = {
    IdSP?: IntFieldUpdateOperationsInput | number
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type PumpStationUpsertWithWhereUniqueWithoutNetworkInput = {
    where: PumpStationWhereUniqueInput
    update: XOR<PumpStationUpdateWithoutNetworkInput, PumpStationUncheckedUpdateWithoutNetworkInput>
    create: XOR<PumpStationCreateWithoutNetworkInput, PumpStationUncheckedCreateWithoutNetworkInput>
  }

  export type PumpStationUpdateWithWhereUniqueWithoutNetworkInput = {
    where: PumpStationWhereUniqueInput
    data: XOR<PumpStationUpdateWithoutNetworkInput, PumpStationUncheckedUpdateWithoutNetworkInput>
  }

  export type PumpStationUpdateManyWithWhereWithoutNetworkInput = {
    where: PumpStationScalarWhereInput
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyWithoutNetworkInput>
  }

  export type ShabakeDoreKeshtUpsertWithWhereUniqueWithoutNetworkInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    update: XOR<ShabakeDoreKeshtUpdateWithoutNetworkInput, ShabakeDoreKeshtUncheckedUpdateWithoutNetworkInput>
    create: XOR<ShabakeDoreKeshtCreateWithoutNetworkInput, ShabakeDoreKeshtUncheckedCreateWithoutNetworkInput>
  }

  export type ShabakeDoreKeshtUpdateWithWhereUniqueWithoutNetworkInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    data: XOR<ShabakeDoreKeshtUpdateWithoutNetworkInput, ShabakeDoreKeshtUncheckedUpdateWithoutNetworkInput>
  }

  export type ShabakeDoreKeshtUpdateManyWithWhereWithoutNetworkInput = {
    where: ShabakeDoreKeshtScalarWhereInput
    data: XOR<ShabakeDoreKeshtUpdateManyMutationInput, ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkInput>
  }

  export type NoeMahsoolCreateWithoutNoeKeshtInput = {
    Mahsool: string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutNoeMahsoolInput
  }

  export type NoeMahsoolUncheckedCreateWithoutNoeKeshtInput = {
    IdNoeM?: number
    Mahsool: string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutNoeMahsoolInput
  }

  export type NoeMahsoolCreateOrConnectWithoutNoeKeshtInput = {
    where: NoeMahsoolWhereUniqueInput
    create: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput>
  }

  export type NoeMahsoolCreateManyNoeKeshtInputEnvelope = {
    data: NoeMahsoolCreateManyNoeKeshtInput | NoeMahsoolCreateManyNoeKeshtInput[]
  }

  export type NoeMahsoolUpsertWithWhereUniqueWithoutNoeKeshtInput = {
    where: NoeMahsoolWhereUniqueInput
    update: XOR<NoeMahsoolUpdateWithoutNoeKeshtInput, NoeMahsoolUncheckedUpdateWithoutNoeKeshtInput>
    create: XOR<NoeMahsoolCreateWithoutNoeKeshtInput, NoeMahsoolUncheckedCreateWithoutNoeKeshtInput>
  }

  export type NoeMahsoolUpdateWithWhereUniqueWithoutNoeKeshtInput = {
    where: NoeMahsoolWhereUniqueInput
    data: XOR<NoeMahsoolUpdateWithoutNoeKeshtInput, NoeMahsoolUncheckedUpdateWithoutNoeKeshtInput>
  }

  export type NoeMahsoolUpdateManyWithWhereWithoutNoeKeshtInput = {
    where: NoeMahsoolScalarWhereInput
    data: XOR<NoeMahsoolUpdateManyMutationInput, NoeMahsoolUncheckedUpdateManyWithoutNoeKeshtInput>
  }

  export type NoeMahsoolScalarWhereInput = {
    AND?: NoeMahsoolScalarWhereInput | NoeMahsoolScalarWhereInput[]
    OR?: NoeMahsoolScalarWhereInput[]
    NOT?: NoeMahsoolScalarWhereInput | NoeMahsoolScalarWhereInput[]
    IdNoeM?: IntFilter<"NoeMahsool"> | number
    Mahsool?: StringFilter<"NoeMahsool"> | string
    FIdNoeK?: IntFilter<"NoeMahsool"> | number
  }

  export type BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput = {
    IdBahDor: number
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardariKeshtDoreInput
    ShabakeDoreKesht: ShabakeDoreKeshtCreateNestedOneWithoutBahrebardariKeshtDoreInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreCreateOrConnectWithoutNoeMahsoolInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    create: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput>
  }

  export type BahrebardariKeshtDoreCreateManyNoeMahsoolInputEnvelope = {
    data: BahrebardariKeshtDoreCreateManyNoeMahsoolInput | BahrebardariKeshtDoreCreateManyNoeMahsoolInput[]
  }

  export type NoeKeshtCreateWithoutNoeMahsoolInput = {
    Kesht: string
  }

  export type NoeKeshtUncheckedCreateWithoutNoeMahsoolInput = {
    IdNoeK?: number
    Kesht: string
  }

  export type NoeKeshtCreateOrConnectWithoutNoeMahsoolInput = {
    where: NoeKeshtWhereUniqueInput
    create: XOR<NoeKeshtCreateWithoutNoeMahsoolInput, NoeKeshtUncheckedCreateWithoutNoeMahsoolInput>
  }

  export type BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutNoeMahsoolInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    update: XOR<BahrebardariKeshtDoreUpdateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedUpdateWithoutNoeMahsoolInput>
    create: XOR<BahrebardariKeshtDoreCreateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedCreateWithoutNoeMahsoolInput>
  }

  export type BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutNoeMahsoolInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    data: XOR<BahrebardariKeshtDoreUpdateWithoutNoeMahsoolInput, BahrebardariKeshtDoreUncheckedUpdateWithoutNoeMahsoolInput>
  }

  export type BahrebardariKeshtDoreUpdateManyWithWhereWithoutNoeMahsoolInput = {
    where: BahrebardariKeshtDoreScalarWhereInput
    data: XOR<BahrebardariKeshtDoreUpdateManyMutationInput, BahrebardariKeshtDoreUncheckedUpdateManyWithoutNoeMahsoolInput>
  }

  export type NoeKeshtUpsertWithoutNoeMahsoolInput = {
    update: XOR<NoeKeshtUpdateWithoutNoeMahsoolInput, NoeKeshtUncheckedUpdateWithoutNoeMahsoolInput>
    create: XOR<NoeKeshtCreateWithoutNoeMahsoolInput, NoeKeshtUncheckedCreateWithoutNoeMahsoolInput>
    where?: NoeKeshtWhereInput
  }

  export type NoeKeshtUpdateToOneWithWhereWithoutNoeMahsoolInput = {
    where?: NoeKeshtWhereInput
    data: XOR<NoeKeshtUpdateWithoutNoeMahsoolInput, NoeKeshtUncheckedUpdateWithoutNoeMahsoolInput>
  }

  export type NoeKeshtUpdateWithoutNoeMahsoolInput = {
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeKeshtUncheckedUpdateWithoutNoeMahsoolInput = {
    IdNoeK?: IntFieldUpdateOperationsInput | number
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type KhatRaneshCreateWithoutNonFITInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutNonFITInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutNonFITInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutNonFITInput, KhatRaneshUncheckedCreateWithoutNonFITInput>
  }

  export type TrikhDoreKeshtCreateWithoutNonFITInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutNonFITInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutNonFITInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutNonFITInput, TrikhDoreKeshtUncheckedCreateWithoutNonFITInput>
  }

  export type KhatRaneshUpsertWithoutNonFITInput = {
    update: XOR<KhatRaneshUpdateWithoutNonFITInput, KhatRaneshUncheckedUpdateWithoutNonFITInput>
    create: XOR<KhatRaneshCreateWithoutNonFITInput, KhatRaneshUncheckedCreateWithoutNonFITInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutNonFITInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutNonFITInput, KhatRaneshUncheckedUpdateWithoutNonFITInput>
  }

  export type KhatRaneshUpdateWithoutNonFITInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutNonFITInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutNonFITInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutNonFITInput, TrikhDoreKeshtUncheckedUpdateWithoutNonFITInput>
    create: XOR<TrikhDoreKeshtCreateWithoutNonFITInput, TrikhDoreKeshtUncheckedCreateWithoutNonFITInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutNonFITInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutNonFITInput, TrikhDoreKeshtUncheckedUpdateWithoutNonFITInput>
  }

  export type TrikhDoreKeshtUpdateWithoutNonFITInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutNonFITInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutPumpStationInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutPumpStationInput = {
    IdRanesh?: number
    RaneshName: string
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutPumpStationInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput>
  }

  export type KhatRaneshCreateManyPumpStationInputEnvelope = {
    data: KhatRaneshCreateManyPumpStationInput | KhatRaneshCreateManyPumpStationInput[]
  }

  export type AbadeMakhzanCreateWithoutPumpStationInput = {
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanUncheckedCreateWithoutPumpStationInput = {
    IdMakhzan?: number
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanCreateOrConnectWithoutPumpStationInput = {
    where: AbadeMakhzanWhereUniqueInput
    create: XOR<AbadeMakhzanCreateWithoutPumpStationInput, AbadeMakhzanUncheckedCreateWithoutPumpStationInput>
  }

  export type DarjeStationCreateWithoutPumpStationInput = {
    DarajeStation: string
  }

  export type DarjeStationUncheckedCreateWithoutPumpStationInput = {
    IdDStation?: number
    DarajeStation: string
  }

  export type DarjeStationCreateOrConnectWithoutPumpStationInput = {
    where: DarjeStationWhereUniqueInput
    create: XOR<DarjeStationCreateWithoutPumpStationInput, DarjeStationUncheckedCreateWithoutPumpStationInput>
  }

  export type DeliveryPointsCreateWithoutPumpStationsInput = {
    DeliveryPoint: string
  }

  export type DeliveryPointsUncheckedCreateWithoutPumpStationsInput = {
    IdDp?: number
    DeliveryPoint: string
  }

  export type DeliveryPointsCreateOrConnectWithoutPumpStationsInput = {
    where: DeliveryPointsWhereUniqueInput
    create: XOR<DeliveryPointsCreateWithoutPumpStationsInput, DeliveryPointsUncheckedCreateWithoutPumpStationsInput>
  }

  export type NetworkCreateWithoutPumpStationInput = {
    Network: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutNetworkInput
    SystemPart: SystemPartCreateNestedOneWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateWithoutPumpStationInput = {
    IdNet?: number
    Network: string
    FIdSP: number
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkCreateOrConnectWithoutPumpStationInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutPumpStationInput, NetworkUncheckedCreateWithoutPumpStationInput>
  }

  export type KhatRaneshUpsertWithWhereUniqueWithoutPumpStationInput = {
    where: KhatRaneshWhereUniqueInput
    update: XOR<KhatRaneshUpdateWithoutPumpStationInput, KhatRaneshUncheckedUpdateWithoutPumpStationInput>
    create: XOR<KhatRaneshCreateWithoutPumpStationInput, KhatRaneshUncheckedCreateWithoutPumpStationInput>
  }

  export type KhatRaneshUpdateWithWhereUniqueWithoutPumpStationInput = {
    where: KhatRaneshWhereUniqueInput
    data: XOR<KhatRaneshUpdateWithoutPumpStationInput, KhatRaneshUncheckedUpdateWithoutPumpStationInput>
  }

  export type KhatRaneshUpdateManyWithWhereWithoutPumpStationInput = {
    where: KhatRaneshScalarWhereInput
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyWithoutPumpStationInput>
  }

  export type AbadeMakhzanUpsertWithoutPumpStationInput = {
    update: XOR<AbadeMakhzanUpdateWithoutPumpStationInput, AbadeMakhzanUncheckedUpdateWithoutPumpStationInput>
    create: XOR<AbadeMakhzanCreateWithoutPumpStationInput, AbadeMakhzanUncheckedCreateWithoutPumpStationInput>
    where?: AbadeMakhzanWhereInput
  }

  export type AbadeMakhzanUpdateToOneWithWhereWithoutPumpStationInput = {
    where?: AbadeMakhzanWhereInput
    data: XOR<AbadeMakhzanUpdateWithoutPumpStationInput, AbadeMakhzanUncheckedUpdateWithoutPumpStationInput>
  }

  export type AbadeMakhzanUpdateWithoutPumpStationInput = {
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbadeMakhzanUncheckedUpdateWithoutPumpStationInput = {
    IdMakhzan?: IntFieldUpdateOperationsInput | number
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationUpsertWithoutPumpStationInput = {
    update: XOR<DarjeStationUpdateWithoutPumpStationInput, DarjeStationUncheckedUpdateWithoutPumpStationInput>
    create: XOR<DarjeStationCreateWithoutPumpStationInput, DarjeStationUncheckedCreateWithoutPumpStationInput>
    where?: DarjeStationWhereInput
  }

  export type DarjeStationUpdateToOneWithWhereWithoutPumpStationInput = {
    where?: DarjeStationWhereInput
    data: XOR<DarjeStationUpdateWithoutPumpStationInput, DarjeStationUncheckedUpdateWithoutPumpStationInput>
  }

  export type DarjeStationUpdateWithoutPumpStationInput = {
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationUncheckedUpdateWithoutPumpStationInput = {
    IdDStation?: IntFieldUpdateOperationsInput | number
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryPointsUpsertWithoutPumpStationsInput = {
    update: XOR<DeliveryPointsUpdateWithoutPumpStationsInput, DeliveryPointsUncheckedUpdateWithoutPumpStationsInput>
    create: XOR<DeliveryPointsCreateWithoutPumpStationsInput, DeliveryPointsUncheckedCreateWithoutPumpStationsInput>
    where?: DeliveryPointsWhereInput
  }

  export type DeliveryPointsUpdateToOneWithWhereWithoutPumpStationsInput = {
    where?: DeliveryPointsWhereInput
    data: XOR<DeliveryPointsUpdateWithoutPumpStationsInput, DeliveryPointsUncheckedUpdateWithoutPumpStationsInput>
  }

  export type DeliveryPointsUpdateWithoutPumpStationsInput = {
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryPointsUncheckedUpdateWithoutPumpStationsInput = {
    IdDp?: IntFieldUpdateOperationsInput | number
    DeliveryPoint?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkUpsertWithoutPumpStationInput = {
    update: XOR<NetworkUpdateWithoutPumpStationInput, NetworkUncheckedUpdateWithoutPumpStationInput>
    create: XOR<NetworkCreateWithoutPumpStationInput, NetworkUncheckedCreateWithoutPumpStationInput>
    where?: NetworkWhereInput
  }

  export type NetworkUpdateToOneWithWhereWithoutPumpStationInput = {
    where?: NetworkWhereInput
    data: XOR<NetworkUpdateWithoutPumpStationInput, NetworkUncheckedUpdateWithoutPumpStationInput>
  }

  export type NetworkUpdateWithoutPumpStationInput = {
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutNetworkNestedInput
    SystemPart?: SystemPartUpdateOneRequiredWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateWithoutPumpStationInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type KhatRaneshPumpCreateWithoutPumpTypeInput = {
    ModelPump?: string | null
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutKhatRaneshPumpInput
  }

  export type KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput = {
    IdRanesh?: number
    FIdRanesh: number
    ModelPump?: string | null
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpCreateOrConnectWithoutPumpTypeInput = {
    where: KhatRaneshPumpWhereUniqueInput
    create: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput>
  }

  export type KhatRaneshPumpCreateManyPumpTypeInputEnvelope = {
    data: KhatRaneshPumpCreateManyPumpTypeInput | KhatRaneshPumpCreateManyPumpTypeInput[]
  }

  export type KhatRaneshPumpUpsertWithWhereUniqueWithoutPumpTypeInput = {
    where: KhatRaneshPumpWhereUniqueInput
    update: XOR<KhatRaneshPumpUpdateWithoutPumpTypeInput, KhatRaneshPumpUncheckedUpdateWithoutPumpTypeInput>
    create: XOR<KhatRaneshPumpCreateWithoutPumpTypeInput, KhatRaneshPumpUncheckedCreateWithoutPumpTypeInput>
  }

  export type KhatRaneshPumpUpdateWithWhereUniqueWithoutPumpTypeInput = {
    where: KhatRaneshPumpWhereUniqueInput
    data: XOR<KhatRaneshPumpUpdateWithoutPumpTypeInput, KhatRaneshPumpUncheckedUpdateWithoutPumpTypeInput>
  }

  export type KhatRaneshPumpUpdateManyWithWhereWithoutPumpTypeInput = {
    where: KhatRaneshPumpScalarWhereInput
    data: XOR<KhatRaneshPumpUpdateManyMutationInput, KhatRaneshPumpUncheckedUpdateManyWithoutPumpTypeInput>
  }

  export type RainfallTypeCreateWithoutRainfallStationInput = {
    RainfallType: string
  }

  export type RainfallTypeUncheckedCreateWithoutRainfallStationInput = {
    IdRaiTy?: number
    RainfallType: string
  }

  export type RainfallTypeCreateOrConnectWithoutRainfallStationInput = {
    where: RainfallTypeWhereUniqueInput
    create: XOR<RainfallTypeCreateWithoutRainfallStationInput, RainfallTypeUncheckedCreateWithoutRainfallStationInput>
  }

  export type TrikhDoreKeshtCreateWithoutRainfallStationInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutRainfallStationInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutRainfallStationInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedCreateWithoutRainfallStationInput>
  }

  export type WeatherStationCreateWithoutRainfallStationInput = {
    Station: string
  }

  export type WeatherStationUncheckedCreateWithoutRainfallStationInput = {
    IdWeaSta?: number
    Station: string
  }

  export type WeatherStationCreateOrConnectWithoutRainfallStationInput = {
    where: WeatherStationWhereUniqueInput
    create: XOR<WeatherStationCreateWithoutRainfallStationInput, WeatherStationUncheckedCreateWithoutRainfallStationInput>
  }

  export type RainfallTypeUpsertWithoutRainfallStationInput = {
    update: XOR<RainfallTypeUpdateWithoutRainfallStationInput, RainfallTypeUncheckedUpdateWithoutRainfallStationInput>
    create: XOR<RainfallTypeCreateWithoutRainfallStationInput, RainfallTypeUncheckedCreateWithoutRainfallStationInput>
    where?: RainfallTypeWhereInput
  }

  export type RainfallTypeUpdateToOneWithWhereWithoutRainfallStationInput = {
    where?: RainfallTypeWhereInput
    data: XOR<RainfallTypeUpdateWithoutRainfallStationInput, RainfallTypeUncheckedUpdateWithoutRainfallStationInput>
  }

  export type RainfallTypeUpdateWithoutRainfallStationInput = {
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallTypeUncheckedUpdateWithoutRainfallStationInput = {
    IdRaiTy?: IntFieldUpdateOperationsInput | number
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type TrikhDoreKeshtUpsertWithoutRainfallStationInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedUpdateWithoutRainfallStationInput>
    create: XOR<TrikhDoreKeshtCreateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedCreateWithoutRainfallStationInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutRainfallStationInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutRainfallStationInput, TrikhDoreKeshtUncheckedUpdateWithoutRainfallStationInput>
  }

  export type TrikhDoreKeshtUpdateWithoutRainfallStationInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutRainfallStationInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type WeatherStationUpsertWithoutRainfallStationInput = {
    update: XOR<WeatherStationUpdateWithoutRainfallStationInput, WeatherStationUncheckedUpdateWithoutRainfallStationInput>
    create: XOR<WeatherStationCreateWithoutRainfallStationInput, WeatherStationUncheckedCreateWithoutRainfallStationInput>
    where?: WeatherStationWhereInput
  }

  export type WeatherStationUpdateToOneWithWhereWithoutRainfallStationInput = {
    where?: WeatherStationWhereInput
    data: XOR<WeatherStationUpdateWithoutRainfallStationInput, WeatherStationUncheckedUpdateWithoutRainfallStationInput>
  }

  export type WeatherStationUpdateWithoutRainfallStationInput = {
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationUncheckedUpdateWithoutRainfallStationInput = {
    IdWeaSta?: IntFieldUpdateOperationsInput | number
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallStationCreateWithoutRainfallTypeInput = {
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutRainfallStationInput
    WeatherStation: WeatherStationCreateNestedOneWithoutRainfallStationInput
  }

  export type RainfallStationUncheckedCreateWithoutRainfallTypeInput = {
    IdRaiSta?: number
    FIdWeaSta: number
    FIdTrikh: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationCreateOrConnectWithoutRainfallTypeInput = {
    where: RainfallStationWhereUniqueInput
    create: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput>
  }

  export type RainfallStationCreateManyRainfallTypeInputEnvelope = {
    data: RainfallStationCreateManyRainfallTypeInput | RainfallStationCreateManyRainfallTypeInput[]
  }

  export type RainfallStationUpsertWithWhereUniqueWithoutRainfallTypeInput = {
    where: RainfallStationWhereUniqueInput
    update: XOR<RainfallStationUpdateWithoutRainfallTypeInput, RainfallStationUncheckedUpdateWithoutRainfallTypeInput>
    create: XOR<RainfallStationCreateWithoutRainfallTypeInput, RainfallStationUncheckedCreateWithoutRainfallTypeInput>
  }

  export type RainfallStationUpdateWithWhereUniqueWithoutRainfallTypeInput = {
    where: RainfallStationWhereUniqueInput
    data: XOR<RainfallStationUpdateWithoutRainfallTypeInput, RainfallStationUncheckedUpdateWithoutRainfallTypeInput>
  }

  export type RainfallStationUpdateManyWithWhereWithoutRainfallTypeInput = {
    where: RainfallStationScalarWhereInput
    data: XOR<RainfallStationUpdateManyMutationInput, RainfallStationUncheckedUpdateManyWithoutRainfallTypeInput>
  }

  export type RainfallStationScalarWhereInput = {
    AND?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
    OR?: RainfallStationScalarWhereInput[]
    NOT?: RainfallStationScalarWhereInput | RainfallStationScalarWhereInput[]
    IdRaiSta?: IntFilter<"RainfallStation"> | number
    FIdWeaSta?: IntFilter<"RainfallStation"> | number
    FIdTrikh?: IntFilter<"RainfallStation"> | number
    FIdRaiTy?: IntFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
  }

  export type ShabakeDoreKeshtCreateWithoutSaleZeraeeInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutShabakeDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutShabakeDoreKeshtInput
    Network: NetworkCreateNestedOneWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdDore: number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutShabakeDoreKeshtInput
  }

  export type ShabakeDoreKeshtCreateOrConnectWithoutSaleZeraeeInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    create: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput>
  }

  export type ShabakeDoreKeshtCreateManySaleZeraeeInputEnvelope = {
    data: ShabakeDoreKeshtCreateManySaleZeraeeInput | ShabakeDoreKeshtCreateManySaleZeraeeInput[]
  }

  export type TrikhDoreKeshtCreateWithoutSaleZeraeeInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput = {
    IdTarDor?: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutSaleZeraeeInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput>
  }

  export type TrikhDoreKeshtCreateManySaleZeraeeInputEnvelope = {
    data: TrikhDoreKeshtCreateManySaleZeraeeInput | TrikhDoreKeshtCreateManySaleZeraeeInput[]
  }

  export type ShabakeDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    update: XOR<ShabakeDoreKeshtUpdateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput>
    create: XOR<ShabakeDoreKeshtCreateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedCreateWithoutSaleZeraeeInput>
  }

  export type ShabakeDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput = {
    where: ShabakeDoreKeshtWhereUniqueInput
    data: XOR<ShabakeDoreKeshtUpdateWithoutSaleZeraeeInput, ShabakeDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput>
  }

  export type ShabakeDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput = {
    where: ShabakeDoreKeshtScalarWhereInput
    data: XOR<ShabakeDoreKeshtUpdateManyMutationInput, ShabakeDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeInput>
  }

  export type TrikhDoreKeshtUpsertWithWhereUniqueWithoutSaleZeraeeInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    update: XOR<TrikhDoreKeshtUpdateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput>
    create: XOR<TrikhDoreKeshtCreateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedCreateWithoutSaleZeraeeInput>
  }

  export type TrikhDoreKeshtUpdateWithWhereUniqueWithoutSaleZeraeeInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    data: XOR<TrikhDoreKeshtUpdateWithoutSaleZeraeeInput, TrikhDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput>
  }

  export type TrikhDoreKeshtUpdateManyWithWhereWithoutSaleZeraeeInput = {
    where: TrikhDoreKeshtScalarWhereInput
    data: XOR<TrikhDoreKeshtUpdateManyMutationInput, TrikhDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeInput>
  }

  export type KhatRaneshCreateWithoutSeghliPumpInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutSeghliPumpInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutSeghliPumpInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput>
  }

  export type KhatRaneshCreateManySeghliPumpInputEnvelope = {
    data: KhatRaneshCreateManySeghliPumpInput | KhatRaneshCreateManySeghliPumpInput[]
  }

  export type KhatRaneshUpsertWithWhereUniqueWithoutSeghliPumpInput = {
    where: KhatRaneshWhereUniqueInput
    update: XOR<KhatRaneshUpdateWithoutSeghliPumpInput, KhatRaneshUncheckedUpdateWithoutSeghliPumpInput>
    create: XOR<KhatRaneshCreateWithoutSeghliPumpInput, KhatRaneshUncheckedCreateWithoutSeghliPumpInput>
  }

  export type KhatRaneshUpdateWithWhereUniqueWithoutSeghliPumpInput = {
    where: KhatRaneshWhereUniqueInput
    data: XOR<KhatRaneshUpdateWithoutSeghliPumpInput, KhatRaneshUncheckedUpdateWithoutSeghliPumpInput>
  }

  export type KhatRaneshUpdateManyWithWhereWithoutSeghliPumpInput = {
    where: KhatRaneshScalarWhereInput
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyWithoutSeghliPumpInput>
  }

  export type NetworkCreateWithoutSystemPartInput = {
    Network: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateWithoutSystemPartInput = {
    IdNet?: number
    Network: string
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutNetworkInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkCreateOrConnectWithoutSystemPartInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput>
  }

  export type NetworkCreateManySystemPartInputEnvelope = {
    data: NetworkCreateManySystemPartInput | NetworkCreateManySystemPartInput[]
  }

  export type NetworkUpsertWithWhereUniqueWithoutSystemPartInput = {
    where: NetworkWhereUniqueInput
    update: XOR<NetworkUpdateWithoutSystemPartInput, NetworkUncheckedUpdateWithoutSystemPartInput>
    create: XOR<NetworkCreateWithoutSystemPartInput, NetworkUncheckedCreateWithoutSystemPartInput>
  }

  export type NetworkUpdateWithWhereUniqueWithoutSystemPartInput = {
    where: NetworkWhereUniqueInput
    data: XOR<NetworkUpdateWithoutSystemPartInput, NetworkUncheckedUpdateWithoutSystemPartInput>
  }

  export type NetworkUpdateManyWithWhereWithoutSystemPartInput = {
    where: NetworkScalarWhereInput
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyWithoutSystemPartInput>
  }

  export type NetworkScalarWhereInput = {
    AND?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
    OR?: NetworkScalarWhereInput[]
    NOT?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
    IdNet?: IntFilter<"Network"> | number
    Network?: StringFilter<"Network"> | string
    FIdSP?: IntFilter<"Network"> | number
  }

  export type KhatRaneshCreateWithoutTakhlieMakhzanInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    Test?: TestCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutTakhlieMakhzanInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    Test?: TestUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutTakhlieMakhzanInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedCreateWithoutTakhlieMakhzanInput>
  }

  export type TrikhDoreKeshtCreateWithoutTakhlieMakhzanInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutTakhlieMakhzanInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutTakhlieMakhzanInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedCreateWithoutTakhlieMakhzanInput>
  }

  export type KhatRaneshUpsertWithoutTakhlieMakhzanInput = {
    update: XOR<KhatRaneshUpdateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedUpdateWithoutTakhlieMakhzanInput>
    create: XOR<KhatRaneshCreateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedCreateWithoutTakhlieMakhzanInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutTakhlieMakhzanInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutTakhlieMakhzanInput, KhatRaneshUncheckedUpdateWithoutTakhlieMakhzanInput>
  }

  export type KhatRaneshUpdateWithoutTakhlieMakhzanInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutTakhlieMakhzanInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutTakhlieMakhzanInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedUpdateWithoutTakhlieMakhzanInput>
    create: XOR<TrikhDoreKeshtCreateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedCreateWithoutTakhlieMakhzanInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutTakhlieMakhzanInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutTakhlieMakhzanInput, TrikhDoreKeshtUncheckedUpdateWithoutTakhlieMakhzanInput>
  }

  export type TrikhDoreKeshtUpdateWithoutTakhlieMakhzanInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutTakhlieMakhzanInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type KhatRaneshCreateWithoutTestInput = {
    RaneshName: string
    Active?: boolean
    Abgir?: AbgirCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutKhatRaneshInput
    DarajePipe: DarajePipeCreateNestedOneWithoutKhatRaneshInput
    MeasuringTool: MeasuringToolCreateNestedOneWithoutKhatRaneshInput
    PumpStation: PumpStationCreateNestedOneWithoutKhatRaneshInput
    SeghliPump: SeghliPumpCreateNestedOneWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshUncheckedCreateWithoutTestInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
    Abgir?: AbgirUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedCreateNestedManyWithoutKhatRaneshInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutKhatRaneshInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutKhatRaneshInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutKhatRaneshInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedCreateNestedManyWithoutKhatRaneshInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedCreateNestedManyWithoutKhatRaneshInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutKhatRaneshInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutKhatRaneshInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutKhatRaneshInput
  }

  export type KhatRaneshCreateOrConnectWithoutTestInput = {
    where: KhatRaneshWhereUniqueInput
    create: XOR<KhatRaneshCreateWithoutTestInput, KhatRaneshUncheckedCreateWithoutTestInput>
  }

  export type TrikhDoreKeshtCreateWithoutTestInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    MahShamsi: MahShamsiCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutTestInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutTestInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutTestInput, TrikhDoreKeshtUncheckedCreateWithoutTestInput>
  }

  export type KhatRaneshUpsertWithoutTestInput = {
    update: XOR<KhatRaneshUpdateWithoutTestInput, KhatRaneshUncheckedUpdateWithoutTestInput>
    create: XOR<KhatRaneshCreateWithoutTestInput, KhatRaneshUncheckedCreateWithoutTestInput>
    where?: KhatRaneshWhereInput
  }

  export type KhatRaneshUpdateToOneWithWhereWithoutTestInput = {
    where?: KhatRaneshWhereInput
    data: XOR<KhatRaneshUpdateWithoutTestInput, KhatRaneshUncheckedUpdateWithoutTestInput>
  }

  export type KhatRaneshUpdateWithoutTestInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutTestInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type TrikhDoreKeshtUpsertWithoutTestInput = {
    update: XOR<TrikhDoreKeshtUpdateWithoutTestInput, TrikhDoreKeshtUncheckedUpdateWithoutTestInput>
    create: XOR<TrikhDoreKeshtCreateWithoutTestInput, TrikhDoreKeshtUncheckedCreateWithoutTestInput>
    where?: TrikhDoreKeshtWhereInput
  }

  export type TrikhDoreKeshtUpdateToOneWithWhereWithoutTestInput = {
    where?: TrikhDoreKeshtWhereInput
    data: XOR<TrikhDoreKeshtUpdateWithoutTestInput, TrikhDoreKeshtUncheckedUpdateWithoutTestInput>
  }

  export type TrikhDoreKeshtUpdateWithoutTestInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutTestInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type BahrebardairProgramCreateWithoutTrikhDoreKeshtInput = {
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardairProgramInput
  }

  export type BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdProgram?: number
    FIdRanesh: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramWhereUniqueInput
    create: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramCreateManyTrikhDoreKeshtInputEnvelope = {
    data: BahrebardairProgramCreateManyTrikhDoreKeshtInput | BahrebardairProgramCreateManyTrikhDoreKeshtInput[]
  }

  export type BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput = {
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardairProgramSeghliInput
  }

  export type BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdProSrgl?: number
    FIdRanesh: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    create: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInputEnvelope = {
    data: BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInput | BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInput[]
  }

  export type BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput = {
    Taghvim: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardariTaghvimInput
  }

  export type BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdTag?: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    create: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardariTaghvimCreateManyTrikhDoreKeshtInputEnvelope = {
    data: BahrebardariTaghvimCreateManyTrikhDoreKeshtInput | BahrebardariTaghvimCreateManyTrikhDoreKeshtInput[]
  }

  export type EshtebahAvamelCreateWithoutTrikhDoreKeshtInput = {
    IdEsht: number
    Eshtebah: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutEshtebahAvamelInput
  }

  export type EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdEsht: number
    FIdRanesh: number
    Eshtebah: number
  }

  export type EshtebahAvamelCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: EshtebahAvamelWhereUniqueInput
    create: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type EshtebahAvamelCreateManyTrikhDoreKeshtInputEnvelope = {
    data: EshtebahAvamelCreateManyTrikhDoreKeshtInput | EshtebahAvamelCreateManyTrikhDoreKeshtInput[]
  }

  export type FlowBehboodCreateWithoutTrikhDoreKeshtInput = {
    Flow: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutFlowBehboodInput
  }

  export type FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdBehbood?: number
    FIdRanesh: number
    Flow: number
  }

  export type FlowBehboodCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: FlowBehboodWhereUniqueInput
    create: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type FlowBehboodCreateManyTrikhDoreKeshtInputEnvelope = {
    data: FlowBehboodCreateManyTrikhDoreKeshtInput | FlowBehboodCreateManyTrikhDoreKeshtInput[]
  }

  export type FlowmeterCreateWithoutTrikhDoreKeshtInput = {
    IdFIT: number
    Flowmeter: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutFlowmeterInput
  }

  export type FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdFIT: number
    FIdRanesh: number
    Flowmeter: number
  }

  export type FlowmeterCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: FlowmeterWhereUniqueInput
    create: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type FlowmeterCreateManyTrikhDoreKeshtInputEnvelope = {
    data: FlowmeterCreateManyTrikhDoreKeshtInput | FlowmeterCreateManyTrikhDoreKeshtInput[]
  }

  export type KontorCreateWithoutTrikhDoreKeshtInput = {
    Kontor: number
    Abgir: AbgirCreateNestedOneWithoutKontorInput
  }

  export type KontorUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdKon?: number
    FIdKontor: number
    Kontor: number
  }

  export type KontorCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: KontorWhereUniqueInput
    create: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type KontorCreateManyTrikhDoreKeshtInputEnvelope = {
    data: KontorCreateManyTrikhDoreKeshtInput | KontorCreateManyTrikhDoreKeshtInput[]
  }

  export type NashtShabakeCreateWithoutTrikhDoreKeshtInput = {
    NashtShabake: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutNashtShabakeInput
  }

  export type NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdNasht?: number
    FIdRanesh: number
    NashtShabake: number
  }

  export type NashtShabakeCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: NashtShabakeWhereUniqueInput
    create: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type NashtShabakeCreateManyTrikhDoreKeshtInputEnvelope = {
    data: NashtShabakeCreateManyTrikhDoreKeshtInput | NashtShabakeCreateManyTrikhDoreKeshtInput[]
  }

  export type NonFITCreateWithoutTrikhDoreKeshtInput = {
    IdNonFIT: number
    VOLUM: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutNonFITInput
  }

  export type NonFITUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdNonFIT: number
    FIdRanesh: number
    VOLUM: number
  }

  export type NonFITCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: NonFITWhereUniqueInput
    create: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type NonFITCreateManyTrikhDoreKeshtInputEnvelope = {
    data: NonFITCreateManyTrikhDoreKeshtInput | NonFITCreateManyTrikhDoreKeshtInput[]
  }

  export type RainfallStationCreateWithoutTrikhDoreKeshtInput = {
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
    RainfallType: RainfallTypeCreateNestedOneWithoutRainfallStationInput
    WeatherStation: WeatherStationCreateNestedOneWithoutRainfallStationInput
  }

  export type RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdRaiSta?: number
    FIdWeaSta: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: RainfallStationWhereUniqueInput
    create: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type RainfallStationCreateManyTrikhDoreKeshtInputEnvelope = {
    data: RainfallStationCreateManyTrikhDoreKeshtInput | RainfallStationCreateManyTrikhDoreKeshtInput[]
  }

  export type TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput = {
    Takhlie: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutTakhlieMakhzanInput
  }

  export type TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdTakhlie?: number
    FIdRanesh: number
    Takhlie: number
  }

  export type TakhlieMakhzanCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: TakhlieMakhzanWhereUniqueInput
    create: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type TakhlieMakhzanCreateManyTrikhDoreKeshtInputEnvelope = {
    data: TakhlieMakhzanCreateManyTrikhDoreKeshtInput | TakhlieMakhzanCreateManyTrikhDoreKeshtInput[]
  }

  export type TestCreateWithoutTrikhDoreKeshtInput = {
    Test: number
    KhatRanesh: KhatRaneshCreateNestedOneWithoutTestInput
  }

  export type TestUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdTest?: number
    FIdRanesh: number
    Test: number
  }

  export type TestCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type TestCreateManyTrikhDoreKeshtInputEnvelope = {
    data: TestCreateManyTrikhDoreKeshtInput | TestCreateManyTrikhDoreKeshtInput[]
  }

  export type DoreKeshtCreateWithoutTrikhDoreKeshtInput = {
    Dore: string
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdDore?: number
    Dore: string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: DoreKeshtWhereUniqueInput
    create: XOR<DoreKeshtCreateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type MahShamsiCreateWithoutTrikhDoreKeshtInput = {
    IdMah: number
    Mah: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutMahInput
  }

  export type MahShamsiUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdMah: number
    Mah: string
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutMahInput
  }

  export type MahShamsiCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: MahShamsiWhereUniqueInput
    create: XOR<MahShamsiCreateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type SaleZeraeeCreateWithoutTrikhDoreKeshtInput = {
    SaleZeraee: string
    ShabakeDoreKesht?: ShabakeDoreKeshtCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeUncheckedCreateWithoutTrikhDoreKeshtInput = {
    IdSal?: number
    SaleZeraee: string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeCreateOrConnectWithoutTrikhDoreKeshtInput = {
    where: SaleZeraeeWhereUniqueInput
    create: XOR<SaleZeraeeCreateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramWhereUniqueInput
    update: XOR<BahrebardairProgramUpdateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<BahrebardairProgramCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramWhereUniqueInput
    data: XOR<BahrebardairProgramUpdateWithoutTrikhDoreKeshtInput, BahrebardairProgramUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramScalarWhereInput
    data: XOR<BahrebardairProgramUpdateManyMutationInput, BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramSeghliUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    update: XOR<BahrebardairProgramSeghliUpdateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<BahrebardairProgramSeghliCreateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramSeghliUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramSeghliWhereUniqueInput
    data: XOR<BahrebardairProgramSeghliUpdateWithoutTrikhDoreKeshtInput, BahrebardairProgramSeghliUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardairProgramSeghliUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: BahrebardairProgramSeghliScalarWhereInput
    data: XOR<BahrebardairProgramSeghliUpdateManyMutationInput, BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardariTaghvimUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    update: XOR<BahrebardariTaghvimUpdateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<BahrebardariTaghvimCreateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardariTaghvimUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: BahrebardariTaghvimWhereUniqueInput
    data: XOR<BahrebardariTaghvimUpdateWithoutTrikhDoreKeshtInput, BahrebardariTaghvimUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type BahrebardariTaghvimUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: BahrebardariTaghvimScalarWhereInput
    data: XOR<BahrebardariTaghvimUpdateManyMutationInput, BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type EshtebahAvamelUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: EshtebahAvamelWhereUniqueInput
    update: XOR<EshtebahAvamelUpdateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<EshtebahAvamelCreateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type EshtebahAvamelUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: EshtebahAvamelWhereUniqueInput
    data: XOR<EshtebahAvamelUpdateWithoutTrikhDoreKeshtInput, EshtebahAvamelUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type EshtebahAvamelUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: EshtebahAvamelScalarWhereInput
    data: XOR<EshtebahAvamelUpdateManyMutationInput, EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type FlowBehboodUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: FlowBehboodWhereUniqueInput
    update: XOR<FlowBehboodUpdateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<FlowBehboodCreateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type FlowBehboodUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: FlowBehboodWhereUniqueInput
    data: XOR<FlowBehboodUpdateWithoutTrikhDoreKeshtInput, FlowBehboodUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type FlowBehboodUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: FlowBehboodScalarWhereInput
    data: XOR<FlowBehboodUpdateManyMutationInput, FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type FlowmeterUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: FlowmeterWhereUniqueInput
    update: XOR<FlowmeterUpdateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<FlowmeterCreateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type FlowmeterUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: FlowmeterWhereUniqueInput
    data: XOR<FlowmeterUpdateWithoutTrikhDoreKeshtInput, FlowmeterUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type FlowmeterUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: FlowmeterScalarWhereInput
    data: XOR<FlowmeterUpdateManyMutationInput, FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type KontorUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: KontorWhereUniqueInput
    update: XOR<KontorUpdateWithoutTrikhDoreKeshtInput, KontorUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<KontorCreateWithoutTrikhDoreKeshtInput, KontorUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type KontorUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: KontorWhereUniqueInput
    data: XOR<KontorUpdateWithoutTrikhDoreKeshtInput, KontorUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type KontorUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: KontorScalarWhereInput
    data: XOR<KontorUpdateManyMutationInput, KontorUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type NashtShabakeUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: NashtShabakeWhereUniqueInput
    update: XOR<NashtShabakeUpdateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<NashtShabakeCreateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type NashtShabakeUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: NashtShabakeWhereUniqueInput
    data: XOR<NashtShabakeUpdateWithoutTrikhDoreKeshtInput, NashtShabakeUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type NashtShabakeUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: NashtShabakeScalarWhereInput
    data: XOR<NashtShabakeUpdateManyMutationInput, NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type NonFITUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: NonFITWhereUniqueInput
    update: XOR<NonFITUpdateWithoutTrikhDoreKeshtInput, NonFITUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<NonFITCreateWithoutTrikhDoreKeshtInput, NonFITUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type NonFITUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: NonFITWhereUniqueInput
    data: XOR<NonFITUpdateWithoutTrikhDoreKeshtInput, NonFITUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type NonFITUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: NonFITScalarWhereInput
    data: XOR<NonFITUpdateManyMutationInput, NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type RainfallStationUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: RainfallStationWhereUniqueInput
    update: XOR<RainfallStationUpdateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<RainfallStationCreateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type RainfallStationUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: RainfallStationWhereUniqueInput
    data: XOR<RainfallStationUpdateWithoutTrikhDoreKeshtInput, RainfallStationUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type RainfallStationUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: RainfallStationScalarWhereInput
    data: XOR<RainfallStationUpdateManyMutationInput, RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type TakhlieMakhzanUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: TakhlieMakhzanWhereUniqueInput
    update: XOR<TakhlieMakhzanUpdateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<TakhlieMakhzanCreateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type TakhlieMakhzanUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: TakhlieMakhzanWhereUniqueInput
    data: XOR<TakhlieMakhzanUpdateWithoutTrikhDoreKeshtInput, TakhlieMakhzanUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type TakhlieMakhzanUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: TakhlieMakhzanScalarWhereInput
    data: XOR<TakhlieMakhzanUpdateManyMutationInput, TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type TestUpsertWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: TestWhereUniqueInput
    update: XOR<TestUpdateWithoutTrikhDoreKeshtInput, TestUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<TestCreateWithoutTrikhDoreKeshtInput, TestUncheckedCreateWithoutTrikhDoreKeshtInput>
  }

  export type TestUpdateWithWhereUniqueWithoutTrikhDoreKeshtInput = {
    where: TestWhereUniqueInput
    data: XOR<TestUpdateWithoutTrikhDoreKeshtInput, TestUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type TestUpdateManyWithWhereWithoutTrikhDoreKeshtInput = {
    where: TestScalarWhereInput
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyWithoutTrikhDoreKeshtInput>
  }

  export type DoreKeshtUpsertWithoutTrikhDoreKeshtInput = {
    update: XOR<DoreKeshtUpdateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<DoreKeshtCreateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedCreateWithoutTrikhDoreKeshtInput>
    where?: DoreKeshtWhereInput
  }

  export type DoreKeshtUpdateToOneWithWhereWithoutTrikhDoreKeshtInput = {
    where?: DoreKeshtWhereInput
    data: XOR<DoreKeshtUpdateWithoutTrikhDoreKeshtInput, DoreKeshtUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type DoreKeshtUpdateWithoutTrikhDoreKeshtInput = {
    Dore?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutDoreKeshtNestedInput
  }

  export type DoreKeshtUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput
  }

  export type MahShamsiUpsertWithoutTrikhDoreKeshtInput = {
    update: XOR<MahShamsiUpdateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<MahShamsiCreateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedCreateWithoutTrikhDoreKeshtInput>
    where?: MahShamsiWhereInput
  }

  export type MahShamsiUpdateToOneWithWhereWithoutTrikhDoreKeshtInput = {
    where?: MahShamsiWhereInput
    data: XOR<MahShamsiUpdateWithoutTrikhDoreKeshtInput, MahShamsiUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type MahShamsiUpdateWithoutTrikhDoreKeshtInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutMahNestedInput
  }

  export type MahShamsiUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutMahNestedInput
  }

  export type SaleZeraeeUpsertWithoutTrikhDoreKeshtInput = {
    update: XOR<SaleZeraeeUpdateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedUpdateWithoutTrikhDoreKeshtInput>
    create: XOR<SaleZeraeeCreateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutTrikhDoreKeshtInput>
    where?: SaleZeraeeWhereInput
  }

  export type SaleZeraeeUpdateToOneWithWhereWithoutTrikhDoreKeshtInput = {
    where?: SaleZeraeeWhereInput
    data: XOR<SaleZeraeeUpdateWithoutTrikhDoreKeshtInput, SaleZeraeeUncheckedUpdateWithoutTrikhDoreKeshtInput>
  }

  export type SaleZeraeeUpdateWithoutTrikhDoreKeshtInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type SaleZeraeeUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type RainfallStationCreateWithoutWeatherStationInput = {
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
    RainfallType: RainfallTypeCreateNestedOneWithoutRainfallStationInput
    TrikhDoreKesht: TrikhDoreKeshtCreateNestedOneWithoutRainfallStationInput
  }

  export type RainfallStationUncheckedCreateWithoutWeatherStationInput = {
    IdRaiSta?: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationCreateOrConnectWithoutWeatherStationInput = {
    where: RainfallStationWhereUniqueInput
    create: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput>
  }

  export type RainfallStationCreateManyWeatherStationInputEnvelope = {
    data: RainfallStationCreateManyWeatherStationInput | RainfallStationCreateManyWeatherStationInput[]
  }

  export type RainfallStationUpsertWithWhereUniqueWithoutWeatherStationInput = {
    where: RainfallStationWhereUniqueInput
    update: XOR<RainfallStationUpdateWithoutWeatherStationInput, RainfallStationUncheckedUpdateWithoutWeatherStationInput>
    create: XOR<RainfallStationCreateWithoutWeatherStationInput, RainfallStationUncheckedCreateWithoutWeatherStationInput>
  }

  export type RainfallStationUpdateWithWhereUniqueWithoutWeatherStationInput = {
    where: RainfallStationWhereUniqueInput
    data: XOR<RainfallStationUpdateWithoutWeatherStationInput, RainfallStationUncheckedUpdateWithoutWeatherStationInput>
  }

  export type RainfallStationUpdateManyWithWhereWithoutWeatherStationInput = {
    where: RainfallStationScalarWhereInput
    data: XOR<RainfallStationUpdateManyMutationInput, RainfallStationUncheckedUpdateManyWithoutWeatherStationInput>
  }

  export type BareshMotaleatCreateWithoutMahInput = {
    BareshMotaleat: Decimal | DecimalJsLike | number | string
    Network: NetworkCreateNestedOneWithoutBareshMotaleatInput
  }

  export type BareshMotaleatUncheckedCreateWithoutMahInput = {
    IdBarMot?: number
    FIdNet: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateOrConnectWithoutMahInput = {
    where: BareshMotaleatWhereUniqueInput
    create: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput>
  }

  export type BareshMotaleatCreateManyMahInputEnvelope = {
    data: BareshMotaleatCreateManyMahInput | BareshMotaleatCreateManyMahInput[]
  }

  export type TrikhDoreKeshtCreateWithoutMahShamsiInput = {
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestCreateNestedManyWithoutTrikhDoreKeshtInput
    DoreKesht: DoreKeshtCreateNestedOneWithoutTrikhDoreKeshtInput
    SaleZeraee: SaleZeraeeCreateNestedOneWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    BahrebardairProgram?: BahrebardairProgramUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    EshtebahAvamel?: EshtebahAvamelUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    FlowBehbood?: FlowBehboodUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Flowmeter?: FlowmeterUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Kontor?: KontorUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NashtShabake?: NashtShabakeUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    NonFIT?: NonFITUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    RainfallStation?: RainfallStationUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
    Test?: TestUncheckedCreateNestedManyWithoutTrikhDoreKeshtInput
  }

  export type TrikhDoreKeshtCreateOrConnectWithoutMahShamsiInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    create: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput>
  }

  export type TrikhDoreKeshtCreateManyMahShamsiInputEnvelope = {
    data: TrikhDoreKeshtCreateManyMahShamsiInput | TrikhDoreKeshtCreateManyMahShamsiInput[]
  }

  export type BareshMotaleatUpsertWithWhereUniqueWithoutMahInput = {
    where: BareshMotaleatWhereUniqueInput
    update: XOR<BareshMotaleatUpdateWithoutMahInput, BareshMotaleatUncheckedUpdateWithoutMahInput>
    create: XOR<BareshMotaleatCreateWithoutMahInput, BareshMotaleatUncheckedCreateWithoutMahInput>
  }

  export type BareshMotaleatUpdateWithWhereUniqueWithoutMahInput = {
    where: BareshMotaleatWhereUniqueInput
    data: XOR<BareshMotaleatUpdateWithoutMahInput, BareshMotaleatUncheckedUpdateWithoutMahInput>
  }

  export type BareshMotaleatUpdateManyWithWhereWithoutMahInput = {
    where: BareshMotaleatScalarWhereInput
    data: XOR<BareshMotaleatUpdateManyMutationInput, BareshMotaleatUncheckedUpdateManyWithoutMahInput>
  }

  export type TrikhDoreKeshtUpsertWithWhereUniqueWithoutMahShamsiInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    update: XOR<TrikhDoreKeshtUpdateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedUpdateWithoutMahShamsiInput>
    create: XOR<TrikhDoreKeshtCreateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedCreateWithoutMahShamsiInput>
  }

  export type TrikhDoreKeshtUpdateWithWhereUniqueWithoutMahShamsiInput = {
    where: TrikhDoreKeshtWhereUniqueInput
    data: XOR<TrikhDoreKeshtUpdateWithoutMahShamsiInput, TrikhDoreKeshtUncheckedUpdateWithoutMahShamsiInput>
  }

  export type TrikhDoreKeshtUpdateManyWithWhereWithoutMahShamsiInput = {
    where: TrikhDoreKeshtScalarWhereInput
    data: XOR<TrikhDoreKeshtUpdateManyMutationInput, TrikhDoreKeshtUncheckedUpdateManyWithoutMahShamsiInput>
  }

  export type BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput = {
    IdBahDor: number
    Area: Decimal | DecimalJsLike | number | string
    KhatRanesh: KhatRaneshCreateNestedOneWithoutBahrebardariKeshtDoreInput
    NoeMahsool: NoeMahsoolCreateNestedOneWithoutBahrebardariKeshtDoreInput
  }

  export type BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput = {
    IdBahDor: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreCreateOrConnectWithoutShabakeDoreKeshtInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    create: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput>
  }

  export type BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInputEnvelope = {
    data: BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInput | BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInput[]
  }

  export type DoreKeshtCreateWithoutShabakeDoreKeshtInput = {
    Dore: string
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtUncheckedCreateWithoutShabakeDoreKeshtInput = {
    IdDore?: number
    Dore: string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutDoreKeshtInput
  }

  export type DoreKeshtCreateOrConnectWithoutShabakeDoreKeshtInput = {
    where: DoreKeshtWhereUniqueInput
    create: XOR<DoreKeshtCreateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedCreateWithoutShabakeDoreKeshtInput>
  }

  export type NetworkCreateWithoutShabakeDoreKeshtInput = {
    Network: string
    BareshMotaleat?: BareshMotaleatCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaCreateNestedManyWithoutNetworkInput
    SystemPart: SystemPartCreateNestedOneWithoutNetworkInput
    PumpStation?: PumpStationCreateNestedManyWithoutNetworkInput
  }

  export type NetworkUncheckedCreateWithoutShabakeDoreKeshtInput = {
    IdNet?: number
    Network: string
    FIdSP: number
    BareshMotaleat?: BareshMotaleatUncheckedCreateNestedManyWithoutNetworkInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedCreateNestedManyWithoutNetworkInput
    PumpStation?: PumpStationUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type NetworkCreateOrConnectWithoutShabakeDoreKeshtInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutShabakeDoreKeshtInput, NetworkUncheckedCreateWithoutShabakeDoreKeshtInput>
  }

  export type SaleZeraeeCreateWithoutShabakeDoreKeshtInput = {
    SaleZeraee: string
    TrikhDoreKesht?: TrikhDoreKeshtCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeUncheckedCreateWithoutShabakeDoreKeshtInput = {
    IdSal?: number
    SaleZeraee: string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedCreateNestedManyWithoutSaleZeraeeInput
  }

  export type SaleZeraeeCreateOrConnectWithoutShabakeDoreKeshtInput = {
    where: SaleZeraeeWhereUniqueInput
    create: XOR<SaleZeraeeCreateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutShabakeDoreKeshtInput>
  }

  export type BahrebardariKeshtDoreUpsertWithWhereUniqueWithoutShabakeDoreKeshtInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    update: XOR<BahrebardariKeshtDoreUpdateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedUpdateWithoutShabakeDoreKeshtInput>
    create: XOR<BahrebardariKeshtDoreCreateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedCreateWithoutShabakeDoreKeshtInput>
  }

  export type BahrebardariKeshtDoreUpdateWithWhereUniqueWithoutShabakeDoreKeshtInput = {
    where: BahrebardariKeshtDoreWhereUniqueInput
    data: XOR<BahrebardariKeshtDoreUpdateWithoutShabakeDoreKeshtInput, BahrebardariKeshtDoreUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type BahrebardariKeshtDoreUpdateManyWithWhereWithoutShabakeDoreKeshtInput = {
    where: BahrebardariKeshtDoreScalarWhereInput
    data: XOR<BahrebardariKeshtDoreUpdateManyMutationInput, BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtInput>
  }

  export type DoreKeshtUpsertWithoutShabakeDoreKeshtInput = {
    update: XOR<DoreKeshtUpdateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedUpdateWithoutShabakeDoreKeshtInput>
    create: XOR<DoreKeshtCreateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedCreateWithoutShabakeDoreKeshtInput>
    where?: DoreKeshtWhereInput
  }

  export type DoreKeshtUpdateToOneWithWhereWithoutShabakeDoreKeshtInput = {
    where?: DoreKeshtWhereInput
    data: XOR<DoreKeshtUpdateWithoutShabakeDoreKeshtInput, DoreKeshtUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type DoreKeshtUpdateWithoutShabakeDoreKeshtInput = {
    Dore?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutDoreKeshtNestedInput
  }

  export type DoreKeshtUncheckedUpdateWithoutShabakeDoreKeshtInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutDoreKeshtNestedInput
  }

  export type NetworkUpsertWithoutShabakeDoreKeshtInput = {
    update: XOR<NetworkUpdateWithoutShabakeDoreKeshtInput, NetworkUncheckedUpdateWithoutShabakeDoreKeshtInput>
    create: XOR<NetworkCreateWithoutShabakeDoreKeshtInput, NetworkUncheckedCreateWithoutShabakeDoreKeshtInput>
    where?: NetworkWhereInput
  }

  export type NetworkUpdateToOneWithWhereWithoutShabakeDoreKeshtInput = {
    where?: NetworkWhereInput
    data: XOR<NetworkUpdateWithoutShabakeDoreKeshtInput, NetworkUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type NetworkUpdateWithoutShabakeDoreKeshtInput = {
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutNetworkNestedInput
    SystemPart?: SystemPartUpdateOneRequiredWithoutNetworkNestedInput
    PumpStation?: PumpStationUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateWithoutShabakeDoreKeshtInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type SaleZeraeeUpsertWithoutShabakeDoreKeshtInput = {
    update: XOR<SaleZeraeeUpdateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedUpdateWithoutShabakeDoreKeshtInput>
    create: XOR<SaleZeraeeCreateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedCreateWithoutShabakeDoreKeshtInput>
    where?: SaleZeraeeWhereInput
  }

  export type SaleZeraeeUpdateToOneWithWhereWithoutShabakeDoreKeshtInput = {
    where?: SaleZeraeeWhereInput
    data: XOR<SaleZeraeeUpdateWithoutShabakeDoreKeshtInput, SaleZeraeeUncheckedUpdateWithoutShabakeDoreKeshtInput>
  }

  export type SaleZeraeeUpdateWithoutShabakeDoreKeshtInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type SaleZeraeeUncheckedUpdateWithoutShabakeDoreKeshtInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
    TrikhDoreKesht?: TrikhDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeNestedInput
  }

  export type PumpStationCreateManyAbadeMakhzanInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdDP: number
    Ready?: boolean
  }

  export type PumpStationUpdateWithoutAbadeMakhzanInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUpdateManyWithoutPumpStationNestedInput
    DarjeStation?: DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput
    DeliveryPoint?: DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput
    Network?: NetworkUpdateOneRequiredWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateWithoutAbadeMakhzanInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateManyWithoutAbadeMakhzanInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KontorCreateManyAbgirInput = {
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUpdateWithoutAbgirInput = {
    Kontor?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutKontorNestedInput
  }

  export type KontorUncheckedUpdateWithoutAbgirInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorUncheckedUpdateManyWithoutAbgirInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateManyDarajePipeInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
  }

  export type KhatRaneshUpdateWithoutDarajePipeInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutDarajePipeInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateManyWithoutDarajePipeInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PumpStationCreateManyDeliveryPointInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
    Ready?: boolean
  }

  export type PumpStationUpdateWithoutDeliveryPointInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUpdateManyWithoutPumpStationNestedInput
    AbadeMakhzan?: AbadeMakhzanUpdateOneWithoutPumpStationNestedInput
    DarjeStation?: DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput
    Network?: NetworkUpdateOneRequiredWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateWithoutDeliveryPointInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateManyWithoutDeliveryPointInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PumpStationCreateManyDarjeStationInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
  }

  export type PumpStationUpdateWithoutDarjeStationInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUpdateManyWithoutPumpStationNestedInput
    AbadeMakhzan?: AbadeMakhzanUpdateOneWithoutPumpStationNestedInput
    DeliveryPoint?: DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput
    Network?: NetworkUpdateOneRequiredWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateWithoutDarjeStationInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateManyWithoutDarjeStationInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShabakeDoreKeshtCreateManyDoreKeshtInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
  }

  export type TrikhDoreKeshtCreateManyDoreKeshtInput = {
    FIdSal: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
  }

  export type ShabakeDoreKeshtUpdateWithoutDoreKeshtInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutShabakeDoreKeshtNestedInput
    Network?: NetworkUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateWithoutDoreKeshtInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutDoreKeshtInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
  }

  export type TrikhDoreKeshtUpdateWithoutDoreKeshtInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutDoreKeshtInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutDoreKeshtInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
  }

  export type AbgirCreateManyKhatRaneshInput = {
    Abgir: string
  }

  export type BahrebardairProgramCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardariKeshtDoreCreateManyKhatRaneshInput = {
    IdBahDor: number
    FIdShDo: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type EshtebahAvamelCreateManyKhatRaneshInput = {
    IdEsht: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type FlowBehboodCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Flow: number
  }

  export type FlowmeterCreateManyKhatRaneshInput = {
    IdFIT: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type KhatRaneshAreaCreateManyKhatRaneshInput = {
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpCreateManyKhatRaneshInput = {
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshSegliCreateManyKhatRaneshInput = {
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type NashtShabakeCreateManyKhatRaneshInput = {
    FIdTriDor: number
    NashtShabake: number
  }

  export type NonFITCreateManyKhatRaneshInput = {
    IdNonFIT: number
    VOLUM: number
  }

  export type TakhlieMakhzanCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Takhlie: number
  }

  export type TestCreateManyKhatRaneshInput = {
    FIdTarDor: number
    Test: number
  }

  export type AbgirUpdateWithoutKhatRaneshInput = {
    Abgir?: StringFieldUpdateOperationsInput | string
    Kontor?: KontorUpdateManyWithoutAbgirNestedInput
  }

  export type AbgirUncheckedUpdateWithoutKhatRaneshInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
    Kontor?: KontorUncheckedUpdateManyWithoutAbgirNestedInput
  }

  export type AbgirUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type BahrebardairProgramUpdateWithoutKhatRaneshInput = {
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramNestedInput
  }

  export type BahrebardairProgramUncheckedUpdateWithoutKhatRaneshInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliUpdateWithoutKhatRaneshInput = {
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput
  }

  export type BahrebardairProgramSeghliUncheckedUpdateWithoutKhatRaneshInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardariKeshtDoreUpdateWithoutKhatRaneshInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NoeMahsool?: NoeMahsoolUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
  }

  export type BahrebardariKeshtDoreUncheckedUpdateWithoutKhatRaneshInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpdateWithoutKhatRaneshInput = {
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput
  }

  export type BahrebardariTaghvimUncheckedUpdateWithoutKhatRaneshInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type EshtebahAvamelUpdateWithoutKhatRaneshInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutEshtebahAvamelNestedInput
  }

  export type EshtebahAvamelUncheckedUpdateWithoutKhatRaneshInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUpdateWithoutKhatRaneshInput = {
    Flow?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutFlowBehboodNestedInput
  }

  export type FlowBehboodUncheckedUpdateWithoutKhatRaneshInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowmeterUpdateWithoutKhatRaneshInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutFlowmeterNestedInput
  }

  export type FlowmeterUncheckedUpdateWithoutKhatRaneshInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type KhatRaneshAreaUpdateWithoutKhatRaneshInput = {
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Land?: LandUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
    Network?: NetworkUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
  }

  export type KhatRaneshAreaUncheckedUpdateWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpUpdateWithoutKhatRaneshInput = {
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
    PumpType?: PumpTypeUpdateOneRequiredWithoutKhatRaneshPumpNestedInput
  }

  export type KhatRaneshPumpUncheckedUpdateWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshSegliUpdateWithoutKhatRaneshInput = {
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedUpdateWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NashtShabakeUpdateWithoutKhatRaneshInput = {
    NashtShabake?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutNashtShabakeNestedInput
  }

  export type NashtShabakeUncheckedUpdateWithoutKhatRaneshInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUpdateWithoutKhatRaneshInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutNonFITNestedInput
  }

  export type NonFITUncheckedUpdateWithoutKhatRaneshInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUpdateWithoutKhatRaneshInput = {
    Takhlie?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutTakhlieMakhzanNestedInput
  }

  export type TakhlieMakhzanUncheckedUpdateWithoutKhatRaneshInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TestUpdateWithoutKhatRaneshInput = {
    Test?: IntFieldUpdateOperationsInput | number
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutKhatRaneshInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestUncheckedUpdateManyWithoutKhatRaneshInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshAreaCreateManyLandInput = {
    FIdRanesh: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateWithoutLandInput = {
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
    Network?: NetworkUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
  }

  export type KhatRaneshAreaUncheckedUpdateWithoutLandInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutLandInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshCreateManyMeasuringToolInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    Active?: boolean
  }

  export type KhatRaneshUpdateWithoutMeasuringToolInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutMeasuringToolInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateManyWithoutMeasuringToolInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BareshMotaleatCreateManyNetworkInput = {
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateManyNetworkInput = {
    FIdRanesh: number
    FIdLand: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type PumpStationCreateManyNetworkInput = {
    NameStation: string
    KM?: number | null
    FIdDStation: number
    FIdMakhzan?: number | null
    FIdDP: number
    Ready?: boolean
  }

  export type ShabakeDoreKeshtCreateManyNetworkInput = {
    IdShDo: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdSal: number
    FIdDore: number
  }

  export type BareshMotaleatUpdateWithoutNetworkInput = {
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Mah?: MahShamsiUpdateOneRequiredWithoutBareshMotaleatNestedInput
  }

  export type BareshMotaleatUncheckedUpdateWithoutNetworkInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedUpdateManyWithoutNetworkInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateWithoutNetworkInput = {
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
    Land?: LandUpdateOneRequiredWithoutKhatRaneshAreaNestedInput
  }

  export type KhatRaneshAreaUncheckedUpdateWithoutNetworkInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateManyWithoutNetworkInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PumpStationUpdateWithoutNetworkInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUpdateManyWithoutPumpStationNestedInput
    AbadeMakhzan?: AbadeMakhzanUpdateOneWithoutPumpStationNestedInput
    DarjeStation?: DarjeStationUpdateOneRequiredWithoutPumpStationNestedInput
    DeliveryPoint?: DeliveryPointsUpdateOneRequiredWithoutPumpStationsNestedInput
  }

  export type PumpStationUncheckedUpdateWithoutNetworkInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
    KhatRanesh?: KhatRaneshUncheckedUpdateManyWithoutPumpStationNestedInput
  }

  export type PumpStationUncheckedUpdateManyWithoutNetworkInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
    FIdDP?: IntFieldUpdateOperationsInput | number
    Ready?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShabakeDoreKeshtUpdateWithoutNetworkInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutShabakeDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateWithoutNetworkInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
  }

  export type NoeMahsoolCreateManyNoeKeshtInput = {
    Mahsool: string
  }

  export type NoeMahsoolUpdateWithoutNoeKeshtInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutNoeMahsoolNestedInput
  }

  export type NoeMahsoolUncheckedUpdateWithoutNoeKeshtInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutNoeMahsoolNestedInput
  }

  export type NoeMahsoolUncheckedUpdateManyWithoutNoeKeshtInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
  }

  export type BahrebardariKeshtDoreCreateManyNoeMahsoolInput = {
    IdBahDor: number
    FIdShDo: number
    FIdRanesh: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateWithoutNoeMahsoolInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
  }

  export type BahrebardariKeshtDoreUncheckedUpdateWithoutNoeMahsoolInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutNoeMahsoolInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdShDo?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshCreateManyPumpStationInput = {
    RaneshName: string
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    Active?: boolean
  }

  export type KhatRaneshUpdateWithoutPumpStationInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    SeghliPump?: SeghliPumpUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutPumpStationInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateManyWithoutPumpStationInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KhatRaneshPumpCreateManyPumpTypeInput = {
    FIdRanesh: number
    ModelPump?: string | null
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUpdateWithoutPumpTypeInput = {
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutKhatRaneshPumpNestedInput
  }

  export type KhatRaneshPumpUncheckedUpdateWithoutPumpTypeInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpUncheckedUpdateManyWithoutPumpTypeInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type RainfallStationCreateManyRainfallTypeInput = {
    FIdWeaSta: number
    FIdTrikh: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateWithoutRainfallTypeInput = {
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutRainfallStationNestedInput
    WeatherStation?: WeatherStationUpdateOneRequiredWithoutRainfallStationNestedInput
  }

  export type RainfallStationUncheckedUpdateWithoutRainfallTypeInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateManyWithoutRainfallTypeInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ShabakeDoreKeshtCreateManySaleZeraeeInput = {
    IdShDo: number
    FIdNet: number
    TrikhShorooe: Date | string
    TrikhPayan: Date | string
    FIdDore: number
  }

  export type TrikhDoreKeshtCreateManySaleZeraeeInput = {
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
    Mah: number
  }

  export type ShabakeDoreKeshtUpdateWithoutSaleZeraeeInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutShabakeDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
    Network?: NetworkUpdateOneRequiredWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdDore?: IntFieldUpdateOperationsInput | number
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtNestedInput
  }

  export type ShabakeDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeInput = {
    IdShDo?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    TrikhShorooe?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhPayan?: DateTimeFieldUpdateOperationsInput | Date | string
    FIdDore?: IntFieldUpdateOperationsInput | number
  }

  export type TrikhDoreKeshtUpdateWithoutSaleZeraeeInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    MahShamsi?: MahShamsiUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutSaleZeraeeInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutSaleZeraeeInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    Mah?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateManySeghliPumpInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdMeasuring: number
    Active?: boolean
  }

  export type KhatRaneshUpdateWithoutSeghliPumpInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutKhatRaneshNestedInput
    DarajePipe?: DarajePipeUpdateOneRequiredWithoutKhatRaneshNestedInput
    MeasuringTool?: MeasuringToolUpdateOneRequiredWithoutKhatRaneshNestedInput
    PumpStation?: PumpStationUpdateOneRequiredWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateWithoutSeghliPumpInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    Abgir?: AbgirUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariKeshtDore?: BahrebardariKeshtDoreUncheckedUpdateManyWithoutKhatRaneshNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutKhatRaneshNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutKhatRaneshNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshPump?: KhatRaneshPumpUncheckedUpdateManyWithoutKhatRaneshNestedInput
    KhatRaneshSegli?: KhatRaneshSegliUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutKhatRaneshNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutKhatRaneshNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutKhatRaneshNestedInput
    Test?: TestUncheckedUpdateManyWithoutKhatRaneshNestedInput
  }

  export type KhatRaneshUncheckedUpdateManyWithoutSeghliPumpInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NetworkCreateManySystemPartInput = {
    Network: string
  }

  export type NetworkUpdateWithoutSystemPartInput = {
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateWithoutSystemPartInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    BareshMotaleat?: BareshMotaleatUncheckedUpdateManyWithoutNetworkNestedInput
    KhatRaneshArea?: KhatRaneshAreaUncheckedUpdateManyWithoutNetworkNestedInput
    PumpStation?: PumpStationUncheckedUpdateManyWithoutNetworkNestedInput
    ShabakeDoreKesht?: ShabakeDoreKeshtUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type NetworkUncheckedUpdateManyWithoutSystemPartInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
  }

  export type BahrebardairProgramCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramSeghliCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Zarfiat?: Decimal | DecimalJsLike | number | string | null
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardariTaghvimCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type EshtebahAvamelCreateManyTrikhDoreKeshtInput = {
    IdEsht: number
    FIdRanesh: number
    Eshtebah: number
  }

  export type FlowBehboodCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Flow: number
  }

  export type FlowmeterCreateManyTrikhDoreKeshtInput = {
    IdFIT: number
    FIdRanesh: number
    Flowmeter: number
  }

  export type KontorCreateManyTrikhDoreKeshtInput = {
    FIdKontor: number
    Kontor: number
  }

  export type NashtShabakeCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    NashtShabake: number
  }

  export type NonFITCreateManyTrikhDoreKeshtInput = {
    IdNonFIT: number
    FIdRanesh: number
    VOLUM: number
  }

  export type RainfallStationCreateManyTrikhDoreKeshtInput = {
    FIdWeaSta: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type TakhlieMakhzanCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Takhlie: number
  }

  export type TestCreateManyTrikhDoreKeshtInput = {
    FIdRanesh: number
    Test: number
  }

  export type BahrebardairProgramUpdateWithoutTrikhDoreKeshtInput = {
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramNestedInput
  }

  export type BahrebardairProgramUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliUpdateWithoutTrikhDoreKeshtInput = {
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardairProgramSeghliNestedInput
  }

  export type BahrebardairProgramSeghliUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdProSrgl?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardariTaghvimUpdateWithoutTrikhDoreKeshtInput = {
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardariTaghvimNestedInput
  }

  export type BahrebardariTaghvimUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type EshtebahAvamelUpdateWithoutTrikhDoreKeshtInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutEshtebahAvamelNestedInput
  }

  export type EshtebahAvamelUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUpdateWithoutTrikhDoreKeshtInput = {
    Flow?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutFlowBehboodNestedInput
  }

  export type FlowBehboodUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowmeterUpdateWithoutTrikhDoreKeshtInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutFlowmeterNestedInput
  }

  export type FlowmeterUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type KontorUpdateWithoutTrikhDoreKeshtInput = {
    Kontor?: IntFieldUpdateOperationsInput | number
    Abgir?: AbgirUpdateOneRequiredWithoutKontorNestedInput
  }

  export type KontorUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUpdateWithoutTrikhDoreKeshtInput = {
    NashtShabake?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutNashtShabakeNestedInput
  }

  export type NashtShabakeUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUpdateWithoutTrikhDoreKeshtInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutNonFITNestedInput
  }

  export type NonFITUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type RainfallStationUpdateWithoutTrikhDoreKeshtInput = {
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    RainfallType?: RainfallTypeUpdateOneRequiredWithoutRainfallStationNestedInput
    WeatherStation?: WeatherStationUpdateOneRequiredWithoutRainfallStationNestedInput
  }

  export type RainfallStationUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TakhlieMakhzanUpdateWithoutTrikhDoreKeshtInput = {
    Takhlie?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutTakhlieMakhzanNestedInput
  }

  export type TakhlieMakhzanUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TestUpdateWithoutTrikhDoreKeshtInput = {
    Test?: IntFieldUpdateOperationsInput | number
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutTrikhDoreKeshtInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestUncheckedUpdateManyWithoutTrikhDoreKeshtInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type RainfallStationCreateManyWeatherStationInput = {
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateWithoutWeatherStationInput = {
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    RainfallType?: RainfallTypeUpdateOneRequiredWithoutRainfallStationNestedInput
    TrikhDoreKesht?: TrikhDoreKeshtUpdateOneRequiredWithoutRainfallStationNestedInput
  }

  export type RainfallStationUncheckedUpdateWithoutWeatherStationInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateManyWithoutWeatherStationInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateManyMahInput = {
    FIdNet: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type TrikhDoreKeshtCreateManyMahShamsiInput = {
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
    Dahe: number
    Sal: number
  }

  export type BareshMotaleatUpdateWithoutMahInput = {
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Network?: NetworkUpdateOneRequiredWithoutBareshMotaleatNestedInput
  }

  export type BareshMotaleatUncheckedUpdateWithoutMahInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedUpdateManyWithoutMahInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TrikhDoreKeshtUpdateWithoutMahShamsiInput = {
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUpdateManyWithoutTrikhDoreKeshtNestedInput
    DoreKesht?: DoreKeshtUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
    SaleZeraee?: SaleZeraeeUpdateOneRequiredWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateWithoutMahShamsiInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
    BahrebardairProgram?: BahrebardairProgramUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardairProgramSeghli?: BahrebardairProgramSeghliUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    BahrebardariTaghvim?: BahrebardariTaghvimUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    EshtebahAvamel?: EshtebahAvamelUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    FlowBehbood?: FlowBehboodUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Flowmeter?: FlowmeterUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Kontor?: KontorUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NashtShabake?: NashtShabakeUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    NonFIT?: NonFITUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    RainfallStation?: RainfallStationUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    TakhlieMakhzan?: TakhlieMakhzanUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
    Test?: TestUncheckedUpdateManyWithoutTrikhDoreKeshtNestedInput
  }

  export type TrikhDoreKeshtUncheckedUpdateManyWithoutMahShamsiInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
    Dahe?: IntFieldUpdateOperationsInput | number
    Sal?: IntFieldUpdateOperationsInput | number
  }

  export type BahrebardariKeshtDoreCreateManyShabakeDoreKeshtInput = {
    IdBahDor: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateWithoutShabakeDoreKeshtInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    KhatRanesh?: KhatRaneshUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
    NoeMahsool?: NoeMahsoolUpdateOneRequiredWithoutBahrebardariKeshtDoreNestedInput
  }

  export type BahrebardariKeshtDoreUncheckedUpdateWithoutShabakeDoreKeshtInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyWithoutShabakeDoreKeshtInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}