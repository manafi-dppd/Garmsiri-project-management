
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AbadeMakhzan
 * 
 */
export type AbadeMakhzan = $Result.DefaultSelection<Prisma.$AbadeMakhzanPayload>
/**
 * Model Abgir
 * 
 */
export type Abgir = $Result.DefaultSelection<Prisma.$AbgirPayload>
/**
 * Model AtashSoozi
 * 
 */
export type AtashSoozi = $Result.DefaultSelection<Prisma.$AtashSooziPayload>
/**
 * Model BahrebardairProgram
 * 
 */
export type BahrebardairProgram = $Result.DefaultSelection<Prisma.$BahrebardairProgramPayload>
/**
 * Model BahrebardariKeshtDore
 * 
 */
export type BahrebardariKeshtDore = $Result.DefaultSelection<Prisma.$BahrebardariKeshtDorePayload>
/**
 * Model BahrebardariTaghvim
 * 
 */
export type BahrebardariTaghvim = $Result.DefaultSelection<Prisma.$BahrebardariTaghvimPayload>
/**
 * Model BareshMotaleat
 * 
 */
export type BareshMotaleat = $Result.DefaultSelection<Prisma.$BareshMotaleatPayload>
/**
 * Model DarajePipe
 * 
 */
export type DarajePipe = $Result.DefaultSelection<Prisma.$DarajePipePayload>
/**
 * Model DarjeStation
 * 
 */
export type DarjeStation = $Result.DefaultSelection<Prisma.$DarjeStationPayload>
/**
 * Model DoreKesht
 * 
 */
export type DoreKesht = $Result.DefaultSelection<Prisma.$DoreKeshtPayload>
/**
 * Model EshtebahAvamel
 * 
 */
export type EshtebahAvamel = $Result.DefaultSelection<Prisma.$EshtebahAvamelPayload>
/**
 * Model FlowBehbood
 * 
 */
export type FlowBehbood = $Result.DefaultSelection<Prisma.$FlowBehboodPayload>
/**
 * Model Flowmeter
 * 
 */
export type Flowmeter = $Result.DefaultSelection<Prisma.$FlowmeterPayload>
/**
 * Model KhatRanesh
 * 
 */
export type KhatRanesh = $Result.DefaultSelection<Prisma.$KhatRaneshPayload>
/**
 * Model KhatRaneshArea
 * 
 */
export type KhatRaneshArea = $Result.DefaultSelection<Prisma.$KhatRaneshAreaPayload>
/**
 * Model KhatRaneshPump
 * 
 */
export type KhatRaneshPump = $Result.DefaultSelection<Prisma.$KhatRaneshPumpPayload>
/**
 * Model KhatRaneshSegli
 * 
 */
export type KhatRaneshSegli = $Result.DefaultSelection<Prisma.$KhatRaneshSegliPayload>
/**
 * Model Kontor
 * 
 */
export type Kontor = $Result.DefaultSelection<Prisma.$KontorPayload>
/**
 * Model Land
 * 
 */
export type Land = $Result.DefaultSelection<Prisma.$LandPayload>
/**
 * Model Mah
 * 
 */
export type Mah = $Result.DefaultSelection<Prisma.$MahPayload>
/**
 * Model MeasuringTool
 * 
 */
export type MeasuringTool = $Result.DefaultSelection<Prisma.$MeasuringToolPayload>
/**
 * Model NashtShabake
 * 
 */
export type NashtShabake = $Result.DefaultSelection<Prisma.$NashtShabakePayload>
/**
 * Model Network
 * 
 */
export type Network = $Result.DefaultSelection<Prisma.$NetworkPayload>
/**
 * Model NoeKesht
 * 
 */
export type NoeKesht = $Result.DefaultSelection<Prisma.$NoeKeshtPayload>
/**
 * Model NoeMahsool
 * 
 */
export type NoeMahsool = $Result.DefaultSelection<Prisma.$NoeMahsoolPayload>
/**
 * Model NonFIT
 * 
 */
export type NonFIT = $Result.DefaultSelection<Prisma.$NonFITPayload>
/**
 * Model PumpStation
 * 
 */
export type PumpStation = $Result.DefaultSelection<Prisma.$PumpStationPayload>
/**
 * Model PumpType
 * 
 */
export type PumpType = $Result.DefaultSelection<Prisma.$PumpTypePayload>
/**
 * Model RainfallStation
 * 
 */
export type RainfallStation = $Result.DefaultSelection<Prisma.$RainfallStationPayload>
/**
 * Model RainfallType
 * 
 */
export type RainfallType = $Result.DefaultSelection<Prisma.$RainfallTypePayload>
/**
 * Model SaleZeraee
 * 
 */
export type SaleZeraee = $Result.DefaultSelection<Prisma.$SaleZeraeePayload>
/**
 * Model SeghliPump
 * 
 */
export type SeghliPump = $Result.DefaultSelection<Prisma.$SeghliPumpPayload>
/**
 * Model SystemPart
 * 
 */
export type SystemPart = $Result.DefaultSelection<Prisma.$SystemPartPayload>
/**
 * Model TakhlieMakhzan
 * 
 */
export type TakhlieMakhzan = $Result.DefaultSelection<Prisma.$TakhlieMakhzanPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TrikhDoreKesht
 * 
 */
export type TrikhDoreKesht = $Result.DefaultSelection<Prisma.$TrikhDoreKeshtPayload>
/**
 * Model WeatherStation
 * 
 */
export type WeatherStation = $Result.DefaultSelection<Prisma.$WeatherStationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AbadeMakhzans
 * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AbadeMakhzans
   * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.abadeMakhzan`: Exposes CRUD operations for the **AbadeMakhzan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AbadeMakhzans
    * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
    * ```
    */
  get abadeMakhzan(): Prisma.AbadeMakhzanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.abgir`: Exposes CRUD operations for the **Abgir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abgirs
    * const abgirs = await prisma.abgir.findMany()
    * ```
    */
  get abgir(): Prisma.AbgirDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.atashSoozi`: Exposes CRUD operations for the **AtashSoozi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AtashSoozis
    * const atashSoozis = await prisma.atashSoozi.findMany()
    * ```
    */
  get atashSoozi(): Prisma.AtashSooziDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardairProgram`: Exposes CRUD operations for the **BahrebardairProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardairPrograms
    * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany()
    * ```
    */
  get bahrebardairProgram(): Prisma.BahrebardairProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardariKeshtDore`: Exposes CRUD operations for the **BahrebardariKeshtDore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardariKeshtDores
    * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany()
    * ```
    */
  get bahrebardariKeshtDore(): Prisma.BahrebardariKeshtDoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bahrebardariTaghvim`: Exposes CRUD operations for the **BahrebardariTaghvim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BahrebardariTaghvims
    * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany()
    * ```
    */
  get bahrebardariTaghvim(): Prisma.BahrebardariTaghvimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bareshMotaleat`: Exposes CRUD operations for the **BareshMotaleat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BareshMotaleats
    * const bareshMotaleats = await prisma.bareshMotaleat.findMany()
    * ```
    */
  get bareshMotaleat(): Prisma.BareshMotaleatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.darajePipe`: Exposes CRUD operations for the **DarajePipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DarajePipes
    * const darajePipes = await prisma.darajePipe.findMany()
    * ```
    */
  get darajePipe(): Prisma.DarajePipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.darjeStation`: Exposes CRUD operations for the **DarjeStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DarjeStations
    * const darjeStations = await prisma.darjeStation.findMany()
    * ```
    */
  get darjeStation(): Prisma.DarjeStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doreKesht`: Exposes CRUD operations for the **DoreKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoreKeshts
    * const doreKeshts = await prisma.doreKesht.findMany()
    * ```
    */
  get doreKesht(): Prisma.DoreKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eshtebahAvamel`: Exposes CRUD operations for the **EshtebahAvamel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EshtebahAvamels
    * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany()
    * ```
    */
  get eshtebahAvamel(): Prisma.EshtebahAvamelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowBehbood`: Exposes CRUD operations for the **FlowBehbood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowBehboods
    * const flowBehboods = await prisma.flowBehbood.findMany()
    * ```
    */
  get flowBehbood(): Prisma.FlowBehboodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowmeter`: Exposes CRUD operations for the **Flowmeter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flowmeters
    * const flowmeters = await prisma.flowmeter.findMany()
    * ```
    */
  get flowmeter(): Prisma.FlowmeterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRanesh`: Exposes CRUD operations for the **KhatRanesh** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshes
    * const khatRaneshes = await prisma.khatRanesh.findMany()
    * ```
    */
  get khatRanesh(): Prisma.KhatRaneshDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshArea`: Exposes CRUD operations for the **KhatRaneshArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshAreas
    * const khatRaneshAreas = await prisma.khatRaneshArea.findMany()
    * ```
    */
  get khatRaneshArea(): Prisma.KhatRaneshAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshPump`: Exposes CRUD operations for the **KhatRaneshPump** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshPumps
    * const khatRaneshPumps = await prisma.khatRaneshPump.findMany()
    * ```
    */
  get khatRaneshPump(): Prisma.KhatRaneshPumpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.khatRaneshSegli`: Exposes CRUD operations for the **KhatRaneshSegli** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KhatRaneshSeglis
    * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany()
    * ```
    */
  get khatRaneshSegli(): Prisma.KhatRaneshSegliDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kontor`: Exposes CRUD operations for the **Kontor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kontors
    * const kontors = await prisma.kontor.findMany()
    * ```
    */
  get kontor(): Prisma.KontorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land`: Exposes CRUD operations for the **Land** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lands
    * const lands = await prisma.land.findMany()
    * ```
    */
  get land(): Prisma.LandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mah`: Exposes CRUD operations for the **Mah** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mahs
    * const mahs = await prisma.mah.findMany()
    * ```
    */
  get mah(): Prisma.MahDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.measuringTool`: Exposes CRUD operations for the **MeasuringTool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeasuringTools
    * const measuringTools = await prisma.measuringTool.findMany()
    * ```
    */
  get measuringTool(): Prisma.MeasuringToolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nashtShabake`: Exposes CRUD operations for the **NashtShabake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NashtShabakes
    * const nashtShabakes = await prisma.nashtShabake.findMany()
    * ```
    */
  get nashtShabake(): Prisma.NashtShabakeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.network`: Exposes CRUD operations for the **Network** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Networks
    * const networks = await prisma.network.findMany()
    * ```
    */
  get network(): Prisma.NetworkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noeKesht`: Exposes CRUD operations for the **NoeKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoeKeshts
    * const noeKeshts = await prisma.noeKesht.findMany()
    * ```
    */
  get noeKesht(): Prisma.NoeKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noeMahsool`: Exposes CRUD operations for the **NoeMahsool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoeMahsools
    * const noeMahsools = await prisma.noeMahsool.findMany()
    * ```
    */
  get noeMahsool(): Prisma.NoeMahsoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nonFIT`: Exposes CRUD operations for the **NonFIT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NonFITS
    * const nonFITS = await prisma.nonFIT.findMany()
    * ```
    */
  get nonFIT(): Prisma.NonFITDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pumpStation`: Exposes CRUD operations for the **PumpStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PumpStations
    * const pumpStations = await prisma.pumpStation.findMany()
    * ```
    */
  get pumpStation(): Prisma.PumpStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pumpType`: Exposes CRUD operations for the **PumpType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PumpTypes
    * const pumpTypes = await prisma.pumpType.findMany()
    * ```
    */
  get pumpType(): Prisma.PumpTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainfallStation`: Exposes CRUD operations for the **RainfallStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainfallStations
    * const rainfallStations = await prisma.rainfallStation.findMany()
    * ```
    */
  get rainfallStation(): Prisma.RainfallStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainfallType`: Exposes CRUD operations for the **RainfallType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainfallTypes
    * const rainfallTypes = await prisma.rainfallType.findMany()
    * ```
    */
  get rainfallType(): Prisma.RainfallTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleZeraee`: Exposes CRUD operations for the **SaleZeraee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleZeraees
    * const saleZeraees = await prisma.saleZeraee.findMany()
    * ```
    */
  get saleZeraee(): Prisma.SaleZeraeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seghliPump`: Exposes CRUD operations for the **SeghliPump** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeghliPumps
    * const seghliPumps = await prisma.seghliPump.findMany()
    * ```
    */
  get seghliPump(): Prisma.SeghliPumpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemPart`: Exposes CRUD operations for the **SystemPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemParts
    * const systemParts = await prisma.systemPart.findMany()
    * ```
    */
  get systemPart(): Prisma.SystemPartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takhlieMakhzan`: Exposes CRUD operations for the **TakhlieMakhzan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TakhlieMakhzans
    * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany()
    * ```
    */
  get takhlieMakhzan(): Prisma.TakhlieMakhzanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trikhDoreKesht`: Exposes CRUD operations for the **TrikhDoreKesht** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrikhDoreKeshts
    * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany()
    * ```
    */
  get trikhDoreKesht(): Prisma.TrikhDoreKeshtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weatherStation`: Exposes CRUD operations for the **WeatherStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherStations
    * const weatherStations = await prisma.weatherStation.findMany()
    * ```
    */
  get weatherStation(): Prisma.WeatherStationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AbadeMakhzan: 'AbadeMakhzan',
    Abgir: 'Abgir',
    AtashSoozi: 'AtashSoozi',
    BahrebardairProgram: 'BahrebardairProgram',
    BahrebardariKeshtDore: 'BahrebardariKeshtDore',
    BahrebardariTaghvim: 'BahrebardariTaghvim',
    BareshMotaleat: 'BareshMotaleat',
    DarajePipe: 'DarajePipe',
    DarjeStation: 'DarjeStation',
    DoreKesht: 'DoreKesht',
    EshtebahAvamel: 'EshtebahAvamel',
    FlowBehbood: 'FlowBehbood',
    Flowmeter: 'Flowmeter',
    KhatRanesh: 'KhatRanesh',
    KhatRaneshArea: 'KhatRaneshArea',
    KhatRaneshPump: 'KhatRaneshPump',
    KhatRaneshSegli: 'KhatRaneshSegli',
    Kontor: 'Kontor',
    Land: 'Land',
    Mah: 'Mah',
    MeasuringTool: 'MeasuringTool',
    NashtShabake: 'NashtShabake',
    Network: 'Network',
    NoeKesht: 'NoeKesht',
    NoeMahsool: 'NoeMahsool',
    NonFIT: 'NonFIT',
    PumpStation: 'PumpStation',
    PumpType: 'PumpType',
    RainfallStation: 'RainfallStation',
    RainfallType: 'RainfallType',
    SaleZeraee: 'SaleZeraee',
    SeghliPump: 'SeghliPump',
    SystemPart: 'SystemPart',
    TakhlieMakhzan: 'TakhlieMakhzan',
    Test: 'Test',
    TrikhDoreKesht: 'TrikhDoreKesht',
    WeatherStation: 'WeatherStation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "abadeMakhzan" | "abgir" | "atashSoozi" | "bahrebardairProgram" | "bahrebardariKeshtDore" | "bahrebardariTaghvim" | "bareshMotaleat" | "darajePipe" | "darjeStation" | "doreKesht" | "eshtebahAvamel" | "flowBehbood" | "flowmeter" | "khatRanesh" | "khatRaneshArea" | "khatRaneshPump" | "khatRaneshSegli" | "kontor" | "land" | "mah" | "measuringTool" | "nashtShabake" | "network" | "noeKesht" | "noeMahsool" | "nonFIT" | "pumpStation" | "pumpType" | "rainfallStation" | "rainfallType" | "saleZeraee" | "seghliPump" | "systemPart" | "takhlieMakhzan" | "test" | "trikhDoreKesht" | "weatherStation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AbadeMakhzan: {
        payload: Prisma.$AbadeMakhzanPayload<ExtArgs>
        fields: Prisma.AbadeMakhzanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbadeMakhzanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          findFirst: {
            args: Prisma.AbadeMakhzanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbadeMakhzanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          findMany: {
            args: Prisma.AbadeMakhzanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>[]
          }
          create: {
            args: Prisma.AbadeMakhzanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          createMany: {
            args: Prisma.AbadeMakhzanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbadeMakhzanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          update: {
            args: Prisma.AbadeMakhzanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          deleteMany: {
            args: Prisma.AbadeMakhzanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbadeMakhzanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbadeMakhzanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbadeMakhzanPayload>
          }
          aggregate: {
            args: Prisma.AbadeMakhzanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbadeMakhzan>
          }
          groupBy: {
            args: Prisma.AbadeMakhzanGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbadeMakhzanGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbadeMakhzanCountArgs<ExtArgs>
            result: $Utils.Optional<AbadeMakhzanCountAggregateOutputType> | number
          }
        }
      }
      Abgir: {
        payload: Prisma.$AbgirPayload<ExtArgs>
        fields: Prisma.AbgirFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbgirFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbgirFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          findFirst: {
            args: Prisma.AbgirFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbgirFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          findMany: {
            args: Prisma.AbgirFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>[]
          }
          create: {
            args: Prisma.AbgirCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          createMany: {
            args: Prisma.AbgirCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbgirDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          update: {
            args: Prisma.AbgirUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          deleteMany: {
            args: Prisma.AbgirDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbgirUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbgirUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbgirPayload>
          }
          aggregate: {
            args: Prisma.AbgirAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbgir>
          }
          groupBy: {
            args: Prisma.AbgirGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbgirGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbgirCountArgs<ExtArgs>
            result: $Utils.Optional<AbgirCountAggregateOutputType> | number
          }
        }
      }
      AtashSoozi: {
        payload: Prisma.$AtashSooziPayload<ExtArgs>
        fields: Prisma.AtashSooziFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AtashSooziFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AtashSooziFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          findFirst: {
            args: Prisma.AtashSooziFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AtashSooziFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          findMany: {
            args: Prisma.AtashSooziFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>[]
          }
          create: {
            args: Prisma.AtashSooziCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          createMany: {
            args: Prisma.AtashSooziCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AtashSooziDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          update: {
            args: Prisma.AtashSooziUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          deleteMany: {
            args: Prisma.AtashSooziDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AtashSooziUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AtashSooziUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtashSooziPayload>
          }
          aggregate: {
            args: Prisma.AtashSooziAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAtashSoozi>
          }
          groupBy: {
            args: Prisma.AtashSooziGroupByArgs<ExtArgs>
            result: $Utils.Optional<AtashSooziGroupByOutputType>[]
          }
          count: {
            args: Prisma.AtashSooziCountArgs<ExtArgs>
            result: $Utils.Optional<AtashSooziCountAggregateOutputType> | number
          }
        }
      }
      BahrebardairProgram: {
        payload: Prisma.$BahrebardairProgramPayload<ExtArgs>
        fields: Prisma.BahrebardairProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardairProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          findFirst: {
            args: Prisma.BahrebardairProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardairProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          findMany: {
            args: Prisma.BahrebardairProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>[]
          }
          create: {
            args: Prisma.BahrebardairProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          createMany: {
            args: Prisma.BahrebardairProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardairProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          update: {
            args: Prisma.BahrebardairProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          deleteMany: {
            args: Prisma.BahrebardairProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardairProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardairProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardairProgramPayload>
          }
          aggregate: {
            args: Prisma.BahrebardairProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardairProgram>
          }
          groupBy: {
            args: Prisma.BahrebardairProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardairProgramCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardairProgramCountAggregateOutputType> | number
          }
        }
      }
      BahrebardariKeshtDore: {
        payload: Prisma.$BahrebardariKeshtDorePayload<ExtArgs>
        fields: Prisma.BahrebardariKeshtDoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardariKeshtDoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          findFirst: {
            args: Prisma.BahrebardariKeshtDoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          findMany: {
            args: Prisma.BahrebardariKeshtDoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>[]
          }
          create: {
            args: Prisma.BahrebardariKeshtDoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          createMany: {
            args: Prisma.BahrebardariKeshtDoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardariKeshtDoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          update: {
            args: Prisma.BahrebardariKeshtDoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          deleteMany: {
            args: Prisma.BahrebardariKeshtDoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardariKeshtDoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardariKeshtDoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariKeshtDorePayload>
          }
          aggregate: {
            args: Prisma.BahrebardariKeshtDoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardariKeshtDore>
          }
          groupBy: {
            args: Prisma.BahrebardariKeshtDoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariKeshtDoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardariKeshtDoreCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariKeshtDoreCountAggregateOutputType> | number
          }
        }
      }
      BahrebardariTaghvim: {
        payload: Prisma.$BahrebardariTaghvimPayload<ExtArgs>
        fields: Prisma.BahrebardariTaghvimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BahrebardariTaghvimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          findFirst: {
            args: Prisma.BahrebardariTaghvimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          findMany: {
            args: Prisma.BahrebardariTaghvimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>[]
          }
          create: {
            args: Prisma.BahrebardariTaghvimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          createMany: {
            args: Prisma.BahrebardariTaghvimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BahrebardariTaghvimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          update: {
            args: Prisma.BahrebardariTaghvimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          deleteMany: {
            args: Prisma.BahrebardariTaghvimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BahrebardariTaghvimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BahrebardariTaghvimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BahrebardariTaghvimPayload>
          }
          aggregate: {
            args: Prisma.BahrebardariTaghvimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBahrebardariTaghvim>
          }
          groupBy: {
            args: Prisma.BahrebardariTaghvimGroupByArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariTaghvimGroupByOutputType>[]
          }
          count: {
            args: Prisma.BahrebardariTaghvimCountArgs<ExtArgs>
            result: $Utils.Optional<BahrebardariTaghvimCountAggregateOutputType> | number
          }
        }
      }
      BareshMotaleat: {
        payload: Prisma.$BareshMotaleatPayload<ExtArgs>
        fields: Prisma.BareshMotaleatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BareshMotaleatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BareshMotaleatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          findFirst: {
            args: Prisma.BareshMotaleatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BareshMotaleatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          findMany: {
            args: Prisma.BareshMotaleatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>[]
          }
          create: {
            args: Prisma.BareshMotaleatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          createMany: {
            args: Prisma.BareshMotaleatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BareshMotaleatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          update: {
            args: Prisma.BareshMotaleatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          deleteMany: {
            args: Prisma.BareshMotaleatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BareshMotaleatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BareshMotaleatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BareshMotaleatPayload>
          }
          aggregate: {
            args: Prisma.BareshMotaleatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBareshMotaleat>
          }
          groupBy: {
            args: Prisma.BareshMotaleatGroupByArgs<ExtArgs>
            result: $Utils.Optional<BareshMotaleatGroupByOutputType>[]
          }
          count: {
            args: Prisma.BareshMotaleatCountArgs<ExtArgs>
            result: $Utils.Optional<BareshMotaleatCountAggregateOutputType> | number
          }
        }
      }
      DarajePipe: {
        payload: Prisma.$DarajePipePayload<ExtArgs>
        fields: Prisma.DarajePipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DarajePipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DarajePipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          findFirst: {
            args: Prisma.DarajePipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DarajePipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          findMany: {
            args: Prisma.DarajePipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>[]
          }
          create: {
            args: Prisma.DarajePipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          createMany: {
            args: Prisma.DarajePipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DarajePipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          update: {
            args: Prisma.DarajePipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          deleteMany: {
            args: Prisma.DarajePipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DarajePipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DarajePipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarajePipePayload>
          }
          aggregate: {
            args: Prisma.DarajePipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDarajePipe>
          }
          groupBy: {
            args: Prisma.DarajePipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DarajePipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DarajePipeCountArgs<ExtArgs>
            result: $Utils.Optional<DarajePipeCountAggregateOutputType> | number
          }
        }
      }
      DarjeStation: {
        payload: Prisma.$DarjeStationPayload<ExtArgs>
        fields: Prisma.DarjeStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DarjeStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DarjeStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          findFirst: {
            args: Prisma.DarjeStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DarjeStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          findMany: {
            args: Prisma.DarjeStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>[]
          }
          create: {
            args: Prisma.DarjeStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          createMany: {
            args: Prisma.DarjeStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DarjeStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          update: {
            args: Prisma.DarjeStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          deleteMany: {
            args: Prisma.DarjeStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DarjeStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DarjeStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarjeStationPayload>
          }
          aggregate: {
            args: Prisma.DarjeStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDarjeStation>
          }
          groupBy: {
            args: Prisma.DarjeStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DarjeStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DarjeStationCountArgs<ExtArgs>
            result: $Utils.Optional<DarjeStationCountAggregateOutputType> | number
          }
        }
      }
      DoreKesht: {
        payload: Prisma.$DoreKeshtPayload<ExtArgs>
        fields: Prisma.DoreKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoreKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoreKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          findFirst: {
            args: Prisma.DoreKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoreKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          findMany: {
            args: Prisma.DoreKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>[]
          }
          create: {
            args: Prisma.DoreKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          createMany: {
            args: Prisma.DoreKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DoreKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          update: {
            args: Prisma.DoreKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          deleteMany: {
            args: Prisma.DoreKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoreKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoreKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoreKeshtPayload>
          }
          aggregate: {
            args: Prisma.DoreKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoreKesht>
          }
          groupBy: {
            args: Prisma.DoreKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoreKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoreKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<DoreKeshtCountAggregateOutputType> | number
          }
        }
      }
      EshtebahAvamel: {
        payload: Prisma.$EshtebahAvamelPayload<ExtArgs>
        fields: Prisma.EshtebahAvamelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EshtebahAvamelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          findFirst: {
            args: Prisma.EshtebahAvamelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EshtebahAvamelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          findMany: {
            args: Prisma.EshtebahAvamelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>[]
          }
          create: {
            args: Prisma.EshtebahAvamelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          createMany: {
            args: Prisma.EshtebahAvamelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EshtebahAvamelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          update: {
            args: Prisma.EshtebahAvamelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          deleteMany: {
            args: Prisma.EshtebahAvamelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EshtebahAvamelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EshtebahAvamelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EshtebahAvamelPayload>
          }
          aggregate: {
            args: Prisma.EshtebahAvamelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEshtebahAvamel>
          }
          groupBy: {
            args: Prisma.EshtebahAvamelGroupByArgs<ExtArgs>
            result: $Utils.Optional<EshtebahAvamelGroupByOutputType>[]
          }
          count: {
            args: Prisma.EshtebahAvamelCountArgs<ExtArgs>
            result: $Utils.Optional<EshtebahAvamelCountAggregateOutputType> | number
          }
        }
      }
      FlowBehbood: {
        payload: Prisma.$FlowBehboodPayload<ExtArgs>
        fields: Prisma.FlowBehboodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowBehboodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowBehboodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          findFirst: {
            args: Prisma.FlowBehboodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowBehboodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          findMany: {
            args: Prisma.FlowBehboodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>[]
          }
          create: {
            args: Prisma.FlowBehboodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          createMany: {
            args: Prisma.FlowBehboodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowBehboodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          update: {
            args: Prisma.FlowBehboodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          deleteMany: {
            args: Prisma.FlowBehboodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowBehboodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowBehboodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowBehboodPayload>
          }
          aggregate: {
            args: Prisma.FlowBehboodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowBehbood>
          }
          groupBy: {
            args: Prisma.FlowBehboodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowBehboodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowBehboodCountArgs<ExtArgs>
            result: $Utils.Optional<FlowBehboodCountAggregateOutputType> | number
          }
        }
      }
      Flowmeter: {
        payload: Prisma.$FlowmeterPayload<ExtArgs>
        fields: Prisma.FlowmeterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowmeterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowmeterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          findFirst: {
            args: Prisma.FlowmeterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowmeterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          findMany: {
            args: Prisma.FlowmeterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>[]
          }
          create: {
            args: Prisma.FlowmeterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          createMany: {
            args: Prisma.FlowmeterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowmeterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          update: {
            args: Prisma.FlowmeterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          deleteMany: {
            args: Prisma.FlowmeterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowmeterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowmeterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowmeterPayload>
          }
          aggregate: {
            args: Prisma.FlowmeterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowmeter>
          }
          groupBy: {
            args: Prisma.FlowmeterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowmeterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowmeterCountArgs<ExtArgs>
            result: $Utils.Optional<FlowmeterCountAggregateOutputType> | number
          }
        }
      }
      KhatRanesh: {
        payload: Prisma.$KhatRaneshPayload<ExtArgs>
        fields: Prisma.KhatRaneshFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          update: {
            args: Prisma.KhatRaneshUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRanesh>
          }
          groupBy: {
            args: Prisma.KhatRaneshGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshArea: {
        payload: Prisma.$KhatRaneshAreaPayload<ExtArgs>
        fields: Prisma.KhatRaneshAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          update: {
            args: Prisma.KhatRaneshAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshAreaPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshArea>
          }
          groupBy: {
            args: Prisma.KhatRaneshAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshAreaCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshAreaCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshPump: {
        payload: Prisma.$KhatRaneshPumpPayload<ExtArgs>
        fields: Prisma.KhatRaneshPumpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshPumpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshPumpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshPumpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshPumpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshPumpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshPumpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          update: {
            args: Prisma.KhatRaneshPumpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshPumpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshPumpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshPumpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshPumpPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshPumpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshPump>
          }
          groupBy: {
            args: Prisma.KhatRaneshPumpGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshPumpGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshPumpCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshPumpCountAggregateOutputType> | number
          }
        }
      }
      KhatRaneshSegli: {
        payload: Prisma.$KhatRaneshSegliPayload<ExtArgs>
        fields: Prisma.KhatRaneshSegliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KhatRaneshSegliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          findFirst: {
            args: Prisma.KhatRaneshSegliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          findMany: {
            args: Prisma.KhatRaneshSegliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>[]
          }
          create: {
            args: Prisma.KhatRaneshSegliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          createMany: {
            args: Prisma.KhatRaneshSegliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KhatRaneshSegliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          update: {
            args: Prisma.KhatRaneshSegliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          deleteMany: {
            args: Prisma.KhatRaneshSegliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KhatRaneshSegliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KhatRaneshSegliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KhatRaneshSegliPayload>
          }
          aggregate: {
            args: Prisma.KhatRaneshSegliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKhatRaneshSegli>
          }
          groupBy: {
            args: Prisma.KhatRaneshSegliGroupByArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshSegliGroupByOutputType>[]
          }
          count: {
            args: Prisma.KhatRaneshSegliCountArgs<ExtArgs>
            result: $Utils.Optional<KhatRaneshSegliCountAggregateOutputType> | number
          }
        }
      }
      Kontor: {
        payload: Prisma.$KontorPayload<ExtArgs>
        fields: Prisma.KontorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KontorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KontorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          findFirst: {
            args: Prisma.KontorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KontorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          findMany: {
            args: Prisma.KontorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>[]
          }
          create: {
            args: Prisma.KontorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          createMany: {
            args: Prisma.KontorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KontorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          update: {
            args: Prisma.KontorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          deleteMany: {
            args: Prisma.KontorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KontorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KontorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorPayload>
          }
          aggregate: {
            args: Prisma.KontorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKontor>
          }
          groupBy: {
            args: Prisma.KontorGroupByArgs<ExtArgs>
            result: $Utils.Optional<KontorGroupByOutputType>[]
          }
          count: {
            args: Prisma.KontorCountArgs<ExtArgs>
            result: $Utils.Optional<KontorCountAggregateOutputType> | number
          }
        }
      }
      Land: {
        payload: Prisma.$LandPayload<ExtArgs>
        fields: Prisma.LandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          findFirst: {
            args: Prisma.LandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          findMany: {
            args: Prisma.LandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>[]
          }
          create: {
            args: Prisma.LandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          createMany: {
            args: Prisma.LandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          update: {
            args: Prisma.LandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          deleteMany: {
            args: Prisma.LandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPayload>
          }
          aggregate: {
            args: Prisma.LandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand>
          }
          groupBy: {
            args: Prisma.LandGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandCountArgs<ExtArgs>
            result: $Utils.Optional<LandCountAggregateOutputType> | number
          }
        }
      }
      Mah: {
        payload: Prisma.$MahPayload<ExtArgs>
        fields: Prisma.MahFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MahFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MahFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          findFirst: {
            args: Prisma.MahFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MahFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          findMany: {
            args: Prisma.MahFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>[]
          }
          create: {
            args: Prisma.MahCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          createMany: {
            args: Prisma.MahCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MahDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          update: {
            args: Prisma.MahUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          deleteMany: {
            args: Prisma.MahDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MahUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MahUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahPayload>
          }
          aggregate: {
            args: Prisma.MahAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMah>
          }
          groupBy: {
            args: Prisma.MahGroupByArgs<ExtArgs>
            result: $Utils.Optional<MahGroupByOutputType>[]
          }
          count: {
            args: Prisma.MahCountArgs<ExtArgs>
            result: $Utils.Optional<MahCountAggregateOutputType> | number
          }
        }
      }
      MeasuringTool: {
        payload: Prisma.$MeasuringToolPayload<ExtArgs>
        fields: Prisma.MeasuringToolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeasuringToolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeasuringToolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          findFirst: {
            args: Prisma.MeasuringToolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeasuringToolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          findMany: {
            args: Prisma.MeasuringToolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>[]
          }
          create: {
            args: Prisma.MeasuringToolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          createMany: {
            args: Prisma.MeasuringToolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeasuringToolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          update: {
            args: Prisma.MeasuringToolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          deleteMany: {
            args: Prisma.MeasuringToolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeasuringToolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeasuringToolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasuringToolPayload>
          }
          aggregate: {
            args: Prisma.MeasuringToolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeasuringTool>
          }
          groupBy: {
            args: Prisma.MeasuringToolGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeasuringToolGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeasuringToolCountArgs<ExtArgs>
            result: $Utils.Optional<MeasuringToolCountAggregateOutputType> | number
          }
        }
      }
      NashtShabake: {
        payload: Prisma.$NashtShabakePayload<ExtArgs>
        fields: Prisma.NashtShabakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NashtShabakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NashtShabakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          findFirst: {
            args: Prisma.NashtShabakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NashtShabakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          findMany: {
            args: Prisma.NashtShabakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>[]
          }
          create: {
            args: Prisma.NashtShabakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          createMany: {
            args: Prisma.NashtShabakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NashtShabakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          update: {
            args: Prisma.NashtShabakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          deleteMany: {
            args: Prisma.NashtShabakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NashtShabakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NashtShabakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NashtShabakePayload>
          }
          aggregate: {
            args: Prisma.NashtShabakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNashtShabake>
          }
          groupBy: {
            args: Prisma.NashtShabakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NashtShabakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NashtShabakeCountArgs<ExtArgs>
            result: $Utils.Optional<NashtShabakeCountAggregateOutputType> | number
          }
        }
      }
      Network: {
        payload: Prisma.$NetworkPayload<ExtArgs>
        fields: Prisma.NetworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findFirst: {
            args: Prisma.NetworkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findMany: {
            args: Prisma.NetworkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>[]
          }
          create: {
            args: Prisma.NetworkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          createMany: {
            args: Prisma.NetworkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NetworkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          update: {
            args: Prisma.NetworkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          deleteMany: {
            args: Prisma.NetworkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NetworkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          aggregate: {
            args: Prisma.NetworkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetwork>
          }
          groupBy: {
            args: Prisma.NetworkGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkCountAggregateOutputType> | number
          }
        }
      }
      NoeKesht: {
        payload: Prisma.$NoeKeshtPayload<ExtArgs>
        fields: Prisma.NoeKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoeKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoeKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          findFirst: {
            args: Prisma.NoeKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoeKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          findMany: {
            args: Prisma.NoeKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>[]
          }
          create: {
            args: Prisma.NoeKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          createMany: {
            args: Prisma.NoeKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoeKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          update: {
            args: Prisma.NoeKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          deleteMany: {
            args: Prisma.NoeKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoeKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoeKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeKeshtPayload>
          }
          aggregate: {
            args: Prisma.NoeKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoeKesht>
          }
          groupBy: {
            args: Prisma.NoeKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoeKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoeKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<NoeKeshtCountAggregateOutputType> | number
          }
        }
      }
      NoeMahsool: {
        payload: Prisma.$NoeMahsoolPayload<ExtArgs>
        fields: Prisma.NoeMahsoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoeMahsoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoeMahsoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          findFirst: {
            args: Prisma.NoeMahsoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoeMahsoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          findMany: {
            args: Prisma.NoeMahsoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>[]
          }
          create: {
            args: Prisma.NoeMahsoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          createMany: {
            args: Prisma.NoeMahsoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoeMahsoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          update: {
            args: Prisma.NoeMahsoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          deleteMany: {
            args: Prisma.NoeMahsoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoeMahsoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoeMahsoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoeMahsoolPayload>
          }
          aggregate: {
            args: Prisma.NoeMahsoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoeMahsool>
          }
          groupBy: {
            args: Prisma.NoeMahsoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoeMahsoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoeMahsoolCountArgs<ExtArgs>
            result: $Utils.Optional<NoeMahsoolCountAggregateOutputType> | number
          }
        }
      }
      NonFIT: {
        payload: Prisma.$NonFITPayload<ExtArgs>
        fields: Prisma.NonFITFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NonFITFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NonFITFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          findFirst: {
            args: Prisma.NonFITFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NonFITFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          findMany: {
            args: Prisma.NonFITFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>[]
          }
          create: {
            args: Prisma.NonFITCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          createMany: {
            args: Prisma.NonFITCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NonFITDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          update: {
            args: Prisma.NonFITUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          deleteMany: {
            args: Prisma.NonFITDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NonFITUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NonFITUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NonFITPayload>
          }
          aggregate: {
            args: Prisma.NonFITAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNonFIT>
          }
          groupBy: {
            args: Prisma.NonFITGroupByArgs<ExtArgs>
            result: $Utils.Optional<NonFITGroupByOutputType>[]
          }
          count: {
            args: Prisma.NonFITCountArgs<ExtArgs>
            result: $Utils.Optional<NonFITCountAggregateOutputType> | number
          }
        }
      }
      PumpStation: {
        payload: Prisma.$PumpStationPayload<ExtArgs>
        fields: Prisma.PumpStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PumpStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PumpStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          findFirst: {
            args: Prisma.PumpStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PumpStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          findMany: {
            args: Prisma.PumpStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>[]
          }
          create: {
            args: Prisma.PumpStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          createMany: {
            args: Prisma.PumpStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PumpStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          update: {
            args: Prisma.PumpStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          deleteMany: {
            args: Prisma.PumpStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PumpStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PumpStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpStationPayload>
          }
          aggregate: {
            args: Prisma.PumpStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePumpStation>
          }
          groupBy: {
            args: Prisma.PumpStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PumpStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PumpStationCountArgs<ExtArgs>
            result: $Utils.Optional<PumpStationCountAggregateOutputType> | number
          }
        }
      }
      PumpType: {
        payload: Prisma.$PumpTypePayload<ExtArgs>
        fields: Prisma.PumpTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PumpTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PumpTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          findFirst: {
            args: Prisma.PumpTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PumpTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          findMany: {
            args: Prisma.PumpTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>[]
          }
          create: {
            args: Prisma.PumpTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          createMany: {
            args: Prisma.PumpTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PumpTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          update: {
            args: Prisma.PumpTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          deleteMany: {
            args: Prisma.PumpTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PumpTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PumpTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PumpTypePayload>
          }
          aggregate: {
            args: Prisma.PumpTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePumpType>
          }
          groupBy: {
            args: Prisma.PumpTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PumpTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PumpTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PumpTypeCountAggregateOutputType> | number
          }
        }
      }
      RainfallStation: {
        payload: Prisma.$RainfallStationPayload<ExtArgs>
        fields: Prisma.RainfallStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainfallStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainfallStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          findFirst: {
            args: Prisma.RainfallStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainfallStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          findMany: {
            args: Prisma.RainfallStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>[]
          }
          create: {
            args: Prisma.RainfallStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          createMany: {
            args: Prisma.RainfallStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RainfallStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          update: {
            args: Prisma.RainfallStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          deleteMany: {
            args: Prisma.RainfallStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainfallStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainfallStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallStationPayload>
          }
          aggregate: {
            args: Prisma.RainfallStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainfallStation>
          }
          groupBy: {
            args: Prisma.RainfallStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainfallStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainfallStationCountArgs<ExtArgs>
            result: $Utils.Optional<RainfallStationCountAggregateOutputType> | number
          }
        }
      }
      RainfallType: {
        payload: Prisma.$RainfallTypePayload<ExtArgs>
        fields: Prisma.RainfallTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainfallTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainfallTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          findFirst: {
            args: Prisma.RainfallTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainfallTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          findMany: {
            args: Prisma.RainfallTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>[]
          }
          create: {
            args: Prisma.RainfallTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          createMany: {
            args: Prisma.RainfallTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RainfallTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          update: {
            args: Prisma.RainfallTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          deleteMany: {
            args: Prisma.RainfallTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainfallTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainfallTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainfallTypePayload>
          }
          aggregate: {
            args: Prisma.RainfallTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainfallType>
          }
          groupBy: {
            args: Prisma.RainfallTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainfallTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainfallTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RainfallTypeCountAggregateOutputType> | number
          }
        }
      }
      SaleZeraee: {
        payload: Prisma.$SaleZeraeePayload<ExtArgs>
        fields: Prisma.SaleZeraeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleZeraeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleZeraeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          findFirst: {
            args: Prisma.SaleZeraeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleZeraeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          findMany: {
            args: Prisma.SaleZeraeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>[]
          }
          create: {
            args: Prisma.SaleZeraeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          createMany: {
            args: Prisma.SaleZeraeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaleZeraeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          update: {
            args: Prisma.SaleZeraeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          deleteMany: {
            args: Prisma.SaleZeraeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleZeraeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleZeraeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleZeraeePayload>
          }
          aggregate: {
            args: Prisma.SaleZeraeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleZeraee>
          }
          groupBy: {
            args: Prisma.SaleZeraeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleZeraeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleZeraeeCountArgs<ExtArgs>
            result: $Utils.Optional<SaleZeraeeCountAggregateOutputType> | number
          }
        }
      }
      SeghliPump: {
        payload: Prisma.$SeghliPumpPayload<ExtArgs>
        fields: Prisma.SeghliPumpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeghliPumpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeghliPumpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          findFirst: {
            args: Prisma.SeghliPumpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeghliPumpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          findMany: {
            args: Prisma.SeghliPumpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>[]
          }
          create: {
            args: Prisma.SeghliPumpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          createMany: {
            args: Prisma.SeghliPumpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeghliPumpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          update: {
            args: Prisma.SeghliPumpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          deleteMany: {
            args: Prisma.SeghliPumpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeghliPumpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeghliPumpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeghliPumpPayload>
          }
          aggregate: {
            args: Prisma.SeghliPumpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeghliPump>
          }
          groupBy: {
            args: Prisma.SeghliPumpGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeghliPumpGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeghliPumpCountArgs<ExtArgs>
            result: $Utils.Optional<SeghliPumpCountAggregateOutputType> | number
          }
        }
      }
      SystemPart: {
        payload: Prisma.$SystemPartPayload<ExtArgs>
        fields: Prisma.SystemPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          findFirst: {
            args: Prisma.SystemPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          findMany: {
            args: Prisma.SystemPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>[]
          }
          create: {
            args: Prisma.SystemPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          createMany: {
            args: Prisma.SystemPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          update: {
            args: Prisma.SystemPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          deleteMany: {
            args: Prisma.SystemPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPartPayload>
          }
          aggregate: {
            args: Prisma.SystemPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemPart>
          }
          groupBy: {
            args: Prisma.SystemPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemPartCountArgs<ExtArgs>
            result: $Utils.Optional<SystemPartCountAggregateOutputType> | number
          }
        }
      }
      TakhlieMakhzan: {
        payload: Prisma.$TakhlieMakhzanPayload<ExtArgs>
        fields: Prisma.TakhlieMakhzanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakhlieMakhzanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          findFirst: {
            args: Prisma.TakhlieMakhzanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          findMany: {
            args: Prisma.TakhlieMakhzanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>[]
          }
          create: {
            args: Prisma.TakhlieMakhzanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          createMany: {
            args: Prisma.TakhlieMakhzanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TakhlieMakhzanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          update: {
            args: Prisma.TakhlieMakhzanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          deleteMany: {
            args: Prisma.TakhlieMakhzanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakhlieMakhzanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TakhlieMakhzanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakhlieMakhzanPayload>
          }
          aggregate: {
            args: Prisma.TakhlieMakhzanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakhlieMakhzan>
          }
          groupBy: {
            args: Prisma.TakhlieMakhzanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakhlieMakhzanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakhlieMakhzanCountArgs<ExtArgs>
            result: $Utils.Optional<TakhlieMakhzanCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TrikhDoreKesht: {
        payload: Prisma.$TrikhDoreKeshtPayload<ExtArgs>
        fields: Prisma.TrikhDoreKeshtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrikhDoreKeshtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          findFirst: {
            args: Prisma.TrikhDoreKeshtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          findMany: {
            args: Prisma.TrikhDoreKeshtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>[]
          }
          create: {
            args: Prisma.TrikhDoreKeshtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          createMany: {
            args: Prisma.TrikhDoreKeshtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrikhDoreKeshtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          update: {
            args: Prisma.TrikhDoreKeshtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          deleteMany: {
            args: Prisma.TrikhDoreKeshtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrikhDoreKeshtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrikhDoreKeshtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrikhDoreKeshtPayload>
          }
          aggregate: {
            args: Prisma.TrikhDoreKeshtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrikhDoreKesht>
          }
          groupBy: {
            args: Prisma.TrikhDoreKeshtGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrikhDoreKeshtGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrikhDoreKeshtCountArgs<ExtArgs>
            result: $Utils.Optional<TrikhDoreKeshtCountAggregateOutputType> | number
          }
        }
      }
      WeatherStation: {
        payload: Prisma.$WeatherStationPayload<ExtArgs>
        fields: Prisma.WeatherStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          findFirst: {
            args: Prisma.WeatherStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          findMany: {
            args: Prisma.WeatherStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>[]
          }
          create: {
            args: Prisma.WeatherStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          createMany: {
            args: Prisma.WeatherStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeatherStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          update: {
            args: Prisma.WeatherStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          deleteMany: {
            args: Prisma.WeatherStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeatherStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherStationPayload>
          }
          aggregate: {
            args: Prisma.WeatherStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherStation>
          }
          groupBy: {
            args: Prisma.WeatherStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherStationCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherStationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    abadeMakhzan?: AbadeMakhzanOmit
    abgir?: AbgirOmit
    atashSoozi?: AtashSooziOmit
    bahrebardairProgram?: BahrebardairProgramOmit
    bahrebardariKeshtDore?: BahrebardariKeshtDoreOmit
    bahrebardariTaghvim?: BahrebardariTaghvimOmit
    bareshMotaleat?: BareshMotaleatOmit
    darajePipe?: DarajePipeOmit
    darjeStation?: DarjeStationOmit
    doreKesht?: DoreKeshtOmit
    eshtebahAvamel?: EshtebahAvamelOmit
    flowBehbood?: FlowBehboodOmit
    flowmeter?: FlowmeterOmit
    khatRanesh?: KhatRaneshOmit
    khatRaneshArea?: KhatRaneshAreaOmit
    khatRaneshPump?: KhatRaneshPumpOmit
    khatRaneshSegli?: KhatRaneshSegliOmit
    kontor?: KontorOmit
    land?: LandOmit
    mah?: MahOmit
    measuringTool?: MeasuringToolOmit
    nashtShabake?: NashtShabakeOmit
    network?: NetworkOmit
    noeKesht?: NoeKeshtOmit
    noeMahsool?: NoeMahsoolOmit
    nonFIT?: NonFITOmit
    pumpStation?: PumpStationOmit
    pumpType?: PumpTypeOmit
    rainfallStation?: RainfallStationOmit
    rainfallType?: RainfallTypeOmit
    saleZeraee?: SaleZeraeeOmit
    seghliPump?: SeghliPumpOmit
    systemPart?: SystemPartOmit
    takhlieMakhzan?: TakhlieMakhzanOmit
    test?: TestOmit
    trikhDoreKesht?: TrikhDoreKeshtOmit
    weatherStation?: WeatherStationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model AbadeMakhzan
   */

  export type AggregateAbadeMakhzan = {
    _count: AbadeMakhzanCountAggregateOutputType | null
    _avg: AbadeMakhzanAvgAggregateOutputType | null
    _sum: AbadeMakhzanSumAggregateOutputType | null
    _min: AbadeMakhzanMinAggregateOutputType | null
    _max: AbadeMakhzanMaxAggregateOutputType | null
  }

  export type AbadeMakhzanAvgAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
  }

  export type AbadeMakhzanSumAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
  }

  export type AbadeMakhzanMinAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
    NameStation: string | null
  }

  export type AbadeMakhzanMaxAggregateOutputType = {
    IdMakhzan: number | null
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal | null
    HadeaghalHajm: number | null
    NameStation: string | null
  }

  export type AbadeMakhzanCountAggregateOutputType = {
    IdMakhzan: number
    TooleBala: number
    ArzeBala: number
    TooleKaf: number
    ArzeKaf: number
    Omgh: number
    HajmMohasebat: number
    HadeaghalHajm: number
    NameStation: number
    _all: number
  }


  export type AbadeMakhzanAvgAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
  }

  export type AbadeMakhzanSumAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
  }

  export type AbadeMakhzanMinAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
  }

  export type AbadeMakhzanMaxAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
  }

  export type AbadeMakhzanCountAggregateInputType = {
    IdMakhzan?: true
    TooleBala?: true
    ArzeBala?: true
    TooleKaf?: true
    ArzeKaf?: true
    Omgh?: true
    HajmMohasebat?: true
    HadeaghalHajm?: true
    NameStation?: true
    _all?: true
  }

  export type AbadeMakhzanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbadeMakhzan to aggregate.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AbadeMakhzans
    **/
    _count?: true | AbadeMakhzanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbadeMakhzanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbadeMakhzanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbadeMakhzanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbadeMakhzanMaxAggregateInputType
  }

  export type GetAbadeMakhzanAggregateType<T extends AbadeMakhzanAggregateArgs> = {
        [P in keyof T & keyof AggregateAbadeMakhzan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbadeMakhzan[P]>
      : GetScalarType<T[P], AggregateAbadeMakhzan[P]>
  }




  export type AbadeMakhzanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbadeMakhzanWhereInput
    orderBy?: AbadeMakhzanOrderByWithAggregationInput | AbadeMakhzanOrderByWithAggregationInput[]
    by: AbadeMakhzanScalarFieldEnum[] | AbadeMakhzanScalarFieldEnum
    having?: AbadeMakhzanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbadeMakhzanCountAggregateInputType | true
    _avg?: AbadeMakhzanAvgAggregateInputType
    _sum?: AbadeMakhzanSumAggregateInputType
    _min?: AbadeMakhzanMinAggregateInputType
    _max?: AbadeMakhzanMaxAggregateInputType
  }

  export type AbadeMakhzanGroupByOutputType = {
    IdMakhzan: number
    TooleBala: Decimal | null
    ArzeBala: Decimal | null
    TooleKaf: Decimal | null
    ArzeKaf: Decimal | null
    Omgh: Decimal | null
    HajmMohasebat: Decimal
    HadeaghalHajm: number | null
    NameStation: string
    _count: AbadeMakhzanCountAggregateOutputType | null
    _avg: AbadeMakhzanAvgAggregateOutputType | null
    _sum: AbadeMakhzanSumAggregateOutputType | null
    _min: AbadeMakhzanMinAggregateOutputType | null
    _max: AbadeMakhzanMaxAggregateOutputType | null
  }

  type GetAbadeMakhzanGroupByPayload<T extends AbadeMakhzanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbadeMakhzanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbadeMakhzanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbadeMakhzanGroupByOutputType[P]>
            : GetScalarType<T[P], AbadeMakhzanGroupByOutputType[P]>
        }
      >
    >


  export type AbadeMakhzanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMakhzan?: boolean
    TooleBala?: boolean
    ArzeBala?: boolean
    TooleKaf?: boolean
    ArzeKaf?: boolean
    Omgh?: boolean
    HajmMohasebat?: boolean
    HadeaghalHajm?: boolean
    NameStation?: boolean
  }, ExtArgs["result"]["abadeMakhzan"]>



  export type AbadeMakhzanSelectScalar = {
    IdMakhzan?: boolean
    TooleBala?: boolean
    ArzeBala?: boolean
    TooleKaf?: boolean
    ArzeKaf?: boolean
    Omgh?: boolean
    HajmMohasebat?: boolean
    HadeaghalHajm?: boolean
    NameStation?: boolean
  }

  export type AbadeMakhzanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMakhzan" | "TooleBala" | "ArzeBala" | "TooleKaf" | "ArzeKaf" | "Omgh" | "HajmMohasebat" | "HadeaghalHajm" | "NameStation", ExtArgs["result"]["abadeMakhzan"]>

  export type $AbadeMakhzanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AbadeMakhzan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdMakhzan: number
      TooleBala: Prisma.Decimal | null
      ArzeBala: Prisma.Decimal | null
      TooleKaf: Prisma.Decimal | null
      ArzeKaf: Prisma.Decimal | null
      Omgh: Prisma.Decimal | null
      HajmMohasebat: Prisma.Decimal
      HadeaghalHajm: number | null
      NameStation: string
    }, ExtArgs["result"]["abadeMakhzan"]>
    composites: {}
  }

  type AbadeMakhzanGetPayload<S extends boolean | null | undefined | AbadeMakhzanDefaultArgs> = $Result.GetResult<Prisma.$AbadeMakhzanPayload, S>

  type AbadeMakhzanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbadeMakhzanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbadeMakhzanCountAggregateInputType | true
    }

  export interface AbadeMakhzanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AbadeMakhzan'], meta: { name: 'AbadeMakhzan' } }
    /**
     * Find zero or one AbadeMakhzan that matches the filter.
     * @param {AbadeMakhzanFindUniqueArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbadeMakhzanFindUniqueArgs>(args: SelectSubset<T, AbadeMakhzanFindUniqueArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AbadeMakhzan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbadeMakhzanFindUniqueOrThrowArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbadeMakhzanFindUniqueOrThrowArgs>(args: SelectSubset<T, AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AbadeMakhzan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindFirstArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbadeMakhzanFindFirstArgs>(args?: SelectSubset<T, AbadeMakhzanFindFirstArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AbadeMakhzan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindFirstOrThrowArgs} args - Arguments to find a AbadeMakhzan
     * @example
     * // Get one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbadeMakhzanFindFirstOrThrowArgs>(args?: SelectSubset<T, AbadeMakhzanFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AbadeMakhzans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AbadeMakhzans
     * const abadeMakhzans = await prisma.abadeMakhzan.findMany()
     * 
     * // Get first 10 AbadeMakhzans
     * const abadeMakhzans = await prisma.abadeMakhzan.findMany({ take: 10 })
     * 
     * // Only select the `IdMakhzan`
     * const abadeMakhzanWithIdMakhzanOnly = await prisma.abadeMakhzan.findMany({ select: { IdMakhzan: true } })
     * 
     */
    findMany<T extends AbadeMakhzanFindManyArgs>(args?: SelectSubset<T, AbadeMakhzanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AbadeMakhzan.
     * @param {AbadeMakhzanCreateArgs} args - Arguments to create a AbadeMakhzan.
     * @example
     * // Create one AbadeMakhzan
     * const AbadeMakhzan = await prisma.abadeMakhzan.create({
     *   data: {
     *     // ... data to create a AbadeMakhzan
     *   }
     * })
     * 
     */
    create<T extends AbadeMakhzanCreateArgs>(args: SelectSubset<T, AbadeMakhzanCreateArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AbadeMakhzans.
     * @param {AbadeMakhzanCreateManyArgs} args - Arguments to create many AbadeMakhzans.
     * @example
     * // Create many AbadeMakhzans
     * const abadeMakhzan = await prisma.abadeMakhzan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbadeMakhzanCreateManyArgs>(args?: SelectSubset<T, AbadeMakhzanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AbadeMakhzan.
     * @param {AbadeMakhzanDeleteArgs} args - Arguments to delete one AbadeMakhzan.
     * @example
     * // Delete one AbadeMakhzan
     * const AbadeMakhzan = await prisma.abadeMakhzan.delete({
     *   where: {
     *     // ... filter to delete one AbadeMakhzan
     *   }
     * })
     * 
     */
    delete<T extends AbadeMakhzanDeleteArgs>(args: SelectSubset<T, AbadeMakhzanDeleteArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AbadeMakhzan.
     * @param {AbadeMakhzanUpdateArgs} args - Arguments to update one AbadeMakhzan.
     * @example
     * // Update one AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbadeMakhzanUpdateArgs>(args: SelectSubset<T, AbadeMakhzanUpdateArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AbadeMakhzans.
     * @param {AbadeMakhzanDeleteManyArgs} args - Arguments to filter AbadeMakhzans to delete.
     * @example
     * // Delete a few AbadeMakhzans
     * const { count } = await prisma.abadeMakhzan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbadeMakhzanDeleteManyArgs>(args?: SelectSubset<T, AbadeMakhzanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbadeMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AbadeMakhzans
     * const abadeMakhzan = await prisma.abadeMakhzan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbadeMakhzanUpdateManyArgs>(args: SelectSubset<T, AbadeMakhzanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AbadeMakhzan.
     * @param {AbadeMakhzanUpsertArgs} args - Arguments to update or create a AbadeMakhzan.
     * @example
     * // Update or create a AbadeMakhzan
     * const abadeMakhzan = await prisma.abadeMakhzan.upsert({
     *   create: {
     *     // ... data to create a AbadeMakhzan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AbadeMakhzan we want to update
     *   }
     * })
     */
    upsert<T extends AbadeMakhzanUpsertArgs>(args: SelectSubset<T, AbadeMakhzanUpsertArgs<ExtArgs>>): Prisma__AbadeMakhzanClient<$Result.GetResult<Prisma.$AbadeMakhzanPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AbadeMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanCountArgs} args - Arguments to filter AbadeMakhzans to count.
     * @example
     * // Count the number of AbadeMakhzans
     * const count = await prisma.abadeMakhzan.count({
     *   where: {
     *     // ... the filter for the AbadeMakhzans we want to count
     *   }
     * })
    **/
    count<T extends AbadeMakhzanCountArgs>(
      args?: Subset<T, AbadeMakhzanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbadeMakhzanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AbadeMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbadeMakhzanAggregateArgs>(args: Subset<T, AbadeMakhzanAggregateArgs>): Prisma.PrismaPromise<GetAbadeMakhzanAggregateType<T>>

    /**
     * Group by AbadeMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbadeMakhzanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbadeMakhzanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbadeMakhzanGroupByArgs['orderBy'] }
        : { orderBy?: AbadeMakhzanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbadeMakhzanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbadeMakhzanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AbadeMakhzan model
   */
  readonly fields: AbadeMakhzanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AbadeMakhzan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbadeMakhzanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AbadeMakhzan model
   */ 
  interface AbadeMakhzanFieldRefs {
    readonly IdMakhzan: FieldRef<"AbadeMakhzan", 'Int'>
    readonly TooleBala: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly ArzeBala: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly TooleKaf: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly ArzeKaf: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly Omgh: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly HajmMohasebat: FieldRef<"AbadeMakhzan", 'Decimal'>
    readonly HadeaghalHajm: FieldRef<"AbadeMakhzan", 'Int'>
    readonly NameStation: FieldRef<"AbadeMakhzan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AbadeMakhzan findUnique
   */
  export type AbadeMakhzanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan findUniqueOrThrow
   */
  export type AbadeMakhzanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan findFirst
   */
  export type AbadeMakhzanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbadeMakhzans.
     */
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan findFirstOrThrow
   */
  export type AbadeMakhzanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzan to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbadeMakhzans.
     */
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan findMany
   */
  export type AbadeMakhzanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which AbadeMakhzans to fetch.
     */
    where?: AbadeMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbadeMakhzans to fetch.
     */
    orderBy?: AbadeMakhzanOrderByWithRelationInput | AbadeMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AbadeMakhzans.
     */
    cursor?: AbadeMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbadeMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbadeMakhzans.
     */
    skip?: number
    distinct?: AbadeMakhzanScalarFieldEnum | AbadeMakhzanScalarFieldEnum[]
  }

  /**
   * AbadeMakhzan create
   */
  export type AbadeMakhzanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * The data needed to create a AbadeMakhzan.
     */
    data: XOR<AbadeMakhzanCreateInput, AbadeMakhzanUncheckedCreateInput>
  }

  /**
   * AbadeMakhzan createMany
   */
  export type AbadeMakhzanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AbadeMakhzans.
     */
    data: AbadeMakhzanCreateManyInput | AbadeMakhzanCreateManyInput[]
  }

  /**
   * AbadeMakhzan update
   */
  export type AbadeMakhzanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * The data needed to update a AbadeMakhzan.
     */
    data: XOR<AbadeMakhzanUpdateInput, AbadeMakhzanUncheckedUpdateInput>
    /**
     * Choose, which AbadeMakhzan to update.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan updateMany
   */
  export type AbadeMakhzanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AbadeMakhzans.
     */
    data: XOR<AbadeMakhzanUpdateManyMutationInput, AbadeMakhzanUncheckedUpdateManyInput>
    /**
     * Filter which AbadeMakhzans to update
     */
    where?: AbadeMakhzanWhereInput
    /**
     * Limit how many AbadeMakhzans to update.
     */
    limit?: number
  }

  /**
   * AbadeMakhzan upsert
   */
  export type AbadeMakhzanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * The filter to search for the AbadeMakhzan to update in case it exists.
     */
    where: AbadeMakhzanWhereUniqueInput
    /**
     * In case the AbadeMakhzan found by the `where` argument doesn't exist, create a new AbadeMakhzan with this data.
     */
    create: XOR<AbadeMakhzanCreateInput, AbadeMakhzanUncheckedCreateInput>
    /**
     * In case the AbadeMakhzan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbadeMakhzanUpdateInput, AbadeMakhzanUncheckedUpdateInput>
  }

  /**
   * AbadeMakhzan delete
   */
  export type AbadeMakhzanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
    /**
     * Filter which AbadeMakhzan to delete.
     */
    where: AbadeMakhzanWhereUniqueInput
  }

  /**
   * AbadeMakhzan deleteMany
   */
  export type AbadeMakhzanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbadeMakhzans to delete
     */
    where?: AbadeMakhzanWhereInput
    /**
     * Limit how many AbadeMakhzans to delete.
     */
    limit?: number
  }

  /**
   * AbadeMakhzan without action
   */
  export type AbadeMakhzanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbadeMakhzan
     */
    select?: AbadeMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbadeMakhzan
     */
    omit?: AbadeMakhzanOmit<ExtArgs> | null
  }


  /**
   * Model Abgir
   */

  export type AggregateAbgir = {
    _count: AbgirCountAggregateOutputType | null
    _avg: AbgirAvgAggregateOutputType | null
    _sum: AbgirSumAggregateOutputType | null
    _min: AbgirMinAggregateOutputType | null
    _max: AbgirMaxAggregateOutputType | null
  }

  export type AbgirAvgAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
  }

  export type AbgirSumAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
  }

  export type AbgirMinAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
    Abgir: string | null
  }

  export type AbgirMaxAggregateOutputType = {
    IdKontor: number | null
    FIdRanesh: number | null
    Abgir: string | null
  }

  export type AbgirCountAggregateOutputType = {
    IdKontor: number
    FIdRanesh: number
    Abgir: number
    _all: number
  }


  export type AbgirAvgAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
  }

  export type AbgirSumAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
  }

  export type AbgirMinAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
  }

  export type AbgirMaxAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
  }

  export type AbgirCountAggregateInputType = {
    IdKontor?: true
    FIdRanesh?: true
    Abgir?: true
    _all?: true
  }

  export type AbgirAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abgir to aggregate.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abgirs
    **/
    _count?: true | AbgirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbgirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbgirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbgirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbgirMaxAggregateInputType
  }

  export type GetAbgirAggregateType<T extends AbgirAggregateArgs> = {
        [P in keyof T & keyof AggregateAbgir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbgir[P]>
      : GetScalarType<T[P], AggregateAbgir[P]>
  }




  export type AbgirGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbgirWhereInput
    orderBy?: AbgirOrderByWithAggregationInput | AbgirOrderByWithAggregationInput[]
    by: AbgirScalarFieldEnum[] | AbgirScalarFieldEnum
    having?: AbgirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbgirCountAggregateInputType | true
    _avg?: AbgirAvgAggregateInputType
    _sum?: AbgirSumAggregateInputType
    _min?: AbgirMinAggregateInputType
    _max?: AbgirMaxAggregateInputType
  }

  export type AbgirGroupByOutputType = {
    IdKontor: number
    FIdRanesh: number
    Abgir: string
    _count: AbgirCountAggregateOutputType | null
    _avg: AbgirAvgAggregateOutputType | null
    _sum: AbgirSumAggregateOutputType | null
    _min: AbgirMinAggregateOutputType | null
    _max: AbgirMaxAggregateOutputType | null
  }

  type GetAbgirGroupByPayload<T extends AbgirGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbgirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbgirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbgirGroupByOutputType[P]>
            : GetScalarType<T[P], AbgirGroupByOutputType[P]>
        }
      >
    >


  export type AbgirSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdKontor?: boolean
    FIdRanesh?: boolean
    Abgir?: boolean
  }, ExtArgs["result"]["abgir"]>



  export type AbgirSelectScalar = {
    IdKontor?: boolean
    FIdRanesh?: boolean
    Abgir?: boolean
  }

  export type AbgirOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdKontor" | "FIdRanesh" | "Abgir", ExtArgs["result"]["abgir"]>

  export type $AbgirPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Abgir"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdKontor: number
      FIdRanesh: number
      Abgir: string
    }, ExtArgs["result"]["abgir"]>
    composites: {}
  }

  type AbgirGetPayload<S extends boolean | null | undefined | AbgirDefaultArgs> = $Result.GetResult<Prisma.$AbgirPayload, S>

  type AbgirCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbgirFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbgirCountAggregateInputType | true
    }

  export interface AbgirDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Abgir'], meta: { name: 'Abgir' } }
    /**
     * Find zero or one Abgir that matches the filter.
     * @param {AbgirFindUniqueArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbgirFindUniqueArgs>(args: SelectSubset<T, AbgirFindUniqueArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Abgir that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbgirFindUniqueOrThrowArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbgirFindUniqueOrThrowArgs>(args: SelectSubset<T, AbgirFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Abgir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindFirstArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbgirFindFirstArgs>(args?: SelectSubset<T, AbgirFindFirstArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Abgir that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindFirstOrThrowArgs} args - Arguments to find a Abgir
     * @example
     * // Get one Abgir
     * const abgir = await prisma.abgir.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbgirFindFirstOrThrowArgs>(args?: SelectSubset<T, AbgirFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Abgirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abgirs
     * const abgirs = await prisma.abgir.findMany()
     * 
     * // Get first 10 Abgirs
     * const abgirs = await prisma.abgir.findMany({ take: 10 })
     * 
     * // Only select the `IdKontor`
     * const abgirWithIdKontorOnly = await prisma.abgir.findMany({ select: { IdKontor: true } })
     * 
     */
    findMany<T extends AbgirFindManyArgs>(args?: SelectSubset<T, AbgirFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Abgir.
     * @param {AbgirCreateArgs} args - Arguments to create a Abgir.
     * @example
     * // Create one Abgir
     * const Abgir = await prisma.abgir.create({
     *   data: {
     *     // ... data to create a Abgir
     *   }
     * })
     * 
     */
    create<T extends AbgirCreateArgs>(args: SelectSubset<T, AbgirCreateArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Abgirs.
     * @param {AbgirCreateManyArgs} args - Arguments to create many Abgirs.
     * @example
     * // Create many Abgirs
     * const abgir = await prisma.abgir.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbgirCreateManyArgs>(args?: SelectSubset<T, AbgirCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Abgir.
     * @param {AbgirDeleteArgs} args - Arguments to delete one Abgir.
     * @example
     * // Delete one Abgir
     * const Abgir = await prisma.abgir.delete({
     *   where: {
     *     // ... filter to delete one Abgir
     *   }
     * })
     * 
     */
    delete<T extends AbgirDeleteArgs>(args: SelectSubset<T, AbgirDeleteArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Abgir.
     * @param {AbgirUpdateArgs} args - Arguments to update one Abgir.
     * @example
     * // Update one Abgir
     * const abgir = await prisma.abgir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbgirUpdateArgs>(args: SelectSubset<T, AbgirUpdateArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Abgirs.
     * @param {AbgirDeleteManyArgs} args - Arguments to filter Abgirs to delete.
     * @example
     * // Delete a few Abgirs
     * const { count } = await prisma.abgir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbgirDeleteManyArgs>(args?: SelectSubset<T, AbgirDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abgirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abgirs
     * const abgir = await prisma.abgir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbgirUpdateManyArgs>(args: SelectSubset<T, AbgirUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Abgir.
     * @param {AbgirUpsertArgs} args - Arguments to update or create a Abgir.
     * @example
     * // Update or create a Abgir
     * const abgir = await prisma.abgir.upsert({
     *   create: {
     *     // ... data to create a Abgir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Abgir we want to update
     *   }
     * })
     */
    upsert<T extends AbgirUpsertArgs>(args: SelectSubset<T, AbgirUpsertArgs<ExtArgs>>): Prisma__AbgirClient<$Result.GetResult<Prisma.$AbgirPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Abgirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirCountArgs} args - Arguments to filter Abgirs to count.
     * @example
     * // Count the number of Abgirs
     * const count = await prisma.abgir.count({
     *   where: {
     *     // ... the filter for the Abgirs we want to count
     *   }
     * })
    **/
    count<T extends AbgirCountArgs>(
      args?: Subset<T, AbgirCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbgirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Abgir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbgirAggregateArgs>(args: Subset<T, AbgirAggregateArgs>): Prisma.PrismaPromise<GetAbgirAggregateType<T>>

    /**
     * Group by Abgir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbgirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbgirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbgirGroupByArgs['orderBy'] }
        : { orderBy?: AbgirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbgirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbgirGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Abgir model
   */
  readonly fields: AbgirFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Abgir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbgirClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Abgir model
   */ 
  interface AbgirFieldRefs {
    readonly IdKontor: FieldRef<"Abgir", 'Int'>
    readonly FIdRanesh: FieldRef<"Abgir", 'Int'>
    readonly Abgir: FieldRef<"Abgir", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Abgir findUnique
   */
  export type AbgirFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir findUniqueOrThrow
   */
  export type AbgirFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir findFirst
   */
  export type AbgirFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abgirs.
     */
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir findFirstOrThrow
   */
  export type AbgirFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter, which Abgir to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abgirs.
     */
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir findMany
   */
  export type AbgirFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter, which Abgirs to fetch.
     */
    where?: AbgirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abgirs to fetch.
     */
    orderBy?: AbgirOrderByWithRelationInput | AbgirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abgirs.
     */
    cursor?: AbgirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abgirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abgirs.
     */
    skip?: number
    distinct?: AbgirScalarFieldEnum | AbgirScalarFieldEnum[]
  }

  /**
   * Abgir create
   */
  export type AbgirCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * The data needed to create a Abgir.
     */
    data: XOR<AbgirCreateInput, AbgirUncheckedCreateInput>
  }

  /**
   * Abgir createMany
   */
  export type AbgirCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abgirs.
     */
    data: AbgirCreateManyInput | AbgirCreateManyInput[]
  }

  /**
   * Abgir update
   */
  export type AbgirUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * The data needed to update a Abgir.
     */
    data: XOR<AbgirUpdateInput, AbgirUncheckedUpdateInput>
    /**
     * Choose, which Abgir to update.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir updateMany
   */
  export type AbgirUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abgirs.
     */
    data: XOR<AbgirUpdateManyMutationInput, AbgirUncheckedUpdateManyInput>
    /**
     * Filter which Abgirs to update
     */
    where?: AbgirWhereInput
    /**
     * Limit how many Abgirs to update.
     */
    limit?: number
  }

  /**
   * Abgir upsert
   */
  export type AbgirUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * The filter to search for the Abgir to update in case it exists.
     */
    where: AbgirWhereUniqueInput
    /**
     * In case the Abgir found by the `where` argument doesn't exist, create a new Abgir with this data.
     */
    create: XOR<AbgirCreateInput, AbgirUncheckedCreateInput>
    /**
     * In case the Abgir was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbgirUpdateInput, AbgirUncheckedUpdateInput>
  }

  /**
   * Abgir delete
   */
  export type AbgirDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
    /**
     * Filter which Abgir to delete.
     */
    where: AbgirWhereUniqueInput
  }

  /**
   * Abgir deleteMany
   */
  export type AbgirDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abgirs to delete
     */
    where?: AbgirWhereInput
    /**
     * Limit how many Abgirs to delete.
     */
    limit?: number
  }

  /**
   * Abgir without action
   */
  export type AbgirDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abgir
     */
    select?: AbgirSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Abgir
     */
    omit?: AbgirOmit<ExtArgs> | null
  }


  /**
   * Model AtashSoozi
   */

  export type AggregateAtashSoozi = {
    _count: AtashSooziCountAggregateOutputType | null
    _avg: AtashSooziAvgAggregateOutputType | null
    _sum: AtashSooziSumAggregateOutputType | null
    _min: AtashSooziMinAggregateOutputType | null
    _max: AtashSooziMaxAggregateOutputType | null
  }

  export type AtashSooziAvgAggregateOutputType = {
    IdAtash: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    AtashSoozi: number | null
  }

  export type AtashSooziSumAggregateOutputType = {
    IdAtash: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    AtashSoozi: number | null
  }

  export type AtashSooziMinAggregateOutputType = {
    IdAtash: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    AtashSoozi: number | null
  }

  export type AtashSooziMaxAggregateOutputType = {
    IdAtash: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    AtashSoozi: number | null
  }

  export type AtashSooziCountAggregateOutputType = {
    IdAtash: number
    FIdRanesh: number
    FIdTarDor: number
    AtashSoozi: number
    _all: number
  }


  export type AtashSooziAvgAggregateInputType = {
    IdAtash?: true
    FIdRanesh?: true
    FIdTarDor?: true
    AtashSoozi?: true
  }

  export type AtashSooziSumAggregateInputType = {
    IdAtash?: true
    FIdRanesh?: true
    FIdTarDor?: true
    AtashSoozi?: true
  }

  export type AtashSooziMinAggregateInputType = {
    IdAtash?: true
    FIdRanesh?: true
    FIdTarDor?: true
    AtashSoozi?: true
  }

  export type AtashSooziMaxAggregateInputType = {
    IdAtash?: true
    FIdRanesh?: true
    FIdTarDor?: true
    AtashSoozi?: true
  }

  export type AtashSooziCountAggregateInputType = {
    IdAtash?: true
    FIdRanesh?: true
    FIdTarDor?: true
    AtashSoozi?: true
    _all?: true
  }

  export type AtashSooziAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AtashSoozi to aggregate.
     */
    where?: AtashSooziWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AtashSoozis to fetch.
     */
    orderBy?: AtashSooziOrderByWithRelationInput | AtashSooziOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AtashSooziWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AtashSoozis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AtashSoozis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AtashSoozis
    **/
    _count?: true | AtashSooziCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtashSooziAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtashSooziSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtashSooziMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtashSooziMaxAggregateInputType
  }

  export type GetAtashSooziAggregateType<T extends AtashSooziAggregateArgs> = {
        [P in keyof T & keyof AggregateAtashSoozi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtashSoozi[P]>
      : GetScalarType<T[P], AggregateAtashSoozi[P]>
  }




  export type AtashSooziGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AtashSooziWhereInput
    orderBy?: AtashSooziOrderByWithAggregationInput | AtashSooziOrderByWithAggregationInput[]
    by: AtashSooziScalarFieldEnum[] | AtashSooziScalarFieldEnum
    having?: AtashSooziScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtashSooziCountAggregateInputType | true
    _avg?: AtashSooziAvgAggregateInputType
    _sum?: AtashSooziSumAggregateInputType
    _min?: AtashSooziMinAggregateInputType
    _max?: AtashSooziMaxAggregateInputType
  }

  export type AtashSooziGroupByOutputType = {
    IdAtash: number
    FIdRanesh: number | null
    FIdTarDor: number | null
    AtashSoozi: number | null
    _count: AtashSooziCountAggregateOutputType | null
    _avg: AtashSooziAvgAggregateOutputType | null
    _sum: AtashSooziSumAggregateOutputType | null
    _min: AtashSooziMinAggregateOutputType | null
    _max: AtashSooziMaxAggregateOutputType | null
  }

  type GetAtashSooziGroupByPayload<T extends AtashSooziGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtashSooziGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtashSooziGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtashSooziGroupByOutputType[P]>
            : GetScalarType<T[P], AtashSooziGroupByOutputType[P]>
        }
      >
    >


  export type AtashSooziSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdAtash?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    AtashSoozi?: boolean
  }, ExtArgs["result"]["atashSoozi"]>



  export type AtashSooziSelectScalar = {
    IdAtash?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    AtashSoozi?: boolean
  }

  export type AtashSooziOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdAtash" | "FIdRanesh" | "FIdTarDor" | "AtashSoozi", ExtArgs["result"]["atashSoozi"]>

  export type $AtashSooziPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AtashSoozi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdAtash: number
      FIdRanesh: number | null
      FIdTarDor: number | null
      AtashSoozi: number | null
    }, ExtArgs["result"]["atashSoozi"]>
    composites: {}
  }

  type AtashSooziGetPayload<S extends boolean | null | undefined | AtashSooziDefaultArgs> = $Result.GetResult<Prisma.$AtashSooziPayload, S>

  type AtashSooziCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AtashSooziFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AtashSooziCountAggregateInputType | true
    }

  export interface AtashSooziDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AtashSoozi'], meta: { name: 'AtashSoozi' } }
    /**
     * Find zero or one AtashSoozi that matches the filter.
     * @param {AtashSooziFindUniqueArgs} args - Arguments to find a AtashSoozi
     * @example
     * // Get one AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AtashSooziFindUniqueArgs>(args: SelectSubset<T, AtashSooziFindUniqueArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AtashSoozi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AtashSooziFindUniqueOrThrowArgs} args - Arguments to find a AtashSoozi
     * @example
     * // Get one AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AtashSooziFindUniqueOrThrowArgs>(args: SelectSubset<T, AtashSooziFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AtashSoozi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziFindFirstArgs} args - Arguments to find a AtashSoozi
     * @example
     * // Get one AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AtashSooziFindFirstArgs>(args?: SelectSubset<T, AtashSooziFindFirstArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AtashSoozi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziFindFirstOrThrowArgs} args - Arguments to find a AtashSoozi
     * @example
     * // Get one AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AtashSooziFindFirstOrThrowArgs>(args?: SelectSubset<T, AtashSooziFindFirstOrThrowArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AtashSoozis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AtashSoozis
     * const atashSoozis = await prisma.atashSoozi.findMany()
     * 
     * // Get first 10 AtashSoozis
     * const atashSoozis = await prisma.atashSoozi.findMany({ take: 10 })
     * 
     * // Only select the `IdAtash`
     * const atashSooziWithIdAtashOnly = await prisma.atashSoozi.findMany({ select: { IdAtash: true } })
     * 
     */
    findMany<T extends AtashSooziFindManyArgs>(args?: SelectSubset<T, AtashSooziFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AtashSoozi.
     * @param {AtashSooziCreateArgs} args - Arguments to create a AtashSoozi.
     * @example
     * // Create one AtashSoozi
     * const AtashSoozi = await prisma.atashSoozi.create({
     *   data: {
     *     // ... data to create a AtashSoozi
     *   }
     * })
     * 
     */
    create<T extends AtashSooziCreateArgs>(args: SelectSubset<T, AtashSooziCreateArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AtashSoozis.
     * @param {AtashSooziCreateManyArgs} args - Arguments to create many AtashSoozis.
     * @example
     * // Create many AtashSoozis
     * const atashSoozi = await prisma.atashSoozi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AtashSooziCreateManyArgs>(args?: SelectSubset<T, AtashSooziCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AtashSoozi.
     * @param {AtashSooziDeleteArgs} args - Arguments to delete one AtashSoozi.
     * @example
     * // Delete one AtashSoozi
     * const AtashSoozi = await prisma.atashSoozi.delete({
     *   where: {
     *     // ... filter to delete one AtashSoozi
     *   }
     * })
     * 
     */
    delete<T extends AtashSooziDeleteArgs>(args: SelectSubset<T, AtashSooziDeleteArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AtashSoozi.
     * @param {AtashSooziUpdateArgs} args - Arguments to update one AtashSoozi.
     * @example
     * // Update one AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AtashSooziUpdateArgs>(args: SelectSubset<T, AtashSooziUpdateArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AtashSoozis.
     * @param {AtashSooziDeleteManyArgs} args - Arguments to filter AtashSoozis to delete.
     * @example
     * // Delete a few AtashSoozis
     * const { count } = await prisma.atashSoozi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AtashSooziDeleteManyArgs>(args?: SelectSubset<T, AtashSooziDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AtashSoozis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AtashSoozis
     * const atashSoozi = await prisma.atashSoozi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AtashSooziUpdateManyArgs>(args: SelectSubset<T, AtashSooziUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AtashSoozi.
     * @param {AtashSooziUpsertArgs} args - Arguments to update or create a AtashSoozi.
     * @example
     * // Update or create a AtashSoozi
     * const atashSoozi = await prisma.atashSoozi.upsert({
     *   create: {
     *     // ... data to create a AtashSoozi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AtashSoozi we want to update
     *   }
     * })
     */
    upsert<T extends AtashSooziUpsertArgs>(args: SelectSubset<T, AtashSooziUpsertArgs<ExtArgs>>): Prisma__AtashSooziClient<$Result.GetResult<Prisma.$AtashSooziPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AtashSoozis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziCountArgs} args - Arguments to filter AtashSoozis to count.
     * @example
     * // Count the number of AtashSoozis
     * const count = await prisma.atashSoozi.count({
     *   where: {
     *     // ... the filter for the AtashSoozis we want to count
     *   }
     * })
    **/
    count<T extends AtashSooziCountArgs>(
      args?: Subset<T, AtashSooziCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtashSooziCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AtashSoozi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtashSooziAggregateArgs>(args: Subset<T, AtashSooziAggregateArgs>): Prisma.PrismaPromise<GetAtashSooziAggregateType<T>>

    /**
     * Group by AtashSoozi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtashSooziGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtashSooziGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtashSooziGroupByArgs['orderBy'] }
        : { orderBy?: AtashSooziGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtashSooziGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtashSooziGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AtashSoozi model
   */
  readonly fields: AtashSooziFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AtashSoozi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AtashSooziClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AtashSoozi model
   */ 
  interface AtashSooziFieldRefs {
    readonly IdAtash: FieldRef<"AtashSoozi", 'Int'>
    readonly FIdRanesh: FieldRef<"AtashSoozi", 'Int'>
    readonly FIdTarDor: FieldRef<"AtashSoozi", 'Int'>
    readonly AtashSoozi: FieldRef<"AtashSoozi", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AtashSoozi findUnique
   */
  export type AtashSooziFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter, which AtashSoozi to fetch.
     */
    where: AtashSooziWhereUniqueInput
  }

  /**
   * AtashSoozi findUniqueOrThrow
   */
  export type AtashSooziFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter, which AtashSoozi to fetch.
     */
    where: AtashSooziWhereUniqueInput
  }

  /**
   * AtashSoozi findFirst
   */
  export type AtashSooziFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter, which AtashSoozi to fetch.
     */
    where?: AtashSooziWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AtashSoozis to fetch.
     */
    orderBy?: AtashSooziOrderByWithRelationInput | AtashSooziOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AtashSoozis.
     */
    cursor?: AtashSooziWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AtashSoozis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AtashSoozis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AtashSoozis.
     */
    distinct?: AtashSooziScalarFieldEnum | AtashSooziScalarFieldEnum[]
  }

  /**
   * AtashSoozi findFirstOrThrow
   */
  export type AtashSooziFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter, which AtashSoozi to fetch.
     */
    where?: AtashSooziWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AtashSoozis to fetch.
     */
    orderBy?: AtashSooziOrderByWithRelationInput | AtashSooziOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AtashSoozis.
     */
    cursor?: AtashSooziWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AtashSoozis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AtashSoozis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AtashSoozis.
     */
    distinct?: AtashSooziScalarFieldEnum | AtashSooziScalarFieldEnum[]
  }

  /**
   * AtashSoozi findMany
   */
  export type AtashSooziFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter, which AtashSoozis to fetch.
     */
    where?: AtashSooziWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AtashSoozis to fetch.
     */
    orderBy?: AtashSooziOrderByWithRelationInput | AtashSooziOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AtashSoozis.
     */
    cursor?: AtashSooziWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AtashSoozis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AtashSoozis.
     */
    skip?: number
    distinct?: AtashSooziScalarFieldEnum | AtashSooziScalarFieldEnum[]
  }

  /**
   * AtashSoozi create
   */
  export type AtashSooziCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * The data needed to create a AtashSoozi.
     */
    data: XOR<AtashSooziCreateInput, AtashSooziUncheckedCreateInput>
  }

  /**
   * AtashSoozi createMany
   */
  export type AtashSooziCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AtashSoozis.
     */
    data: AtashSooziCreateManyInput | AtashSooziCreateManyInput[]
  }

  /**
   * AtashSoozi update
   */
  export type AtashSooziUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * The data needed to update a AtashSoozi.
     */
    data: XOR<AtashSooziUpdateInput, AtashSooziUncheckedUpdateInput>
    /**
     * Choose, which AtashSoozi to update.
     */
    where: AtashSooziWhereUniqueInput
  }

  /**
   * AtashSoozi updateMany
   */
  export type AtashSooziUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AtashSoozis.
     */
    data: XOR<AtashSooziUpdateManyMutationInput, AtashSooziUncheckedUpdateManyInput>
    /**
     * Filter which AtashSoozis to update
     */
    where?: AtashSooziWhereInput
    /**
     * Limit how many AtashSoozis to update.
     */
    limit?: number
  }

  /**
   * AtashSoozi upsert
   */
  export type AtashSooziUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * The filter to search for the AtashSoozi to update in case it exists.
     */
    where: AtashSooziWhereUniqueInput
    /**
     * In case the AtashSoozi found by the `where` argument doesn't exist, create a new AtashSoozi with this data.
     */
    create: XOR<AtashSooziCreateInput, AtashSooziUncheckedCreateInput>
    /**
     * In case the AtashSoozi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AtashSooziUpdateInput, AtashSooziUncheckedUpdateInput>
  }

  /**
   * AtashSoozi delete
   */
  export type AtashSooziDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
    /**
     * Filter which AtashSoozi to delete.
     */
    where: AtashSooziWhereUniqueInput
  }

  /**
   * AtashSoozi deleteMany
   */
  export type AtashSooziDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AtashSoozis to delete
     */
    where?: AtashSooziWhereInput
    /**
     * Limit how many AtashSoozis to delete.
     */
    limit?: number
  }

  /**
   * AtashSoozi without action
   */
  export type AtashSooziDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtashSoozi
     */
    select?: AtashSooziSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AtashSoozi
     */
    omit?: AtashSooziOmit<ExtArgs> | null
  }


  /**
   * Model BahrebardairProgram
   */

  export type AggregateBahrebardairProgram = {
    _count: BahrebardairProgramCountAggregateOutputType | null
    _avg: BahrebardairProgramAvgAggregateOutputType | null
    _sum: BahrebardairProgramSumAggregateOutputType | null
    _min: BahrebardairProgramMinAggregateOutputType | null
    _max: BahrebardairProgramMaxAggregateOutputType | null
  }

  export type BahrebardairProgramAvgAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
  }

  export type BahrebardairProgramSumAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
  }

  export type BahrebardairProgramMinAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramMaxAggregateOutputType = {
    IdProgram: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Tedad: number | null
    Shorooe: Date | null
    Paian: Date | null
  }

  export type BahrebardairProgramCountAggregateOutputType = {
    IdProgram: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe: number
    Paian: number
    _all: number
  }


  export type BahrebardairProgramAvgAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
  }

  export type BahrebardairProgramSumAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
  }

  export type BahrebardairProgramMinAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramMaxAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
  }

  export type BahrebardairProgramCountAggregateInputType = {
    IdProgram?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Tedad?: true
    Shorooe?: true
    Paian?: true
    _all?: true
  }

  export type BahrebardairProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairProgram to aggregate.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardairPrograms
    **/
    _count?: true | BahrebardairProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardairProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardairProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardairProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardairProgramMaxAggregateInputType
  }

  export type GetBahrebardairProgramAggregateType<T extends BahrebardairProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardairProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardairProgram[P]>
      : GetScalarType<T[P], AggregateBahrebardairProgram[P]>
  }




  export type BahrebardairProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardairProgramWhereInput
    orderBy?: BahrebardairProgramOrderByWithAggregationInput | BahrebardairProgramOrderByWithAggregationInput[]
    by: BahrebardairProgramScalarFieldEnum[] | BahrebardairProgramScalarFieldEnum
    having?: BahrebardairProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardairProgramCountAggregateInputType | true
    _avg?: BahrebardairProgramAvgAggregateInputType
    _sum?: BahrebardairProgramSumAggregateInputType
    _min?: BahrebardairProgramMinAggregateInputType
    _max?: BahrebardairProgramMaxAggregateInputType
  }

  export type BahrebardairProgramGroupByOutputType = {
    IdProgram: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe: Date | null
    Paian: Date | null
    _count: BahrebardairProgramCountAggregateOutputType | null
    _avg: BahrebardairProgramAvgAggregateOutputType | null
    _sum: BahrebardairProgramSumAggregateOutputType | null
    _min: BahrebardairProgramMinAggregateOutputType | null
    _max: BahrebardairProgramMaxAggregateOutputType | null
  }

  type GetBahrebardairProgramGroupByPayload<T extends BahrebardairProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardairProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardairProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardairProgramGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardairProgramGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardairProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdProgram?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Tedad?: boolean
    Shorooe?: boolean
    Paian?: boolean
  }, ExtArgs["result"]["bahrebardairProgram"]>



  export type BahrebardairProgramSelectScalar = {
    IdProgram?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Tedad?: boolean
    Shorooe?: boolean
    Paian?: boolean
  }

  export type BahrebardairProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdProgram" | "FIdRanesh" | "FIdTarDor" | "Tedad" | "Shorooe" | "Paian", ExtArgs["result"]["bahrebardairProgram"]>

  export type $BahrebardairProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardairProgram"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdProgram: number
      FIdRanesh: number
      FIdTarDor: number
      Tedad: number
      Shorooe: Date | null
      Paian: Date | null
    }, ExtArgs["result"]["bahrebardairProgram"]>
    composites: {}
  }

  type BahrebardairProgramGetPayload<S extends boolean | null | undefined | BahrebardairProgramDefaultArgs> = $Result.GetResult<Prisma.$BahrebardairProgramPayload, S>

  type BahrebardairProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardairProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardairProgramCountAggregateInputType | true
    }

  export interface BahrebardairProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardairProgram'], meta: { name: 'BahrebardairProgram' } }
    /**
     * Find zero or one BahrebardairProgram that matches the filter.
     * @param {BahrebardairProgramFindUniqueArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardairProgramFindUniqueArgs>(args: SelectSubset<T, BahrebardairProgramFindUniqueArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardairProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardairProgramFindUniqueOrThrowArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardairProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindFirstArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardairProgramFindFirstArgs>(args?: SelectSubset<T, BahrebardairProgramFindFirstArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardairProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindFirstOrThrowArgs} args - Arguments to find a BahrebardairProgram
     * @example
     * // Get one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardairProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardairProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardairPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardairPrograms
     * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany()
     * 
     * // Get first 10 BahrebardairPrograms
     * const bahrebardairPrograms = await prisma.bahrebardairProgram.findMany({ take: 10 })
     * 
     * // Only select the `IdProgram`
     * const bahrebardairProgramWithIdProgramOnly = await prisma.bahrebardairProgram.findMany({ select: { IdProgram: true } })
     * 
     */
    findMany<T extends BahrebardairProgramFindManyArgs>(args?: SelectSubset<T, BahrebardairProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardairProgram.
     * @param {BahrebardairProgramCreateArgs} args - Arguments to create a BahrebardairProgram.
     * @example
     * // Create one BahrebardairProgram
     * const BahrebardairProgram = await prisma.bahrebardairProgram.create({
     *   data: {
     *     // ... data to create a BahrebardairProgram
     *   }
     * })
     * 
     */
    create<T extends BahrebardairProgramCreateArgs>(args: SelectSubset<T, BahrebardairProgramCreateArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardairPrograms.
     * @param {BahrebardairProgramCreateManyArgs} args - Arguments to create many BahrebardairPrograms.
     * @example
     * // Create many BahrebardairPrograms
     * const bahrebardairProgram = await prisma.bahrebardairProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardairProgramCreateManyArgs>(args?: SelectSubset<T, BahrebardairProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardairProgram.
     * @param {BahrebardairProgramDeleteArgs} args - Arguments to delete one BahrebardairProgram.
     * @example
     * // Delete one BahrebardairProgram
     * const BahrebardairProgram = await prisma.bahrebardairProgram.delete({
     *   where: {
     *     // ... filter to delete one BahrebardairProgram
     *   }
     * })
     * 
     */
    delete<T extends BahrebardairProgramDeleteArgs>(args: SelectSubset<T, BahrebardairProgramDeleteArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardairProgram.
     * @param {BahrebardairProgramUpdateArgs} args - Arguments to update one BahrebardairProgram.
     * @example
     * // Update one BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardairProgramUpdateArgs>(args: SelectSubset<T, BahrebardairProgramUpdateArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardairPrograms.
     * @param {BahrebardairProgramDeleteManyArgs} args - Arguments to filter BahrebardairPrograms to delete.
     * @example
     * // Delete a few BahrebardairPrograms
     * const { count } = await prisma.bahrebardairProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardairProgramDeleteManyArgs>(args?: SelectSubset<T, BahrebardairProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardairPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardairPrograms
     * const bahrebardairProgram = await prisma.bahrebardairProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardairProgramUpdateManyArgs>(args: SelectSubset<T, BahrebardairProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardairProgram.
     * @param {BahrebardairProgramUpsertArgs} args - Arguments to update or create a BahrebardairProgram.
     * @example
     * // Update or create a BahrebardairProgram
     * const bahrebardairProgram = await prisma.bahrebardairProgram.upsert({
     *   create: {
     *     // ... data to create a BahrebardairProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardairProgram we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardairProgramUpsertArgs>(args: SelectSubset<T, BahrebardairProgramUpsertArgs<ExtArgs>>): Prisma__BahrebardairProgramClient<$Result.GetResult<Prisma.$BahrebardairProgramPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardairPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramCountArgs} args - Arguments to filter BahrebardairPrograms to count.
     * @example
     * // Count the number of BahrebardairPrograms
     * const count = await prisma.bahrebardairProgram.count({
     *   where: {
     *     // ... the filter for the BahrebardairPrograms we want to count
     *   }
     * })
    **/
    count<T extends BahrebardairProgramCountArgs>(
      args?: Subset<T, BahrebardairProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardairProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardairProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardairProgramAggregateArgs>(args: Subset<T, BahrebardairProgramAggregateArgs>): Prisma.PrismaPromise<GetBahrebardairProgramAggregateType<T>>

    /**
     * Group by BahrebardairProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardairProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardairProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardairProgramGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardairProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardairProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardairProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardairProgram model
   */
  readonly fields: BahrebardairProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardairProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardairProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardairProgram model
   */ 
  interface BahrebardairProgramFieldRefs {
    readonly IdProgram: FieldRef<"BahrebardairProgram", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardairProgram", 'Int'>
    readonly FIdTarDor: FieldRef<"BahrebardairProgram", 'Int'>
    readonly Tedad: FieldRef<"BahrebardairProgram", 'Int'>
    readonly Shorooe: FieldRef<"BahrebardairProgram", 'DateTime'>
    readonly Paian: FieldRef<"BahrebardairProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardairProgram findUnique
   */
  export type BahrebardairProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram findUniqueOrThrow
   */
  export type BahrebardairProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram findFirst
   */
  export type BahrebardairProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairPrograms.
     */
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram findFirstOrThrow
   */
  export type BahrebardairProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardairProgram to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardairPrograms.
     */
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram findMany
   */
  export type BahrebardairProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardairPrograms to fetch.
     */
    where?: BahrebardairProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardairPrograms to fetch.
     */
    orderBy?: BahrebardairProgramOrderByWithRelationInput | BahrebardairProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardairPrograms.
     */
    cursor?: BahrebardairProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardairPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardairPrograms.
     */
    skip?: number
    distinct?: BahrebardairProgramScalarFieldEnum | BahrebardairProgramScalarFieldEnum[]
  }

  /**
   * BahrebardairProgram create
   */
  export type BahrebardairProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * The data needed to create a BahrebardairProgram.
     */
    data: XOR<BahrebardairProgramCreateInput, BahrebardairProgramUncheckedCreateInput>
  }

  /**
   * BahrebardairProgram createMany
   */
  export type BahrebardairProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardairPrograms.
     */
    data: BahrebardairProgramCreateManyInput | BahrebardairProgramCreateManyInput[]
  }

  /**
   * BahrebardairProgram update
   */
  export type BahrebardairProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * The data needed to update a BahrebardairProgram.
     */
    data: XOR<BahrebardairProgramUpdateInput, BahrebardairProgramUncheckedUpdateInput>
    /**
     * Choose, which BahrebardairProgram to update.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram updateMany
   */
  export type BahrebardairProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardairPrograms.
     */
    data: XOR<BahrebardairProgramUpdateManyMutationInput, BahrebardairProgramUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardairPrograms to update
     */
    where?: BahrebardairProgramWhereInput
    /**
     * Limit how many BahrebardairPrograms to update.
     */
    limit?: number
  }

  /**
   * BahrebardairProgram upsert
   */
  export type BahrebardairProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * The filter to search for the BahrebardairProgram to update in case it exists.
     */
    where: BahrebardairProgramWhereUniqueInput
    /**
     * In case the BahrebardairProgram found by the `where` argument doesn't exist, create a new BahrebardairProgram with this data.
     */
    create: XOR<BahrebardairProgramCreateInput, BahrebardairProgramUncheckedCreateInput>
    /**
     * In case the BahrebardairProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardairProgramUpdateInput, BahrebardairProgramUncheckedUpdateInput>
  }

  /**
   * BahrebardairProgram delete
   */
  export type BahrebardairProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
    /**
     * Filter which BahrebardairProgram to delete.
     */
    where: BahrebardairProgramWhereUniqueInput
  }

  /**
   * BahrebardairProgram deleteMany
   */
  export type BahrebardairProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardairPrograms to delete
     */
    where?: BahrebardairProgramWhereInput
    /**
     * Limit how many BahrebardairPrograms to delete.
     */
    limit?: number
  }

  /**
   * BahrebardairProgram without action
   */
  export type BahrebardairProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardairProgram
     */
    select?: BahrebardairProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardairProgram
     */
    omit?: BahrebardairProgramOmit<ExtArgs> | null
  }


  /**
   * Model BahrebardariKeshtDore
   */

  export type AggregateBahrebardariKeshtDore = {
    _count: BahrebardariKeshtDoreCountAggregateOutputType | null
    _avg: BahrebardariKeshtDoreAvgAggregateOutputType | null
    _sum: BahrebardariKeshtDoreSumAggregateOutputType | null
    _min: BahrebardariKeshtDoreMinAggregateOutputType | null
    _max: BahrebardariKeshtDoreMaxAggregateOutputType | null
  }

  export type BahrebardariKeshtDoreAvgAggregateOutputType = {
    IdBahDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreSumAggregateOutputType = {
    IdBahDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreMinAggregateOutputType = {
    IdBahDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreMaxAggregateOutputType = {
    IdBahDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    FIdRanesh: number | null
    FIdNoeM: number | null
    Area: Decimal | null
  }

  export type BahrebardariKeshtDoreCountAggregateOutputType = {
    IdBahDor: number
    FIdSal: number
    FIdDore: number
    FIdRanesh: number
    FIdNoeM: number
    Area: number
    _all: number
  }


  export type BahrebardariKeshtDoreAvgAggregateInputType = {
    IdBahDor?: true
    FIdSal?: true
    FIdDore?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreSumAggregateInputType = {
    IdBahDor?: true
    FIdSal?: true
    FIdDore?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreMinAggregateInputType = {
    IdBahDor?: true
    FIdSal?: true
    FIdDore?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreMaxAggregateInputType = {
    IdBahDor?: true
    FIdSal?: true
    FIdDore?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
  }

  export type BahrebardariKeshtDoreCountAggregateInputType = {
    IdBahDor?: true
    FIdSal?: true
    FIdDore?: true
    FIdRanesh?: true
    FIdNoeM?: true
    Area?: true
    _all?: true
  }

  export type BahrebardariKeshtDoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariKeshtDore to aggregate.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardariKeshtDores
    **/
    _count?: true | BahrebardariKeshtDoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardariKeshtDoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardariKeshtDoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardariKeshtDoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardariKeshtDoreMaxAggregateInputType
  }

  export type GetBahrebardariKeshtDoreAggregateType<T extends BahrebardariKeshtDoreAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardariKeshtDore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardariKeshtDore[P]>
      : GetScalarType<T[P], AggregateBahrebardariKeshtDore[P]>
  }




  export type BahrebardariKeshtDoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariKeshtDoreWhereInput
    orderBy?: BahrebardariKeshtDoreOrderByWithAggregationInput | BahrebardariKeshtDoreOrderByWithAggregationInput[]
    by: BahrebardariKeshtDoreScalarFieldEnum[] | BahrebardariKeshtDoreScalarFieldEnum
    having?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardariKeshtDoreCountAggregateInputType | true
    _avg?: BahrebardariKeshtDoreAvgAggregateInputType
    _sum?: BahrebardariKeshtDoreSumAggregateInputType
    _min?: BahrebardariKeshtDoreMinAggregateInputType
    _max?: BahrebardariKeshtDoreMaxAggregateInputType
  }

  export type BahrebardariKeshtDoreGroupByOutputType = {
    IdBahDor: number
    FIdSal: number
    FIdDore: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal
    _count: BahrebardariKeshtDoreCountAggregateOutputType | null
    _avg: BahrebardariKeshtDoreAvgAggregateOutputType | null
    _sum: BahrebardariKeshtDoreSumAggregateOutputType | null
    _min: BahrebardariKeshtDoreMinAggregateOutputType | null
    _max: BahrebardariKeshtDoreMaxAggregateOutputType | null
  }

  type GetBahrebardariKeshtDoreGroupByPayload<T extends BahrebardariKeshtDoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardariKeshtDoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardariKeshtDoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardariKeshtDoreGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardariKeshtDoreGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardariKeshtDoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBahDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    FIdRanesh?: boolean
    FIdNoeM?: boolean
    Area?: boolean
  }, ExtArgs["result"]["bahrebardariKeshtDore"]>



  export type BahrebardariKeshtDoreSelectScalar = {
    IdBahDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    FIdRanesh?: boolean
    FIdNoeM?: boolean
    Area?: boolean
  }

  export type BahrebardariKeshtDoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBahDor" | "FIdSal" | "FIdDore" | "FIdRanesh" | "FIdNoeM" | "Area", ExtArgs["result"]["bahrebardariKeshtDore"]>

  export type $BahrebardariKeshtDorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardariKeshtDore"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdBahDor: number
      FIdSal: number
      FIdDore: number
      FIdRanesh: number
      FIdNoeM: number
      Area: Prisma.Decimal
    }, ExtArgs["result"]["bahrebardariKeshtDore"]>
    composites: {}
  }

  type BahrebardariKeshtDoreGetPayload<S extends boolean | null | undefined | BahrebardariKeshtDoreDefaultArgs> = $Result.GetResult<Prisma.$BahrebardariKeshtDorePayload, S>

  type BahrebardariKeshtDoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardariKeshtDoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardariKeshtDoreCountAggregateInputType | true
    }

  export interface BahrebardariKeshtDoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardariKeshtDore'], meta: { name: 'BahrebardariKeshtDore' } }
    /**
     * Find zero or one BahrebardariKeshtDore that matches the filter.
     * @param {BahrebardariKeshtDoreFindUniqueArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardariKeshtDoreFindUniqueArgs>(args: SelectSubset<T, BahrebardariKeshtDoreFindUniqueArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardariKeshtDore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardariKeshtDoreFindUniqueOrThrowArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardariKeshtDoreFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariKeshtDore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindFirstArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardariKeshtDoreFindFirstArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindFirstArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariKeshtDore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindFirstOrThrowArgs} args - Arguments to find a BahrebardariKeshtDore
     * @example
     * // Get one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardariKeshtDoreFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardariKeshtDores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardariKeshtDores
     * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany()
     * 
     * // Get first 10 BahrebardariKeshtDores
     * const bahrebardariKeshtDores = await prisma.bahrebardariKeshtDore.findMany({ take: 10 })
     * 
     * // Only select the `IdBahDor`
     * const bahrebardariKeshtDoreWithIdBahDorOnly = await prisma.bahrebardariKeshtDore.findMany({ select: { IdBahDor: true } })
     * 
     */
    findMany<T extends BahrebardariKeshtDoreFindManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreCreateArgs} args - Arguments to create a BahrebardariKeshtDore.
     * @example
     * // Create one BahrebardariKeshtDore
     * const BahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.create({
     *   data: {
     *     // ... data to create a BahrebardariKeshtDore
     *   }
     * })
     * 
     */
    create<T extends BahrebardariKeshtDoreCreateArgs>(args: SelectSubset<T, BahrebardariKeshtDoreCreateArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardariKeshtDores.
     * @param {BahrebardariKeshtDoreCreateManyArgs} args - Arguments to create many BahrebardariKeshtDores.
     * @example
     * // Create many BahrebardariKeshtDores
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardariKeshtDoreCreateManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreDeleteArgs} args - Arguments to delete one BahrebardariKeshtDore.
     * @example
     * // Delete one BahrebardariKeshtDore
     * const BahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.delete({
     *   where: {
     *     // ... filter to delete one BahrebardariKeshtDore
     *   }
     * })
     * 
     */
    delete<T extends BahrebardariKeshtDoreDeleteArgs>(args: SelectSubset<T, BahrebardariKeshtDoreDeleteArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreUpdateArgs} args - Arguments to update one BahrebardariKeshtDore.
     * @example
     * // Update one BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardariKeshtDoreUpdateArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpdateArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardariKeshtDores.
     * @param {BahrebardariKeshtDoreDeleteManyArgs} args - Arguments to filter BahrebardariKeshtDores to delete.
     * @example
     * // Delete a few BahrebardariKeshtDores
     * const { count } = await prisma.bahrebardariKeshtDore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardariKeshtDoreDeleteManyArgs>(args?: SelectSubset<T, BahrebardariKeshtDoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardariKeshtDores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardariKeshtDores
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardariKeshtDoreUpdateManyArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardariKeshtDore.
     * @param {BahrebardariKeshtDoreUpsertArgs} args - Arguments to update or create a BahrebardariKeshtDore.
     * @example
     * // Update or create a BahrebardariKeshtDore
     * const bahrebardariKeshtDore = await prisma.bahrebardariKeshtDore.upsert({
     *   create: {
     *     // ... data to create a BahrebardariKeshtDore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardariKeshtDore we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardariKeshtDoreUpsertArgs>(args: SelectSubset<T, BahrebardariKeshtDoreUpsertArgs<ExtArgs>>): Prisma__BahrebardariKeshtDoreClient<$Result.GetResult<Prisma.$BahrebardariKeshtDorePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardariKeshtDores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreCountArgs} args - Arguments to filter BahrebardariKeshtDores to count.
     * @example
     * // Count the number of BahrebardariKeshtDores
     * const count = await prisma.bahrebardariKeshtDore.count({
     *   where: {
     *     // ... the filter for the BahrebardariKeshtDores we want to count
     *   }
     * })
    **/
    count<T extends BahrebardariKeshtDoreCountArgs>(
      args?: Subset<T, BahrebardariKeshtDoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardariKeshtDoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardariKeshtDore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardariKeshtDoreAggregateArgs>(args: Subset<T, BahrebardariKeshtDoreAggregateArgs>): Prisma.PrismaPromise<GetBahrebardariKeshtDoreAggregateType<T>>

    /**
     * Group by BahrebardariKeshtDore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariKeshtDoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardariKeshtDoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardariKeshtDoreGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardariKeshtDoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardariKeshtDoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardariKeshtDoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardariKeshtDore model
   */
  readonly fields: BahrebardariKeshtDoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardariKeshtDore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardariKeshtDoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardariKeshtDore model
   */ 
  interface BahrebardariKeshtDoreFieldRefs {
    readonly IdBahDor: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdSal: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdDore: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly FIdNoeM: FieldRef<"BahrebardariKeshtDore", 'Int'>
    readonly Area: FieldRef<"BahrebardariKeshtDore", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardariKeshtDore findUnique
   */
  export type BahrebardariKeshtDoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore findUniqueOrThrow
   */
  export type BahrebardariKeshtDoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore findFirst
   */
  export type BahrebardariKeshtDoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariKeshtDores.
     */
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore findFirstOrThrow
   */
  export type BahrebardariKeshtDoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDore to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariKeshtDores.
     */
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore findMany
   */
  export type BahrebardariKeshtDoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariKeshtDores to fetch.
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariKeshtDores to fetch.
     */
    orderBy?: BahrebardariKeshtDoreOrderByWithRelationInput | BahrebardariKeshtDoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardariKeshtDores.
     */
    cursor?: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariKeshtDores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariKeshtDores.
     */
    skip?: number
    distinct?: BahrebardariKeshtDoreScalarFieldEnum | BahrebardariKeshtDoreScalarFieldEnum[]
  }

  /**
   * BahrebardariKeshtDore create
   */
  export type BahrebardariKeshtDoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * The data needed to create a BahrebardariKeshtDore.
     */
    data: XOR<BahrebardariKeshtDoreCreateInput, BahrebardariKeshtDoreUncheckedCreateInput>
  }

  /**
   * BahrebardariKeshtDore createMany
   */
  export type BahrebardariKeshtDoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardariKeshtDores.
     */
    data: BahrebardariKeshtDoreCreateManyInput | BahrebardariKeshtDoreCreateManyInput[]
  }

  /**
   * BahrebardariKeshtDore update
   */
  export type BahrebardariKeshtDoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * The data needed to update a BahrebardariKeshtDore.
     */
    data: XOR<BahrebardariKeshtDoreUpdateInput, BahrebardariKeshtDoreUncheckedUpdateInput>
    /**
     * Choose, which BahrebardariKeshtDore to update.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore updateMany
   */
  export type BahrebardariKeshtDoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardariKeshtDores.
     */
    data: XOR<BahrebardariKeshtDoreUpdateManyMutationInput, BahrebardariKeshtDoreUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardariKeshtDores to update
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * Limit how many BahrebardariKeshtDores to update.
     */
    limit?: number
  }

  /**
   * BahrebardariKeshtDore upsert
   */
  export type BahrebardariKeshtDoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * The filter to search for the BahrebardariKeshtDore to update in case it exists.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
    /**
     * In case the BahrebardariKeshtDore found by the `where` argument doesn't exist, create a new BahrebardariKeshtDore with this data.
     */
    create: XOR<BahrebardariKeshtDoreCreateInput, BahrebardariKeshtDoreUncheckedCreateInput>
    /**
     * In case the BahrebardariKeshtDore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardariKeshtDoreUpdateInput, BahrebardariKeshtDoreUncheckedUpdateInput>
  }

  /**
   * BahrebardariKeshtDore delete
   */
  export type BahrebardariKeshtDoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
    /**
     * Filter which BahrebardariKeshtDore to delete.
     */
    where: BahrebardariKeshtDoreWhereUniqueInput
  }

  /**
   * BahrebardariKeshtDore deleteMany
   */
  export type BahrebardariKeshtDoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariKeshtDores to delete
     */
    where?: BahrebardariKeshtDoreWhereInput
    /**
     * Limit how many BahrebardariKeshtDores to delete.
     */
    limit?: number
  }

  /**
   * BahrebardariKeshtDore without action
   */
  export type BahrebardariKeshtDoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariKeshtDore
     */
    select?: BahrebardariKeshtDoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariKeshtDore
     */
    omit?: BahrebardariKeshtDoreOmit<ExtArgs> | null
  }


  /**
   * Model BahrebardariTaghvim
   */

  export type AggregateBahrebardariTaghvim = {
    _count: BahrebardariTaghvimCountAggregateOutputType | null
    _avg: BahrebardariTaghvimAvgAggregateOutputType | null
    _sum: BahrebardariTaghvimSumAggregateOutputType | null
    _min: BahrebardariTaghvimMinAggregateOutputType | null
    _max: BahrebardariTaghvimMaxAggregateOutputType | null
  }

  export type BahrebardariTaghvimAvgAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimSumAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimMinAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimMaxAggregateOutputType = {
    IdTag: number | null
    FIdTarDor: number | null
    FIdRanesh: number | null
    Taghvim: Decimal | null
  }

  export type BahrebardariTaghvimCountAggregateOutputType = {
    IdTag: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: number
    _all: number
  }


  export type BahrebardariTaghvimAvgAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimSumAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimMinAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimMaxAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
  }

  export type BahrebardariTaghvimCountAggregateInputType = {
    IdTag?: true
    FIdTarDor?: true
    FIdRanesh?: true
    Taghvim?: true
    _all?: true
  }

  export type BahrebardariTaghvimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariTaghvim to aggregate.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BahrebardariTaghvims
    **/
    _count?: true | BahrebardariTaghvimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BahrebardariTaghvimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BahrebardariTaghvimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BahrebardariTaghvimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BahrebardariTaghvimMaxAggregateInputType
  }

  export type GetBahrebardariTaghvimAggregateType<T extends BahrebardariTaghvimAggregateArgs> = {
        [P in keyof T & keyof AggregateBahrebardariTaghvim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBahrebardariTaghvim[P]>
      : GetScalarType<T[P], AggregateBahrebardariTaghvim[P]>
  }




  export type BahrebardariTaghvimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BahrebardariTaghvimWhereInput
    orderBy?: BahrebardariTaghvimOrderByWithAggregationInput | BahrebardariTaghvimOrderByWithAggregationInput[]
    by: BahrebardariTaghvimScalarFieldEnum[] | BahrebardariTaghvimScalarFieldEnum
    having?: BahrebardariTaghvimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BahrebardariTaghvimCountAggregateInputType | true
    _avg?: BahrebardariTaghvimAvgAggregateInputType
    _sum?: BahrebardariTaghvimSumAggregateInputType
    _min?: BahrebardariTaghvimMinAggregateInputType
    _max?: BahrebardariTaghvimMaxAggregateInputType
  }

  export type BahrebardariTaghvimGroupByOutputType = {
    IdTag: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal
    _count: BahrebardariTaghvimCountAggregateOutputType | null
    _avg: BahrebardariTaghvimAvgAggregateOutputType | null
    _sum: BahrebardariTaghvimSumAggregateOutputType | null
    _min: BahrebardariTaghvimMinAggregateOutputType | null
    _max: BahrebardariTaghvimMaxAggregateOutputType | null
  }

  type GetBahrebardariTaghvimGroupByPayload<T extends BahrebardariTaghvimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BahrebardariTaghvimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BahrebardariTaghvimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BahrebardariTaghvimGroupByOutputType[P]>
            : GetScalarType<T[P], BahrebardariTaghvimGroupByOutputType[P]>
        }
      >
    >


  export type BahrebardariTaghvimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTag?: boolean
    FIdTarDor?: boolean
    FIdRanesh?: boolean
    Taghvim?: boolean
  }, ExtArgs["result"]["bahrebardariTaghvim"]>



  export type BahrebardariTaghvimSelectScalar = {
    IdTag?: boolean
    FIdTarDor?: boolean
    FIdRanesh?: boolean
    Taghvim?: boolean
  }

  export type BahrebardariTaghvimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTag" | "FIdTarDor" | "FIdRanesh" | "Taghvim", ExtArgs["result"]["bahrebardariTaghvim"]>

  export type $BahrebardariTaghvimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BahrebardariTaghvim"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTag: number
      FIdTarDor: number
      FIdRanesh: number
      Taghvim: Prisma.Decimal
    }, ExtArgs["result"]["bahrebardariTaghvim"]>
    composites: {}
  }

  type BahrebardariTaghvimGetPayload<S extends boolean | null | undefined | BahrebardariTaghvimDefaultArgs> = $Result.GetResult<Prisma.$BahrebardariTaghvimPayload, S>

  type BahrebardariTaghvimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BahrebardariTaghvimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BahrebardariTaghvimCountAggregateInputType | true
    }

  export interface BahrebardariTaghvimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BahrebardariTaghvim'], meta: { name: 'BahrebardariTaghvim' } }
    /**
     * Find zero or one BahrebardariTaghvim that matches the filter.
     * @param {BahrebardariTaghvimFindUniqueArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BahrebardariTaghvimFindUniqueArgs>(args: SelectSubset<T, BahrebardariTaghvimFindUniqueArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BahrebardariTaghvim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BahrebardariTaghvimFindUniqueOrThrowArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BahrebardariTaghvimFindUniqueOrThrowArgs>(args: SelectSubset<T, BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariTaghvim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindFirstArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BahrebardariTaghvimFindFirstArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindFirstArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BahrebardariTaghvim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindFirstOrThrowArgs} args - Arguments to find a BahrebardariTaghvim
     * @example
     * // Get one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BahrebardariTaghvimFindFirstOrThrowArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BahrebardariTaghvims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BahrebardariTaghvims
     * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany()
     * 
     * // Get first 10 BahrebardariTaghvims
     * const bahrebardariTaghvims = await prisma.bahrebardariTaghvim.findMany({ take: 10 })
     * 
     * // Only select the `IdTag`
     * const bahrebardariTaghvimWithIdTagOnly = await prisma.bahrebardariTaghvim.findMany({ select: { IdTag: true } })
     * 
     */
    findMany<T extends BahrebardariTaghvimFindManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BahrebardariTaghvim.
     * @param {BahrebardariTaghvimCreateArgs} args - Arguments to create a BahrebardariTaghvim.
     * @example
     * // Create one BahrebardariTaghvim
     * const BahrebardariTaghvim = await prisma.bahrebardariTaghvim.create({
     *   data: {
     *     // ... data to create a BahrebardariTaghvim
     *   }
     * })
     * 
     */
    create<T extends BahrebardariTaghvimCreateArgs>(args: SelectSubset<T, BahrebardariTaghvimCreateArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BahrebardariTaghvims.
     * @param {BahrebardariTaghvimCreateManyArgs} args - Arguments to create many BahrebardariTaghvims.
     * @example
     * // Create many BahrebardariTaghvims
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BahrebardariTaghvimCreateManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BahrebardariTaghvim.
     * @param {BahrebardariTaghvimDeleteArgs} args - Arguments to delete one BahrebardariTaghvim.
     * @example
     * // Delete one BahrebardariTaghvim
     * const BahrebardariTaghvim = await prisma.bahrebardariTaghvim.delete({
     *   where: {
     *     // ... filter to delete one BahrebardariTaghvim
     *   }
     * })
     * 
     */
    delete<T extends BahrebardariTaghvimDeleteArgs>(args: SelectSubset<T, BahrebardariTaghvimDeleteArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BahrebardariTaghvim.
     * @param {BahrebardariTaghvimUpdateArgs} args - Arguments to update one BahrebardariTaghvim.
     * @example
     * // Update one BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BahrebardariTaghvimUpdateArgs>(args: SelectSubset<T, BahrebardariTaghvimUpdateArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BahrebardariTaghvims.
     * @param {BahrebardariTaghvimDeleteManyArgs} args - Arguments to filter BahrebardariTaghvims to delete.
     * @example
     * // Delete a few BahrebardariTaghvims
     * const { count } = await prisma.bahrebardariTaghvim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BahrebardariTaghvimDeleteManyArgs>(args?: SelectSubset<T, BahrebardariTaghvimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BahrebardariTaghvims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BahrebardariTaghvims
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BahrebardariTaghvimUpdateManyArgs>(args: SelectSubset<T, BahrebardariTaghvimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BahrebardariTaghvim.
     * @param {BahrebardariTaghvimUpsertArgs} args - Arguments to update or create a BahrebardariTaghvim.
     * @example
     * // Update or create a BahrebardariTaghvim
     * const bahrebardariTaghvim = await prisma.bahrebardariTaghvim.upsert({
     *   create: {
     *     // ... data to create a BahrebardariTaghvim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BahrebardariTaghvim we want to update
     *   }
     * })
     */
    upsert<T extends BahrebardariTaghvimUpsertArgs>(args: SelectSubset<T, BahrebardariTaghvimUpsertArgs<ExtArgs>>): Prisma__BahrebardariTaghvimClient<$Result.GetResult<Prisma.$BahrebardariTaghvimPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BahrebardariTaghvims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimCountArgs} args - Arguments to filter BahrebardariTaghvims to count.
     * @example
     * // Count the number of BahrebardariTaghvims
     * const count = await prisma.bahrebardariTaghvim.count({
     *   where: {
     *     // ... the filter for the BahrebardariTaghvims we want to count
     *   }
     * })
    **/
    count<T extends BahrebardariTaghvimCountArgs>(
      args?: Subset<T, BahrebardariTaghvimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BahrebardariTaghvimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BahrebardariTaghvim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BahrebardariTaghvimAggregateArgs>(args: Subset<T, BahrebardariTaghvimAggregateArgs>): Prisma.PrismaPromise<GetBahrebardariTaghvimAggregateType<T>>

    /**
     * Group by BahrebardariTaghvim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BahrebardariTaghvimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BahrebardariTaghvimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BahrebardariTaghvimGroupByArgs['orderBy'] }
        : { orderBy?: BahrebardariTaghvimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BahrebardariTaghvimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBahrebardariTaghvimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BahrebardariTaghvim model
   */
  readonly fields: BahrebardariTaghvimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BahrebardariTaghvim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BahrebardariTaghvimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BahrebardariTaghvim model
   */ 
  interface BahrebardariTaghvimFieldRefs {
    readonly IdTag: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly FIdTarDor: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly FIdRanesh: FieldRef<"BahrebardariTaghvim", 'Int'>
    readonly Taghvim: FieldRef<"BahrebardariTaghvim", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BahrebardariTaghvim findUnique
   */
  export type BahrebardariTaghvimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim findUniqueOrThrow
   */
  export type BahrebardariTaghvimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim findFirst
   */
  export type BahrebardariTaghvimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariTaghvims.
     */
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim findFirstOrThrow
   */
  export type BahrebardariTaghvimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvim to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BahrebardariTaghvims.
     */
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim findMany
   */
  export type BahrebardariTaghvimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter, which BahrebardariTaghvims to fetch.
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BahrebardariTaghvims to fetch.
     */
    orderBy?: BahrebardariTaghvimOrderByWithRelationInput | BahrebardariTaghvimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BahrebardariTaghvims.
     */
    cursor?: BahrebardariTaghvimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BahrebardariTaghvims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BahrebardariTaghvims.
     */
    skip?: number
    distinct?: BahrebardariTaghvimScalarFieldEnum | BahrebardariTaghvimScalarFieldEnum[]
  }

  /**
   * BahrebardariTaghvim create
   */
  export type BahrebardariTaghvimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * The data needed to create a BahrebardariTaghvim.
     */
    data: XOR<BahrebardariTaghvimCreateInput, BahrebardariTaghvimUncheckedCreateInput>
  }

  /**
   * BahrebardariTaghvim createMany
   */
  export type BahrebardariTaghvimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BahrebardariTaghvims.
     */
    data: BahrebardariTaghvimCreateManyInput | BahrebardariTaghvimCreateManyInput[]
  }

  /**
   * BahrebardariTaghvim update
   */
  export type BahrebardariTaghvimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * The data needed to update a BahrebardariTaghvim.
     */
    data: XOR<BahrebardariTaghvimUpdateInput, BahrebardariTaghvimUncheckedUpdateInput>
    /**
     * Choose, which BahrebardariTaghvim to update.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim updateMany
   */
  export type BahrebardariTaghvimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BahrebardariTaghvims.
     */
    data: XOR<BahrebardariTaghvimUpdateManyMutationInput, BahrebardariTaghvimUncheckedUpdateManyInput>
    /**
     * Filter which BahrebardariTaghvims to update
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * Limit how many BahrebardariTaghvims to update.
     */
    limit?: number
  }

  /**
   * BahrebardariTaghvim upsert
   */
  export type BahrebardariTaghvimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * The filter to search for the BahrebardariTaghvim to update in case it exists.
     */
    where: BahrebardariTaghvimWhereUniqueInput
    /**
     * In case the BahrebardariTaghvim found by the `where` argument doesn't exist, create a new BahrebardariTaghvim with this data.
     */
    create: XOR<BahrebardariTaghvimCreateInput, BahrebardariTaghvimUncheckedCreateInput>
    /**
     * In case the BahrebardariTaghvim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BahrebardariTaghvimUpdateInput, BahrebardariTaghvimUncheckedUpdateInput>
  }

  /**
   * BahrebardariTaghvim delete
   */
  export type BahrebardariTaghvimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
    /**
     * Filter which BahrebardariTaghvim to delete.
     */
    where: BahrebardariTaghvimWhereUniqueInput
  }

  /**
   * BahrebardariTaghvim deleteMany
   */
  export type BahrebardariTaghvimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BahrebardariTaghvims to delete
     */
    where?: BahrebardariTaghvimWhereInput
    /**
     * Limit how many BahrebardariTaghvims to delete.
     */
    limit?: number
  }

  /**
   * BahrebardariTaghvim without action
   */
  export type BahrebardariTaghvimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BahrebardariTaghvim
     */
    select?: BahrebardariTaghvimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BahrebardariTaghvim
     */
    omit?: BahrebardariTaghvimOmit<ExtArgs> | null
  }


  /**
   * Model BareshMotaleat
   */

  export type AggregateBareshMotaleat = {
    _count: BareshMotaleatCountAggregateOutputType | null
    _avg: BareshMotaleatAvgAggregateOutputType | null
    _sum: BareshMotaleatSumAggregateOutputType | null
    _min: BareshMotaleatMinAggregateOutputType | null
    _max: BareshMotaleatMaxAggregateOutputType | null
  }

  export type BareshMotaleatAvgAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatSumAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatMinAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatMaxAggregateOutputType = {
    IdBarMot: number | null
    FIdNet: number | null
    FIdMah: number | null
    BareshMotaleat: Decimal | null
  }

  export type BareshMotaleatCountAggregateOutputType = {
    IdBarMot: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: number
    _all: number
  }


  export type BareshMotaleatAvgAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatSumAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatMinAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatMaxAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
  }

  export type BareshMotaleatCountAggregateInputType = {
    IdBarMot?: true
    FIdNet?: true
    FIdMah?: true
    BareshMotaleat?: true
    _all?: true
  }

  export type BareshMotaleatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BareshMotaleat to aggregate.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BareshMotaleats
    **/
    _count?: true | BareshMotaleatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BareshMotaleatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BareshMotaleatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BareshMotaleatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BareshMotaleatMaxAggregateInputType
  }

  export type GetBareshMotaleatAggregateType<T extends BareshMotaleatAggregateArgs> = {
        [P in keyof T & keyof AggregateBareshMotaleat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBareshMotaleat[P]>
      : GetScalarType<T[P], AggregateBareshMotaleat[P]>
  }




  export type BareshMotaleatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BareshMotaleatWhereInput
    orderBy?: BareshMotaleatOrderByWithAggregationInput | BareshMotaleatOrderByWithAggregationInput[]
    by: BareshMotaleatScalarFieldEnum[] | BareshMotaleatScalarFieldEnum
    having?: BareshMotaleatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BareshMotaleatCountAggregateInputType | true
    _avg?: BareshMotaleatAvgAggregateInputType
    _sum?: BareshMotaleatSumAggregateInputType
    _min?: BareshMotaleatMinAggregateInputType
    _max?: BareshMotaleatMaxAggregateInputType
  }

  export type BareshMotaleatGroupByOutputType = {
    IdBarMot: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal
    _count: BareshMotaleatCountAggregateOutputType | null
    _avg: BareshMotaleatAvgAggregateOutputType | null
    _sum: BareshMotaleatSumAggregateOutputType | null
    _min: BareshMotaleatMinAggregateOutputType | null
    _max: BareshMotaleatMaxAggregateOutputType | null
  }

  type GetBareshMotaleatGroupByPayload<T extends BareshMotaleatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BareshMotaleatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BareshMotaleatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BareshMotaleatGroupByOutputType[P]>
            : GetScalarType<T[P], BareshMotaleatGroupByOutputType[P]>
        }
      >
    >


  export type BareshMotaleatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBarMot?: boolean
    FIdNet?: boolean
    FIdMah?: boolean
    BareshMotaleat?: boolean
  }, ExtArgs["result"]["bareshMotaleat"]>



  export type BareshMotaleatSelectScalar = {
    IdBarMot?: boolean
    FIdNet?: boolean
    FIdMah?: boolean
    BareshMotaleat?: boolean
  }

  export type BareshMotaleatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBarMot" | "FIdNet" | "FIdMah" | "BareshMotaleat", ExtArgs["result"]["bareshMotaleat"]>

  export type $BareshMotaleatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BareshMotaleat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdBarMot: number
      FIdNet: number
      FIdMah: number
      BareshMotaleat: Prisma.Decimal
    }, ExtArgs["result"]["bareshMotaleat"]>
    composites: {}
  }

  type BareshMotaleatGetPayload<S extends boolean | null | undefined | BareshMotaleatDefaultArgs> = $Result.GetResult<Prisma.$BareshMotaleatPayload, S>

  type BareshMotaleatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BareshMotaleatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BareshMotaleatCountAggregateInputType | true
    }

  export interface BareshMotaleatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BareshMotaleat'], meta: { name: 'BareshMotaleat' } }
    /**
     * Find zero or one BareshMotaleat that matches the filter.
     * @param {BareshMotaleatFindUniqueArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BareshMotaleatFindUniqueArgs>(args: SelectSubset<T, BareshMotaleatFindUniqueArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BareshMotaleat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BareshMotaleatFindUniqueOrThrowArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BareshMotaleatFindUniqueOrThrowArgs>(args: SelectSubset<T, BareshMotaleatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BareshMotaleat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindFirstArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BareshMotaleatFindFirstArgs>(args?: SelectSubset<T, BareshMotaleatFindFirstArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BareshMotaleat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindFirstOrThrowArgs} args - Arguments to find a BareshMotaleat
     * @example
     * // Get one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BareshMotaleatFindFirstOrThrowArgs>(args?: SelectSubset<T, BareshMotaleatFindFirstOrThrowArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BareshMotaleats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BareshMotaleats
     * const bareshMotaleats = await prisma.bareshMotaleat.findMany()
     * 
     * // Get first 10 BareshMotaleats
     * const bareshMotaleats = await prisma.bareshMotaleat.findMany({ take: 10 })
     * 
     * // Only select the `IdBarMot`
     * const bareshMotaleatWithIdBarMotOnly = await prisma.bareshMotaleat.findMany({ select: { IdBarMot: true } })
     * 
     */
    findMany<T extends BareshMotaleatFindManyArgs>(args?: SelectSubset<T, BareshMotaleatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BareshMotaleat.
     * @param {BareshMotaleatCreateArgs} args - Arguments to create a BareshMotaleat.
     * @example
     * // Create one BareshMotaleat
     * const BareshMotaleat = await prisma.bareshMotaleat.create({
     *   data: {
     *     // ... data to create a BareshMotaleat
     *   }
     * })
     * 
     */
    create<T extends BareshMotaleatCreateArgs>(args: SelectSubset<T, BareshMotaleatCreateArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BareshMotaleats.
     * @param {BareshMotaleatCreateManyArgs} args - Arguments to create many BareshMotaleats.
     * @example
     * // Create many BareshMotaleats
     * const bareshMotaleat = await prisma.bareshMotaleat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BareshMotaleatCreateManyArgs>(args?: SelectSubset<T, BareshMotaleatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BareshMotaleat.
     * @param {BareshMotaleatDeleteArgs} args - Arguments to delete one BareshMotaleat.
     * @example
     * // Delete one BareshMotaleat
     * const BareshMotaleat = await prisma.bareshMotaleat.delete({
     *   where: {
     *     // ... filter to delete one BareshMotaleat
     *   }
     * })
     * 
     */
    delete<T extends BareshMotaleatDeleteArgs>(args: SelectSubset<T, BareshMotaleatDeleteArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BareshMotaleat.
     * @param {BareshMotaleatUpdateArgs} args - Arguments to update one BareshMotaleat.
     * @example
     * // Update one BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BareshMotaleatUpdateArgs>(args: SelectSubset<T, BareshMotaleatUpdateArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BareshMotaleats.
     * @param {BareshMotaleatDeleteManyArgs} args - Arguments to filter BareshMotaleats to delete.
     * @example
     * // Delete a few BareshMotaleats
     * const { count } = await prisma.bareshMotaleat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BareshMotaleatDeleteManyArgs>(args?: SelectSubset<T, BareshMotaleatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BareshMotaleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BareshMotaleats
     * const bareshMotaleat = await prisma.bareshMotaleat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BareshMotaleatUpdateManyArgs>(args: SelectSubset<T, BareshMotaleatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BareshMotaleat.
     * @param {BareshMotaleatUpsertArgs} args - Arguments to update or create a BareshMotaleat.
     * @example
     * // Update or create a BareshMotaleat
     * const bareshMotaleat = await prisma.bareshMotaleat.upsert({
     *   create: {
     *     // ... data to create a BareshMotaleat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BareshMotaleat we want to update
     *   }
     * })
     */
    upsert<T extends BareshMotaleatUpsertArgs>(args: SelectSubset<T, BareshMotaleatUpsertArgs<ExtArgs>>): Prisma__BareshMotaleatClient<$Result.GetResult<Prisma.$BareshMotaleatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BareshMotaleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatCountArgs} args - Arguments to filter BareshMotaleats to count.
     * @example
     * // Count the number of BareshMotaleats
     * const count = await prisma.bareshMotaleat.count({
     *   where: {
     *     // ... the filter for the BareshMotaleats we want to count
     *   }
     * })
    **/
    count<T extends BareshMotaleatCountArgs>(
      args?: Subset<T, BareshMotaleatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BareshMotaleatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BareshMotaleat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BareshMotaleatAggregateArgs>(args: Subset<T, BareshMotaleatAggregateArgs>): Prisma.PrismaPromise<GetBareshMotaleatAggregateType<T>>

    /**
     * Group by BareshMotaleat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BareshMotaleatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BareshMotaleatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BareshMotaleatGroupByArgs['orderBy'] }
        : { orderBy?: BareshMotaleatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BareshMotaleatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBareshMotaleatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BareshMotaleat model
   */
  readonly fields: BareshMotaleatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BareshMotaleat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BareshMotaleatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BareshMotaleat model
   */ 
  interface BareshMotaleatFieldRefs {
    readonly IdBarMot: FieldRef<"BareshMotaleat", 'Int'>
    readonly FIdNet: FieldRef<"BareshMotaleat", 'Int'>
    readonly FIdMah: FieldRef<"BareshMotaleat", 'Int'>
    readonly BareshMotaleat: FieldRef<"BareshMotaleat", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BareshMotaleat findUnique
   */
  export type BareshMotaleatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat findUniqueOrThrow
   */
  export type BareshMotaleatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat findFirst
   */
  export type BareshMotaleatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BareshMotaleats.
     */
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat findFirstOrThrow
   */
  export type BareshMotaleatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter, which BareshMotaleat to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BareshMotaleats.
     */
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat findMany
   */
  export type BareshMotaleatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter, which BareshMotaleats to fetch.
     */
    where?: BareshMotaleatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BareshMotaleats to fetch.
     */
    orderBy?: BareshMotaleatOrderByWithRelationInput | BareshMotaleatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BareshMotaleats.
     */
    cursor?: BareshMotaleatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BareshMotaleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BareshMotaleats.
     */
    skip?: number
    distinct?: BareshMotaleatScalarFieldEnum | BareshMotaleatScalarFieldEnum[]
  }

  /**
   * BareshMotaleat create
   */
  export type BareshMotaleatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * The data needed to create a BareshMotaleat.
     */
    data: XOR<BareshMotaleatCreateInput, BareshMotaleatUncheckedCreateInput>
  }

  /**
   * BareshMotaleat createMany
   */
  export type BareshMotaleatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BareshMotaleats.
     */
    data: BareshMotaleatCreateManyInput | BareshMotaleatCreateManyInput[]
  }

  /**
   * BareshMotaleat update
   */
  export type BareshMotaleatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * The data needed to update a BareshMotaleat.
     */
    data: XOR<BareshMotaleatUpdateInput, BareshMotaleatUncheckedUpdateInput>
    /**
     * Choose, which BareshMotaleat to update.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat updateMany
   */
  export type BareshMotaleatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BareshMotaleats.
     */
    data: XOR<BareshMotaleatUpdateManyMutationInput, BareshMotaleatUncheckedUpdateManyInput>
    /**
     * Filter which BareshMotaleats to update
     */
    where?: BareshMotaleatWhereInput
    /**
     * Limit how many BareshMotaleats to update.
     */
    limit?: number
  }

  /**
   * BareshMotaleat upsert
   */
  export type BareshMotaleatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * The filter to search for the BareshMotaleat to update in case it exists.
     */
    where: BareshMotaleatWhereUniqueInput
    /**
     * In case the BareshMotaleat found by the `where` argument doesn't exist, create a new BareshMotaleat with this data.
     */
    create: XOR<BareshMotaleatCreateInput, BareshMotaleatUncheckedCreateInput>
    /**
     * In case the BareshMotaleat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BareshMotaleatUpdateInput, BareshMotaleatUncheckedUpdateInput>
  }

  /**
   * BareshMotaleat delete
   */
  export type BareshMotaleatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
    /**
     * Filter which BareshMotaleat to delete.
     */
    where: BareshMotaleatWhereUniqueInput
  }

  /**
   * BareshMotaleat deleteMany
   */
  export type BareshMotaleatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BareshMotaleats to delete
     */
    where?: BareshMotaleatWhereInput
    /**
     * Limit how many BareshMotaleats to delete.
     */
    limit?: number
  }

  /**
   * BareshMotaleat without action
   */
  export type BareshMotaleatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BareshMotaleat
     */
    select?: BareshMotaleatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BareshMotaleat
     */
    omit?: BareshMotaleatOmit<ExtArgs> | null
  }


  /**
   * Model DarajePipe
   */

  export type AggregateDarajePipe = {
    _count: DarajePipeCountAggregateOutputType | null
    _avg: DarajePipeAvgAggregateOutputType | null
    _sum: DarajePipeSumAggregateOutputType | null
    _min: DarajePipeMinAggregateOutputType | null
    _max: DarajePipeMaxAggregateOutputType | null
  }

  export type DarajePipeAvgAggregateOutputType = {
    IdDPipe: number | null
  }

  export type DarajePipeSumAggregateOutputType = {
    IdDPipe: number | null
  }

  export type DarajePipeMinAggregateOutputType = {
    IdDPipe: number | null
    DarajePipe: string | null
  }

  export type DarajePipeMaxAggregateOutputType = {
    IdDPipe: number | null
    DarajePipe: string | null
  }

  export type DarajePipeCountAggregateOutputType = {
    IdDPipe: number
    DarajePipe: number
    _all: number
  }


  export type DarajePipeAvgAggregateInputType = {
    IdDPipe?: true
  }

  export type DarajePipeSumAggregateInputType = {
    IdDPipe?: true
  }

  export type DarajePipeMinAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
  }

  export type DarajePipeMaxAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
  }

  export type DarajePipeCountAggregateInputType = {
    IdDPipe?: true
    DarajePipe?: true
    _all?: true
  }

  export type DarajePipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarajePipe to aggregate.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DarajePipes
    **/
    _count?: true | DarajePipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DarajePipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DarajePipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DarajePipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DarajePipeMaxAggregateInputType
  }

  export type GetDarajePipeAggregateType<T extends DarajePipeAggregateArgs> = {
        [P in keyof T & keyof AggregateDarajePipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDarajePipe[P]>
      : GetScalarType<T[P], AggregateDarajePipe[P]>
  }




  export type DarajePipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarajePipeWhereInput
    orderBy?: DarajePipeOrderByWithAggregationInput | DarajePipeOrderByWithAggregationInput[]
    by: DarajePipeScalarFieldEnum[] | DarajePipeScalarFieldEnum
    having?: DarajePipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DarajePipeCountAggregateInputType | true
    _avg?: DarajePipeAvgAggregateInputType
    _sum?: DarajePipeSumAggregateInputType
    _min?: DarajePipeMinAggregateInputType
    _max?: DarajePipeMaxAggregateInputType
  }

  export type DarajePipeGroupByOutputType = {
    IdDPipe: number
    DarajePipe: string
    _count: DarajePipeCountAggregateOutputType | null
    _avg: DarajePipeAvgAggregateOutputType | null
    _sum: DarajePipeSumAggregateOutputType | null
    _min: DarajePipeMinAggregateOutputType | null
    _max: DarajePipeMaxAggregateOutputType | null
  }

  type GetDarajePipeGroupByPayload<T extends DarajePipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DarajePipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DarajePipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DarajePipeGroupByOutputType[P]>
            : GetScalarType<T[P], DarajePipeGroupByOutputType[P]>
        }
      >
    >


  export type DarajePipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDPipe?: boolean
    DarajePipe?: boolean
  }, ExtArgs["result"]["darajePipe"]>



  export type DarajePipeSelectScalar = {
    IdDPipe?: boolean
    DarajePipe?: boolean
  }

  export type DarajePipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDPipe" | "DarajePipe", ExtArgs["result"]["darajePipe"]>

  export type $DarajePipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DarajePipe"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdDPipe: number
      DarajePipe: string
    }, ExtArgs["result"]["darajePipe"]>
    composites: {}
  }

  type DarajePipeGetPayload<S extends boolean | null | undefined | DarajePipeDefaultArgs> = $Result.GetResult<Prisma.$DarajePipePayload, S>

  type DarajePipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DarajePipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DarajePipeCountAggregateInputType | true
    }

  export interface DarajePipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DarajePipe'], meta: { name: 'DarajePipe' } }
    /**
     * Find zero or one DarajePipe that matches the filter.
     * @param {DarajePipeFindUniqueArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DarajePipeFindUniqueArgs>(args: SelectSubset<T, DarajePipeFindUniqueArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DarajePipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DarajePipeFindUniqueOrThrowArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DarajePipeFindUniqueOrThrowArgs>(args: SelectSubset<T, DarajePipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DarajePipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindFirstArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DarajePipeFindFirstArgs>(args?: SelectSubset<T, DarajePipeFindFirstArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DarajePipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindFirstOrThrowArgs} args - Arguments to find a DarajePipe
     * @example
     * // Get one DarajePipe
     * const darajePipe = await prisma.darajePipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DarajePipeFindFirstOrThrowArgs>(args?: SelectSubset<T, DarajePipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DarajePipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DarajePipes
     * const darajePipes = await prisma.darajePipe.findMany()
     * 
     * // Get first 10 DarajePipes
     * const darajePipes = await prisma.darajePipe.findMany({ take: 10 })
     * 
     * // Only select the `IdDPipe`
     * const darajePipeWithIdDPipeOnly = await prisma.darajePipe.findMany({ select: { IdDPipe: true } })
     * 
     */
    findMany<T extends DarajePipeFindManyArgs>(args?: SelectSubset<T, DarajePipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DarajePipe.
     * @param {DarajePipeCreateArgs} args - Arguments to create a DarajePipe.
     * @example
     * // Create one DarajePipe
     * const DarajePipe = await prisma.darajePipe.create({
     *   data: {
     *     // ... data to create a DarajePipe
     *   }
     * })
     * 
     */
    create<T extends DarajePipeCreateArgs>(args: SelectSubset<T, DarajePipeCreateArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DarajePipes.
     * @param {DarajePipeCreateManyArgs} args - Arguments to create many DarajePipes.
     * @example
     * // Create many DarajePipes
     * const darajePipe = await prisma.darajePipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DarajePipeCreateManyArgs>(args?: SelectSubset<T, DarajePipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DarajePipe.
     * @param {DarajePipeDeleteArgs} args - Arguments to delete one DarajePipe.
     * @example
     * // Delete one DarajePipe
     * const DarajePipe = await prisma.darajePipe.delete({
     *   where: {
     *     // ... filter to delete one DarajePipe
     *   }
     * })
     * 
     */
    delete<T extends DarajePipeDeleteArgs>(args: SelectSubset<T, DarajePipeDeleteArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DarajePipe.
     * @param {DarajePipeUpdateArgs} args - Arguments to update one DarajePipe.
     * @example
     * // Update one DarajePipe
     * const darajePipe = await prisma.darajePipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DarajePipeUpdateArgs>(args: SelectSubset<T, DarajePipeUpdateArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DarajePipes.
     * @param {DarajePipeDeleteManyArgs} args - Arguments to filter DarajePipes to delete.
     * @example
     * // Delete a few DarajePipes
     * const { count } = await prisma.darajePipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DarajePipeDeleteManyArgs>(args?: SelectSubset<T, DarajePipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarajePipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DarajePipes
     * const darajePipe = await prisma.darajePipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DarajePipeUpdateManyArgs>(args: SelectSubset<T, DarajePipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DarajePipe.
     * @param {DarajePipeUpsertArgs} args - Arguments to update or create a DarajePipe.
     * @example
     * // Update or create a DarajePipe
     * const darajePipe = await prisma.darajePipe.upsert({
     *   create: {
     *     // ... data to create a DarajePipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DarajePipe we want to update
     *   }
     * })
     */
    upsert<T extends DarajePipeUpsertArgs>(args: SelectSubset<T, DarajePipeUpsertArgs<ExtArgs>>): Prisma__DarajePipeClient<$Result.GetResult<Prisma.$DarajePipePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DarajePipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeCountArgs} args - Arguments to filter DarajePipes to count.
     * @example
     * // Count the number of DarajePipes
     * const count = await prisma.darajePipe.count({
     *   where: {
     *     // ... the filter for the DarajePipes we want to count
     *   }
     * })
    **/
    count<T extends DarajePipeCountArgs>(
      args?: Subset<T, DarajePipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DarajePipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DarajePipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DarajePipeAggregateArgs>(args: Subset<T, DarajePipeAggregateArgs>): Prisma.PrismaPromise<GetDarajePipeAggregateType<T>>

    /**
     * Group by DarajePipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarajePipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DarajePipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DarajePipeGroupByArgs['orderBy'] }
        : { orderBy?: DarajePipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DarajePipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDarajePipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DarajePipe model
   */
  readonly fields: DarajePipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DarajePipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DarajePipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DarajePipe model
   */ 
  interface DarajePipeFieldRefs {
    readonly IdDPipe: FieldRef<"DarajePipe", 'Int'>
    readonly DarajePipe: FieldRef<"DarajePipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DarajePipe findUnique
   */
  export type DarajePipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe findUniqueOrThrow
   */
  export type DarajePipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe findFirst
   */
  export type DarajePipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarajePipes.
     */
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe findFirstOrThrow
   */
  export type DarajePipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter, which DarajePipe to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarajePipes.
     */
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe findMany
   */
  export type DarajePipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter, which DarajePipes to fetch.
     */
    where?: DarajePipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarajePipes to fetch.
     */
    orderBy?: DarajePipeOrderByWithRelationInput | DarajePipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DarajePipes.
     */
    cursor?: DarajePipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarajePipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarajePipes.
     */
    skip?: number
    distinct?: DarajePipeScalarFieldEnum | DarajePipeScalarFieldEnum[]
  }

  /**
   * DarajePipe create
   */
  export type DarajePipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * The data needed to create a DarajePipe.
     */
    data: XOR<DarajePipeCreateInput, DarajePipeUncheckedCreateInput>
  }

  /**
   * DarajePipe createMany
   */
  export type DarajePipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DarajePipes.
     */
    data: DarajePipeCreateManyInput | DarajePipeCreateManyInput[]
  }

  /**
   * DarajePipe update
   */
  export type DarajePipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * The data needed to update a DarajePipe.
     */
    data: XOR<DarajePipeUpdateInput, DarajePipeUncheckedUpdateInput>
    /**
     * Choose, which DarajePipe to update.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe updateMany
   */
  export type DarajePipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DarajePipes.
     */
    data: XOR<DarajePipeUpdateManyMutationInput, DarajePipeUncheckedUpdateManyInput>
    /**
     * Filter which DarajePipes to update
     */
    where?: DarajePipeWhereInput
    /**
     * Limit how many DarajePipes to update.
     */
    limit?: number
  }

  /**
   * DarajePipe upsert
   */
  export type DarajePipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * The filter to search for the DarajePipe to update in case it exists.
     */
    where: DarajePipeWhereUniqueInput
    /**
     * In case the DarajePipe found by the `where` argument doesn't exist, create a new DarajePipe with this data.
     */
    create: XOR<DarajePipeCreateInput, DarajePipeUncheckedCreateInput>
    /**
     * In case the DarajePipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DarajePipeUpdateInput, DarajePipeUncheckedUpdateInput>
  }

  /**
   * DarajePipe delete
   */
  export type DarajePipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
    /**
     * Filter which DarajePipe to delete.
     */
    where: DarajePipeWhereUniqueInput
  }

  /**
   * DarajePipe deleteMany
   */
  export type DarajePipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarajePipes to delete
     */
    where?: DarajePipeWhereInput
    /**
     * Limit how many DarajePipes to delete.
     */
    limit?: number
  }

  /**
   * DarajePipe without action
   */
  export type DarajePipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarajePipe
     */
    select?: DarajePipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarajePipe
     */
    omit?: DarajePipeOmit<ExtArgs> | null
  }


  /**
   * Model DarjeStation
   */

  export type AggregateDarjeStation = {
    _count: DarjeStationCountAggregateOutputType | null
    _avg: DarjeStationAvgAggregateOutputType | null
    _sum: DarjeStationSumAggregateOutputType | null
    _min: DarjeStationMinAggregateOutputType | null
    _max: DarjeStationMaxAggregateOutputType | null
  }

  export type DarjeStationAvgAggregateOutputType = {
    IdDStation: number | null
  }

  export type DarjeStationSumAggregateOutputType = {
    IdDStation: number | null
  }

  export type DarjeStationMinAggregateOutputType = {
    IdDStation: number | null
    DarajeStation: string | null
  }

  export type DarjeStationMaxAggregateOutputType = {
    IdDStation: number | null
    DarajeStation: string | null
  }

  export type DarjeStationCountAggregateOutputType = {
    IdDStation: number
    DarajeStation: number
    _all: number
  }


  export type DarjeStationAvgAggregateInputType = {
    IdDStation?: true
  }

  export type DarjeStationSumAggregateInputType = {
    IdDStation?: true
  }

  export type DarjeStationMinAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
  }

  export type DarjeStationMaxAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
  }

  export type DarjeStationCountAggregateInputType = {
    IdDStation?: true
    DarajeStation?: true
    _all?: true
  }

  export type DarjeStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarjeStation to aggregate.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DarjeStations
    **/
    _count?: true | DarjeStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DarjeStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DarjeStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DarjeStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DarjeStationMaxAggregateInputType
  }

  export type GetDarjeStationAggregateType<T extends DarjeStationAggregateArgs> = {
        [P in keyof T & keyof AggregateDarjeStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDarjeStation[P]>
      : GetScalarType<T[P], AggregateDarjeStation[P]>
  }




  export type DarjeStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarjeStationWhereInput
    orderBy?: DarjeStationOrderByWithAggregationInput | DarjeStationOrderByWithAggregationInput[]
    by: DarjeStationScalarFieldEnum[] | DarjeStationScalarFieldEnum
    having?: DarjeStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DarjeStationCountAggregateInputType | true
    _avg?: DarjeStationAvgAggregateInputType
    _sum?: DarjeStationSumAggregateInputType
    _min?: DarjeStationMinAggregateInputType
    _max?: DarjeStationMaxAggregateInputType
  }

  export type DarjeStationGroupByOutputType = {
    IdDStation: number
    DarajeStation: string
    _count: DarjeStationCountAggregateOutputType | null
    _avg: DarjeStationAvgAggregateOutputType | null
    _sum: DarjeStationSumAggregateOutputType | null
    _min: DarjeStationMinAggregateOutputType | null
    _max: DarjeStationMaxAggregateOutputType | null
  }

  type GetDarjeStationGroupByPayload<T extends DarjeStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DarjeStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DarjeStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DarjeStationGroupByOutputType[P]>
            : GetScalarType<T[P], DarjeStationGroupByOutputType[P]>
        }
      >
    >


  export type DarjeStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDStation?: boolean
    DarajeStation?: boolean
  }, ExtArgs["result"]["darjeStation"]>



  export type DarjeStationSelectScalar = {
    IdDStation?: boolean
    DarajeStation?: boolean
  }

  export type DarjeStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDStation" | "DarajeStation", ExtArgs["result"]["darjeStation"]>

  export type $DarjeStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DarjeStation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdDStation: number
      DarajeStation: string
    }, ExtArgs["result"]["darjeStation"]>
    composites: {}
  }

  type DarjeStationGetPayload<S extends boolean | null | undefined | DarjeStationDefaultArgs> = $Result.GetResult<Prisma.$DarjeStationPayload, S>

  type DarjeStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DarjeStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DarjeStationCountAggregateInputType | true
    }

  export interface DarjeStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DarjeStation'], meta: { name: 'DarjeStation' } }
    /**
     * Find zero or one DarjeStation that matches the filter.
     * @param {DarjeStationFindUniqueArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DarjeStationFindUniqueArgs>(args: SelectSubset<T, DarjeStationFindUniqueArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DarjeStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DarjeStationFindUniqueOrThrowArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DarjeStationFindUniqueOrThrowArgs>(args: SelectSubset<T, DarjeStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DarjeStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindFirstArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DarjeStationFindFirstArgs>(args?: SelectSubset<T, DarjeStationFindFirstArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DarjeStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindFirstOrThrowArgs} args - Arguments to find a DarjeStation
     * @example
     * // Get one DarjeStation
     * const darjeStation = await prisma.darjeStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DarjeStationFindFirstOrThrowArgs>(args?: SelectSubset<T, DarjeStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DarjeStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DarjeStations
     * const darjeStations = await prisma.darjeStation.findMany()
     * 
     * // Get first 10 DarjeStations
     * const darjeStations = await prisma.darjeStation.findMany({ take: 10 })
     * 
     * // Only select the `IdDStation`
     * const darjeStationWithIdDStationOnly = await prisma.darjeStation.findMany({ select: { IdDStation: true } })
     * 
     */
    findMany<T extends DarjeStationFindManyArgs>(args?: SelectSubset<T, DarjeStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DarjeStation.
     * @param {DarjeStationCreateArgs} args - Arguments to create a DarjeStation.
     * @example
     * // Create one DarjeStation
     * const DarjeStation = await prisma.darjeStation.create({
     *   data: {
     *     // ... data to create a DarjeStation
     *   }
     * })
     * 
     */
    create<T extends DarjeStationCreateArgs>(args: SelectSubset<T, DarjeStationCreateArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DarjeStations.
     * @param {DarjeStationCreateManyArgs} args - Arguments to create many DarjeStations.
     * @example
     * // Create many DarjeStations
     * const darjeStation = await prisma.darjeStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DarjeStationCreateManyArgs>(args?: SelectSubset<T, DarjeStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DarjeStation.
     * @param {DarjeStationDeleteArgs} args - Arguments to delete one DarjeStation.
     * @example
     * // Delete one DarjeStation
     * const DarjeStation = await prisma.darjeStation.delete({
     *   where: {
     *     // ... filter to delete one DarjeStation
     *   }
     * })
     * 
     */
    delete<T extends DarjeStationDeleteArgs>(args: SelectSubset<T, DarjeStationDeleteArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DarjeStation.
     * @param {DarjeStationUpdateArgs} args - Arguments to update one DarjeStation.
     * @example
     * // Update one DarjeStation
     * const darjeStation = await prisma.darjeStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DarjeStationUpdateArgs>(args: SelectSubset<T, DarjeStationUpdateArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DarjeStations.
     * @param {DarjeStationDeleteManyArgs} args - Arguments to filter DarjeStations to delete.
     * @example
     * // Delete a few DarjeStations
     * const { count } = await prisma.darjeStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DarjeStationDeleteManyArgs>(args?: SelectSubset<T, DarjeStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarjeStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DarjeStations
     * const darjeStation = await prisma.darjeStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DarjeStationUpdateManyArgs>(args: SelectSubset<T, DarjeStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DarjeStation.
     * @param {DarjeStationUpsertArgs} args - Arguments to update or create a DarjeStation.
     * @example
     * // Update or create a DarjeStation
     * const darjeStation = await prisma.darjeStation.upsert({
     *   create: {
     *     // ... data to create a DarjeStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DarjeStation we want to update
     *   }
     * })
     */
    upsert<T extends DarjeStationUpsertArgs>(args: SelectSubset<T, DarjeStationUpsertArgs<ExtArgs>>): Prisma__DarjeStationClient<$Result.GetResult<Prisma.$DarjeStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DarjeStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationCountArgs} args - Arguments to filter DarjeStations to count.
     * @example
     * // Count the number of DarjeStations
     * const count = await prisma.darjeStation.count({
     *   where: {
     *     // ... the filter for the DarjeStations we want to count
     *   }
     * })
    **/
    count<T extends DarjeStationCountArgs>(
      args?: Subset<T, DarjeStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DarjeStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DarjeStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DarjeStationAggregateArgs>(args: Subset<T, DarjeStationAggregateArgs>): Prisma.PrismaPromise<GetDarjeStationAggregateType<T>>

    /**
     * Group by DarjeStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarjeStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DarjeStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DarjeStationGroupByArgs['orderBy'] }
        : { orderBy?: DarjeStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DarjeStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDarjeStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DarjeStation model
   */
  readonly fields: DarjeStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DarjeStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DarjeStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DarjeStation model
   */ 
  interface DarjeStationFieldRefs {
    readonly IdDStation: FieldRef<"DarjeStation", 'Int'>
    readonly DarajeStation: FieldRef<"DarjeStation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DarjeStation findUnique
   */
  export type DarjeStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation findUniqueOrThrow
   */
  export type DarjeStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation findFirst
   */
  export type DarjeStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarjeStations.
     */
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation findFirstOrThrow
   */
  export type DarjeStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter, which DarjeStation to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarjeStations.
     */
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation findMany
   */
  export type DarjeStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter, which DarjeStations to fetch.
     */
    where?: DarjeStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarjeStations to fetch.
     */
    orderBy?: DarjeStationOrderByWithRelationInput | DarjeStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DarjeStations.
     */
    cursor?: DarjeStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarjeStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarjeStations.
     */
    skip?: number
    distinct?: DarjeStationScalarFieldEnum | DarjeStationScalarFieldEnum[]
  }

  /**
   * DarjeStation create
   */
  export type DarjeStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * The data needed to create a DarjeStation.
     */
    data: XOR<DarjeStationCreateInput, DarjeStationUncheckedCreateInput>
  }

  /**
   * DarjeStation createMany
   */
  export type DarjeStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DarjeStations.
     */
    data: DarjeStationCreateManyInput | DarjeStationCreateManyInput[]
  }

  /**
   * DarjeStation update
   */
  export type DarjeStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * The data needed to update a DarjeStation.
     */
    data: XOR<DarjeStationUpdateInput, DarjeStationUncheckedUpdateInput>
    /**
     * Choose, which DarjeStation to update.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation updateMany
   */
  export type DarjeStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DarjeStations.
     */
    data: XOR<DarjeStationUpdateManyMutationInput, DarjeStationUncheckedUpdateManyInput>
    /**
     * Filter which DarjeStations to update
     */
    where?: DarjeStationWhereInput
    /**
     * Limit how many DarjeStations to update.
     */
    limit?: number
  }

  /**
   * DarjeStation upsert
   */
  export type DarjeStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * The filter to search for the DarjeStation to update in case it exists.
     */
    where: DarjeStationWhereUniqueInput
    /**
     * In case the DarjeStation found by the `where` argument doesn't exist, create a new DarjeStation with this data.
     */
    create: XOR<DarjeStationCreateInput, DarjeStationUncheckedCreateInput>
    /**
     * In case the DarjeStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DarjeStationUpdateInput, DarjeStationUncheckedUpdateInput>
  }

  /**
   * DarjeStation delete
   */
  export type DarjeStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
    /**
     * Filter which DarjeStation to delete.
     */
    where: DarjeStationWhereUniqueInput
  }

  /**
   * DarjeStation deleteMany
   */
  export type DarjeStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarjeStations to delete
     */
    where?: DarjeStationWhereInput
    /**
     * Limit how many DarjeStations to delete.
     */
    limit?: number
  }

  /**
   * DarjeStation without action
   */
  export type DarjeStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarjeStation
     */
    select?: DarjeStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarjeStation
     */
    omit?: DarjeStationOmit<ExtArgs> | null
  }


  /**
   * Model DoreKesht
   */

  export type AggregateDoreKesht = {
    _count: DoreKeshtCountAggregateOutputType | null
    _avg: DoreKeshtAvgAggregateOutputType | null
    _sum: DoreKeshtSumAggregateOutputType | null
    _min: DoreKeshtMinAggregateOutputType | null
    _max: DoreKeshtMaxAggregateOutputType | null
  }

  export type DoreKeshtAvgAggregateOutputType = {
    IdDore: number | null
  }

  export type DoreKeshtSumAggregateOutputType = {
    IdDore: number | null
  }

  export type DoreKeshtMinAggregateOutputType = {
    IdDore: number | null
    Dore: string | null
  }

  export type DoreKeshtMaxAggregateOutputType = {
    IdDore: number | null
    Dore: string | null
  }

  export type DoreKeshtCountAggregateOutputType = {
    IdDore: number
    Dore: number
    _all: number
  }


  export type DoreKeshtAvgAggregateInputType = {
    IdDore?: true
  }

  export type DoreKeshtSumAggregateInputType = {
    IdDore?: true
  }

  export type DoreKeshtMinAggregateInputType = {
    IdDore?: true
    Dore?: true
  }

  export type DoreKeshtMaxAggregateInputType = {
    IdDore?: true
    Dore?: true
  }

  export type DoreKeshtCountAggregateInputType = {
    IdDore?: true
    Dore?: true
    _all?: true
  }

  export type DoreKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoreKesht to aggregate.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoreKeshts
    **/
    _count?: true | DoreKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoreKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoreKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoreKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoreKeshtMaxAggregateInputType
  }

  export type GetDoreKeshtAggregateType<T extends DoreKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateDoreKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoreKesht[P]>
      : GetScalarType<T[P], AggregateDoreKesht[P]>
  }




  export type DoreKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoreKeshtWhereInput
    orderBy?: DoreKeshtOrderByWithAggregationInput | DoreKeshtOrderByWithAggregationInput[]
    by: DoreKeshtScalarFieldEnum[] | DoreKeshtScalarFieldEnum
    having?: DoreKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoreKeshtCountAggregateInputType | true
    _avg?: DoreKeshtAvgAggregateInputType
    _sum?: DoreKeshtSumAggregateInputType
    _min?: DoreKeshtMinAggregateInputType
    _max?: DoreKeshtMaxAggregateInputType
  }

  export type DoreKeshtGroupByOutputType = {
    IdDore: number
    Dore: string
    _count: DoreKeshtCountAggregateOutputType | null
    _avg: DoreKeshtAvgAggregateOutputType | null
    _sum: DoreKeshtSumAggregateOutputType | null
    _min: DoreKeshtMinAggregateOutputType | null
    _max: DoreKeshtMaxAggregateOutputType | null
  }

  type GetDoreKeshtGroupByPayload<T extends DoreKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoreKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoreKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoreKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], DoreKeshtGroupByOutputType[P]>
        }
      >
    >


  export type DoreKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDore?: boolean
    Dore?: boolean
  }, ExtArgs["result"]["doreKesht"]>



  export type DoreKeshtSelectScalar = {
    IdDore?: boolean
    Dore?: boolean
  }

  export type DoreKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdDore" | "Dore", ExtArgs["result"]["doreKesht"]>

  export type $DoreKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoreKesht"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdDore: number
      Dore: string
    }, ExtArgs["result"]["doreKesht"]>
    composites: {}
  }

  type DoreKeshtGetPayload<S extends boolean | null | undefined | DoreKeshtDefaultArgs> = $Result.GetResult<Prisma.$DoreKeshtPayload, S>

  type DoreKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoreKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoreKeshtCountAggregateInputType | true
    }

  export interface DoreKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoreKesht'], meta: { name: 'DoreKesht' } }
    /**
     * Find zero or one DoreKesht that matches the filter.
     * @param {DoreKeshtFindUniqueArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoreKeshtFindUniqueArgs>(args: SelectSubset<T, DoreKeshtFindUniqueArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DoreKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoreKeshtFindUniqueOrThrowArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoreKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, DoreKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DoreKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindFirstArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoreKeshtFindFirstArgs>(args?: SelectSubset<T, DoreKeshtFindFirstArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DoreKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindFirstOrThrowArgs} args - Arguments to find a DoreKesht
     * @example
     * // Get one DoreKesht
     * const doreKesht = await prisma.doreKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoreKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, DoreKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DoreKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoreKeshts
     * const doreKeshts = await prisma.doreKesht.findMany()
     * 
     * // Get first 10 DoreKeshts
     * const doreKeshts = await prisma.doreKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdDore`
     * const doreKeshtWithIdDoreOnly = await prisma.doreKesht.findMany({ select: { IdDore: true } })
     * 
     */
    findMany<T extends DoreKeshtFindManyArgs>(args?: SelectSubset<T, DoreKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DoreKesht.
     * @param {DoreKeshtCreateArgs} args - Arguments to create a DoreKesht.
     * @example
     * // Create one DoreKesht
     * const DoreKesht = await prisma.doreKesht.create({
     *   data: {
     *     // ... data to create a DoreKesht
     *   }
     * })
     * 
     */
    create<T extends DoreKeshtCreateArgs>(args: SelectSubset<T, DoreKeshtCreateArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DoreKeshts.
     * @param {DoreKeshtCreateManyArgs} args - Arguments to create many DoreKeshts.
     * @example
     * // Create many DoreKeshts
     * const doreKesht = await prisma.doreKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoreKeshtCreateManyArgs>(args?: SelectSubset<T, DoreKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DoreKesht.
     * @param {DoreKeshtDeleteArgs} args - Arguments to delete one DoreKesht.
     * @example
     * // Delete one DoreKesht
     * const DoreKesht = await prisma.doreKesht.delete({
     *   where: {
     *     // ... filter to delete one DoreKesht
     *   }
     * })
     * 
     */
    delete<T extends DoreKeshtDeleteArgs>(args: SelectSubset<T, DoreKeshtDeleteArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DoreKesht.
     * @param {DoreKeshtUpdateArgs} args - Arguments to update one DoreKesht.
     * @example
     * // Update one DoreKesht
     * const doreKesht = await prisma.doreKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoreKeshtUpdateArgs>(args: SelectSubset<T, DoreKeshtUpdateArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DoreKeshts.
     * @param {DoreKeshtDeleteManyArgs} args - Arguments to filter DoreKeshts to delete.
     * @example
     * // Delete a few DoreKeshts
     * const { count } = await prisma.doreKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoreKeshtDeleteManyArgs>(args?: SelectSubset<T, DoreKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoreKeshts
     * const doreKesht = await prisma.doreKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoreKeshtUpdateManyArgs>(args: SelectSubset<T, DoreKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoreKesht.
     * @param {DoreKeshtUpsertArgs} args - Arguments to update or create a DoreKesht.
     * @example
     * // Update or create a DoreKesht
     * const doreKesht = await prisma.doreKesht.upsert({
     *   create: {
     *     // ... data to create a DoreKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoreKesht we want to update
     *   }
     * })
     */
    upsert<T extends DoreKeshtUpsertArgs>(args: SelectSubset<T, DoreKeshtUpsertArgs<ExtArgs>>): Prisma__DoreKeshtClient<$Result.GetResult<Prisma.$DoreKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtCountArgs} args - Arguments to filter DoreKeshts to count.
     * @example
     * // Count the number of DoreKeshts
     * const count = await prisma.doreKesht.count({
     *   where: {
     *     // ... the filter for the DoreKeshts we want to count
     *   }
     * })
    **/
    count<T extends DoreKeshtCountArgs>(
      args?: Subset<T, DoreKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoreKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoreKeshtAggregateArgs>(args: Subset<T, DoreKeshtAggregateArgs>): Prisma.PrismaPromise<GetDoreKeshtAggregateType<T>>

    /**
     * Group by DoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoreKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoreKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoreKeshtGroupByArgs['orderBy'] }
        : { orderBy?: DoreKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoreKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoreKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoreKesht model
   */
  readonly fields: DoreKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoreKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoreKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoreKesht model
   */ 
  interface DoreKeshtFieldRefs {
    readonly IdDore: FieldRef<"DoreKesht", 'Int'>
    readonly Dore: FieldRef<"DoreKesht", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoreKesht findUnique
   */
  export type DoreKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht findUniqueOrThrow
   */
  export type DoreKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht findFirst
   */
  export type DoreKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoreKeshts.
     */
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht findFirstOrThrow
   */
  export type DoreKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which DoreKesht to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoreKeshts.
     */
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht findMany
   */
  export type DoreKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which DoreKeshts to fetch.
     */
    where?: DoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoreKeshts to fetch.
     */
    orderBy?: DoreKeshtOrderByWithRelationInput | DoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoreKeshts.
     */
    cursor?: DoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoreKeshts.
     */
    skip?: number
    distinct?: DoreKeshtScalarFieldEnum | DoreKeshtScalarFieldEnum[]
  }

  /**
   * DoreKesht create
   */
  export type DoreKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * The data needed to create a DoreKesht.
     */
    data: XOR<DoreKeshtCreateInput, DoreKeshtUncheckedCreateInput>
  }

  /**
   * DoreKesht createMany
   */
  export type DoreKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoreKeshts.
     */
    data: DoreKeshtCreateManyInput | DoreKeshtCreateManyInput[]
  }

  /**
   * DoreKesht update
   */
  export type DoreKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * The data needed to update a DoreKesht.
     */
    data: XOR<DoreKeshtUpdateInput, DoreKeshtUncheckedUpdateInput>
    /**
     * Choose, which DoreKesht to update.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht updateMany
   */
  export type DoreKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoreKeshts.
     */
    data: XOR<DoreKeshtUpdateManyMutationInput, DoreKeshtUncheckedUpdateManyInput>
    /**
     * Filter which DoreKeshts to update
     */
    where?: DoreKeshtWhereInput
    /**
     * Limit how many DoreKeshts to update.
     */
    limit?: number
  }

  /**
   * DoreKesht upsert
   */
  export type DoreKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * The filter to search for the DoreKesht to update in case it exists.
     */
    where: DoreKeshtWhereUniqueInput
    /**
     * In case the DoreKesht found by the `where` argument doesn't exist, create a new DoreKesht with this data.
     */
    create: XOR<DoreKeshtCreateInput, DoreKeshtUncheckedCreateInput>
    /**
     * In case the DoreKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoreKeshtUpdateInput, DoreKeshtUncheckedUpdateInput>
  }

  /**
   * DoreKesht delete
   */
  export type DoreKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
    /**
     * Filter which DoreKesht to delete.
     */
    where: DoreKeshtWhereUniqueInput
  }

  /**
   * DoreKesht deleteMany
   */
  export type DoreKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoreKeshts to delete
     */
    where?: DoreKeshtWhereInput
    /**
     * Limit how many DoreKeshts to delete.
     */
    limit?: number
  }

  /**
   * DoreKesht without action
   */
  export type DoreKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoreKesht
     */
    select?: DoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoreKesht
     */
    omit?: DoreKeshtOmit<ExtArgs> | null
  }


  /**
   * Model EshtebahAvamel
   */

  export type AggregateEshtebahAvamel = {
    _count: EshtebahAvamelCountAggregateOutputType | null
    _avg: EshtebahAvamelAvgAggregateOutputType | null
    _sum: EshtebahAvamelSumAggregateOutputType | null
    _min: EshtebahAvamelMinAggregateOutputType | null
    _max: EshtebahAvamelMaxAggregateOutputType | null
  }

  export type EshtebahAvamelAvgAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelSumAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelMinAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelMaxAggregateOutputType = {
    IdEsht: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Eshtebah: number | null
  }

  export type EshtebahAvamelCountAggregateOutputType = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
    _all: number
  }


  export type EshtebahAvamelAvgAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelSumAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelMinAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelMaxAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
  }

  export type EshtebahAvamelCountAggregateInputType = {
    IdEsht?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Eshtebah?: true
    _all?: true
  }

  export type EshtebahAvamelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EshtebahAvamel to aggregate.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EshtebahAvamels
    **/
    _count?: true | EshtebahAvamelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EshtebahAvamelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EshtebahAvamelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EshtebahAvamelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EshtebahAvamelMaxAggregateInputType
  }

  export type GetEshtebahAvamelAggregateType<T extends EshtebahAvamelAggregateArgs> = {
        [P in keyof T & keyof AggregateEshtebahAvamel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEshtebahAvamel[P]>
      : GetScalarType<T[P], AggregateEshtebahAvamel[P]>
  }




  export type EshtebahAvamelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EshtebahAvamelWhereInput
    orderBy?: EshtebahAvamelOrderByWithAggregationInput | EshtebahAvamelOrderByWithAggregationInput[]
    by: EshtebahAvamelScalarFieldEnum[] | EshtebahAvamelScalarFieldEnum
    having?: EshtebahAvamelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EshtebahAvamelCountAggregateInputType | true
    _avg?: EshtebahAvamelAvgAggregateInputType
    _sum?: EshtebahAvamelSumAggregateInputType
    _min?: EshtebahAvamelMinAggregateInputType
    _max?: EshtebahAvamelMaxAggregateInputType
  }

  export type EshtebahAvamelGroupByOutputType = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
    _count: EshtebahAvamelCountAggregateOutputType | null
    _avg: EshtebahAvamelAvgAggregateOutputType | null
    _sum: EshtebahAvamelSumAggregateOutputType | null
    _min: EshtebahAvamelMinAggregateOutputType | null
    _max: EshtebahAvamelMaxAggregateOutputType | null
  }

  type GetEshtebahAvamelGroupByPayload<T extends EshtebahAvamelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EshtebahAvamelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EshtebahAvamelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EshtebahAvamelGroupByOutputType[P]>
            : GetScalarType<T[P], EshtebahAvamelGroupByOutputType[P]>
        }
      >
    >


  export type EshtebahAvamelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdEsht?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Eshtebah?: boolean
  }, ExtArgs["result"]["eshtebahAvamel"]>



  export type EshtebahAvamelSelectScalar = {
    IdEsht?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Eshtebah?: boolean
  }

  export type EshtebahAvamelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdEsht" | "FIdRanesh" | "FIdTarDor" | "Eshtebah", ExtArgs["result"]["eshtebahAvamel"]>

  export type $EshtebahAvamelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EshtebahAvamel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdEsht: number
      FIdRanesh: number
      FIdTarDor: number
      Eshtebah: number
    }, ExtArgs["result"]["eshtebahAvamel"]>
    composites: {}
  }

  type EshtebahAvamelGetPayload<S extends boolean | null | undefined | EshtebahAvamelDefaultArgs> = $Result.GetResult<Prisma.$EshtebahAvamelPayload, S>

  type EshtebahAvamelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EshtebahAvamelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EshtebahAvamelCountAggregateInputType | true
    }

  export interface EshtebahAvamelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EshtebahAvamel'], meta: { name: 'EshtebahAvamel' } }
    /**
     * Find zero or one EshtebahAvamel that matches the filter.
     * @param {EshtebahAvamelFindUniqueArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EshtebahAvamelFindUniqueArgs>(args: SelectSubset<T, EshtebahAvamelFindUniqueArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EshtebahAvamel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EshtebahAvamelFindUniqueOrThrowArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EshtebahAvamelFindUniqueOrThrowArgs>(args: SelectSubset<T, EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EshtebahAvamel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindFirstArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EshtebahAvamelFindFirstArgs>(args?: SelectSubset<T, EshtebahAvamelFindFirstArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EshtebahAvamel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindFirstOrThrowArgs} args - Arguments to find a EshtebahAvamel
     * @example
     * // Get one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EshtebahAvamelFindFirstOrThrowArgs>(args?: SelectSubset<T, EshtebahAvamelFindFirstOrThrowArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EshtebahAvamels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EshtebahAvamels
     * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany()
     * 
     * // Get first 10 EshtebahAvamels
     * const eshtebahAvamels = await prisma.eshtebahAvamel.findMany({ take: 10 })
     * 
     * // Only select the `IdEsht`
     * const eshtebahAvamelWithIdEshtOnly = await prisma.eshtebahAvamel.findMany({ select: { IdEsht: true } })
     * 
     */
    findMany<T extends EshtebahAvamelFindManyArgs>(args?: SelectSubset<T, EshtebahAvamelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EshtebahAvamel.
     * @param {EshtebahAvamelCreateArgs} args - Arguments to create a EshtebahAvamel.
     * @example
     * // Create one EshtebahAvamel
     * const EshtebahAvamel = await prisma.eshtebahAvamel.create({
     *   data: {
     *     // ... data to create a EshtebahAvamel
     *   }
     * })
     * 
     */
    create<T extends EshtebahAvamelCreateArgs>(args: SelectSubset<T, EshtebahAvamelCreateArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EshtebahAvamels.
     * @param {EshtebahAvamelCreateManyArgs} args - Arguments to create many EshtebahAvamels.
     * @example
     * // Create many EshtebahAvamels
     * const eshtebahAvamel = await prisma.eshtebahAvamel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EshtebahAvamelCreateManyArgs>(args?: SelectSubset<T, EshtebahAvamelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EshtebahAvamel.
     * @param {EshtebahAvamelDeleteArgs} args - Arguments to delete one EshtebahAvamel.
     * @example
     * // Delete one EshtebahAvamel
     * const EshtebahAvamel = await prisma.eshtebahAvamel.delete({
     *   where: {
     *     // ... filter to delete one EshtebahAvamel
     *   }
     * })
     * 
     */
    delete<T extends EshtebahAvamelDeleteArgs>(args: SelectSubset<T, EshtebahAvamelDeleteArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EshtebahAvamel.
     * @param {EshtebahAvamelUpdateArgs} args - Arguments to update one EshtebahAvamel.
     * @example
     * // Update one EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EshtebahAvamelUpdateArgs>(args: SelectSubset<T, EshtebahAvamelUpdateArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EshtebahAvamels.
     * @param {EshtebahAvamelDeleteManyArgs} args - Arguments to filter EshtebahAvamels to delete.
     * @example
     * // Delete a few EshtebahAvamels
     * const { count } = await prisma.eshtebahAvamel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EshtebahAvamelDeleteManyArgs>(args?: SelectSubset<T, EshtebahAvamelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EshtebahAvamels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EshtebahAvamels
     * const eshtebahAvamel = await prisma.eshtebahAvamel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EshtebahAvamelUpdateManyArgs>(args: SelectSubset<T, EshtebahAvamelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EshtebahAvamel.
     * @param {EshtebahAvamelUpsertArgs} args - Arguments to update or create a EshtebahAvamel.
     * @example
     * // Update or create a EshtebahAvamel
     * const eshtebahAvamel = await prisma.eshtebahAvamel.upsert({
     *   create: {
     *     // ... data to create a EshtebahAvamel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EshtebahAvamel we want to update
     *   }
     * })
     */
    upsert<T extends EshtebahAvamelUpsertArgs>(args: SelectSubset<T, EshtebahAvamelUpsertArgs<ExtArgs>>): Prisma__EshtebahAvamelClient<$Result.GetResult<Prisma.$EshtebahAvamelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EshtebahAvamels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelCountArgs} args - Arguments to filter EshtebahAvamels to count.
     * @example
     * // Count the number of EshtebahAvamels
     * const count = await prisma.eshtebahAvamel.count({
     *   where: {
     *     // ... the filter for the EshtebahAvamels we want to count
     *   }
     * })
    **/
    count<T extends EshtebahAvamelCountArgs>(
      args?: Subset<T, EshtebahAvamelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EshtebahAvamelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EshtebahAvamel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EshtebahAvamelAggregateArgs>(args: Subset<T, EshtebahAvamelAggregateArgs>): Prisma.PrismaPromise<GetEshtebahAvamelAggregateType<T>>

    /**
     * Group by EshtebahAvamel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EshtebahAvamelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EshtebahAvamelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EshtebahAvamelGroupByArgs['orderBy'] }
        : { orderBy?: EshtebahAvamelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EshtebahAvamelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEshtebahAvamelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EshtebahAvamel model
   */
  readonly fields: EshtebahAvamelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EshtebahAvamel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EshtebahAvamelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EshtebahAvamel model
   */ 
  interface EshtebahAvamelFieldRefs {
    readonly IdEsht: FieldRef<"EshtebahAvamel", 'Int'>
    readonly FIdRanesh: FieldRef<"EshtebahAvamel", 'Int'>
    readonly FIdTarDor: FieldRef<"EshtebahAvamel", 'Int'>
    readonly Eshtebah: FieldRef<"EshtebahAvamel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EshtebahAvamel findUnique
   */
  export type EshtebahAvamelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel findUniqueOrThrow
   */
  export type EshtebahAvamelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel findFirst
   */
  export type EshtebahAvamelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EshtebahAvamels.
     */
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel findFirstOrThrow
   */
  export type EshtebahAvamelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamel to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EshtebahAvamels.
     */
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel findMany
   */
  export type EshtebahAvamelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter, which EshtebahAvamels to fetch.
     */
    where?: EshtebahAvamelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EshtebahAvamels to fetch.
     */
    orderBy?: EshtebahAvamelOrderByWithRelationInput | EshtebahAvamelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EshtebahAvamels.
     */
    cursor?: EshtebahAvamelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EshtebahAvamels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EshtebahAvamels.
     */
    skip?: number
    distinct?: EshtebahAvamelScalarFieldEnum | EshtebahAvamelScalarFieldEnum[]
  }

  /**
   * EshtebahAvamel create
   */
  export type EshtebahAvamelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * The data needed to create a EshtebahAvamel.
     */
    data: XOR<EshtebahAvamelCreateInput, EshtebahAvamelUncheckedCreateInput>
  }

  /**
   * EshtebahAvamel createMany
   */
  export type EshtebahAvamelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EshtebahAvamels.
     */
    data: EshtebahAvamelCreateManyInput | EshtebahAvamelCreateManyInput[]
  }

  /**
   * EshtebahAvamel update
   */
  export type EshtebahAvamelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * The data needed to update a EshtebahAvamel.
     */
    data: XOR<EshtebahAvamelUpdateInput, EshtebahAvamelUncheckedUpdateInput>
    /**
     * Choose, which EshtebahAvamel to update.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel updateMany
   */
  export type EshtebahAvamelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EshtebahAvamels.
     */
    data: XOR<EshtebahAvamelUpdateManyMutationInput, EshtebahAvamelUncheckedUpdateManyInput>
    /**
     * Filter which EshtebahAvamels to update
     */
    where?: EshtebahAvamelWhereInput
    /**
     * Limit how many EshtebahAvamels to update.
     */
    limit?: number
  }

  /**
   * EshtebahAvamel upsert
   */
  export type EshtebahAvamelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * The filter to search for the EshtebahAvamel to update in case it exists.
     */
    where: EshtebahAvamelWhereUniqueInput
    /**
     * In case the EshtebahAvamel found by the `where` argument doesn't exist, create a new EshtebahAvamel with this data.
     */
    create: XOR<EshtebahAvamelCreateInput, EshtebahAvamelUncheckedCreateInput>
    /**
     * In case the EshtebahAvamel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EshtebahAvamelUpdateInput, EshtebahAvamelUncheckedUpdateInput>
  }

  /**
   * EshtebahAvamel delete
   */
  export type EshtebahAvamelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
    /**
     * Filter which EshtebahAvamel to delete.
     */
    where: EshtebahAvamelWhereUniqueInput
  }

  /**
   * EshtebahAvamel deleteMany
   */
  export type EshtebahAvamelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EshtebahAvamels to delete
     */
    where?: EshtebahAvamelWhereInput
    /**
     * Limit how many EshtebahAvamels to delete.
     */
    limit?: number
  }

  /**
   * EshtebahAvamel without action
   */
  export type EshtebahAvamelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EshtebahAvamel
     */
    select?: EshtebahAvamelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EshtebahAvamel
     */
    omit?: EshtebahAvamelOmit<ExtArgs> | null
  }


  /**
   * Model FlowBehbood
   */

  export type AggregateFlowBehbood = {
    _count: FlowBehboodCountAggregateOutputType | null
    _avg: FlowBehboodAvgAggregateOutputType | null
    _sum: FlowBehboodSumAggregateOutputType | null
    _min: FlowBehboodMinAggregateOutputType | null
    _max: FlowBehboodMaxAggregateOutputType | null
  }

  export type FlowBehboodAvgAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodSumAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodMinAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodMaxAggregateOutputType = {
    IdBehbood: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Flow: number | null
  }

  export type FlowBehboodCountAggregateOutputType = {
    IdBehbood: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
    _all: number
  }


  export type FlowBehboodAvgAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodSumAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodMinAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodMaxAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
  }

  export type FlowBehboodCountAggregateInputType = {
    IdBehbood?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Flow?: true
    _all?: true
  }

  export type FlowBehboodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowBehbood to aggregate.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowBehboods
    **/
    _count?: true | FlowBehboodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowBehboodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowBehboodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowBehboodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowBehboodMaxAggregateInputType
  }

  export type GetFlowBehboodAggregateType<T extends FlowBehboodAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowBehbood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowBehbood[P]>
      : GetScalarType<T[P], AggregateFlowBehbood[P]>
  }




  export type FlowBehboodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowBehboodWhereInput
    orderBy?: FlowBehboodOrderByWithAggregationInput | FlowBehboodOrderByWithAggregationInput[]
    by: FlowBehboodScalarFieldEnum[] | FlowBehboodScalarFieldEnum
    having?: FlowBehboodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowBehboodCountAggregateInputType | true
    _avg?: FlowBehboodAvgAggregateInputType
    _sum?: FlowBehboodSumAggregateInputType
    _min?: FlowBehboodMinAggregateInputType
    _max?: FlowBehboodMaxAggregateInputType
  }

  export type FlowBehboodGroupByOutputType = {
    IdBehbood: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
    _count: FlowBehboodCountAggregateOutputType | null
    _avg: FlowBehboodAvgAggregateOutputType | null
    _sum: FlowBehboodSumAggregateOutputType | null
    _min: FlowBehboodMinAggregateOutputType | null
    _max: FlowBehboodMaxAggregateOutputType | null
  }

  type GetFlowBehboodGroupByPayload<T extends FlowBehboodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowBehboodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowBehboodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowBehboodGroupByOutputType[P]>
            : GetScalarType<T[P], FlowBehboodGroupByOutputType[P]>
        }
      >
    >


  export type FlowBehboodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdBehbood?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Flow?: boolean
  }, ExtArgs["result"]["flowBehbood"]>



  export type FlowBehboodSelectScalar = {
    IdBehbood?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Flow?: boolean
  }

  export type FlowBehboodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdBehbood" | "FIdRanesh" | "FIdTarDor" | "Flow", ExtArgs["result"]["flowBehbood"]>

  export type $FlowBehboodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowBehbood"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdBehbood: number
      FIdRanesh: number
      FIdTarDor: number
      Flow: number
    }, ExtArgs["result"]["flowBehbood"]>
    composites: {}
  }

  type FlowBehboodGetPayload<S extends boolean | null | undefined | FlowBehboodDefaultArgs> = $Result.GetResult<Prisma.$FlowBehboodPayload, S>

  type FlowBehboodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowBehboodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowBehboodCountAggregateInputType | true
    }

  export interface FlowBehboodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowBehbood'], meta: { name: 'FlowBehbood' } }
    /**
     * Find zero or one FlowBehbood that matches the filter.
     * @param {FlowBehboodFindUniqueArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowBehboodFindUniqueArgs>(args: SelectSubset<T, FlowBehboodFindUniqueArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FlowBehbood that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowBehboodFindUniqueOrThrowArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowBehboodFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowBehboodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FlowBehbood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindFirstArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowBehboodFindFirstArgs>(args?: SelectSubset<T, FlowBehboodFindFirstArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FlowBehbood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindFirstOrThrowArgs} args - Arguments to find a FlowBehbood
     * @example
     * // Get one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowBehboodFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowBehboodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FlowBehboods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowBehboods
     * const flowBehboods = await prisma.flowBehbood.findMany()
     * 
     * // Get first 10 FlowBehboods
     * const flowBehboods = await prisma.flowBehbood.findMany({ take: 10 })
     * 
     * // Only select the `IdBehbood`
     * const flowBehboodWithIdBehboodOnly = await prisma.flowBehbood.findMany({ select: { IdBehbood: true } })
     * 
     */
    findMany<T extends FlowBehboodFindManyArgs>(args?: SelectSubset<T, FlowBehboodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FlowBehbood.
     * @param {FlowBehboodCreateArgs} args - Arguments to create a FlowBehbood.
     * @example
     * // Create one FlowBehbood
     * const FlowBehbood = await prisma.flowBehbood.create({
     *   data: {
     *     // ... data to create a FlowBehbood
     *   }
     * })
     * 
     */
    create<T extends FlowBehboodCreateArgs>(args: SelectSubset<T, FlowBehboodCreateArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FlowBehboods.
     * @param {FlowBehboodCreateManyArgs} args - Arguments to create many FlowBehboods.
     * @example
     * // Create many FlowBehboods
     * const flowBehbood = await prisma.flowBehbood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowBehboodCreateManyArgs>(args?: SelectSubset<T, FlowBehboodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FlowBehbood.
     * @param {FlowBehboodDeleteArgs} args - Arguments to delete one FlowBehbood.
     * @example
     * // Delete one FlowBehbood
     * const FlowBehbood = await prisma.flowBehbood.delete({
     *   where: {
     *     // ... filter to delete one FlowBehbood
     *   }
     * })
     * 
     */
    delete<T extends FlowBehboodDeleteArgs>(args: SelectSubset<T, FlowBehboodDeleteArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FlowBehbood.
     * @param {FlowBehboodUpdateArgs} args - Arguments to update one FlowBehbood.
     * @example
     * // Update one FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowBehboodUpdateArgs>(args: SelectSubset<T, FlowBehboodUpdateArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FlowBehboods.
     * @param {FlowBehboodDeleteManyArgs} args - Arguments to filter FlowBehboods to delete.
     * @example
     * // Delete a few FlowBehboods
     * const { count } = await prisma.flowBehbood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowBehboodDeleteManyArgs>(args?: SelectSubset<T, FlowBehboodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowBehboods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowBehboods
     * const flowBehbood = await prisma.flowBehbood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowBehboodUpdateManyArgs>(args: SelectSubset<T, FlowBehboodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlowBehbood.
     * @param {FlowBehboodUpsertArgs} args - Arguments to update or create a FlowBehbood.
     * @example
     * // Update or create a FlowBehbood
     * const flowBehbood = await prisma.flowBehbood.upsert({
     *   create: {
     *     // ... data to create a FlowBehbood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowBehbood we want to update
     *   }
     * })
     */
    upsert<T extends FlowBehboodUpsertArgs>(args: SelectSubset<T, FlowBehboodUpsertArgs<ExtArgs>>): Prisma__FlowBehboodClient<$Result.GetResult<Prisma.$FlowBehboodPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FlowBehboods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodCountArgs} args - Arguments to filter FlowBehboods to count.
     * @example
     * // Count the number of FlowBehboods
     * const count = await prisma.flowBehbood.count({
     *   where: {
     *     // ... the filter for the FlowBehboods we want to count
     *   }
     * })
    **/
    count<T extends FlowBehboodCountArgs>(
      args?: Subset<T, FlowBehboodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowBehboodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowBehbood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowBehboodAggregateArgs>(args: Subset<T, FlowBehboodAggregateArgs>): Prisma.PrismaPromise<GetFlowBehboodAggregateType<T>>

    /**
     * Group by FlowBehbood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowBehboodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowBehboodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowBehboodGroupByArgs['orderBy'] }
        : { orderBy?: FlowBehboodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowBehboodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowBehboodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowBehbood model
   */
  readonly fields: FlowBehboodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowBehbood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowBehboodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowBehbood model
   */ 
  interface FlowBehboodFieldRefs {
    readonly IdBehbood: FieldRef<"FlowBehbood", 'Int'>
    readonly FIdRanesh: FieldRef<"FlowBehbood", 'Int'>
    readonly FIdTarDor: FieldRef<"FlowBehbood", 'Int'>
    readonly Flow: FieldRef<"FlowBehbood", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FlowBehbood findUnique
   */
  export type FlowBehboodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood findUniqueOrThrow
   */
  export type FlowBehboodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood findFirst
   */
  export type FlowBehboodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowBehboods.
     */
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood findFirstOrThrow
   */
  export type FlowBehboodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter, which FlowBehbood to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowBehboods.
     */
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood findMany
   */
  export type FlowBehboodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter, which FlowBehboods to fetch.
     */
    where?: FlowBehboodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowBehboods to fetch.
     */
    orderBy?: FlowBehboodOrderByWithRelationInput | FlowBehboodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowBehboods.
     */
    cursor?: FlowBehboodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowBehboods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowBehboods.
     */
    skip?: number
    distinct?: FlowBehboodScalarFieldEnum | FlowBehboodScalarFieldEnum[]
  }

  /**
   * FlowBehbood create
   */
  export type FlowBehboodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * The data needed to create a FlowBehbood.
     */
    data: XOR<FlowBehboodCreateInput, FlowBehboodUncheckedCreateInput>
  }

  /**
   * FlowBehbood createMany
   */
  export type FlowBehboodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowBehboods.
     */
    data: FlowBehboodCreateManyInput | FlowBehboodCreateManyInput[]
  }

  /**
   * FlowBehbood update
   */
  export type FlowBehboodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * The data needed to update a FlowBehbood.
     */
    data: XOR<FlowBehboodUpdateInput, FlowBehboodUncheckedUpdateInput>
    /**
     * Choose, which FlowBehbood to update.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood updateMany
   */
  export type FlowBehboodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowBehboods.
     */
    data: XOR<FlowBehboodUpdateManyMutationInput, FlowBehboodUncheckedUpdateManyInput>
    /**
     * Filter which FlowBehboods to update
     */
    where?: FlowBehboodWhereInput
    /**
     * Limit how many FlowBehboods to update.
     */
    limit?: number
  }

  /**
   * FlowBehbood upsert
   */
  export type FlowBehboodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * The filter to search for the FlowBehbood to update in case it exists.
     */
    where: FlowBehboodWhereUniqueInput
    /**
     * In case the FlowBehbood found by the `where` argument doesn't exist, create a new FlowBehbood with this data.
     */
    create: XOR<FlowBehboodCreateInput, FlowBehboodUncheckedCreateInput>
    /**
     * In case the FlowBehbood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowBehboodUpdateInput, FlowBehboodUncheckedUpdateInput>
  }

  /**
   * FlowBehbood delete
   */
  export type FlowBehboodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
    /**
     * Filter which FlowBehbood to delete.
     */
    where: FlowBehboodWhereUniqueInput
  }

  /**
   * FlowBehbood deleteMany
   */
  export type FlowBehboodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowBehboods to delete
     */
    where?: FlowBehboodWhereInput
    /**
     * Limit how many FlowBehboods to delete.
     */
    limit?: number
  }

  /**
   * FlowBehbood without action
   */
  export type FlowBehboodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowBehbood
     */
    select?: FlowBehboodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowBehbood
     */
    omit?: FlowBehboodOmit<ExtArgs> | null
  }


  /**
   * Model Flowmeter
   */

  export type AggregateFlowmeter = {
    _count: FlowmeterCountAggregateOutputType | null
    _avg: FlowmeterAvgAggregateOutputType | null
    _sum: FlowmeterSumAggregateOutputType | null
    _min: FlowmeterMinAggregateOutputType | null
    _max: FlowmeterMaxAggregateOutputType | null
  }

  export type FlowmeterAvgAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterSumAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterMinAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterMaxAggregateOutputType = {
    IdFIT: number | null
    FIdRanesh: number | null
    FIdTrikh: number | null
    Flowmeter: number | null
  }

  export type FlowmeterCountAggregateOutputType = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
    _all: number
  }


  export type FlowmeterAvgAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterSumAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterMinAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterMaxAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
  }

  export type FlowmeterCountAggregateInputType = {
    IdFIT?: true
    FIdRanesh?: true
    FIdTrikh?: true
    Flowmeter?: true
    _all?: true
  }

  export type FlowmeterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowmeter to aggregate.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flowmeters
    **/
    _count?: true | FlowmeterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowmeterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowmeterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowmeterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowmeterMaxAggregateInputType
  }

  export type GetFlowmeterAggregateType<T extends FlowmeterAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowmeter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowmeter[P]>
      : GetScalarType<T[P], AggregateFlowmeter[P]>
  }




  export type FlowmeterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowmeterWhereInput
    orderBy?: FlowmeterOrderByWithAggregationInput | FlowmeterOrderByWithAggregationInput[]
    by: FlowmeterScalarFieldEnum[] | FlowmeterScalarFieldEnum
    having?: FlowmeterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowmeterCountAggregateInputType | true
    _avg?: FlowmeterAvgAggregateInputType
    _sum?: FlowmeterSumAggregateInputType
    _min?: FlowmeterMinAggregateInputType
    _max?: FlowmeterMaxAggregateInputType
  }

  export type FlowmeterGroupByOutputType = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
    _count: FlowmeterCountAggregateOutputType | null
    _avg: FlowmeterAvgAggregateOutputType | null
    _sum: FlowmeterSumAggregateOutputType | null
    _min: FlowmeterMinAggregateOutputType | null
    _max: FlowmeterMaxAggregateOutputType | null
  }

  type GetFlowmeterGroupByPayload<T extends FlowmeterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowmeterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowmeterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowmeterGroupByOutputType[P]>
            : GetScalarType<T[P], FlowmeterGroupByOutputType[P]>
        }
      >
    >


  export type FlowmeterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdFIT?: boolean
    FIdRanesh?: boolean
    FIdTrikh?: boolean
    Flowmeter?: boolean
  }, ExtArgs["result"]["flowmeter"]>



  export type FlowmeterSelectScalar = {
    IdFIT?: boolean
    FIdRanesh?: boolean
    FIdTrikh?: boolean
    Flowmeter?: boolean
  }

  export type FlowmeterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdFIT" | "FIdRanesh" | "FIdTrikh" | "Flowmeter", ExtArgs["result"]["flowmeter"]>

  export type $FlowmeterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flowmeter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdFIT: number
      FIdRanesh: number
      FIdTrikh: number
      Flowmeter: number
    }, ExtArgs["result"]["flowmeter"]>
    composites: {}
  }

  type FlowmeterGetPayload<S extends boolean | null | undefined | FlowmeterDefaultArgs> = $Result.GetResult<Prisma.$FlowmeterPayload, S>

  type FlowmeterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowmeterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowmeterCountAggregateInputType | true
    }

  export interface FlowmeterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flowmeter'], meta: { name: 'Flowmeter' } }
    /**
     * Find zero or one Flowmeter that matches the filter.
     * @param {FlowmeterFindUniqueArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowmeterFindUniqueArgs>(args: SelectSubset<T, FlowmeterFindUniqueArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Flowmeter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowmeterFindUniqueOrThrowArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowmeterFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowmeterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Flowmeter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindFirstArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowmeterFindFirstArgs>(args?: SelectSubset<T, FlowmeterFindFirstArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Flowmeter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindFirstOrThrowArgs} args - Arguments to find a Flowmeter
     * @example
     * // Get one Flowmeter
     * const flowmeter = await prisma.flowmeter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowmeterFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowmeterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Flowmeters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flowmeters
     * const flowmeters = await prisma.flowmeter.findMany()
     * 
     * // Get first 10 Flowmeters
     * const flowmeters = await prisma.flowmeter.findMany({ take: 10 })
     * 
     * // Only select the `IdFIT`
     * const flowmeterWithIdFITOnly = await prisma.flowmeter.findMany({ select: { IdFIT: true } })
     * 
     */
    findMany<T extends FlowmeterFindManyArgs>(args?: SelectSubset<T, FlowmeterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Flowmeter.
     * @param {FlowmeterCreateArgs} args - Arguments to create a Flowmeter.
     * @example
     * // Create one Flowmeter
     * const Flowmeter = await prisma.flowmeter.create({
     *   data: {
     *     // ... data to create a Flowmeter
     *   }
     * })
     * 
     */
    create<T extends FlowmeterCreateArgs>(args: SelectSubset<T, FlowmeterCreateArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Flowmeters.
     * @param {FlowmeterCreateManyArgs} args - Arguments to create many Flowmeters.
     * @example
     * // Create many Flowmeters
     * const flowmeter = await prisma.flowmeter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowmeterCreateManyArgs>(args?: SelectSubset<T, FlowmeterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flowmeter.
     * @param {FlowmeterDeleteArgs} args - Arguments to delete one Flowmeter.
     * @example
     * // Delete one Flowmeter
     * const Flowmeter = await prisma.flowmeter.delete({
     *   where: {
     *     // ... filter to delete one Flowmeter
     *   }
     * })
     * 
     */
    delete<T extends FlowmeterDeleteArgs>(args: SelectSubset<T, FlowmeterDeleteArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Flowmeter.
     * @param {FlowmeterUpdateArgs} args - Arguments to update one Flowmeter.
     * @example
     * // Update one Flowmeter
     * const flowmeter = await prisma.flowmeter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowmeterUpdateArgs>(args: SelectSubset<T, FlowmeterUpdateArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Flowmeters.
     * @param {FlowmeterDeleteManyArgs} args - Arguments to filter Flowmeters to delete.
     * @example
     * // Delete a few Flowmeters
     * const { count } = await prisma.flowmeter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowmeterDeleteManyArgs>(args?: SelectSubset<T, FlowmeterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flowmeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flowmeters
     * const flowmeter = await prisma.flowmeter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowmeterUpdateManyArgs>(args: SelectSubset<T, FlowmeterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flowmeter.
     * @param {FlowmeterUpsertArgs} args - Arguments to update or create a Flowmeter.
     * @example
     * // Update or create a Flowmeter
     * const flowmeter = await prisma.flowmeter.upsert({
     *   create: {
     *     // ... data to create a Flowmeter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flowmeter we want to update
     *   }
     * })
     */
    upsert<T extends FlowmeterUpsertArgs>(args: SelectSubset<T, FlowmeterUpsertArgs<ExtArgs>>): Prisma__FlowmeterClient<$Result.GetResult<Prisma.$FlowmeterPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Flowmeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterCountArgs} args - Arguments to filter Flowmeters to count.
     * @example
     * // Count the number of Flowmeters
     * const count = await prisma.flowmeter.count({
     *   where: {
     *     // ... the filter for the Flowmeters we want to count
     *   }
     * })
    **/
    count<T extends FlowmeterCountArgs>(
      args?: Subset<T, FlowmeterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowmeterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flowmeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowmeterAggregateArgs>(args: Subset<T, FlowmeterAggregateArgs>): Prisma.PrismaPromise<GetFlowmeterAggregateType<T>>

    /**
     * Group by Flowmeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowmeterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowmeterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowmeterGroupByArgs['orderBy'] }
        : { orderBy?: FlowmeterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowmeterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowmeterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flowmeter model
   */
  readonly fields: FlowmeterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flowmeter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowmeterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flowmeter model
   */ 
  interface FlowmeterFieldRefs {
    readonly IdFIT: FieldRef<"Flowmeter", 'Int'>
    readonly FIdRanesh: FieldRef<"Flowmeter", 'Int'>
    readonly FIdTrikh: FieldRef<"Flowmeter", 'Int'>
    readonly Flowmeter: FieldRef<"Flowmeter", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Flowmeter findUnique
   */
  export type FlowmeterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter findUniqueOrThrow
   */
  export type FlowmeterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter findFirst
   */
  export type FlowmeterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowmeters.
     */
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter findFirstOrThrow
   */
  export type FlowmeterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter, which Flowmeter to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowmeters.
     */
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter findMany
   */
  export type FlowmeterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter, which Flowmeters to fetch.
     */
    where?: FlowmeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowmeters to fetch.
     */
    orderBy?: FlowmeterOrderByWithRelationInput | FlowmeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flowmeters.
     */
    cursor?: FlowmeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowmeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowmeters.
     */
    skip?: number
    distinct?: FlowmeterScalarFieldEnum | FlowmeterScalarFieldEnum[]
  }

  /**
   * Flowmeter create
   */
  export type FlowmeterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * The data needed to create a Flowmeter.
     */
    data: XOR<FlowmeterCreateInput, FlowmeterUncheckedCreateInput>
  }

  /**
   * Flowmeter createMany
   */
  export type FlowmeterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flowmeters.
     */
    data: FlowmeterCreateManyInput | FlowmeterCreateManyInput[]
  }

  /**
   * Flowmeter update
   */
  export type FlowmeterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * The data needed to update a Flowmeter.
     */
    data: XOR<FlowmeterUpdateInput, FlowmeterUncheckedUpdateInput>
    /**
     * Choose, which Flowmeter to update.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter updateMany
   */
  export type FlowmeterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flowmeters.
     */
    data: XOR<FlowmeterUpdateManyMutationInput, FlowmeterUncheckedUpdateManyInput>
    /**
     * Filter which Flowmeters to update
     */
    where?: FlowmeterWhereInput
    /**
     * Limit how many Flowmeters to update.
     */
    limit?: number
  }

  /**
   * Flowmeter upsert
   */
  export type FlowmeterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * The filter to search for the Flowmeter to update in case it exists.
     */
    where: FlowmeterWhereUniqueInput
    /**
     * In case the Flowmeter found by the `where` argument doesn't exist, create a new Flowmeter with this data.
     */
    create: XOR<FlowmeterCreateInput, FlowmeterUncheckedCreateInput>
    /**
     * In case the Flowmeter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowmeterUpdateInput, FlowmeterUncheckedUpdateInput>
  }

  /**
   * Flowmeter delete
   */
  export type FlowmeterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
    /**
     * Filter which Flowmeter to delete.
     */
    where: FlowmeterWhereUniqueInput
  }

  /**
   * Flowmeter deleteMany
   */
  export type FlowmeterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowmeters to delete
     */
    where?: FlowmeterWhereInput
    /**
     * Limit how many Flowmeters to delete.
     */
    limit?: number
  }

  /**
   * Flowmeter without action
   */
  export type FlowmeterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowmeter
     */
    select?: FlowmeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowmeter
     */
    omit?: FlowmeterOmit<ExtArgs> | null
  }


  /**
   * Model KhatRanesh
   */

  export type AggregateKhatRanesh = {
    _count: KhatRaneshCountAggregateOutputType | null
    _avg: KhatRaneshAvgAggregateOutputType | null
    _sum: KhatRaneshSumAggregateOutputType | null
    _min: KhatRaneshMinAggregateOutputType | null
    _max: KhatRaneshMaxAggregateOutputType | null
  }

  export type KhatRaneshAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshSumAggregateOutputType = {
    IdRanesh: number | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshMinAggregateOutputType = {
    IdRanesh: number | null
    RaneshName: string | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshMaxAggregateOutputType = {
    IdRanesh: number | null
    RaneshName: string | null
    FIdPumpSta: number | null
    FIdDPipe: number | null
    FIdSePu: number | null
    FIdMeasuring: number | null
  }

  export type KhatRaneshCountAggregateOutputType = {
    IdRanesh: number
    RaneshName: number
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    _all: number
  }


  export type KhatRaneshAvgAggregateInputType = {
    IdRanesh?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshSumAggregateInputType = {
    IdRanesh?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshMinAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshMaxAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
  }

  export type KhatRaneshCountAggregateInputType = {
    IdRanesh?: true
    RaneshName?: true
    FIdPumpSta?: true
    FIdDPipe?: true
    FIdSePu?: true
    FIdMeasuring?: true
    _all?: true
  }

  export type KhatRaneshAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRanesh to aggregate.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshes
    **/
    _count?: true | KhatRaneshCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshMaxAggregateInputType
  }

  export type GetKhatRaneshAggregateType<T extends KhatRaneshAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRanesh]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRanesh[P]>
      : GetScalarType<T[P], AggregateKhatRanesh[P]>
  }




  export type KhatRaneshGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshWhereInput
    orderBy?: KhatRaneshOrderByWithAggregationInput | KhatRaneshOrderByWithAggregationInput[]
    by: KhatRaneshScalarFieldEnum[] | KhatRaneshScalarFieldEnum
    having?: KhatRaneshScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshCountAggregateInputType | true
    _avg?: KhatRaneshAvgAggregateInputType
    _sum?: KhatRaneshSumAggregateInputType
    _min?: KhatRaneshMinAggregateInputType
    _max?: KhatRaneshMaxAggregateInputType
  }

  export type KhatRaneshGroupByOutputType = {
    IdRanesh: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
    _count: KhatRaneshCountAggregateOutputType | null
    _avg: KhatRaneshAvgAggregateOutputType | null
    _sum: KhatRaneshSumAggregateOutputType | null
    _min: KhatRaneshMinAggregateOutputType | null
    _max: KhatRaneshMaxAggregateOutputType | null
  }

  type GetKhatRaneshGroupByPayload<T extends KhatRaneshGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    RaneshName?: boolean
    FIdPumpSta?: boolean
    FIdDPipe?: boolean
    FIdSePu?: boolean
    FIdMeasuring?: boolean
  }, ExtArgs["result"]["khatRanesh"]>



  export type KhatRaneshSelectScalar = {
    IdRanesh?: boolean
    RaneshName?: boolean
    FIdPumpSta?: boolean
    FIdDPipe?: boolean
    FIdSePu?: boolean
    FIdMeasuring?: boolean
  }

  export type KhatRaneshOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "RaneshName" | "FIdPumpSta" | "FIdDPipe" | "FIdSePu" | "FIdMeasuring", ExtArgs["result"]["khatRanesh"]>

  export type $KhatRaneshPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRanesh"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      RaneshName: string
      FIdPumpSta: number
      FIdDPipe: number
      FIdSePu: number
      FIdMeasuring: number
    }, ExtArgs["result"]["khatRanesh"]>
    composites: {}
  }

  type KhatRaneshGetPayload<S extends boolean | null | undefined | KhatRaneshDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshPayload, S>

  type KhatRaneshCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshCountAggregateInputType | true
    }

  export interface KhatRaneshDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRanesh'], meta: { name: 'KhatRanesh' } }
    /**
     * Find zero or one KhatRanesh that matches the filter.
     * @param {KhatRaneshFindUniqueArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshFindUniqueArgs>(args: SelectSubset<T, KhatRaneshFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRanesh that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshFindUniqueOrThrowArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRanesh that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindFirstArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshFindFirstArgs>(args?: SelectSubset<T, KhatRaneshFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRanesh that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindFirstOrThrowArgs} args - Arguments to find a KhatRanesh
     * @example
     * // Get one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshes
     * const khatRaneshes = await prisma.khatRanesh.findMany()
     * 
     * // Get first 10 KhatRaneshes
     * const khatRaneshes = await prisma.khatRanesh.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshWithIdRaneshOnly = await prisma.khatRanesh.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshFindManyArgs>(args?: SelectSubset<T, KhatRaneshFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRanesh.
     * @param {KhatRaneshCreateArgs} args - Arguments to create a KhatRanesh.
     * @example
     * // Create one KhatRanesh
     * const KhatRanesh = await prisma.khatRanesh.create({
     *   data: {
     *     // ... data to create a KhatRanesh
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshCreateArgs>(args: SelectSubset<T, KhatRaneshCreateArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshes.
     * @param {KhatRaneshCreateManyArgs} args - Arguments to create many KhatRaneshes.
     * @example
     * // Create many KhatRaneshes
     * const khatRanesh = await prisma.khatRanesh.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshCreateManyArgs>(args?: SelectSubset<T, KhatRaneshCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRanesh.
     * @param {KhatRaneshDeleteArgs} args - Arguments to delete one KhatRanesh.
     * @example
     * // Delete one KhatRanesh
     * const KhatRanesh = await prisma.khatRanesh.delete({
     *   where: {
     *     // ... filter to delete one KhatRanesh
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshDeleteArgs>(args: SelectSubset<T, KhatRaneshDeleteArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRanesh.
     * @param {KhatRaneshUpdateArgs} args - Arguments to update one KhatRanesh.
     * @example
     * // Update one KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshUpdateArgs>(args: SelectSubset<T, KhatRaneshUpdateArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshes.
     * @param {KhatRaneshDeleteManyArgs} args - Arguments to filter KhatRaneshes to delete.
     * @example
     * // Delete a few KhatRaneshes
     * const { count } = await prisma.khatRanesh.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshes
     * const khatRanesh = await prisma.khatRanesh.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshUpdateManyArgs>(args: SelectSubset<T, KhatRaneshUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRanesh.
     * @param {KhatRaneshUpsertArgs} args - Arguments to update or create a KhatRanesh.
     * @example
     * // Update or create a KhatRanesh
     * const khatRanesh = await prisma.khatRanesh.upsert({
     *   create: {
     *     // ... data to create a KhatRanesh
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRanesh we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshUpsertArgs>(args: SelectSubset<T, KhatRaneshUpsertArgs<ExtArgs>>): Prisma__KhatRaneshClient<$Result.GetResult<Prisma.$KhatRaneshPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshCountArgs} args - Arguments to filter KhatRaneshes to count.
     * @example
     * // Count the number of KhatRaneshes
     * const count = await prisma.khatRanesh.count({
     *   where: {
     *     // ... the filter for the KhatRaneshes we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshCountArgs>(
      args?: Subset<T, KhatRaneshCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRanesh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshAggregateArgs>(args: Subset<T, KhatRaneshAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshAggregateType<T>>

    /**
     * Group by KhatRanesh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRanesh model
   */
  readonly fields: KhatRaneshFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRanesh.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRanesh model
   */ 
  interface KhatRaneshFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRanesh", 'Int'>
    readonly RaneshName: FieldRef<"KhatRanesh", 'String'>
    readonly FIdPumpSta: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdDPipe: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdSePu: FieldRef<"KhatRanesh", 'Int'>
    readonly FIdMeasuring: FieldRef<"KhatRanesh", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KhatRanesh findUnique
   */
  export type KhatRaneshFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh findUniqueOrThrow
   */
  export type KhatRaneshFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh findFirst
   */
  export type KhatRaneshFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshes.
     */
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh findFirstOrThrow
   */
  export type KhatRaneshFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter, which KhatRanesh to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshes.
     */
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh findMany
   */
  export type KhatRaneshFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshes to fetch.
     */
    where?: KhatRaneshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshes to fetch.
     */
    orderBy?: KhatRaneshOrderByWithRelationInput | KhatRaneshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshes.
     */
    cursor?: KhatRaneshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshes.
     */
    skip?: number
    distinct?: KhatRaneshScalarFieldEnum | KhatRaneshScalarFieldEnum[]
  }

  /**
   * KhatRanesh create
   */
  export type KhatRaneshCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * The data needed to create a KhatRanesh.
     */
    data: XOR<KhatRaneshCreateInput, KhatRaneshUncheckedCreateInput>
  }

  /**
   * KhatRanesh createMany
   */
  export type KhatRaneshCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshes.
     */
    data: KhatRaneshCreateManyInput | KhatRaneshCreateManyInput[]
  }

  /**
   * KhatRanesh update
   */
  export type KhatRaneshUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * The data needed to update a KhatRanesh.
     */
    data: XOR<KhatRaneshUpdateInput, KhatRaneshUncheckedUpdateInput>
    /**
     * Choose, which KhatRanesh to update.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh updateMany
   */
  export type KhatRaneshUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshes.
     */
    data: XOR<KhatRaneshUpdateManyMutationInput, KhatRaneshUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshes to update
     */
    where?: KhatRaneshWhereInput
    /**
     * Limit how many KhatRaneshes to update.
     */
    limit?: number
  }

  /**
   * KhatRanesh upsert
   */
  export type KhatRaneshUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * The filter to search for the KhatRanesh to update in case it exists.
     */
    where: KhatRaneshWhereUniqueInput
    /**
     * In case the KhatRanesh found by the `where` argument doesn't exist, create a new KhatRanesh with this data.
     */
    create: XOR<KhatRaneshCreateInput, KhatRaneshUncheckedCreateInput>
    /**
     * In case the KhatRanesh was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshUpdateInput, KhatRaneshUncheckedUpdateInput>
  }

  /**
   * KhatRanesh delete
   */
  export type KhatRaneshDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
    /**
     * Filter which KhatRanesh to delete.
     */
    where: KhatRaneshWhereUniqueInput
  }

  /**
   * KhatRanesh deleteMany
   */
  export type KhatRaneshDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshes to delete
     */
    where?: KhatRaneshWhereInput
    /**
     * Limit how many KhatRaneshes to delete.
     */
    limit?: number
  }

  /**
   * KhatRanesh without action
   */
  export type KhatRaneshDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRanesh
     */
    select?: KhatRaneshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRanesh
     */
    omit?: KhatRaneshOmit<ExtArgs> | null
  }


  /**
   * Model KhatRaneshArea
   */

  export type AggregateKhatRaneshArea = {
    _count: KhatRaneshAreaCountAggregateOutputType | null
    _avg: KhatRaneshAreaAvgAggregateOutputType | null
    _sum: KhatRaneshAreaSumAggregateOutputType | null
    _min: KhatRaneshAreaMinAggregateOutputType | null
    _max: KhatRaneshAreaMaxAggregateOutputType | null
  }

  export type KhatRaneshAreaAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdLand: number | null
    FIdNet: number | null
    Area: Decimal | null
  }

  export type KhatRaneshAreaCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: number
    _all: number
  }


  export type KhatRaneshAreaAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
  }

  export type KhatRaneshAreaCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdLand?: true
    FIdNet?: true
    Area?: true
    _all?: true
  }

  export type KhatRaneshAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshArea to aggregate.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshAreas
    **/
    _count?: true | KhatRaneshAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshAreaMaxAggregateInputType
  }

  export type GetKhatRaneshAreaAggregateType<T extends KhatRaneshAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshArea[P]>
      : GetScalarType<T[P], AggregateKhatRaneshArea[P]>
  }




  export type KhatRaneshAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshAreaWhereInput
    orderBy?: KhatRaneshAreaOrderByWithAggregationInput | KhatRaneshAreaOrderByWithAggregationInput[]
    by: KhatRaneshAreaScalarFieldEnum[] | KhatRaneshAreaScalarFieldEnum
    having?: KhatRaneshAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshAreaCountAggregateInputType | true
    _avg?: KhatRaneshAreaAvgAggregateInputType
    _sum?: KhatRaneshAreaSumAggregateInputType
    _min?: KhatRaneshAreaMinAggregateInputType
    _max?: KhatRaneshAreaMaxAggregateInputType
  }

  export type KhatRaneshAreaGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal
    _count: KhatRaneshAreaCountAggregateOutputType | null
    _avg: KhatRaneshAreaAvgAggregateOutputType | null
    _sum: KhatRaneshAreaSumAggregateOutputType | null
    _min: KhatRaneshAreaMinAggregateOutputType | null
    _max: KhatRaneshAreaMaxAggregateOutputType | null
  }

  type GetKhatRaneshAreaGroupByPayload<T extends KhatRaneshAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshAreaGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshAreaGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    FIdLand?: boolean
    FIdNet?: boolean
    Area?: boolean
  }, ExtArgs["result"]["khatRaneshArea"]>



  export type KhatRaneshAreaSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    FIdLand?: boolean
    FIdNet?: boolean
    Area?: boolean
  }

  export type KhatRaneshAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "FIdLand" | "FIdNet" | "Area", ExtArgs["result"]["khatRaneshArea"]>

  export type $KhatRaneshAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshArea"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      FIdLand: number
      FIdNet: number
      Area: Prisma.Decimal
    }, ExtArgs["result"]["khatRaneshArea"]>
    composites: {}
  }

  type KhatRaneshAreaGetPayload<S extends boolean | null | undefined | KhatRaneshAreaDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshAreaPayload, S>

  type KhatRaneshAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshAreaCountAggregateInputType | true
    }

  export interface KhatRaneshAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshArea'], meta: { name: 'KhatRaneshArea' } }
    /**
     * Find zero or one KhatRaneshArea that matches the filter.
     * @param {KhatRaneshAreaFindUniqueArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshAreaFindUniqueArgs>(args: SelectSubset<T, KhatRaneshAreaFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshAreaFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindFirstArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshAreaFindFirstArgs>(args?: SelectSubset<T, KhatRaneshAreaFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshArea
     * @example
     * // Get one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshAreas
     * const khatRaneshAreas = await prisma.khatRaneshArea.findMany()
     * 
     * // Get first 10 KhatRaneshAreas
     * const khatRaneshAreas = await prisma.khatRaneshArea.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshAreaWithIdRaneshOnly = await prisma.khatRaneshArea.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshAreaFindManyArgs>(args?: SelectSubset<T, KhatRaneshAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshArea.
     * @param {KhatRaneshAreaCreateArgs} args - Arguments to create a KhatRaneshArea.
     * @example
     * // Create one KhatRaneshArea
     * const KhatRaneshArea = await prisma.khatRaneshArea.create({
     *   data: {
     *     // ... data to create a KhatRaneshArea
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshAreaCreateArgs>(args: SelectSubset<T, KhatRaneshAreaCreateArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshAreas.
     * @param {KhatRaneshAreaCreateManyArgs} args - Arguments to create many KhatRaneshAreas.
     * @example
     * // Create many KhatRaneshAreas
     * const khatRaneshArea = await prisma.khatRaneshArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshAreaCreateManyArgs>(args?: SelectSubset<T, KhatRaneshAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshArea.
     * @param {KhatRaneshAreaDeleteArgs} args - Arguments to delete one KhatRaneshArea.
     * @example
     * // Delete one KhatRaneshArea
     * const KhatRaneshArea = await prisma.khatRaneshArea.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshArea
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshAreaDeleteArgs>(args: SelectSubset<T, KhatRaneshAreaDeleteArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshArea.
     * @param {KhatRaneshAreaUpdateArgs} args - Arguments to update one KhatRaneshArea.
     * @example
     * // Update one KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshAreaUpdateArgs>(args: SelectSubset<T, KhatRaneshAreaUpdateArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshAreas.
     * @param {KhatRaneshAreaDeleteManyArgs} args - Arguments to filter KhatRaneshAreas to delete.
     * @example
     * // Delete a few KhatRaneshAreas
     * const { count } = await prisma.khatRaneshArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshAreaDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshAreas
     * const khatRaneshArea = await prisma.khatRaneshArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshAreaUpdateManyArgs>(args: SelectSubset<T, KhatRaneshAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshArea.
     * @param {KhatRaneshAreaUpsertArgs} args - Arguments to update or create a KhatRaneshArea.
     * @example
     * // Update or create a KhatRaneshArea
     * const khatRaneshArea = await prisma.khatRaneshArea.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshArea we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshAreaUpsertArgs>(args: SelectSubset<T, KhatRaneshAreaUpsertArgs<ExtArgs>>): Prisma__KhatRaneshAreaClient<$Result.GetResult<Prisma.$KhatRaneshAreaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaCountArgs} args - Arguments to filter KhatRaneshAreas to count.
     * @example
     * // Count the number of KhatRaneshAreas
     * const count = await prisma.khatRaneshArea.count({
     *   where: {
     *     // ... the filter for the KhatRaneshAreas we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshAreaCountArgs>(
      args?: Subset<T, KhatRaneshAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshAreaAggregateArgs>(args: Subset<T, KhatRaneshAreaAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshAreaAggregateType<T>>

    /**
     * Group by KhatRaneshArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshAreaGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshArea model
   */
  readonly fields: KhatRaneshAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshArea model
   */ 
  interface KhatRaneshAreaFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdLand: FieldRef<"KhatRaneshArea", 'Int'>
    readonly FIdNet: FieldRef<"KhatRaneshArea", 'Int'>
    readonly Area: FieldRef<"KhatRaneshArea", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshArea findUnique
   */
  export type KhatRaneshAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea findUniqueOrThrow
   */
  export type KhatRaneshAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea findFirst
   */
  export type KhatRaneshAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshAreas.
     */
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea findFirstOrThrow
   */
  export type KhatRaneshAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshArea to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshAreas.
     */
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea findMany
   */
  export type KhatRaneshAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshAreas to fetch.
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshAreas to fetch.
     */
    orderBy?: KhatRaneshAreaOrderByWithRelationInput | KhatRaneshAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshAreas.
     */
    cursor?: KhatRaneshAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshAreas.
     */
    skip?: number
    distinct?: KhatRaneshAreaScalarFieldEnum | KhatRaneshAreaScalarFieldEnum[]
  }

  /**
   * KhatRaneshArea create
   */
  export type KhatRaneshAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshArea.
     */
    data: XOR<KhatRaneshAreaCreateInput, KhatRaneshAreaUncheckedCreateInput>
  }

  /**
   * KhatRaneshArea createMany
   */
  export type KhatRaneshAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshAreas.
     */
    data: KhatRaneshAreaCreateManyInput | KhatRaneshAreaCreateManyInput[]
  }

  /**
   * KhatRaneshArea update
   */
  export type KhatRaneshAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshArea.
     */
    data: XOR<KhatRaneshAreaUpdateInput, KhatRaneshAreaUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshArea to update.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea updateMany
   */
  export type KhatRaneshAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshAreas.
     */
    data: XOR<KhatRaneshAreaUpdateManyMutationInput, KhatRaneshAreaUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshAreas to update
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * Limit how many KhatRaneshAreas to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshArea upsert
   */
  export type KhatRaneshAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshArea to update in case it exists.
     */
    where: KhatRaneshAreaWhereUniqueInput
    /**
     * In case the KhatRaneshArea found by the `where` argument doesn't exist, create a new KhatRaneshArea with this data.
     */
    create: XOR<KhatRaneshAreaCreateInput, KhatRaneshAreaUncheckedCreateInput>
    /**
     * In case the KhatRaneshArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshAreaUpdateInput, KhatRaneshAreaUncheckedUpdateInput>
  }

  /**
   * KhatRaneshArea delete
   */
  export type KhatRaneshAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
    /**
     * Filter which KhatRaneshArea to delete.
     */
    where: KhatRaneshAreaWhereUniqueInput
  }

  /**
   * KhatRaneshArea deleteMany
   */
  export type KhatRaneshAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshAreas to delete
     */
    where?: KhatRaneshAreaWhereInput
    /**
     * Limit how many KhatRaneshAreas to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshArea without action
   */
  export type KhatRaneshAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshArea
     */
    select?: KhatRaneshAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshArea
     */
    omit?: KhatRaneshAreaOmit<ExtArgs> | null
  }


  /**
   * Model KhatRaneshPump
   */

  export type AggregateKhatRaneshPump = {
    _count: KhatRaneshPumpCountAggregateOutputType | null
    _avg: KhatRaneshPumpAvgAggregateOutputType | null
    _sum: KhatRaneshPumpSumAggregateOutputType | null
    _min: KhatRaneshPumpMinAggregateOutputType | null
    _max: KhatRaneshPumpMaxAggregateOutputType | null
  }

  export type KhatRaneshPumpAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    ModelPump: string | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    ModelPump: string | null
    FIdPump: number | null
    TedadPump: number | null
    DebiPomp: Decimal | null
    FesharPump: Decimal | null
    Randeman: number | null
    TavaneNami: Decimal | null
    TavaneJazbi: Decimal | null
    Voltazh: number | null
    DoreMotor: number | null
    FeshareMakesh: number | null
    FeshareRanesh: number | null
    SizeMakesh: number | null
    SizeRanesh: number | null
    SizeKolektor: number | null
    SizeShireKolektor: number | null
  }

  export type KhatRaneshPumpCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    ModelPump: number
    FIdPump: number
    TedadPump: number
    DebiPomp: number
    FesharPump: number
    Randeman: number
    TavaneNami: number
    TavaneJazbi: number
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    _all: number
  }


  export type KhatRaneshPumpAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
  }

  export type KhatRaneshPumpCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    ModelPump?: true
    FIdPump?: true
    TedadPump?: true
    DebiPomp?: true
    FesharPump?: true
    Randeman?: true
    TavaneNami?: true
    TavaneJazbi?: true
    Voltazh?: true
    DoreMotor?: true
    FeshareMakesh?: true
    FeshareRanesh?: true
    SizeMakesh?: true
    SizeRanesh?: true
    SizeKolektor?: true
    SizeShireKolektor?: true
    _all?: true
  }

  export type KhatRaneshPumpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshPump to aggregate.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshPumps
    **/
    _count?: true | KhatRaneshPumpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshPumpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshPumpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshPumpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshPumpMaxAggregateInputType
  }

  export type GetKhatRaneshPumpAggregateType<T extends KhatRaneshPumpAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshPump]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshPump[P]>
      : GetScalarType<T[P], AggregateKhatRaneshPump[P]>
  }




  export type KhatRaneshPumpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshPumpWhereInput
    orderBy?: KhatRaneshPumpOrderByWithAggregationInput | KhatRaneshPumpOrderByWithAggregationInput[]
    by: KhatRaneshPumpScalarFieldEnum[] | KhatRaneshPumpScalarFieldEnum
    having?: KhatRaneshPumpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshPumpCountAggregateInputType | true
    _avg?: KhatRaneshPumpAvgAggregateInputType
    _sum?: KhatRaneshPumpSumAggregateInputType
    _min?: KhatRaneshPumpMinAggregateInputType
    _max?: KhatRaneshPumpMaxAggregateInputType
  }

  export type KhatRaneshPumpGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    ModelPump: string | null
    FIdPump: number
    TedadPump: number | null
    DebiPomp: Decimal
    FesharPump: Decimal
    Randeman: number
    TavaneNami: Decimal
    TavaneJazbi: Decimal
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
    _count: KhatRaneshPumpCountAggregateOutputType | null
    _avg: KhatRaneshPumpAvgAggregateOutputType | null
    _sum: KhatRaneshPumpSumAggregateOutputType | null
    _min: KhatRaneshPumpMinAggregateOutputType | null
    _max: KhatRaneshPumpMaxAggregateOutputType | null
  }

  type GetKhatRaneshPumpGroupByPayload<T extends KhatRaneshPumpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshPumpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshPumpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshPumpGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshPumpGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshPumpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    ModelPump?: boolean
    FIdPump?: boolean
    TedadPump?: boolean
    DebiPomp?: boolean
    FesharPump?: boolean
    Randeman?: boolean
    TavaneNami?: boolean
    TavaneJazbi?: boolean
    Voltazh?: boolean
    DoreMotor?: boolean
    FeshareMakesh?: boolean
    FeshareRanesh?: boolean
    SizeMakesh?: boolean
    SizeRanesh?: boolean
    SizeKolektor?: boolean
    SizeShireKolektor?: boolean
  }, ExtArgs["result"]["khatRaneshPump"]>



  export type KhatRaneshPumpSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    ModelPump?: boolean
    FIdPump?: boolean
    TedadPump?: boolean
    DebiPomp?: boolean
    FesharPump?: boolean
    Randeman?: boolean
    TavaneNami?: boolean
    TavaneJazbi?: boolean
    Voltazh?: boolean
    DoreMotor?: boolean
    FeshareMakesh?: boolean
    FeshareRanesh?: boolean
    SizeMakesh?: boolean
    SizeRanesh?: boolean
    SizeKolektor?: boolean
    SizeShireKolektor?: boolean
  }

  export type KhatRaneshPumpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "ModelPump" | "FIdPump" | "TedadPump" | "DebiPomp" | "FesharPump" | "Randeman" | "TavaneNami" | "TavaneJazbi" | "Voltazh" | "DoreMotor" | "FeshareMakesh" | "FeshareRanesh" | "SizeMakesh" | "SizeRanesh" | "SizeKolektor" | "SizeShireKolektor", ExtArgs["result"]["khatRaneshPump"]>

  export type $KhatRaneshPumpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshPump"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      ModelPump: string | null
      FIdPump: number
      TedadPump: number | null
      DebiPomp: Prisma.Decimal
      FesharPump: Prisma.Decimal
      Randeman: number
      TavaneNami: Prisma.Decimal
      TavaneJazbi: Prisma.Decimal
      Voltazh: number
      DoreMotor: number
      FeshareMakesh: number
      FeshareRanesh: number
      SizeMakesh: number
      SizeRanesh: number
      SizeKolektor: number
      SizeShireKolektor: number
    }, ExtArgs["result"]["khatRaneshPump"]>
    composites: {}
  }

  type KhatRaneshPumpGetPayload<S extends boolean | null | undefined | KhatRaneshPumpDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshPumpPayload, S>

  type KhatRaneshPumpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshPumpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshPumpCountAggregateInputType | true
    }

  export interface KhatRaneshPumpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshPump'], meta: { name: 'KhatRaneshPump' } }
    /**
     * Find zero or one KhatRaneshPump that matches the filter.
     * @param {KhatRaneshPumpFindUniqueArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshPumpFindUniqueArgs>(args: SelectSubset<T, KhatRaneshPumpFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshPump that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshPumpFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshPumpFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshPump that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindFirstArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshPumpFindFirstArgs>(args?: SelectSubset<T, KhatRaneshPumpFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshPump that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshPump
     * @example
     * // Get one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshPumpFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshPumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshPumps
     * const khatRaneshPumps = await prisma.khatRaneshPump.findMany()
     * 
     * // Get first 10 KhatRaneshPumps
     * const khatRaneshPumps = await prisma.khatRaneshPump.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshPumpWithIdRaneshOnly = await prisma.khatRaneshPump.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshPumpFindManyArgs>(args?: SelectSubset<T, KhatRaneshPumpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshPump.
     * @param {KhatRaneshPumpCreateArgs} args - Arguments to create a KhatRaneshPump.
     * @example
     * // Create one KhatRaneshPump
     * const KhatRaneshPump = await prisma.khatRaneshPump.create({
     *   data: {
     *     // ... data to create a KhatRaneshPump
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshPumpCreateArgs>(args: SelectSubset<T, KhatRaneshPumpCreateArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshPumps.
     * @param {KhatRaneshPumpCreateManyArgs} args - Arguments to create many KhatRaneshPumps.
     * @example
     * // Create many KhatRaneshPumps
     * const khatRaneshPump = await prisma.khatRaneshPump.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshPumpCreateManyArgs>(args?: SelectSubset<T, KhatRaneshPumpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshPump.
     * @param {KhatRaneshPumpDeleteArgs} args - Arguments to delete one KhatRaneshPump.
     * @example
     * // Delete one KhatRaneshPump
     * const KhatRaneshPump = await prisma.khatRaneshPump.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshPump
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshPumpDeleteArgs>(args: SelectSubset<T, KhatRaneshPumpDeleteArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshPump.
     * @param {KhatRaneshPumpUpdateArgs} args - Arguments to update one KhatRaneshPump.
     * @example
     * // Update one KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshPumpUpdateArgs>(args: SelectSubset<T, KhatRaneshPumpUpdateArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshPumps.
     * @param {KhatRaneshPumpDeleteManyArgs} args - Arguments to filter KhatRaneshPumps to delete.
     * @example
     * // Delete a few KhatRaneshPumps
     * const { count } = await prisma.khatRaneshPump.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshPumpDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshPumpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshPumps
     * const khatRaneshPump = await prisma.khatRaneshPump.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshPumpUpdateManyArgs>(args: SelectSubset<T, KhatRaneshPumpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshPump.
     * @param {KhatRaneshPumpUpsertArgs} args - Arguments to update or create a KhatRaneshPump.
     * @example
     * // Update or create a KhatRaneshPump
     * const khatRaneshPump = await prisma.khatRaneshPump.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshPump
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshPump we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshPumpUpsertArgs>(args: SelectSubset<T, KhatRaneshPumpUpsertArgs<ExtArgs>>): Prisma__KhatRaneshPumpClient<$Result.GetResult<Prisma.$KhatRaneshPumpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpCountArgs} args - Arguments to filter KhatRaneshPumps to count.
     * @example
     * // Count the number of KhatRaneshPumps
     * const count = await prisma.khatRaneshPump.count({
     *   where: {
     *     // ... the filter for the KhatRaneshPumps we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshPumpCountArgs>(
      args?: Subset<T, KhatRaneshPumpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshPumpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshPumpAggregateArgs>(args: Subset<T, KhatRaneshPumpAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshPumpAggregateType<T>>

    /**
     * Group by KhatRaneshPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshPumpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshPumpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshPumpGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshPumpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshPumpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshPumpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshPump model
   */
  readonly fields: KhatRaneshPumpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshPump.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshPumpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshPump model
   */ 
  interface KhatRaneshPumpFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly ModelPump: FieldRef<"KhatRaneshPump", 'String'>
    readonly FIdPump: FieldRef<"KhatRaneshPump", 'Int'>
    readonly TedadPump: FieldRef<"KhatRaneshPump", 'Int'>
    readonly DebiPomp: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly FesharPump: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly Randeman: FieldRef<"KhatRaneshPump", 'Int'>
    readonly TavaneNami: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly TavaneJazbi: FieldRef<"KhatRaneshPump", 'Decimal'>
    readonly Voltazh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly DoreMotor: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FeshareMakesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly FeshareRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeMakesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeRanesh: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeKolektor: FieldRef<"KhatRaneshPump", 'Int'>
    readonly SizeShireKolektor: FieldRef<"KhatRaneshPump", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshPump findUnique
   */
  export type KhatRaneshPumpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump findUniqueOrThrow
   */
  export type KhatRaneshPumpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump findFirst
   */
  export type KhatRaneshPumpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshPumps.
     */
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump findFirstOrThrow
   */
  export type KhatRaneshPumpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPump to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshPumps.
     */
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump findMany
   */
  export type KhatRaneshPumpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshPumps to fetch.
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshPumps to fetch.
     */
    orderBy?: KhatRaneshPumpOrderByWithRelationInput | KhatRaneshPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshPumps.
     */
    cursor?: KhatRaneshPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshPumps.
     */
    skip?: number
    distinct?: KhatRaneshPumpScalarFieldEnum | KhatRaneshPumpScalarFieldEnum[]
  }

  /**
   * KhatRaneshPump create
   */
  export type KhatRaneshPumpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshPump.
     */
    data: XOR<KhatRaneshPumpCreateInput, KhatRaneshPumpUncheckedCreateInput>
  }

  /**
   * KhatRaneshPump createMany
   */
  export type KhatRaneshPumpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshPumps.
     */
    data: KhatRaneshPumpCreateManyInput | KhatRaneshPumpCreateManyInput[]
  }

  /**
   * KhatRaneshPump update
   */
  export type KhatRaneshPumpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshPump.
     */
    data: XOR<KhatRaneshPumpUpdateInput, KhatRaneshPumpUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshPump to update.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump updateMany
   */
  export type KhatRaneshPumpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshPumps.
     */
    data: XOR<KhatRaneshPumpUpdateManyMutationInput, KhatRaneshPumpUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshPumps to update
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * Limit how many KhatRaneshPumps to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshPump upsert
   */
  export type KhatRaneshPumpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshPump to update in case it exists.
     */
    where: KhatRaneshPumpWhereUniqueInput
    /**
     * In case the KhatRaneshPump found by the `where` argument doesn't exist, create a new KhatRaneshPump with this data.
     */
    create: XOR<KhatRaneshPumpCreateInput, KhatRaneshPumpUncheckedCreateInput>
    /**
     * In case the KhatRaneshPump was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshPumpUpdateInput, KhatRaneshPumpUncheckedUpdateInput>
  }

  /**
   * KhatRaneshPump delete
   */
  export type KhatRaneshPumpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
    /**
     * Filter which KhatRaneshPump to delete.
     */
    where: KhatRaneshPumpWhereUniqueInput
  }

  /**
   * KhatRaneshPump deleteMany
   */
  export type KhatRaneshPumpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshPumps to delete
     */
    where?: KhatRaneshPumpWhereInput
    /**
     * Limit how many KhatRaneshPumps to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshPump without action
   */
  export type KhatRaneshPumpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshPump
     */
    select?: KhatRaneshPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshPump
     */
    omit?: KhatRaneshPumpOmit<ExtArgs> | null
  }


  /**
   * Model KhatRaneshSegli
   */

  export type AggregateKhatRaneshSegli = {
    _count: KhatRaneshSegliCountAggregateOutputType | null
    _avg: KhatRaneshSegliAvgAggregateOutputType | null
    _sum: KhatRaneshSegliSumAggregateOutputType | null
    _min: KhatRaneshSegliMinAggregateOutputType | null
    _max: KhatRaneshSegliMaxAggregateOutputType | null
  }

  export type KhatRaneshSegliAvgAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliSumAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliMinAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliMaxAggregateOutputType = {
    IdRanesh: number | null
    FIdRanesh: number | null
    Zarfiat: Decimal | null
  }

  export type KhatRaneshSegliCountAggregateOutputType = {
    IdRanesh: number
    FIdRanesh: number
    Zarfiat: number
    _all: number
  }


  export type KhatRaneshSegliAvgAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliSumAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliMinAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliMaxAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
  }

  export type KhatRaneshSegliCountAggregateInputType = {
    IdRanesh?: true
    FIdRanesh?: true
    Zarfiat?: true
    _all?: true
  }

  export type KhatRaneshSegliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshSegli to aggregate.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KhatRaneshSeglis
    **/
    _count?: true | KhatRaneshSegliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KhatRaneshSegliAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KhatRaneshSegliSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KhatRaneshSegliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KhatRaneshSegliMaxAggregateInputType
  }

  export type GetKhatRaneshSegliAggregateType<T extends KhatRaneshSegliAggregateArgs> = {
        [P in keyof T & keyof AggregateKhatRaneshSegli]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKhatRaneshSegli[P]>
      : GetScalarType<T[P], AggregateKhatRaneshSegli[P]>
  }




  export type KhatRaneshSegliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KhatRaneshSegliWhereInput
    orderBy?: KhatRaneshSegliOrderByWithAggregationInput | KhatRaneshSegliOrderByWithAggregationInput[]
    by: KhatRaneshSegliScalarFieldEnum[] | KhatRaneshSegliScalarFieldEnum
    having?: KhatRaneshSegliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KhatRaneshSegliCountAggregateInputType | true
    _avg?: KhatRaneshSegliAvgAggregateInputType
    _sum?: KhatRaneshSegliSumAggregateInputType
    _min?: KhatRaneshSegliMinAggregateInputType
    _max?: KhatRaneshSegliMaxAggregateInputType
  }

  export type KhatRaneshSegliGroupByOutputType = {
    IdRanesh: number
    FIdRanesh: number
    Zarfiat: Decimal
    _count: KhatRaneshSegliCountAggregateOutputType | null
    _avg: KhatRaneshSegliAvgAggregateOutputType | null
    _sum: KhatRaneshSegliSumAggregateOutputType | null
    _min: KhatRaneshSegliMinAggregateOutputType | null
    _max: KhatRaneshSegliMaxAggregateOutputType | null
  }

  type GetKhatRaneshSegliGroupByPayload<T extends KhatRaneshSegliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KhatRaneshSegliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KhatRaneshSegliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KhatRaneshSegliGroupByOutputType[P]>
            : GetScalarType<T[P], KhatRaneshSegliGroupByOutputType[P]>
        }
      >
    >


  export type KhatRaneshSegliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRanesh?: boolean
    FIdRanesh?: boolean
    Zarfiat?: boolean
  }, ExtArgs["result"]["khatRaneshSegli"]>



  export type KhatRaneshSegliSelectScalar = {
    IdRanesh?: boolean
    FIdRanesh?: boolean
    Zarfiat?: boolean
  }

  export type KhatRaneshSegliOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRanesh" | "FIdRanesh" | "Zarfiat", ExtArgs["result"]["khatRaneshSegli"]>

  export type $KhatRaneshSegliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KhatRaneshSegli"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRanesh: number
      FIdRanesh: number
      Zarfiat: Prisma.Decimal
    }, ExtArgs["result"]["khatRaneshSegli"]>
    composites: {}
  }

  type KhatRaneshSegliGetPayload<S extends boolean | null | undefined | KhatRaneshSegliDefaultArgs> = $Result.GetResult<Prisma.$KhatRaneshSegliPayload, S>

  type KhatRaneshSegliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KhatRaneshSegliFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KhatRaneshSegliCountAggregateInputType | true
    }

  export interface KhatRaneshSegliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KhatRaneshSegli'], meta: { name: 'KhatRaneshSegli' } }
    /**
     * Find zero or one KhatRaneshSegli that matches the filter.
     * @param {KhatRaneshSegliFindUniqueArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KhatRaneshSegliFindUniqueArgs>(args: SelectSubset<T, KhatRaneshSegliFindUniqueArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KhatRaneshSegli that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KhatRaneshSegliFindUniqueOrThrowArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KhatRaneshSegliFindUniqueOrThrowArgs>(args: SelectSubset<T, KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshSegli that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindFirstArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KhatRaneshSegliFindFirstArgs>(args?: SelectSubset<T, KhatRaneshSegliFindFirstArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KhatRaneshSegli that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindFirstOrThrowArgs} args - Arguments to find a KhatRaneshSegli
     * @example
     * // Get one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KhatRaneshSegliFindFirstOrThrowArgs>(args?: SelectSubset<T, KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KhatRaneshSeglis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KhatRaneshSeglis
     * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany()
     * 
     * // Get first 10 KhatRaneshSeglis
     * const khatRaneshSeglis = await prisma.khatRaneshSegli.findMany({ take: 10 })
     * 
     * // Only select the `IdRanesh`
     * const khatRaneshSegliWithIdRaneshOnly = await prisma.khatRaneshSegli.findMany({ select: { IdRanesh: true } })
     * 
     */
    findMany<T extends KhatRaneshSegliFindManyArgs>(args?: SelectSubset<T, KhatRaneshSegliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KhatRaneshSegli.
     * @param {KhatRaneshSegliCreateArgs} args - Arguments to create a KhatRaneshSegli.
     * @example
     * // Create one KhatRaneshSegli
     * const KhatRaneshSegli = await prisma.khatRaneshSegli.create({
     *   data: {
     *     // ... data to create a KhatRaneshSegli
     *   }
     * })
     * 
     */
    create<T extends KhatRaneshSegliCreateArgs>(args: SelectSubset<T, KhatRaneshSegliCreateArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KhatRaneshSeglis.
     * @param {KhatRaneshSegliCreateManyArgs} args - Arguments to create many KhatRaneshSeglis.
     * @example
     * // Create many KhatRaneshSeglis
     * const khatRaneshSegli = await prisma.khatRaneshSegli.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KhatRaneshSegliCreateManyArgs>(args?: SelectSubset<T, KhatRaneshSegliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KhatRaneshSegli.
     * @param {KhatRaneshSegliDeleteArgs} args - Arguments to delete one KhatRaneshSegli.
     * @example
     * // Delete one KhatRaneshSegli
     * const KhatRaneshSegli = await prisma.khatRaneshSegli.delete({
     *   where: {
     *     // ... filter to delete one KhatRaneshSegli
     *   }
     * })
     * 
     */
    delete<T extends KhatRaneshSegliDeleteArgs>(args: SelectSubset<T, KhatRaneshSegliDeleteArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KhatRaneshSegli.
     * @param {KhatRaneshSegliUpdateArgs} args - Arguments to update one KhatRaneshSegli.
     * @example
     * // Update one KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KhatRaneshSegliUpdateArgs>(args: SelectSubset<T, KhatRaneshSegliUpdateArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KhatRaneshSeglis.
     * @param {KhatRaneshSegliDeleteManyArgs} args - Arguments to filter KhatRaneshSeglis to delete.
     * @example
     * // Delete a few KhatRaneshSeglis
     * const { count } = await prisma.khatRaneshSegli.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KhatRaneshSegliDeleteManyArgs>(args?: SelectSubset<T, KhatRaneshSegliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KhatRaneshSeglis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KhatRaneshSeglis
     * const khatRaneshSegli = await prisma.khatRaneshSegli.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KhatRaneshSegliUpdateManyArgs>(args: SelectSubset<T, KhatRaneshSegliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KhatRaneshSegli.
     * @param {KhatRaneshSegliUpsertArgs} args - Arguments to update or create a KhatRaneshSegli.
     * @example
     * // Update or create a KhatRaneshSegli
     * const khatRaneshSegli = await prisma.khatRaneshSegli.upsert({
     *   create: {
     *     // ... data to create a KhatRaneshSegli
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KhatRaneshSegli we want to update
     *   }
     * })
     */
    upsert<T extends KhatRaneshSegliUpsertArgs>(args: SelectSubset<T, KhatRaneshSegliUpsertArgs<ExtArgs>>): Prisma__KhatRaneshSegliClient<$Result.GetResult<Prisma.$KhatRaneshSegliPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KhatRaneshSeglis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliCountArgs} args - Arguments to filter KhatRaneshSeglis to count.
     * @example
     * // Count the number of KhatRaneshSeglis
     * const count = await prisma.khatRaneshSegli.count({
     *   where: {
     *     // ... the filter for the KhatRaneshSeglis we want to count
     *   }
     * })
    **/
    count<T extends KhatRaneshSegliCountArgs>(
      args?: Subset<T, KhatRaneshSegliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KhatRaneshSegliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KhatRaneshSegli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KhatRaneshSegliAggregateArgs>(args: Subset<T, KhatRaneshSegliAggregateArgs>): Prisma.PrismaPromise<GetKhatRaneshSegliAggregateType<T>>

    /**
     * Group by KhatRaneshSegli.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KhatRaneshSegliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KhatRaneshSegliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KhatRaneshSegliGroupByArgs['orderBy'] }
        : { orderBy?: KhatRaneshSegliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KhatRaneshSegliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKhatRaneshSegliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KhatRaneshSegli model
   */
  readonly fields: KhatRaneshSegliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KhatRaneshSegli.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KhatRaneshSegliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KhatRaneshSegli model
   */ 
  interface KhatRaneshSegliFieldRefs {
    readonly IdRanesh: FieldRef<"KhatRaneshSegli", 'Int'>
    readonly FIdRanesh: FieldRef<"KhatRaneshSegli", 'Int'>
    readonly Zarfiat: FieldRef<"KhatRaneshSegli", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * KhatRaneshSegli findUnique
   */
  export type KhatRaneshSegliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli findUniqueOrThrow
   */
  export type KhatRaneshSegliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli findFirst
   */
  export type KhatRaneshSegliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshSeglis.
     */
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli findFirstOrThrow
   */
  export type KhatRaneshSegliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSegli to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KhatRaneshSeglis.
     */
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli findMany
   */
  export type KhatRaneshSegliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter, which KhatRaneshSeglis to fetch.
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KhatRaneshSeglis to fetch.
     */
    orderBy?: KhatRaneshSegliOrderByWithRelationInput | KhatRaneshSegliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KhatRaneshSeglis.
     */
    cursor?: KhatRaneshSegliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KhatRaneshSeglis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KhatRaneshSeglis.
     */
    skip?: number
    distinct?: KhatRaneshSegliScalarFieldEnum | KhatRaneshSegliScalarFieldEnum[]
  }

  /**
   * KhatRaneshSegli create
   */
  export type KhatRaneshSegliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * The data needed to create a KhatRaneshSegli.
     */
    data: XOR<KhatRaneshSegliCreateInput, KhatRaneshSegliUncheckedCreateInput>
  }

  /**
   * KhatRaneshSegli createMany
   */
  export type KhatRaneshSegliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KhatRaneshSeglis.
     */
    data: KhatRaneshSegliCreateManyInput | KhatRaneshSegliCreateManyInput[]
  }

  /**
   * KhatRaneshSegli update
   */
  export type KhatRaneshSegliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * The data needed to update a KhatRaneshSegli.
     */
    data: XOR<KhatRaneshSegliUpdateInput, KhatRaneshSegliUncheckedUpdateInput>
    /**
     * Choose, which KhatRaneshSegli to update.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli updateMany
   */
  export type KhatRaneshSegliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KhatRaneshSeglis.
     */
    data: XOR<KhatRaneshSegliUpdateManyMutationInput, KhatRaneshSegliUncheckedUpdateManyInput>
    /**
     * Filter which KhatRaneshSeglis to update
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * Limit how many KhatRaneshSeglis to update.
     */
    limit?: number
  }

  /**
   * KhatRaneshSegli upsert
   */
  export type KhatRaneshSegliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * The filter to search for the KhatRaneshSegli to update in case it exists.
     */
    where: KhatRaneshSegliWhereUniqueInput
    /**
     * In case the KhatRaneshSegli found by the `where` argument doesn't exist, create a new KhatRaneshSegli with this data.
     */
    create: XOR<KhatRaneshSegliCreateInput, KhatRaneshSegliUncheckedCreateInput>
    /**
     * In case the KhatRaneshSegli was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KhatRaneshSegliUpdateInput, KhatRaneshSegliUncheckedUpdateInput>
  }

  /**
   * KhatRaneshSegli delete
   */
  export type KhatRaneshSegliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
    /**
     * Filter which KhatRaneshSegli to delete.
     */
    where: KhatRaneshSegliWhereUniqueInput
  }

  /**
   * KhatRaneshSegli deleteMany
   */
  export type KhatRaneshSegliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KhatRaneshSeglis to delete
     */
    where?: KhatRaneshSegliWhereInput
    /**
     * Limit how many KhatRaneshSeglis to delete.
     */
    limit?: number
  }

  /**
   * KhatRaneshSegli without action
   */
  export type KhatRaneshSegliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KhatRaneshSegli
     */
    select?: KhatRaneshSegliSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KhatRaneshSegli
     */
    omit?: KhatRaneshSegliOmit<ExtArgs> | null
  }


  /**
   * Model Kontor
   */

  export type AggregateKontor = {
    _count: KontorCountAggregateOutputType | null
    _avg: KontorAvgAggregateOutputType | null
    _sum: KontorSumAggregateOutputType | null
    _min: KontorMinAggregateOutputType | null
    _max: KontorMaxAggregateOutputType | null
  }

  export type KontorAvgAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorSumAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorMinAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorMaxAggregateOutputType = {
    IdKon: number | null
    FIdKontor: number | null
    FIdTarDor: number | null
    Kontor: number | null
  }

  export type KontorCountAggregateOutputType = {
    IdKon: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
    _all: number
  }


  export type KontorAvgAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorSumAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorMinAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorMaxAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
  }

  export type KontorCountAggregateInputType = {
    IdKon?: true
    FIdKontor?: true
    FIdTarDor?: true
    Kontor?: true
    _all?: true
  }

  export type KontorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kontor to aggregate.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kontors
    **/
    _count?: true | KontorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KontorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KontorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KontorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KontorMaxAggregateInputType
  }

  export type GetKontorAggregateType<T extends KontorAggregateArgs> = {
        [P in keyof T & keyof AggregateKontor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKontor[P]>
      : GetScalarType<T[P], AggregateKontor[P]>
  }




  export type KontorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorWhereInput
    orderBy?: KontorOrderByWithAggregationInput | KontorOrderByWithAggregationInput[]
    by: KontorScalarFieldEnum[] | KontorScalarFieldEnum
    having?: KontorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KontorCountAggregateInputType | true
    _avg?: KontorAvgAggregateInputType
    _sum?: KontorSumAggregateInputType
    _min?: KontorMinAggregateInputType
    _max?: KontorMaxAggregateInputType
  }

  export type KontorGroupByOutputType = {
    IdKon: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
    _count: KontorCountAggregateOutputType | null
    _avg: KontorAvgAggregateOutputType | null
    _sum: KontorSumAggregateOutputType | null
    _min: KontorMinAggregateOutputType | null
    _max: KontorMaxAggregateOutputType | null
  }

  type GetKontorGroupByPayload<T extends KontorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KontorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KontorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KontorGroupByOutputType[P]>
            : GetScalarType<T[P], KontorGroupByOutputType[P]>
        }
      >
    >


  export type KontorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdKon?: boolean
    FIdKontor?: boolean
    FIdTarDor?: boolean
    Kontor?: boolean
  }, ExtArgs["result"]["kontor"]>



  export type KontorSelectScalar = {
    IdKon?: boolean
    FIdKontor?: boolean
    FIdTarDor?: boolean
    Kontor?: boolean
  }

  export type KontorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdKon" | "FIdKontor" | "FIdTarDor" | "Kontor", ExtArgs["result"]["kontor"]>

  export type $KontorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kontor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdKon: number
      FIdKontor: number
      FIdTarDor: number
      Kontor: number
    }, ExtArgs["result"]["kontor"]>
    composites: {}
  }

  type KontorGetPayload<S extends boolean | null | undefined | KontorDefaultArgs> = $Result.GetResult<Prisma.$KontorPayload, S>

  type KontorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KontorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KontorCountAggregateInputType | true
    }

  export interface KontorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kontor'], meta: { name: 'Kontor' } }
    /**
     * Find zero or one Kontor that matches the filter.
     * @param {KontorFindUniqueArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KontorFindUniqueArgs>(args: SelectSubset<T, KontorFindUniqueArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Kontor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KontorFindUniqueOrThrowArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KontorFindUniqueOrThrowArgs>(args: SelectSubset<T, KontorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Kontor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindFirstArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KontorFindFirstArgs>(args?: SelectSubset<T, KontorFindFirstArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Kontor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindFirstOrThrowArgs} args - Arguments to find a Kontor
     * @example
     * // Get one Kontor
     * const kontor = await prisma.kontor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KontorFindFirstOrThrowArgs>(args?: SelectSubset<T, KontorFindFirstOrThrowArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Kontors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kontors
     * const kontors = await prisma.kontor.findMany()
     * 
     * // Get first 10 Kontors
     * const kontors = await prisma.kontor.findMany({ take: 10 })
     * 
     * // Only select the `IdKon`
     * const kontorWithIdKonOnly = await prisma.kontor.findMany({ select: { IdKon: true } })
     * 
     */
    findMany<T extends KontorFindManyArgs>(args?: SelectSubset<T, KontorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Kontor.
     * @param {KontorCreateArgs} args - Arguments to create a Kontor.
     * @example
     * // Create one Kontor
     * const Kontor = await prisma.kontor.create({
     *   data: {
     *     // ... data to create a Kontor
     *   }
     * })
     * 
     */
    create<T extends KontorCreateArgs>(args: SelectSubset<T, KontorCreateArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Kontors.
     * @param {KontorCreateManyArgs} args - Arguments to create many Kontors.
     * @example
     * // Create many Kontors
     * const kontor = await prisma.kontor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KontorCreateManyArgs>(args?: SelectSubset<T, KontorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kontor.
     * @param {KontorDeleteArgs} args - Arguments to delete one Kontor.
     * @example
     * // Delete one Kontor
     * const Kontor = await prisma.kontor.delete({
     *   where: {
     *     // ... filter to delete one Kontor
     *   }
     * })
     * 
     */
    delete<T extends KontorDeleteArgs>(args: SelectSubset<T, KontorDeleteArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Kontor.
     * @param {KontorUpdateArgs} args - Arguments to update one Kontor.
     * @example
     * // Update one Kontor
     * const kontor = await prisma.kontor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KontorUpdateArgs>(args: SelectSubset<T, KontorUpdateArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Kontors.
     * @param {KontorDeleteManyArgs} args - Arguments to filter Kontors to delete.
     * @example
     * // Delete a few Kontors
     * const { count } = await prisma.kontor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KontorDeleteManyArgs>(args?: SelectSubset<T, KontorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kontors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kontors
     * const kontor = await prisma.kontor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KontorUpdateManyArgs>(args: SelectSubset<T, KontorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kontor.
     * @param {KontorUpsertArgs} args - Arguments to update or create a Kontor.
     * @example
     * // Update or create a Kontor
     * const kontor = await prisma.kontor.upsert({
     *   create: {
     *     // ... data to create a Kontor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kontor we want to update
     *   }
     * })
     */
    upsert<T extends KontorUpsertArgs>(args: SelectSubset<T, KontorUpsertArgs<ExtArgs>>): Prisma__KontorClient<$Result.GetResult<Prisma.$KontorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Kontors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorCountArgs} args - Arguments to filter Kontors to count.
     * @example
     * // Count the number of Kontors
     * const count = await prisma.kontor.count({
     *   where: {
     *     // ... the filter for the Kontors we want to count
     *   }
     * })
    **/
    count<T extends KontorCountArgs>(
      args?: Subset<T, KontorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KontorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kontor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KontorAggregateArgs>(args: Subset<T, KontorAggregateArgs>): Prisma.PrismaPromise<GetKontorAggregateType<T>>

    /**
     * Group by Kontor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KontorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KontorGroupByArgs['orderBy'] }
        : { orderBy?: KontorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KontorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKontorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kontor model
   */
  readonly fields: KontorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kontor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KontorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kontor model
   */ 
  interface KontorFieldRefs {
    readonly IdKon: FieldRef<"Kontor", 'Int'>
    readonly FIdKontor: FieldRef<"Kontor", 'Int'>
    readonly FIdTarDor: FieldRef<"Kontor", 'Int'>
    readonly Kontor: FieldRef<"Kontor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Kontor findUnique
   */
  export type KontorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor findUniqueOrThrow
   */
  export type KontorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor findFirst
   */
  export type KontorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kontors.
     */
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor findFirstOrThrow
   */
  export type KontorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter, which Kontor to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kontors.
     */
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor findMany
   */
  export type KontorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter, which Kontors to fetch.
     */
    where?: KontorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kontors to fetch.
     */
    orderBy?: KontorOrderByWithRelationInput | KontorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kontors.
     */
    cursor?: KontorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kontors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kontors.
     */
    skip?: number
    distinct?: KontorScalarFieldEnum | KontorScalarFieldEnum[]
  }

  /**
   * Kontor create
   */
  export type KontorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * The data needed to create a Kontor.
     */
    data: XOR<KontorCreateInput, KontorUncheckedCreateInput>
  }

  /**
   * Kontor createMany
   */
  export type KontorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kontors.
     */
    data: KontorCreateManyInput | KontorCreateManyInput[]
  }

  /**
   * Kontor update
   */
  export type KontorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * The data needed to update a Kontor.
     */
    data: XOR<KontorUpdateInput, KontorUncheckedUpdateInput>
    /**
     * Choose, which Kontor to update.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor updateMany
   */
  export type KontorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kontors.
     */
    data: XOR<KontorUpdateManyMutationInput, KontorUncheckedUpdateManyInput>
    /**
     * Filter which Kontors to update
     */
    where?: KontorWhereInput
    /**
     * Limit how many Kontors to update.
     */
    limit?: number
  }

  /**
   * Kontor upsert
   */
  export type KontorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * The filter to search for the Kontor to update in case it exists.
     */
    where: KontorWhereUniqueInput
    /**
     * In case the Kontor found by the `where` argument doesn't exist, create a new Kontor with this data.
     */
    create: XOR<KontorCreateInput, KontorUncheckedCreateInput>
    /**
     * In case the Kontor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KontorUpdateInput, KontorUncheckedUpdateInput>
  }

  /**
   * Kontor delete
   */
  export type KontorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
    /**
     * Filter which Kontor to delete.
     */
    where: KontorWhereUniqueInput
  }

  /**
   * Kontor deleteMany
   */
  export type KontorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kontors to delete
     */
    where?: KontorWhereInput
    /**
     * Limit how many Kontors to delete.
     */
    limit?: number
  }

  /**
   * Kontor without action
   */
  export type KontorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kontor
     */
    select?: KontorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kontor
     */
    omit?: KontorOmit<ExtArgs> | null
  }


  /**
   * Model Land
   */

  export type AggregateLand = {
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  export type LandAvgAggregateOutputType = {
    IdLand: number | null
  }

  export type LandSumAggregateOutputType = {
    IdLand: number | null
  }

  export type LandMinAggregateOutputType = {
    IdLand: number | null
    Land: string | null
  }

  export type LandMaxAggregateOutputType = {
    IdLand: number | null
    Land: string | null
  }

  export type LandCountAggregateOutputType = {
    IdLand: number
    Land: number
    _all: number
  }


  export type LandAvgAggregateInputType = {
    IdLand?: true
  }

  export type LandSumAggregateInputType = {
    IdLand?: true
  }

  export type LandMinAggregateInputType = {
    IdLand?: true
    Land?: true
  }

  export type LandMaxAggregateInputType = {
    IdLand?: true
    Land?: true
  }

  export type LandCountAggregateInputType = {
    IdLand?: true
    Land?: true
    _all?: true
  }

  export type LandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Land to aggregate.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lands
    **/
    _count?: true | LandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandMaxAggregateInputType
  }

  export type GetLandAggregateType<T extends LandAggregateArgs> = {
        [P in keyof T & keyof AggregateLand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand[P]>
      : GetScalarType<T[P], AggregateLand[P]>
  }




  export type LandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandWhereInput
    orderBy?: LandOrderByWithAggregationInput | LandOrderByWithAggregationInput[]
    by: LandScalarFieldEnum[] | LandScalarFieldEnum
    having?: LandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandCountAggregateInputType | true
    _avg?: LandAvgAggregateInputType
    _sum?: LandSumAggregateInputType
    _min?: LandMinAggregateInputType
    _max?: LandMaxAggregateInputType
  }

  export type LandGroupByOutputType = {
    IdLand: number
    Land: string
    _count: LandCountAggregateOutputType | null
    _avg: LandAvgAggregateOutputType | null
    _sum: LandSumAggregateOutputType | null
    _min: LandMinAggregateOutputType | null
    _max: LandMaxAggregateOutputType | null
  }

  type GetLandGroupByPayload<T extends LandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandGroupByOutputType[P]>
            : GetScalarType<T[P], LandGroupByOutputType[P]>
        }
      >
    >


  export type LandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdLand?: boolean
    Land?: boolean
  }, ExtArgs["result"]["land"]>



  export type LandSelectScalar = {
    IdLand?: boolean
    Land?: boolean
  }

  export type LandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdLand" | "Land", ExtArgs["result"]["land"]>

  export type $LandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Land"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdLand: number
      Land: string
    }, ExtArgs["result"]["land"]>
    composites: {}
  }

  type LandGetPayload<S extends boolean | null | undefined | LandDefaultArgs> = $Result.GetResult<Prisma.$LandPayload, S>

  type LandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandCountAggregateInputType | true
    }

  export interface LandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Land'], meta: { name: 'Land' } }
    /**
     * Find zero or one Land that matches the filter.
     * @param {LandFindUniqueArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandFindUniqueArgs>(args: SelectSubset<T, LandFindUniqueArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Land that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandFindUniqueOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandFindUniqueOrThrowArgs>(args: SelectSubset<T, LandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Land that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindFirstArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandFindFirstArgs>(args?: SelectSubset<T, LandFindFirstArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Land that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindFirstOrThrowArgs} args - Arguments to find a Land
     * @example
     * // Get one Land
     * const land = await prisma.land.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandFindFirstOrThrowArgs>(args?: SelectSubset<T, LandFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Lands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lands
     * const lands = await prisma.land.findMany()
     * 
     * // Get first 10 Lands
     * const lands = await prisma.land.findMany({ take: 10 })
     * 
     * // Only select the `IdLand`
     * const landWithIdLandOnly = await prisma.land.findMany({ select: { IdLand: true } })
     * 
     */
    findMany<T extends LandFindManyArgs>(args?: SelectSubset<T, LandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Land.
     * @param {LandCreateArgs} args - Arguments to create a Land.
     * @example
     * // Create one Land
     * const Land = await prisma.land.create({
     *   data: {
     *     // ... data to create a Land
     *   }
     * })
     * 
     */
    create<T extends LandCreateArgs>(args: SelectSubset<T, LandCreateArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Lands.
     * @param {LandCreateManyArgs} args - Arguments to create many Lands.
     * @example
     * // Create many Lands
     * const land = await prisma.land.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandCreateManyArgs>(args?: SelectSubset<T, LandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land.
     * @param {LandDeleteArgs} args - Arguments to delete one Land.
     * @example
     * // Delete one Land
     * const Land = await prisma.land.delete({
     *   where: {
     *     // ... filter to delete one Land
     *   }
     * })
     * 
     */
    delete<T extends LandDeleteArgs>(args: SelectSubset<T, LandDeleteArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Land.
     * @param {LandUpdateArgs} args - Arguments to update one Land.
     * @example
     * // Update one Land
     * const land = await prisma.land.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandUpdateArgs>(args: SelectSubset<T, LandUpdateArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Lands.
     * @param {LandDeleteManyArgs} args - Arguments to filter Lands to delete.
     * @example
     * // Delete a few Lands
     * const { count } = await prisma.land.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandDeleteManyArgs>(args?: SelectSubset<T, LandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lands
     * const land = await prisma.land.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandUpdateManyArgs>(args: SelectSubset<T, LandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land.
     * @param {LandUpsertArgs} args - Arguments to update or create a Land.
     * @example
     * // Update or create a Land
     * const land = await prisma.land.upsert({
     *   create: {
     *     // ... data to create a Land
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land we want to update
     *   }
     * })
     */
    upsert<T extends LandUpsertArgs>(args: SelectSubset<T, LandUpsertArgs<ExtArgs>>): Prisma__LandClient<$Result.GetResult<Prisma.$LandPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Lands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandCountArgs} args - Arguments to filter Lands to count.
     * @example
     * // Count the number of Lands
     * const count = await prisma.land.count({
     *   where: {
     *     // ... the filter for the Lands we want to count
     *   }
     * })
    **/
    count<T extends LandCountArgs>(
      args?: Subset<T, LandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandAggregateArgs>(args: Subset<T, LandAggregateArgs>): Prisma.PrismaPromise<GetLandAggregateType<T>>

    /**
     * Group by Land.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandGroupByArgs['orderBy'] }
        : { orderBy?: LandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Land model
   */
  readonly fields: LandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Land.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Land model
   */ 
  interface LandFieldRefs {
    readonly IdLand: FieldRef<"Land", 'Int'>
    readonly Land: FieldRef<"Land", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Land findUnique
   */
  export type LandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land findUniqueOrThrow
   */
  export type LandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land findFirst
   */
  export type LandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land findFirstOrThrow
   */
  export type LandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter, which Land to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lands.
     */
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land findMany
   */
  export type LandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter, which Lands to fetch.
     */
    where?: LandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lands to fetch.
     */
    orderBy?: LandOrderByWithRelationInput | LandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lands.
     */
    cursor?: LandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lands.
     */
    skip?: number
    distinct?: LandScalarFieldEnum | LandScalarFieldEnum[]
  }

  /**
   * Land create
   */
  export type LandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * The data needed to create a Land.
     */
    data: XOR<LandCreateInput, LandUncheckedCreateInput>
  }

  /**
   * Land createMany
   */
  export type LandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lands.
     */
    data: LandCreateManyInput | LandCreateManyInput[]
  }

  /**
   * Land update
   */
  export type LandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * The data needed to update a Land.
     */
    data: XOR<LandUpdateInput, LandUncheckedUpdateInput>
    /**
     * Choose, which Land to update.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land updateMany
   */
  export type LandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lands.
     */
    data: XOR<LandUpdateManyMutationInput, LandUncheckedUpdateManyInput>
    /**
     * Filter which Lands to update
     */
    where?: LandWhereInput
    /**
     * Limit how many Lands to update.
     */
    limit?: number
  }

  /**
   * Land upsert
   */
  export type LandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * The filter to search for the Land to update in case it exists.
     */
    where: LandWhereUniqueInput
    /**
     * In case the Land found by the `where` argument doesn't exist, create a new Land with this data.
     */
    create: XOR<LandCreateInput, LandUncheckedCreateInput>
    /**
     * In case the Land was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandUpdateInput, LandUncheckedUpdateInput>
  }

  /**
   * Land delete
   */
  export type LandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
    /**
     * Filter which Land to delete.
     */
    where: LandWhereUniqueInput
  }

  /**
   * Land deleteMany
   */
  export type LandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lands to delete
     */
    where?: LandWhereInput
    /**
     * Limit how many Lands to delete.
     */
    limit?: number
  }

  /**
   * Land without action
   */
  export type LandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land
     */
    select?: LandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Land
     */
    omit?: LandOmit<ExtArgs> | null
  }


  /**
   * Model Mah
   */

  export type AggregateMah = {
    _count: MahCountAggregateOutputType | null
    _avg: MahAvgAggregateOutputType | null
    _sum: MahSumAggregateOutputType | null
    _min: MahMinAggregateOutputType | null
    _max: MahMaxAggregateOutputType | null
  }

  export type MahAvgAggregateOutputType = {
    IdMah: number | null
  }

  export type MahSumAggregateOutputType = {
    IdMah: number | null
  }

  export type MahMinAggregateOutputType = {
    IdMah: number | null
    Mah: string | null
  }

  export type MahMaxAggregateOutputType = {
    IdMah: number | null
    Mah: string | null
  }

  export type MahCountAggregateOutputType = {
    IdMah: number
    Mah: number
    _all: number
  }


  export type MahAvgAggregateInputType = {
    IdMah?: true
  }

  export type MahSumAggregateInputType = {
    IdMah?: true
  }

  export type MahMinAggregateInputType = {
    IdMah?: true
    Mah?: true
  }

  export type MahMaxAggregateInputType = {
    IdMah?: true
    Mah?: true
  }

  export type MahCountAggregateInputType = {
    IdMah?: true
    Mah?: true
    _all?: true
  }

  export type MahAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mah to aggregate.
     */
    where?: MahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahs to fetch.
     */
    orderBy?: MahOrderByWithRelationInput | MahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mahs
    **/
    _count?: true | MahCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MahAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MahSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MahMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MahMaxAggregateInputType
  }

  export type GetMahAggregateType<T extends MahAggregateArgs> = {
        [P in keyof T & keyof AggregateMah]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMah[P]>
      : GetScalarType<T[P], AggregateMah[P]>
  }




  export type MahGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahWhereInput
    orderBy?: MahOrderByWithAggregationInput | MahOrderByWithAggregationInput[]
    by: MahScalarFieldEnum[] | MahScalarFieldEnum
    having?: MahScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MahCountAggregateInputType | true
    _avg?: MahAvgAggregateInputType
    _sum?: MahSumAggregateInputType
    _min?: MahMinAggregateInputType
    _max?: MahMaxAggregateInputType
  }

  export type MahGroupByOutputType = {
    IdMah: number
    Mah: string
    _count: MahCountAggregateOutputType | null
    _avg: MahAvgAggregateOutputType | null
    _sum: MahSumAggregateOutputType | null
    _min: MahMinAggregateOutputType | null
    _max: MahMaxAggregateOutputType | null
  }

  type GetMahGroupByPayload<T extends MahGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MahGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MahGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MahGroupByOutputType[P]>
            : GetScalarType<T[P], MahGroupByOutputType[P]>
        }
      >
    >


  export type MahSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMah?: boolean
    Mah?: boolean
  }, ExtArgs["result"]["mah"]>



  export type MahSelectScalar = {
    IdMah?: boolean
    Mah?: boolean
  }

  export type MahOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMah" | "Mah", ExtArgs["result"]["mah"]>

  export type $MahPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mah"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdMah: number
      Mah: string
    }, ExtArgs["result"]["mah"]>
    composites: {}
  }

  type MahGetPayload<S extends boolean | null | undefined | MahDefaultArgs> = $Result.GetResult<Prisma.$MahPayload, S>

  type MahCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MahFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MahCountAggregateInputType | true
    }

  export interface MahDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mah'], meta: { name: 'Mah' } }
    /**
     * Find zero or one Mah that matches the filter.
     * @param {MahFindUniqueArgs} args - Arguments to find a Mah
     * @example
     * // Get one Mah
     * const mah = await prisma.mah.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MahFindUniqueArgs>(args: SelectSubset<T, MahFindUniqueArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Mah that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MahFindUniqueOrThrowArgs} args - Arguments to find a Mah
     * @example
     * // Get one Mah
     * const mah = await prisma.mah.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MahFindUniqueOrThrowArgs>(args: SelectSubset<T, MahFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Mah that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahFindFirstArgs} args - Arguments to find a Mah
     * @example
     * // Get one Mah
     * const mah = await prisma.mah.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MahFindFirstArgs>(args?: SelectSubset<T, MahFindFirstArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Mah that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahFindFirstOrThrowArgs} args - Arguments to find a Mah
     * @example
     * // Get one Mah
     * const mah = await prisma.mah.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MahFindFirstOrThrowArgs>(args?: SelectSubset<T, MahFindFirstOrThrowArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Mahs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mahs
     * const mahs = await prisma.mah.findMany()
     * 
     * // Get first 10 Mahs
     * const mahs = await prisma.mah.findMany({ take: 10 })
     * 
     * // Only select the `IdMah`
     * const mahWithIdMahOnly = await prisma.mah.findMany({ select: { IdMah: true } })
     * 
     */
    findMany<T extends MahFindManyArgs>(args?: SelectSubset<T, MahFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Mah.
     * @param {MahCreateArgs} args - Arguments to create a Mah.
     * @example
     * // Create one Mah
     * const Mah = await prisma.mah.create({
     *   data: {
     *     // ... data to create a Mah
     *   }
     * })
     * 
     */
    create<T extends MahCreateArgs>(args: SelectSubset<T, MahCreateArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Mahs.
     * @param {MahCreateManyArgs} args - Arguments to create many Mahs.
     * @example
     * // Create many Mahs
     * const mah = await prisma.mah.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MahCreateManyArgs>(args?: SelectSubset<T, MahCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mah.
     * @param {MahDeleteArgs} args - Arguments to delete one Mah.
     * @example
     * // Delete one Mah
     * const Mah = await prisma.mah.delete({
     *   where: {
     *     // ... filter to delete one Mah
     *   }
     * })
     * 
     */
    delete<T extends MahDeleteArgs>(args: SelectSubset<T, MahDeleteArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Mah.
     * @param {MahUpdateArgs} args - Arguments to update one Mah.
     * @example
     * // Update one Mah
     * const mah = await prisma.mah.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MahUpdateArgs>(args: SelectSubset<T, MahUpdateArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Mahs.
     * @param {MahDeleteManyArgs} args - Arguments to filter Mahs to delete.
     * @example
     * // Delete a few Mahs
     * const { count } = await prisma.mah.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MahDeleteManyArgs>(args?: SelectSubset<T, MahDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mahs
     * const mah = await prisma.mah.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MahUpdateManyArgs>(args: SelectSubset<T, MahUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mah.
     * @param {MahUpsertArgs} args - Arguments to update or create a Mah.
     * @example
     * // Update or create a Mah
     * const mah = await prisma.mah.upsert({
     *   create: {
     *     // ... data to create a Mah
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mah we want to update
     *   }
     * })
     */
    upsert<T extends MahUpsertArgs>(args: SelectSubset<T, MahUpsertArgs<ExtArgs>>): Prisma__MahClient<$Result.GetResult<Prisma.$MahPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Mahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahCountArgs} args - Arguments to filter Mahs to count.
     * @example
     * // Count the number of Mahs
     * const count = await prisma.mah.count({
     *   where: {
     *     // ... the filter for the Mahs we want to count
     *   }
     * })
    **/
    count<T extends MahCountArgs>(
      args?: Subset<T, MahCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MahCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MahAggregateArgs>(args: Subset<T, MahAggregateArgs>): Prisma.PrismaPromise<GetMahAggregateType<T>>

    /**
     * Group by Mah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MahGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MahGroupByArgs['orderBy'] }
        : { orderBy?: MahGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MahGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMahGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mah model
   */
  readonly fields: MahFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mah.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MahClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mah model
   */ 
  interface MahFieldRefs {
    readonly IdMah: FieldRef<"Mah", 'Int'>
    readonly Mah: FieldRef<"Mah", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mah findUnique
   */
  export type MahFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter, which Mah to fetch.
     */
    where: MahWhereUniqueInput
  }

  /**
   * Mah findUniqueOrThrow
   */
  export type MahFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter, which Mah to fetch.
     */
    where: MahWhereUniqueInput
  }

  /**
   * Mah findFirst
   */
  export type MahFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter, which Mah to fetch.
     */
    where?: MahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahs to fetch.
     */
    orderBy?: MahOrderByWithRelationInput | MahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahs.
     */
    cursor?: MahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahs.
     */
    distinct?: MahScalarFieldEnum | MahScalarFieldEnum[]
  }

  /**
   * Mah findFirstOrThrow
   */
  export type MahFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter, which Mah to fetch.
     */
    where?: MahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahs to fetch.
     */
    orderBy?: MahOrderByWithRelationInput | MahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahs.
     */
    cursor?: MahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahs.
     */
    distinct?: MahScalarFieldEnum | MahScalarFieldEnum[]
  }

  /**
   * Mah findMany
   */
  export type MahFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter, which Mahs to fetch.
     */
    where?: MahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahs to fetch.
     */
    orderBy?: MahOrderByWithRelationInput | MahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mahs.
     */
    cursor?: MahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahs.
     */
    skip?: number
    distinct?: MahScalarFieldEnum | MahScalarFieldEnum[]
  }

  /**
   * Mah create
   */
  export type MahCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * The data needed to create a Mah.
     */
    data: XOR<MahCreateInput, MahUncheckedCreateInput>
  }

  /**
   * Mah createMany
   */
  export type MahCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mahs.
     */
    data: MahCreateManyInput | MahCreateManyInput[]
  }

  /**
   * Mah update
   */
  export type MahUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * The data needed to update a Mah.
     */
    data: XOR<MahUpdateInput, MahUncheckedUpdateInput>
    /**
     * Choose, which Mah to update.
     */
    where: MahWhereUniqueInput
  }

  /**
   * Mah updateMany
   */
  export type MahUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mahs.
     */
    data: XOR<MahUpdateManyMutationInput, MahUncheckedUpdateManyInput>
    /**
     * Filter which Mahs to update
     */
    where?: MahWhereInput
    /**
     * Limit how many Mahs to update.
     */
    limit?: number
  }

  /**
   * Mah upsert
   */
  export type MahUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * The filter to search for the Mah to update in case it exists.
     */
    where: MahWhereUniqueInput
    /**
     * In case the Mah found by the `where` argument doesn't exist, create a new Mah with this data.
     */
    create: XOR<MahCreateInput, MahUncheckedCreateInput>
    /**
     * In case the Mah was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MahUpdateInput, MahUncheckedUpdateInput>
  }

  /**
   * Mah delete
   */
  export type MahDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
    /**
     * Filter which Mah to delete.
     */
    where: MahWhereUniqueInput
  }

  /**
   * Mah deleteMany
   */
  export type MahDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mahs to delete
     */
    where?: MahWhereInput
    /**
     * Limit how many Mahs to delete.
     */
    limit?: number
  }

  /**
   * Mah without action
   */
  export type MahDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mah
     */
    select?: MahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mah
     */
    omit?: MahOmit<ExtArgs> | null
  }


  /**
   * Model MeasuringTool
   */

  export type AggregateMeasuringTool = {
    _count: MeasuringToolCountAggregateOutputType | null
    _avg: MeasuringToolAvgAggregateOutputType | null
    _sum: MeasuringToolSumAggregateOutputType | null
    _min: MeasuringToolMinAggregateOutputType | null
    _max: MeasuringToolMaxAggregateOutputType | null
  }

  export type MeasuringToolAvgAggregateOutputType = {
    IdMeasuring: number | null
  }

  export type MeasuringToolSumAggregateOutputType = {
    IdMeasuring: number | null
  }

  export type MeasuringToolMinAggregateOutputType = {
    IdMeasuring: number | null
    MeasuringTool: string | null
    Precision: string | null
  }

  export type MeasuringToolMaxAggregateOutputType = {
    IdMeasuring: number | null
    MeasuringTool: string | null
    Precision: string | null
  }

  export type MeasuringToolCountAggregateOutputType = {
    IdMeasuring: number
    MeasuringTool: number
    Precision: number
    _all: number
  }


  export type MeasuringToolAvgAggregateInputType = {
    IdMeasuring?: true
  }

  export type MeasuringToolSumAggregateInputType = {
    IdMeasuring?: true
  }

  export type MeasuringToolMinAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
  }

  export type MeasuringToolMaxAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
  }

  export type MeasuringToolCountAggregateInputType = {
    IdMeasuring?: true
    MeasuringTool?: true
    Precision?: true
    _all?: true
  }

  export type MeasuringToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasuringTool to aggregate.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeasuringTools
    **/
    _count?: true | MeasuringToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeasuringToolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeasuringToolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeasuringToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeasuringToolMaxAggregateInputType
  }

  export type GetMeasuringToolAggregateType<T extends MeasuringToolAggregateArgs> = {
        [P in keyof T & keyof AggregateMeasuringTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeasuringTool[P]>
      : GetScalarType<T[P], AggregateMeasuringTool[P]>
  }




  export type MeasuringToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasuringToolWhereInput
    orderBy?: MeasuringToolOrderByWithAggregationInput | MeasuringToolOrderByWithAggregationInput[]
    by: MeasuringToolScalarFieldEnum[] | MeasuringToolScalarFieldEnum
    having?: MeasuringToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeasuringToolCountAggregateInputType | true
    _avg?: MeasuringToolAvgAggregateInputType
    _sum?: MeasuringToolSumAggregateInputType
    _min?: MeasuringToolMinAggregateInputType
    _max?: MeasuringToolMaxAggregateInputType
  }

  export type MeasuringToolGroupByOutputType = {
    IdMeasuring: number
    MeasuringTool: string
    Precision: string
    _count: MeasuringToolCountAggregateOutputType | null
    _avg: MeasuringToolAvgAggregateOutputType | null
    _sum: MeasuringToolSumAggregateOutputType | null
    _min: MeasuringToolMinAggregateOutputType | null
    _max: MeasuringToolMaxAggregateOutputType | null
  }

  type GetMeasuringToolGroupByPayload<T extends MeasuringToolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeasuringToolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeasuringToolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeasuringToolGroupByOutputType[P]>
            : GetScalarType<T[P], MeasuringToolGroupByOutputType[P]>
        }
      >
    >


  export type MeasuringToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMeasuring?: boolean
    MeasuringTool?: boolean
    Precision?: boolean
  }, ExtArgs["result"]["measuringTool"]>



  export type MeasuringToolSelectScalar = {
    IdMeasuring?: boolean
    MeasuringTool?: boolean
    Precision?: boolean
  }

  export type MeasuringToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdMeasuring" | "MeasuringTool" | "Precision", ExtArgs["result"]["measuringTool"]>

  export type $MeasuringToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeasuringTool"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdMeasuring: number
      MeasuringTool: string
      Precision: string
    }, ExtArgs["result"]["measuringTool"]>
    composites: {}
  }

  type MeasuringToolGetPayload<S extends boolean | null | undefined | MeasuringToolDefaultArgs> = $Result.GetResult<Prisma.$MeasuringToolPayload, S>

  type MeasuringToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeasuringToolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeasuringToolCountAggregateInputType | true
    }

  export interface MeasuringToolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeasuringTool'], meta: { name: 'MeasuringTool' } }
    /**
     * Find zero or one MeasuringTool that matches the filter.
     * @param {MeasuringToolFindUniqueArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeasuringToolFindUniqueArgs>(args: SelectSubset<T, MeasuringToolFindUniqueArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MeasuringTool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeasuringToolFindUniqueOrThrowArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeasuringToolFindUniqueOrThrowArgs>(args: SelectSubset<T, MeasuringToolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MeasuringTool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindFirstArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeasuringToolFindFirstArgs>(args?: SelectSubset<T, MeasuringToolFindFirstArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MeasuringTool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindFirstOrThrowArgs} args - Arguments to find a MeasuringTool
     * @example
     * // Get one MeasuringTool
     * const measuringTool = await prisma.measuringTool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeasuringToolFindFirstOrThrowArgs>(args?: SelectSubset<T, MeasuringToolFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MeasuringTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeasuringTools
     * const measuringTools = await prisma.measuringTool.findMany()
     * 
     * // Get first 10 MeasuringTools
     * const measuringTools = await prisma.measuringTool.findMany({ take: 10 })
     * 
     * // Only select the `IdMeasuring`
     * const measuringToolWithIdMeasuringOnly = await prisma.measuringTool.findMany({ select: { IdMeasuring: true } })
     * 
     */
    findMany<T extends MeasuringToolFindManyArgs>(args?: SelectSubset<T, MeasuringToolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MeasuringTool.
     * @param {MeasuringToolCreateArgs} args - Arguments to create a MeasuringTool.
     * @example
     * // Create one MeasuringTool
     * const MeasuringTool = await prisma.measuringTool.create({
     *   data: {
     *     // ... data to create a MeasuringTool
     *   }
     * })
     * 
     */
    create<T extends MeasuringToolCreateArgs>(args: SelectSubset<T, MeasuringToolCreateArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MeasuringTools.
     * @param {MeasuringToolCreateManyArgs} args - Arguments to create many MeasuringTools.
     * @example
     * // Create many MeasuringTools
     * const measuringTool = await prisma.measuringTool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeasuringToolCreateManyArgs>(args?: SelectSubset<T, MeasuringToolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MeasuringTool.
     * @param {MeasuringToolDeleteArgs} args - Arguments to delete one MeasuringTool.
     * @example
     * // Delete one MeasuringTool
     * const MeasuringTool = await prisma.measuringTool.delete({
     *   where: {
     *     // ... filter to delete one MeasuringTool
     *   }
     * })
     * 
     */
    delete<T extends MeasuringToolDeleteArgs>(args: SelectSubset<T, MeasuringToolDeleteArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MeasuringTool.
     * @param {MeasuringToolUpdateArgs} args - Arguments to update one MeasuringTool.
     * @example
     * // Update one MeasuringTool
     * const measuringTool = await prisma.measuringTool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeasuringToolUpdateArgs>(args: SelectSubset<T, MeasuringToolUpdateArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MeasuringTools.
     * @param {MeasuringToolDeleteManyArgs} args - Arguments to filter MeasuringTools to delete.
     * @example
     * // Delete a few MeasuringTools
     * const { count } = await prisma.measuringTool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeasuringToolDeleteManyArgs>(args?: SelectSubset<T, MeasuringToolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeasuringTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeasuringTools
     * const measuringTool = await prisma.measuringTool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeasuringToolUpdateManyArgs>(args: SelectSubset<T, MeasuringToolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeasuringTool.
     * @param {MeasuringToolUpsertArgs} args - Arguments to update or create a MeasuringTool.
     * @example
     * // Update or create a MeasuringTool
     * const measuringTool = await prisma.measuringTool.upsert({
     *   create: {
     *     // ... data to create a MeasuringTool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeasuringTool we want to update
     *   }
     * })
     */
    upsert<T extends MeasuringToolUpsertArgs>(args: SelectSubset<T, MeasuringToolUpsertArgs<ExtArgs>>): Prisma__MeasuringToolClient<$Result.GetResult<Prisma.$MeasuringToolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MeasuringTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolCountArgs} args - Arguments to filter MeasuringTools to count.
     * @example
     * // Count the number of MeasuringTools
     * const count = await prisma.measuringTool.count({
     *   where: {
     *     // ... the filter for the MeasuringTools we want to count
     *   }
     * })
    **/
    count<T extends MeasuringToolCountArgs>(
      args?: Subset<T, MeasuringToolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeasuringToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeasuringTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeasuringToolAggregateArgs>(args: Subset<T, MeasuringToolAggregateArgs>): Prisma.PrismaPromise<GetMeasuringToolAggregateType<T>>

    /**
     * Group by MeasuringTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasuringToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeasuringToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeasuringToolGroupByArgs['orderBy'] }
        : { orderBy?: MeasuringToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeasuringToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeasuringToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeasuringTool model
   */
  readonly fields: MeasuringToolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeasuringTool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeasuringToolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeasuringTool model
   */ 
  interface MeasuringToolFieldRefs {
    readonly IdMeasuring: FieldRef<"MeasuringTool", 'Int'>
    readonly MeasuringTool: FieldRef<"MeasuringTool", 'String'>
    readonly Precision: FieldRef<"MeasuringTool", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MeasuringTool findUnique
   */
  export type MeasuringToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool findUniqueOrThrow
   */
  export type MeasuringToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool findFirst
   */
  export type MeasuringToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasuringTools.
     */
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool findFirstOrThrow
   */
  export type MeasuringToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter, which MeasuringTool to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasuringTools.
     */
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool findMany
   */
  export type MeasuringToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter, which MeasuringTools to fetch.
     */
    where?: MeasuringToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasuringTools to fetch.
     */
    orderBy?: MeasuringToolOrderByWithRelationInput | MeasuringToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeasuringTools.
     */
    cursor?: MeasuringToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasuringTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasuringTools.
     */
    skip?: number
    distinct?: MeasuringToolScalarFieldEnum | MeasuringToolScalarFieldEnum[]
  }

  /**
   * MeasuringTool create
   */
  export type MeasuringToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * The data needed to create a MeasuringTool.
     */
    data: XOR<MeasuringToolCreateInput, MeasuringToolUncheckedCreateInput>
  }

  /**
   * MeasuringTool createMany
   */
  export type MeasuringToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeasuringTools.
     */
    data: MeasuringToolCreateManyInput | MeasuringToolCreateManyInput[]
  }

  /**
   * MeasuringTool update
   */
  export type MeasuringToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * The data needed to update a MeasuringTool.
     */
    data: XOR<MeasuringToolUpdateInput, MeasuringToolUncheckedUpdateInput>
    /**
     * Choose, which MeasuringTool to update.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool updateMany
   */
  export type MeasuringToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeasuringTools.
     */
    data: XOR<MeasuringToolUpdateManyMutationInput, MeasuringToolUncheckedUpdateManyInput>
    /**
     * Filter which MeasuringTools to update
     */
    where?: MeasuringToolWhereInput
    /**
     * Limit how many MeasuringTools to update.
     */
    limit?: number
  }

  /**
   * MeasuringTool upsert
   */
  export type MeasuringToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * The filter to search for the MeasuringTool to update in case it exists.
     */
    where: MeasuringToolWhereUniqueInput
    /**
     * In case the MeasuringTool found by the `where` argument doesn't exist, create a new MeasuringTool with this data.
     */
    create: XOR<MeasuringToolCreateInput, MeasuringToolUncheckedCreateInput>
    /**
     * In case the MeasuringTool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeasuringToolUpdateInput, MeasuringToolUncheckedUpdateInput>
  }

  /**
   * MeasuringTool delete
   */
  export type MeasuringToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
    /**
     * Filter which MeasuringTool to delete.
     */
    where: MeasuringToolWhereUniqueInput
  }

  /**
   * MeasuringTool deleteMany
   */
  export type MeasuringToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasuringTools to delete
     */
    where?: MeasuringToolWhereInput
    /**
     * Limit how many MeasuringTools to delete.
     */
    limit?: number
  }

  /**
   * MeasuringTool without action
   */
  export type MeasuringToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasuringTool
     */
    select?: MeasuringToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasuringTool
     */
    omit?: MeasuringToolOmit<ExtArgs> | null
  }


  /**
   * Model NashtShabake
   */

  export type AggregateNashtShabake = {
    _count: NashtShabakeCountAggregateOutputType | null
    _avg: NashtShabakeAvgAggregateOutputType | null
    _sum: NashtShabakeSumAggregateOutputType | null
    _min: NashtShabakeMinAggregateOutputType | null
    _max: NashtShabakeMaxAggregateOutputType | null
  }

  export type NashtShabakeAvgAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeSumAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeMinAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeMaxAggregateOutputType = {
    IdNasht: number | null
    FIdRanesh: number | null
    FIdTriDor: number | null
    NashtShabake: number | null
  }

  export type NashtShabakeCountAggregateOutputType = {
    IdNasht: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
    _all: number
  }


  export type NashtShabakeAvgAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeSumAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeMinAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeMaxAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
  }

  export type NashtShabakeCountAggregateInputType = {
    IdNasht?: true
    FIdRanesh?: true
    FIdTriDor?: true
    NashtShabake?: true
    _all?: true
  }

  export type NashtShabakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NashtShabake to aggregate.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NashtShabakes
    **/
    _count?: true | NashtShabakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NashtShabakeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NashtShabakeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NashtShabakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NashtShabakeMaxAggregateInputType
  }

  export type GetNashtShabakeAggregateType<T extends NashtShabakeAggregateArgs> = {
        [P in keyof T & keyof AggregateNashtShabake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNashtShabake[P]>
      : GetScalarType<T[P], AggregateNashtShabake[P]>
  }




  export type NashtShabakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NashtShabakeWhereInput
    orderBy?: NashtShabakeOrderByWithAggregationInput | NashtShabakeOrderByWithAggregationInput[]
    by: NashtShabakeScalarFieldEnum[] | NashtShabakeScalarFieldEnum
    having?: NashtShabakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NashtShabakeCountAggregateInputType | true
    _avg?: NashtShabakeAvgAggregateInputType
    _sum?: NashtShabakeSumAggregateInputType
    _min?: NashtShabakeMinAggregateInputType
    _max?: NashtShabakeMaxAggregateInputType
  }

  export type NashtShabakeGroupByOutputType = {
    IdNasht: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
    _count: NashtShabakeCountAggregateOutputType | null
    _avg: NashtShabakeAvgAggregateOutputType | null
    _sum: NashtShabakeSumAggregateOutputType | null
    _min: NashtShabakeMinAggregateOutputType | null
    _max: NashtShabakeMaxAggregateOutputType | null
  }

  type GetNashtShabakeGroupByPayload<T extends NashtShabakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NashtShabakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NashtShabakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NashtShabakeGroupByOutputType[P]>
            : GetScalarType<T[P], NashtShabakeGroupByOutputType[P]>
        }
      >
    >


  export type NashtShabakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNasht?: boolean
    FIdRanesh?: boolean
    FIdTriDor?: boolean
    NashtShabake?: boolean
  }, ExtArgs["result"]["nashtShabake"]>



  export type NashtShabakeSelectScalar = {
    IdNasht?: boolean
    FIdRanesh?: boolean
    FIdTriDor?: boolean
    NashtShabake?: boolean
  }

  export type NashtShabakeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNasht" | "FIdRanesh" | "FIdTriDor" | "NashtShabake", ExtArgs["result"]["nashtShabake"]>

  export type $NashtShabakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NashtShabake"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdNasht: number
      FIdRanesh: number
      FIdTriDor: number
      NashtShabake: number
    }, ExtArgs["result"]["nashtShabake"]>
    composites: {}
  }

  type NashtShabakeGetPayload<S extends boolean | null | undefined | NashtShabakeDefaultArgs> = $Result.GetResult<Prisma.$NashtShabakePayload, S>

  type NashtShabakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NashtShabakeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NashtShabakeCountAggregateInputType | true
    }

  export interface NashtShabakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NashtShabake'], meta: { name: 'NashtShabake' } }
    /**
     * Find zero or one NashtShabake that matches the filter.
     * @param {NashtShabakeFindUniqueArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NashtShabakeFindUniqueArgs>(args: SelectSubset<T, NashtShabakeFindUniqueArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NashtShabake that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NashtShabakeFindUniqueOrThrowArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NashtShabakeFindUniqueOrThrowArgs>(args: SelectSubset<T, NashtShabakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NashtShabake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindFirstArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NashtShabakeFindFirstArgs>(args?: SelectSubset<T, NashtShabakeFindFirstArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NashtShabake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindFirstOrThrowArgs} args - Arguments to find a NashtShabake
     * @example
     * // Get one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NashtShabakeFindFirstOrThrowArgs>(args?: SelectSubset<T, NashtShabakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NashtShabakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NashtShabakes
     * const nashtShabakes = await prisma.nashtShabake.findMany()
     * 
     * // Get first 10 NashtShabakes
     * const nashtShabakes = await prisma.nashtShabake.findMany({ take: 10 })
     * 
     * // Only select the `IdNasht`
     * const nashtShabakeWithIdNashtOnly = await prisma.nashtShabake.findMany({ select: { IdNasht: true } })
     * 
     */
    findMany<T extends NashtShabakeFindManyArgs>(args?: SelectSubset<T, NashtShabakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NashtShabake.
     * @param {NashtShabakeCreateArgs} args - Arguments to create a NashtShabake.
     * @example
     * // Create one NashtShabake
     * const NashtShabake = await prisma.nashtShabake.create({
     *   data: {
     *     // ... data to create a NashtShabake
     *   }
     * })
     * 
     */
    create<T extends NashtShabakeCreateArgs>(args: SelectSubset<T, NashtShabakeCreateArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NashtShabakes.
     * @param {NashtShabakeCreateManyArgs} args - Arguments to create many NashtShabakes.
     * @example
     * // Create many NashtShabakes
     * const nashtShabake = await prisma.nashtShabake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NashtShabakeCreateManyArgs>(args?: SelectSubset<T, NashtShabakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NashtShabake.
     * @param {NashtShabakeDeleteArgs} args - Arguments to delete one NashtShabake.
     * @example
     * // Delete one NashtShabake
     * const NashtShabake = await prisma.nashtShabake.delete({
     *   where: {
     *     // ... filter to delete one NashtShabake
     *   }
     * })
     * 
     */
    delete<T extends NashtShabakeDeleteArgs>(args: SelectSubset<T, NashtShabakeDeleteArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NashtShabake.
     * @param {NashtShabakeUpdateArgs} args - Arguments to update one NashtShabake.
     * @example
     * // Update one NashtShabake
     * const nashtShabake = await prisma.nashtShabake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NashtShabakeUpdateArgs>(args: SelectSubset<T, NashtShabakeUpdateArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NashtShabakes.
     * @param {NashtShabakeDeleteManyArgs} args - Arguments to filter NashtShabakes to delete.
     * @example
     * // Delete a few NashtShabakes
     * const { count } = await prisma.nashtShabake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NashtShabakeDeleteManyArgs>(args?: SelectSubset<T, NashtShabakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NashtShabakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NashtShabakes
     * const nashtShabake = await prisma.nashtShabake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NashtShabakeUpdateManyArgs>(args: SelectSubset<T, NashtShabakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NashtShabake.
     * @param {NashtShabakeUpsertArgs} args - Arguments to update or create a NashtShabake.
     * @example
     * // Update or create a NashtShabake
     * const nashtShabake = await prisma.nashtShabake.upsert({
     *   create: {
     *     // ... data to create a NashtShabake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NashtShabake we want to update
     *   }
     * })
     */
    upsert<T extends NashtShabakeUpsertArgs>(args: SelectSubset<T, NashtShabakeUpsertArgs<ExtArgs>>): Prisma__NashtShabakeClient<$Result.GetResult<Prisma.$NashtShabakePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NashtShabakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeCountArgs} args - Arguments to filter NashtShabakes to count.
     * @example
     * // Count the number of NashtShabakes
     * const count = await prisma.nashtShabake.count({
     *   where: {
     *     // ... the filter for the NashtShabakes we want to count
     *   }
     * })
    **/
    count<T extends NashtShabakeCountArgs>(
      args?: Subset<T, NashtShabakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NashtShabakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NashtShabake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NashtShabakeAggregateArgs>(args: Subset<T, NashtShabakeAggregateArgs>): Prisma.PrismaPromise<GetNashtShabakeAggregateType<T>>

    /**
     * Group by NashtShabake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NashtShabakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NashtShabakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NashtShabakeGroupByArgs['orderBy'] }
        : { orderBy?: NashtShabakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NashtShabakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNashtShabakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NashtShabake model
   */
  readonly fields: NashtShabakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NashtShabake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NashtShabakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NashtShabake model
   */ 
  interface NashtShabakeFieldRefs {
    readonly IdNasht: FieldRef<"NashtShabake", 'Int'>
    readonly FIdRanesh: FieldRef<"NashtShabake", 'Int'>
    readonly FIdTriDor: FieldRef<"NashtShabake", 'Int'>
    readonly NashtShabake: FieldRef<"NashtShabake", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NashtShabake findUnique
   */
  export type NashtShabakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake findUniqueOrThrow
   */
  export type NashtShabakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake findFirst
   */
  export type NashtShabakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NashtShabakes.
     */
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake findFirstOrThrow
   */
  export type NashtShabakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter, which NashtShabake to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NashtShabakes.
     */
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake findMany
   */
  export type NashtShabakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter, which NashtShabakes to fetch.
     */
    where?: NashtShabakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NashtShabakes to fetch.
     */
    orderBy?: NashtShabakeOrderByWithRelationInput | NashtShabakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NashtShabakes.
     */
    cursor?: NashtShabakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NashtShabakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NashtShabakes.
     */
    skip?: number
    distinct?: NashtShabakeScalarFieldEnum | NashtShabakeScalarFieldEnum[]
  }

  /**
   * NashtShabake create
   */
  export type NashtShabakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * The data needed to create a NashtShabake.
     */
    data: XOR<NashtShabakeCreateInput, NashtShabakeUncheckedCreateInput>
  }

  /**
   * NashtShabake createMany
   */
  export type NashtShabakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NashtShabakes.
     */
    data: NashtShabakeCreateManyInput | NashtShabakeCreateManyInput[]
  }

  /**
   * NashtShabake update
   */
  export type NashtShabakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * The data needed to update a NashtShabake.
     */
    data: XOR<NashtShabakeUpdateInput, NashtShabakeUncheckedUpdateInput>
    /**
     * Choose, which NashtShabake to update.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake updateMany
   */
  export type NashtShabakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NashtShabakes.
     */
    data: XOR<NashtShabakeUpdateManyMutationInput, NashtShabakeUncheckedUpdateManyInput>
    /**
     * Filter which NashtShabakes to update
     */
    where?: NashtShabakeWhereInput
    /**
     * Limit how many NashtShabakes to update.
     */
    limit?: number
  }

  /**
   * NashtShabake upsert
   */
  export type NashtShabakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * The filter to search for the NashtShabake to update in case it exists.
     */
    where: NashtShabakeWhereUniqueInput
    /**
     * In case the NashtShabake found by the `where` argument doesn't exist, create a new NashtShabake with this data.
     */
    create: XOR<NashtShabakeCreateInput, NashtShabakeUncheckedCreateInput>
    /**
     * In case the NashtShabake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NashtShabakeUpdateInput, NashtShabakeUncheckedUpdateInput>
  }

  /**
   * NashtShabake delete
   */
  export type NashtShabakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
    /**
     * Filter which NashtShabake to delete.
     */
    where: NashtShabakeWhereUniqueInput
  }

  /**
   * NashtShabake deleteMany
   */
  export type NashtShabakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NashtShabakes to delete
     */
    where?: NashtShabakeWhereInput
    /**
     * Limit how many NashtShabakes to delete.
     */
    limit?: number
  }

  /**
   * NashtShabake without action
   */
  export type NashtShabakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NashtShabake
     */
    select?: NashtShabakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NashtShabake
     */
    omit?: NashtShabakeOmit<ExtArgs> | null
  }


  /**
   * Model Network
   */

  export type AggregateNetwork = {
    _count: NetworkCountAggregateOutputType | null
    _avg: NetworkAvgAggregateOutputType | null
    _sum: NetworkSumAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  export type NetworkAvgAggregateOutputType = {
    IdNet: number | null
    FIdSP: number | null
  }

  export type NetworkSumAggregateOutputType = {
    IdNet: number | null
    FIdSP: number | null
  }

  export type NetworkMinAggregateOutputType = {
    IdNet: number | null
    Network: string | null
    FIdSP: number | null
  }

  export type NetworkMaxAggregateOutputType = {
    IdNet: number | null
    Network: string | null
    FIdSP: number | null
  }

  export type NetworkCountAggregateOutputType = {
    IdNet: number
    Network: number
    FIdSP: number
    _all: number
  }


  export type NetworkAvgAggregateInputType = {
    IdNet?: true
    FIdSP?: true
  }

  export type NetworkSumAggregateInputType = {
    IdNet?: true
    FIdSP?: true
  }

  export type NetworkMinAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
  }

  export type NetworkMaxAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
  }

  export type NetworkCountAggregateInputType = {
    IdNet?: true
    Network?: true
    FIdSP?: true
    _all?: true
  }

  export type NetworkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Network to aggregate.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Networks
    **/
    _count?: true | NetworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkMaxAggregateInputType
  }

  export type GetNetworkAggregateType<T extends NetworkAggregateArgs> = {
        [P in keyof T & keyof AggregateNetwork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetwork[P]>
      : GetScalarType<T[P], AggregateNetwork[P]>
  }




  export type NetworkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithAggregationInput | NetworkOrderByWithAggregationInput[]
    by: NetworkScalarFieldEnum[] | NetworkScalarFieldEnum
    having?: NetworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkCountAggregateInputType | true
    _avg?: NetworkAvgAggregateInputType
    _sum?: NetworkSumAggregateInputType
    _min?: NetworkMinAggregateInputType
    _max?: NetworkMaxAggregateInputType
  }

  export type NetworkGroupByOutputType = {
    IdNet: number
    Network: string
    FIdSP: number
    _count: NetworkCountAggregateOutputType | null
    _avg: NetworkAvgAggregateOutputType | null
    _sum: NetworkSumAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  type GetNetworkGroupByPayload<T extends NetworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkGroupByOutputType[P]>
        }
      >
    >


  export type NetworkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNet?: boolean
    Network?: boolean
    FIdSP?: boolean
  }, ExtArgs["result"]["network"]>



  export type NetworkSelectScalar = {
    IdNet?: boolean
    Network?: boolean
    FIdSP?: boolean
  }

  export type NetworkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNet" | "Network" | "FIdSP", ExtArgs["result"]["network"]>

  export type $NetworkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Network"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdNet: number
      Network: string
      FIdSP: number
    }, ExtArgs["result"]["network"]>
    composites: {}
  }

  type NetworkGetPayload<S extends boolean | null | undefined | NetworkDefaultArgs> = $Result.GetResult<Prisma.$NetworkPayload, S>

  type NetworkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkCountAggregateInputType | true
    }

  export interface NetworkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Network'], meta: { name: 'Network' } }
    /**
     * Find zero or one Network that matches the filter.
     * @param {NetworkFindUniqueArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkFindUniqueArgs>(args: SelectSubset<T, NetworkFindUniqueArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Network that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkFindUniqueOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Network that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkFindFirstArgs>(args?: SelectSubset<T, NetworkFindFirstArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Network that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Networks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Networks
     * const networks = await prisma.network.findMany()
     * 
     * // Get first 10 Networks
     * const networks = await prisma.network.findMany({ take: 10 })
     * 
     * // Only select the `IdNet`
     * const networkWithIdNetOnly = await prisma.network.findMany({ select: { IdNet: true } })
     * 
     */
    findMany<T extends NetworkFindManyArgs>(args?: SelectSubset<T, NetworkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Network.
     * @param {NetworkCreateArgs} args - Arguments to create a Network.
     * @example
     * // Create one Network
     * const Network = await prisma.network.create({
     *   data: {
     *     // ... data to create a Network
     *   }
     * })
     * 
     */
    create<T extends NetworkCreateArgs>(args: SelectSubset<T, NetworkCreateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Networks.
     * @param {NetworkCreateManyArgs} args - Arguments to create many Networks.
     * @example
     * // Create many Networks
     * const network = await prisma.network.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkCreateManyArgs>(args?: SelectSubset<T, NetworkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Network.
     * @param {NetworkDeleteArgs} args - Arguments to delete one Network.
     * @example
     * // Delete one Network
     * const Network = await prisma.network.delete({
     *   where: {
     *     // ... filter to delete one Network
     *   }
     * })
     * 
     */
    delete<T extends NetworkDeleteArgs>(args: SelectSubset<T, NetworkDeleteArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Network.
     * @param {NetworkUpdateArgs} args - Arguments to update one Network.
     * @example
     * // Update one Network
     * const network = await prisma.network.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkUpdateArgs>(args: SelectSubset<T, NetworkUpdateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Networks.
     * @param {NetworkDeleteManyArgs} args - Arguments to filter Networks to delete.
     * @example
     * // Delete a few Networks
     * const { count } = await prisma.network.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkDeleteManyArgs>(args?: SelectSubset<T, NetworkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Networks
     * const network = await prisma.network.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkUpdateManyArgs>(args: SelectSubset<T, NetworkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Network.
     * @param {NetworkUpsertArgs} args - Arguments to update or create a Network.
     * @example
     * // Update or create a Network
     * const network = await prisma.network.upsert({
     *   create: {
     *     // ... data to create a Network
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Network we want to update
     *   }
     * })
     */
    upsert<T extends NetworkUpsertArgs>(args: SelectSubset<T, NetworkUpsertArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkCountArgs} args - Arguments to filter Networks to count.
     * @example
     * // Count the number of Networks
     * const count = await prisma.network.count({
     *   where: {
     *     // ... the filter for the Networks we want to count
     *   }
     * })
    **/
    count<T extends NetworkCountArgs>(
      args?: Subset<T, NetworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkAggregateArgs>(args: Subset<T, NetworkAggregateArgs>): Prisma.PrismaPromise<GetNetworkAggregateType<T>>

    /**
     * Group by Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkGroupByArgs['orderBy'] }
        : { orderBy?: NetworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Network model
   */
  readonly fields: NetworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Network.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Network model
   */ 
  interface NetworkFieldRefs {
    readonly IdNet: FieldRef<"Network", 'Int'>
    readonly Network: FieldRef<"Network", 'String'>
    readonly FIdSP: FieldRef<"Network", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Network findUnique
   */
  export type NetworkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findUniqueOrThrow
   */
  export type NetworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findFirst
   */
  export type NetworkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findFirstOrThrow
   */
  export type NetworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findMany
   */
  export type NetworkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter, which Networks to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network create
   */
  export type NetworkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * The data needed to create a Network.
     */
    data: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
  }

  /**
   * Network createMany
   */
  export type NetworkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Networks.
     */
    data: NetworkCreateManyInput | NetworkCreateManyInput[]
  }

  /**
   * Network update
   */
  export type NetworkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * The data needed to update a Network.
     */
    data: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
    /**
     * Choose, which Network to update.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network updateMany
   */
  export type NetworkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Networks.
     */
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyInput>
    /**
     * Filter which Networks to update
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to update.
     */
    limit?: number
  }

  /**
   * Network upsert
   */
  export type NetworkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * The filter to search for the Network to update in case it exists.
     */
    where: NetworkWhereUniqueInput
    /**
     * In case the Network found by the `where` argument doesn't exist, create a new Network with this data.
     */
    create: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
    /**
     * In case the Network was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
  }

  /**
   * Network delete
   */
  export type NetworkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Filter which Network to delete.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network deleteMany
   */
  export type NetworkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Networks to delete
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to delete.
     */
    limit?: number
  }

  /**
   * Network without action
   */
  export type NetworkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
  }


  /**
   * Model NoeKesht
   */

  export type AggregateNoeKesht = {
    _count: NoeKeshtCountAggregateOutputType | null
    _avg: NoeKeshtAvgAggregateOutputType | null
    _sum: NoeKeshtSumAggregateOutputType | null
    _min: NoeKeshtMinAggregateOutputType | null
    _max: NoeKeshtMaxAggregateOutputType | null
  }

  export type NoeKeshtAvgAggregateOutputType = {
    IdNoeK: number | null
  }

  export type NoeKeshtSumAggregateOutputType = {
    IdNoeK: number | null
  }

  export type NoeKeshtMinAggregateOutputType = {
    IdNoeK: number | null
    Kesht: string | null
  }

  export type NoeKeshtMaxAggregateOutputType = {
    IdNoeK: number | null
    Kesht: string | null
  }

  export type NoeKeshtCountAggregateOutputType = {
    IdNoeK: number
    Kesht: number
    _all: number
  }


  export type NoeKeshtAvgAggregateInputType = {
    IdNoeK?: true
  }

  export type NoeKeshtSumAggregateInputType = {
    IdNoeK?: true
  }

  export type NoeKeshtMinAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
  }

  export type NoeKeshtMaxAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
  }

  export type NoeKeshtCountAggregateInputType = {
    IdNoeK?: true
    Kesht?: true
    _all?: true
  }

  export type NoeKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeKesht to aggregate.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoeKeshts
    **/
    _count?: true | NoeKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoeKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoeKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoeKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoeKeshtMaxAggregateInputType
  }

  export type GetNoeKeshtAggregateType<T extends NoeKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateNoeKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoeKesht[P]>
      : GetScalarType<T[P], AggregateNoeKesht[P]>
  }




  export type NoeKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoeKeshtWhereInput
    orderBy?: NoeKeshtOrderByWithAggregationInput | NoeKeshtOrderByWithAggregationInput[]
    by: NoeKeshtScalarFieldEnum[] | NoeKeshtScalarFieldEnum
    having?: NoeKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoeKeshtCountAggregateInputType | true
    _avg?: NoeKeshtAvgAggregateInputType
    _sum?: NoeKeshtSumAggregateInputType
    _min?: NoeKeshtMinAggregateInputType
    _max?: NoeKeshtMaxAggregateInputType
  }

  export type NoeKeshtGroupByOutputType = {
    IdNoeK: number
    Kesht: string
    _count: NoeKeshtCountAggregateOutputType | null
    _avg: NoeKeshtAvgAggregateOutputType | null
    _sum: NoeKeshtSumAggregateOutputType | null
    _min: NoeKeshtMinAggregateOutputType | null
    _max: NoeKeshtMaxAggregateOutputType | null
  }

  type GetNoeKeshtGroupByPayload<T extends NoeKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoeKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoeKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoeKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], NoeKeshtGroupByOutputType[P]>
        }
      >
    >


  export type NoeKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNoeK?: boolean
    Kesht?: boolean
  }, ExtArgs["result"]["noeKesht"]>



  export type NoeKeshtSelectScalar = {
    IdNoeK?: boolean
    Kesht?: boolean
  }

  export type NoeKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNoeK" | "Kesht", ExtArgs["result"]["noeKesht"]>

  export type $NoeKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoeKesht"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdNoeK: number
      Kesht: string
    }, ExtArgs["result"]["noeKesht"]>
    composites: {}
  }

  type NoeKeshtGetPayload<S extends boolean | null | undefined | NoeKeshtDefaultArgs> = $Result.GetResult<Prisma.$NoeKeshtPayload, S>

  type NoeKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoeKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoeKeshtCountAggregateInputType | true
    }

  export interface NoeKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoeKesht'], meta: { name: 'NoeKesht' } }
    /**
     * Find zero or one NoeKesht that matches the filter.
     * @param {NoeKeshtFindUniqueArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoeKeshtFindUniqueArgs>(args: SelectSubset<T, NoeKeshtFindUniqueArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NoeKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoeKeshtFindUniqueOrThrowArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoeKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, NoeKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NoeKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindFirstArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoeKeshtFindFirstArgs>(args?: SelectSubset<T, NoeKeshtFindFirstArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NoeKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindFirstOrThrowArgs} args - Arguments to find a NoeKesht
     * @example
     * // Get one NoeKesht
     * const noeKesht = await prisma.noeKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoeKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, NoeKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NoeKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoeKeshts
     * const noeKeshts = await prisma.noeKesht.findMany()
     * 
     * // Get first 10 NoeKeshts
     * const noeKeshts = await prisma.noeKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdNoeK`
     * const noeKeshtWithIdNoeKOnly = await prisma.noeKesht.findMany({ select: { IdNoeK: true } })
     * 
     */
    findMany<T extends NoeKeshtFindManyArgs>(args?: SelectSubset<T, NoeKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NoeKesht.
     * @param {NoeKeshtCreateArgs} args - Arguments to create a NoeKesht.
     * @example
     * // Create one NoeKesht
     * const NoeKesht = await prisma.noeKesht.create({
     *   data: {
     *     // ... data to create a NoeKesht
     *   }
     * })
     * 
     */
    create<T extends NoeKeshtCreateArgs>(args: SelectSubset<T, NoeKeshtCreateArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NoeKeshts.
     * @param {NoeKeshtCreateManyArgs} args - Arguments to create many NoeKeshts.
     * @example
     * // Create many NoeKeshts
     * const noeKesht = await prisma.noeKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoeKeshtCreateManyArgs>(args?: SelectSubset<T, NoeKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoeKesht.
     * @param {NoeKeshtDeleteArgs} args - Arguments to delete one NoeKesht.
     * @example
     * // Delete one NoeKesht
     * const NoeKesht = await prisma.noeKesht.delete({
     *   where: {
     *     // ... filter to delete one NoeKesht
     *   }
     * })
     * 
     */
    delete<T extends NoeKeshtDeleteArgs>(args: SelectSubset<T, NoeKeshtDeleteArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NoeKesht.
     * @param {NoeKeshtUpdateArgs} args - Arguments to update one NoeKesht.
     * @example
     * // Update one NoeKesht
     * const noeKesht = await prisma.noeKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoeKeshtUpdateArgs>(args: SelectSubset<T, NoeKeshtUpdateArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NoeKeshts.
     * @param {NoeKeshtDeleteManyArgs} args - Arguments to filter NoeKeshts to delete.
     * @example
     * // Delete a few NoeKeshts
     * const { count } = await prisma.noeKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoeKeshtDeleteManyArgs>(args?: SelectSubset<T, NoeKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoeKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoeKeshts
     * const noeKesht = await prisma.noeKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoeKeshtUpdateManyArgs>(args: SelectSubset<T, NoeKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoeKesht.
     * @param {NoeKeshtUpsertArgs} args - Arguments to update or create a NoeKesht.
     * @example
     * // Update or create a NoeKesht
     * const noeKesht = await prisma.noeKesht.upsert({
     *   create: {
     *     // ... data to create a NoeKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoeKesht we want to update
     *   }
     * })
     */
    upsert<T extends NoeKeshtUpsertArgs>(args: SelectSubset<T, NoeKeshtUpsertArgs<ExtArgs>>): Prisma__NoeKeshtClient<$Result.GetResult<Prisma.$NoeKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NoeKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtCountArgs} args - Arguments to filter NoeKeshts to count.
     * @example
     * // Count the number of NoeKeshts
     * const count = await prisma.noeKesht.count({
     *   where: {
     *     // ... the filter for the NoeKeshts we want to count
     *   }
     * })
    **/
    count<T extends NoeKeshtCountArgs>(
      args?: Subset<T, NoeKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoeKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoeKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoeKeshtAggregateArgs>(args: Subset<T, NoeKeshtAggregateArgs>): Prisma.PrismaPromise<GetNoeKeshtAggregateType<T>>

    /**
     * Group by NoeKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoeKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoeKeshtGroupByArgs['orderBy'] }
        : { orderBy?: NoeKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoeKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoeKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoeKesht model
   */
  readonly fields: NoeKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoeKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoeKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoeKesht model
   */ 
  interface NoeKeshtFieldRefs {
    readonly IdNoeK: FieldRef<"NoeKesht", 'Int'>
    readonly Kesht: FieldRef<"NoeKesht", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NoeKesht findUnique
   */
  export type NoeKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht findUniqueOrThrow
   */
  export type NoeKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht findFirst
   */
  export type NoeKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeKeshts.
     */
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht findFirstOrThrow
   */
  export type NoeKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter, which NoeKesht to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeKeshts.
     */
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht findMany
   */
  export type NoeKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter, which NoeKeshts to fetch.
     */
    where?: NoeKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeKeshts to fetch.
     */
    orderBy?: NoeKeshtOrderByWithRelationInput | NoeKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoeKeshts.
     */
    cursor?: NoeKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeKeshts.
     */
    skip?: number
    distinct?: NoeKeshtScalarFieldEnum | NoeKeshtScalarFieldEnum[]
  }

  /**
   * NoeKesht create
   */
  export type NoeKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * The data needed to create a NoeKesht.
     */
    data: XOR<NoeKeshtCreateInput, NoeKeshtUncheckedCreateInput>
  }

  /**
   * NoeKesht createMany
   */
  export type NoeKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoeKeshts.
     */
    data: NoeKeshtCreateManyInput | NoeKeshtCreateManyInput[]
  }

  /**
   * NoeKesht update
   */
  export type NoeKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * The data needed to update a NoeKesht.
     */
    data: XOR<NoeKeshtUpdateInput, NoeKeshtUncheckedUpdateInput>
    /**
     * Choose, which NoeKesht to update.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht updateMany
   */
  export type NoeKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoeKeshts.
     */
    data: XOR<NoeKeshtUpdateManyMutationInput, NoeKeshtUncheckedUpdateManyInput>
    /**
     * Filter which NoeKeshts to update
     */
    where?: NoeKeshtWhereInput
    /**
     * Limit how many NoeKeshts to update.
     */
    limit?: number
  }

  /**
   * NoeKesht upsert
   */
  export type NoeKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * The filter to search for the NoeKesht to update in case it exists.
     */
    where: NoeKeshtWhereUniqueInput
    /**
     * In case the NoeKesht found by the `where` argument doesn't exist, create a new NoeKesht with this data.
     */
    create: XOR<NoeKeshtCreateInput, NoeKeshtUncheckedCreateInput>
    /**
     * In case the NoeKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoeKeshtUpdateInput, NoeKeshtUncheckedUpdateInput>
  }

  /**
   * NoeKesht delete
   */
  export type NoeKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
    /**
     * Filter which NoeKesht to delete.
     */
    where: NoeKeshtWhereUniqueInput
  }

  /**
   * NoeKesht deleteMany
   */
  export type NoeKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeKeshts to delete
     */
    where?: NoeKeshtWhereInput
    /**
     * Limit how many NoeKeshts to delete.
     */
    limit?: number
  }

  /**
   * NoeKesht without action
   */
  export type NoeKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeKesht
     */
    select?: NoeKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeKesht
     */
    omit?: NoeKeshtOmit<ExtArgs> | null
  }


  /**
   * Model NoeMahsool
   */

  export type AggregateNoeMahsool = {
    _count: NoeMahsoolCountAggregateOutputType | null
    _avg: NoeMahsoolAvgAggregateOutputType | null
    _sum: NoeMahsoolSumAggregateOutputType | null
    _min: NoeMahsoolMinAggregateOutputType | null
    _max: NoeMahsoolMaxAggregateOutputType | null
  }

  export type NoeMahsoolAvgAggregateOutputType = {
    IdNoeM: number | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolSumAggregateOutputType = {
    IdNoeM: number | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolMinAggregateOutputType = {
    IdNoeM: number | null
    Mahsool: string | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolMaxAggregateOutputType = {
    IdNoeM: number | null
    Mahsool: string | null
    FIdNoeK: number | null
  }

  export type NoeMahsoolCountAggregateOutputType = {
    IdNoeM: number
    Mahsool: number
    FIdNoeK: number
    _all: number
  }


  export type NoeMahsoolAvgAggregateInputType = {
    IdNoeM?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolSumAggregateInputType = {
    IdNoeM?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolMinAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolMaxAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
  }

  export type NoeMahsoolCountAggregateInputType = {
    IdNoeM?: true
    Mahsool?: true
    FIdNoeK?: true
    _all?: true
  }

  export type NoeMahsoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeMahsool to aggregate.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoeMahsools
    **/
    _count?: true | NoeMahsoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoeMahsoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoeMahsoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoeMahsoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoeMahsoolMaxAggregateInputType
  }

  export type GetNoeMahsoolAggregateType<T extends NoeMahsoolAggregateArgs> = {
        [P in keyof T & keyof AggregateNoeMahsool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoeMahsool[P]>
      : GetScalarType<T[P], AggregateNoeMahsool[P]>
  }




  export type NoeMahsoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoeMahsoolWhereInput
    orderBy?: NoeMahsoolOrderByWithAggregationInput | NoeMahsoolOrderByWithAggregationInput[]
    by: NoeMahsoolScalarFieldEnum[] | NoeMahsoolScalarFieldEnum
    having?: NoeMahsoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoeMahsoolCountAggregateInputType | true
    _avg?: NoeMahsoolAvgAggregateInputType
    _sum?: NoeMahsoolSumAggregateInputType
    _min?: NoeMahsoolMinAggregateInputType
    _max?: NoeMahsoolMaxAggregateInputType
  }

  export type NoeMahsoolGroupByOutputType = {
    IdNoeM: number
    Mahsool: string
    FIdNoeK: number
    _count: NoeMahsoolCountAggregateOutputType | null
    _avg: NoeMahsoolAvgAggregateOutputType | null
    _sum: NoeMahsoolSumAggregateOutputType | null
    _min: NoeMahsoolMinAggregateOutputType | null
    _max: NoeMahsoolMaxAggregateOutputType | null
  }

  type GetNoeMahsoolGroupByPayload<T extends NoeMahsoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoeMahsoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoeMahsoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoeMahsoolGroupByOutputType[P]>
            : GetScalarType<T[P], NoeMahsoolGroupByOutputType[P]>
        }
      >
    >


  export type NoeMahsoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNoeM?: boolean
    Mahsool?: boolean
    FIdNoeK?: boolean
  }, ExtArgs["result"]["noeMahsool"]>



  export type NoeMahsoolSelectScalar = {
    IdNoeM?: boolean
    Mahsool?: boolean
    FIdNoeK?: boolean
  }

  export type NoeMahsoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNoeM" | "Mahsool" | "FIdNoeK", ExtArgs["result"]["noeMahsool"]>

  export type $NoeMahsoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoeMahsool"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdNoeM: number
      Mahsool: string
      FIdNoeK: number
    }, ExtArgs["result"]["noeMahsool"]>
    composites: {}
  }

  type NoeMahsoolGetPayload<S extends boolean | null | undefined | NoeMahsoolDefaultArgs> = $Result.GetResult<Prisma.$NoeMahsoolPayload, S>

  type NoeMahsoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoeMahsoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoeMahsoolCountAggregateInputType | true
    }

  export interface NoeMahsoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoeMahsool'], meta: { name: 'NoeMahsool' } }
    /**
     * Find zero or one NoeMahsool that matches the filter.
     * @param {NoeMahsoolFindUniqueArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoeMahsoolFindUniqueArgs>(args: SelectSubset<T, NoeMahsoolFindUniqueArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NoeMahsool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoeMahsoolFindUniqueOrThrowArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoeMahsoolFindUniqueOrThrowArgs>(args: SelectSubset<T, NoeMahsoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NoeMahsool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindFirstArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoeMahsoolFindFirstArgs>(args?: SelectSubset<T, NoeMahsoolFindFirstArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NoeMahsool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindFirstOrThrowArgs} args - Arguments to find a NoeMahsool
     * @example
     * // Get one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoeMahsoolFindFirstOrThrowArgs>(args?: SelectSubset<T, NoeMahsoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NoeMahsools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoeMahsools
     * const noeMahsools = await prisma.noeMahsool.findMany()
     * 
     * // Get first 10 NoeMahsools
     * const noeMahsools = await prisma.noeMahsool.findMany({ take: 10 })
     * 
     * // Only select the `IdNoeM`
     * const noeMahsoolWithIdNoeMOnly = await prisma.noeMahsool.findMany({ select: { IdNoeM: true } })
     * 
     */
    findMany<T extends NoeMahsoolFindManyArgs>(args?: SelectSubset<T, NoeMahsoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NoeMahsool.
     * @param {NoeMahsoolCreateArgs} args - Arguments to create a NoeMahsool.
     * @example
     * // Create one NoeMahsool
     * const NoeMahsool = await prisma.noeMahsool.create({
     *   data: {
     *     // ... data to create a NoeMahsool
     *   }
     * })
     * 
     */
    create<T extends NoeMahsoolCreateArgs>(args: SelectSubset<T, NoeMahsoolCreateArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NoeMahsools.
     * @param {NoeMahsoolCreateManyArgs} args - Arguments to create many NoeMahsools.
     * @example
     * // Create many NoeMahsools
     * const noeMahsool = await prisma.noeMahsool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoeMahsoolCreateManyArgs>(args?: SelectSubset<T, NoeMahsoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoeMahsool.
     * @param {NoeMahsoolDeleteArgs} args - Arguments to delete one NoeMahsool.
     * @example
     * // Delete one NoeMahsool
     * const NoeMahsool = await prisma.noeMahsool.delete({
     *   where: {
     *     // ... filter to delete one NoeMahsool
     *   }
     * })
     * 
     */
    delete<T extends NoeMahsoolDeleteArgs>(args: SelectSubset<T, NoeMahsoolDeleteArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NoeMahsool.
     * @param {NoeMahsoolUpdateArgs} args - Arguments to update one NoeMahsool.
     * @example
     * // Update one NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoeMahsoolUpdateArgs>(args: SelectSubset<T, NoeMahsoolUpdateArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NoeMahsools.
     * @param {NoeMahsoolDeleteManyArgs} args - Arguments to filter NoeMahsools to delete.
     * @example
     * // Delete a few NoeMahsools
     * const { count } = await prisma.noeMahsool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoeMahsoolDeleteManyArgs>(args?: SelectSubset<T, NoeMahsoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoeMahsools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoeMahsools
     * const noeMahsool = await prisma.noeMahsool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoeMahsoolUpdateManyArgs>(args: SelectSubset<T, NoeMahsoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoeMahsool.
     * @param {NoeMahsoolUpsertArgs} args - Arguments to update or create a NoeMahsool.
     * @example
     * // Update or create a NoeMahsool
     * const noeMahsool = await prisma.noeMahsool.upsert({
     *   create: {
     *     // ... data to create a NoeMahsool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoeMahsool we want to update
     *   }
     * })
     */
    upsert<T extends NoeMahsoolUpsertArgs>(args: SelectSubset<T, NoeMahsoolUpsertArgs<ExtArgs>>): Prisma__NoeMahsoolClient<$Result.GetResult<Prisma.$NoeMahsoolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NoeMahsools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolCountArgs} args - Arguments to filter NoeMahsools to count.
     * @example
     * // Count the number of NoeMahsools
     * const count = await prisma.noeMahsool.count({
     *   where: {
     *     // ... the filter for the NoeMahsools we want to count
     *   }
     * })
    **/
    count<T extends NoeMahsoolCountArgs>(
      args?: Subset<T, NoeMahsoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoeMahsoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoeMahsool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoeMahsoolAggregateArgs>(args: Subset<T, NoeMahsoolAggregateArgs>): Prisma.PrismaPromise<GetNoeMahsoolAggregateType<T>>

    /**
     * Group by NoeMahsool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoeMahsoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoeMahsoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoeMahsoolGroupByArgs['orderBy'] }
        : { orderBy?: NoeMahsoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoeMahsoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoeMahsoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoeMahsool model
   */
  readonly fields: NoeMahsoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoeMahsool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoeMahsoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoeMahsool model
   */ 
  interface NoeMahsoolFieldRefs {
    readonly IdNoeM: FieldRef<"NoeMahsool", 'Int'>
    readonly Mahsool: FieldRef<"NoeMahsool", 'String'>
    readonly FIdNoeK: FieldRef<"NoeMahsool", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NoeMahsool findUnique
   */
  export type NoeMahsoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool findUniqueOrThrow
   */
  export type NoeMahsoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool findFirst
   */
  export type NoeMahsoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeMahsools.
     */
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool findFirstOrThrow
   */
  export type NoeMahsoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter, which NoeMahsool to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoeMahsools.
     */
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool findMany
   */
  export type NoeMahsoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter, which NoeMahsools to fetch.
     */
    where?: NoeMahsoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoeMahsools to fetch.
     */
    orderBy?: NoeMahsoolOrderByWithRelationInput | NoeMahsoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoeMahsools.
     */
    cursor?: NoeMahsoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoeMahsools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoeMahsools.
     */
    skip?: number
    distinct?: NoeMahsoolScalarFieldEnum | NoeMahsoolScalarFieldEnum[]
  }

  /**
   * NoeMahsool create
   */
  export type NoeMahsoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * The data needed to create a NoeMahsool.
     */
    data: XOR<NoeMahsoolCreateInput, NoeMahsoolUncheckedCreateInput>
  }

  /**
   * NoeMahsool createMany
   */
  export type NoeMahsoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoeMahsools.
     */
    data: NoeMahsoolCreateManyInput | NoeMahsoolCreateManyInput[]
  }

  /**
   * NoeMahsool update
   */
  export type NoeMahsoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * The data needed to update a NoeMahsool.
     */
    data: XOR<NoeMahsoolUpdateInput, NoeMahsoolUncheckedUpdateInput>
    /**
     * Choose, which NoeMahsool to update.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool updateMany
   */
  export type NoeMahsoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoeMahsools.
     */
    data: XOR<NoeMahsoolUpdateManyMutationInput, NoeMahsoolUncheckedUpdateManyInput>
    /**
     * Filter which NoeMahsools to update
     */
    where?: NoeMahsoolWhereInput
    /**
     * Limit how many NoeMahsools to update.
     */
    limit?: number
  }

  /**
   * NoeMahsool upsert
   */
  export type NoeMahsoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * The filter to search for the NoeMahsool to update in case it exists.
     */
    where: NoeMahsoolWhereUniqueInput
    /**
     * In case the NoeMahsool found by the `where` argument doesn't exist, create a new NoeMahsool with this data.
     */
    create: XOR<NoeMahsoolCreateInput, NoeMahsoolUncheckedCreateInput>
    /**
     * In case the NoeMahsool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoeMahsoolUpdateInput, NoeMahsoolUncheckedUpdateInput>
  }

  /**
   * NoeMahsool delete
   */
  export type NoeMahsoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
    /**
     * Filter which NoeMahsool to delete.
     */
    where: NoeMahsoolWhereUniqueInput
  }

  /**
   * NoeMahsool deleteMany
   */
  export type NoeMahsoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoeMahsools to delete
     */
    where?: NoeMahsoolWhereInput
    /**
     * Limit how many NoeMahsools to delete.
     */
    limit?: number
  }

  /**
   * NoeMahsool without action
   */
  export type NoeMahsoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoeMahsool
     */
    select?: NoeMahsoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoeMahsool
     */
    omit?: NoeMahsoolOmit<ExtArgs> | null
  }


  /**
   * Model NonFIT
   */

  export type AggregateNonFIT = {
    _count: NonFITCountAggregateOutputType | null
    _avg: NonFITAvgAggregateOutputType | null
    _sum: NonFITSumAggregateOutputType | null
    _min: NonFITMinAggregateOutputType | null
    _max: NonFITMaxAggregateOutputType | null
  }

  export type NonFITAvgAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITSumAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITMinAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITMaxAggregateOutputType = {
    IdNonFIT: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    VOLUM: number | null
  }

  export type NonFITCountAggregateOutputType = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor: number
    VOLUM: number
    _all: number
  }


  export type NonFITAvgAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITSumAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITMinAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITMaxAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
  }

  export type NonFITCountAggregateInputType = {
    IdNonFIT?: true
    FIdRanesh?: true
    FIdTarDor?: true
    VOLUM?: true
    _all?: true
  }

  export type NonFITAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonFIT to aggregate.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NonFITS
    **/
    _count?: true | NonFITCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonFITAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonFITSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonFITMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonFITMaxAggregateInputType
  }

  export type GetNonFITAggregateType<T extends NonFITAggregateArgs> = {
        [P in keyof T & keyof AggregateNonFIT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonFIT[P]>
      : GetScalarType<T[P], AggregateNonFIT[P]>
  }




  export type NonFITGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NonFITWhereInput
    orderBy?: NonFITOrderByWithAggregationInput | NonFITOrderByWithAggregationInput[]
    by: NonFITScalarFieldEnum[] | NonFITScalarFieldEnum
    having?: NonFITScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonFITCountAggregateInputType | true
    _avg?: NonFITAvgAggregateInputType
    _sum?: NonFITSumAggregateInputType
    _min?: NonFITMinAggregateInputType
    _max?: NonFITMaxAggregateInputType
  }

  export type NonFITGroupByOutputType = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor: number
    VOLUM: number
    _count: NonFITCountAggregateOutputType | null
    _avg: NonFITAvgAggregateOutputType | null
    _sum: NonFITSumAggregateOutputType | null
    _min: NonFITMinAggregateOutputType | null
    _max: NonFITMaxAggregateOutputType | null
  }

  type GetNonFITGroupByPayload<T extends NonFITGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NonFITGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonFITGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonFITGroupByOutputType[P]>
            : GetScalarType<T[P], NonFITGroupByOutputType[P]>
        }
      >
    >


  export type NonFITSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdNonFIT?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    VOLUM?: boolean
  }, ExtArgs["result"]["nonFIT"]>



  export type NonFITSelectScalar = {
    IdNonFIT?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    VOLUM?: boolean
  }

  export type NonFITOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdNonFIT" | "FIdRanesh" | "FIdTarDor" | "VOLUM", ExtArgs["result"]["nonFIT"]>

  export type $NonFITPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NonFIT"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdNonFIT: number
      FIdRanesh: number
      FIdTarDor: number
      VOLUM: number
    }, ExtArgs["result"]["nonFIT"]>
    composites: {}
  }

  type NonFITGetPayload<S extends boolean | null | undefined | NonFITDefaultArgs> = $Result.GetResult<Prisma.$NonFITPayload, S>

  type NonFITCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NonFITFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NonFITCountAggregateInputType | true
    }

  export interface NonFITDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NonFIT'], meta: { name: 'NonFIT' } }
    /**
     * Find zero or one NonFIT that matches the filter.
     * @param {NonFITFindUniqueArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NonFITFindUniqueArgs>(args: SelectSubset<T, NonFITFindUniqueArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NonFIT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NonFITFindUniqueOrThrowArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NonFITFindUniqueOrThrowArgs>(args: SelectSubset<T, NonFITFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NonFIT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindFirstArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NonFITFindFirstArgs>(args?: SelectSubset<T, NonFITFindFirstArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NonFIT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindFirstOrThrowArgs} args - Arguments to find a NonFIT
     * @example
     * // Get one NonFIT
     * const nonFIT = await prisma.nonFIT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NonFITFindFirstOrThrowArgs>(args?: SelectSubset<T, NonFITFindFirstOrThrowArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NonFITS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NonFITS
     * const nonFITS = await prisma.nonFIT.findMany()
     * 
     * // Get first 10 NonFITS
     * const nonFITS = await prisma.nonFIT.findMany({ take: 10 })
     * 
     * // Only select the `IdNonFIT`
     * const nonFITWithIdNonFITOnly = await prisma.nonFIT.findMany({ select: { IdNonFIT: true } })
     * 
     */
    findMany<T extends NonFITFindManyArgs>(args?: SelectSubset<T, NonFITFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NonFIT.
     * @param {NonFITCreateArgs} args - Arguments to create a NonFIT.
     * @example
     * // Create one NonFIT
     * const NonFIT = await prisma.nonFIT.create({
     *   data: {
     *     // ... data to create a NonFIT
     *   }
     * })
     * 
     */
    create<T extends NonFITCreateArgs>(args: SelectSubset<T, NonFITCreateArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NonFITS.
     * @param {NonFITCreateManyArgs} args - Arguments to create many NonFITS.
     * @example
     * // Create many NonFITS
     * const nonFIT = await prisma.nonFIT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NonFITCreateManyArgs>(args?: SelectSubset<T, NonFITCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NonFIT.
     * @param {NonFITDeleteArgs} args - Arguments to delete one NonFIT.
     * @example
     * // Delete one NonFIT
     * const NonFIT = await prisma.nonFIT.delete({
     *   where: {
     *     // ... filter to delete one NonFIT
     *   }
     * })
     * 
     */
    delete<T extends NonFITDeleteArgs>(args: SelectSubset<T, NonFITDeleteArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NonFIT.
     * @param {NonFITUpdateArgs} args - Arguments to update one NonFIT.
     * @example
     * // Update one NonFIT
     * const nonFIT = await prisma.nonFIT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NonFITUpdateArgs>(args: SelectSubset<T, NonFITUpdateArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NonFITS.
     * @param {NonFITDeleteManyArgs} args - Arguments to filter NonFITS to delete.
     * @example
     * // Delete a few NonFITS
     * const { count } = await prisma.nonFIT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NonFITDeleteManyArgs>(args?: SelectSubset<T, NonFITDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonFITS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NonFITS
     * const nonFIT = await prisma.nonFIT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NonFITUpdateManyArgs>(args: SelectSubset<T, NonFITUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NonFIT.
     * @param {NonFITUpsertArgs} args - Arguments to update or create a NonFIT.
     * @example
     * // Update or create a NonFIT
     * const nonFIT = await prisma.nonFIT.upsert({
     *   create: {
     *     // ... data to create a NonFIT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NonFIT we want to update
     *   }
     * })
     */
    upsert<T extends NonFITUpsertArgs>(args: SelectSubset<T, NonFITUpsertArgs<ExtArgs>>): Prisma__NonFITClient<$Result.GetResult<Prisma.$NonFITPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NonFITS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITCountArgs} args - Arguments to filter NonFITS to count.
     * @example
     * // Count the number of NonFITS
     * const count = await prisma.nonFIT.count({
     *   where: {
     *     // ... the filter for the NonFITS we want to count
     *   }
     * })
    **/
    count<T extends NonFITCountArgs>(
      args?: Subset<T, NonFITCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonFITCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NonFIT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonFITAggregateArgs>(args: Subset<T, NonFITAggregateArgs>): Prisma.PrismaPromise<GetNonFITAggregateType<T>>

    /**
     * Group by NonFIT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonFITGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonFITGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonFITGroupByArgs['orderBy'] }
        : { orderBy?: NonFITGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonFITGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonFITGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NonFIT model
   */
  readonly fields: NonFITFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NonFIT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NonFITClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NonFIT model
   */ 
  interface NonFITFieldRefs {
    readonly IdNonFIT: FieldRef<"NonFIT", 'Int'>
    readonly FIdRanesh: FieldRef<"NonFIT", 'Int'>
    readonly FIdTarDor: FieldRef<"NonFIT", 'Int'>
    readonly VOLUM: FieldRef<"NonFIT", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NonFIT findUnique
   */
  export type NonFITFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT findUniqueOrThrow
   */
  export type NonFITFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT findFirst
   */
  export type NonFITFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonFITS.
     */
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT findFirstOrThrow
   */
  export type NonFITFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter, which NonFIT to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonFITS.
     */
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT findMany
   */
  export type NonFITFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter, which NonFITS to fetch.
     */
    where?: NonFITWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonFITS to fetch.
     */
    orderBy?: NonFITOrderByWithRelationInput | NonFITOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NonFITS.
     */
    cursor?: NonFITWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonFITS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonFITS.
     */
    skip?: number
    distinct?: NonFITScalarFieldEnum | NonFITScalarFieldEnum[]
  }

  /**
   * NonFIT create
   */
  export type NonFITCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * The data needed to create a NonFIT.
     */
    data: XOR<NonFITCreateInput, NonFITUncheckedCreateInput>
  }

  /**
   * NonFIT createMany
   */
  export type NonFITCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NonFITS.
     */
    data: NonFITCreateManyInput | NonFITCreateManyInput[]
  }

  /**
   * NonFIT update
   */
  export type NonFITUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * The data needed to update a NonFIT.
     */
    data: XOR<NonFITUpdateInput, NonFITUncheckedUpdateInput>
    /**
     * Choose, which NonFIT to update.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT updateMany
   */
  export type NonFITUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NonFITS.
     */
    data: XOR<NonFITUpdateManyMutationInput, NonFITUncheckedUpdateManyInput>
    /**
     * Filter which NonFITS to update
     */
    where?: NonFITWhereInput
    /**
     * Limit how many NonFITS to update.
     */
    limit?: number
  }

  /**
   * NonFIT upsert
   */
  export type NonFITUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * The filter to search for the NonFIT to update in case it exists.
     */
    where: NonFITWhereUniqueInput
    /**
     * In case the NonFIT found by the `where` argument doesn't exist, create a new NonFIT with this data.
     */
    create: XOR<NonFITCreateInput, NonFITUncheckedCreateInput>
    /**
     * In case the NonFIT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonFITUpdateInput, NonFITUncheckedUpdateInput>
  }

  /**
   * NonFIT delete
   */
  export type NonFITDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
    /**
     * Filter which NonFIT to delete.
     */
    where: NonFITWhereUniqueInput
  }

  /**
   * NonFIT deleteMany
   */
  export type NonFITDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NonFITS to delete
     */
    where?: NonFITWhereInput
    /**
     * Limit how many NonFITS to delete.
     */
    limit?: number
  }

  /**
   * NonFIT without action
   */
  export type NonFITDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NonFIT
     */
    select?: NonFITSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NonFIT
     */
    omit?: NonFITOmit<ExtArgs> | null
  }


  /**
   * Model PumpStation
   */

  export type AggregatePumpStation = {
    _count: PumpStationCountAggregateOutputType | null
    _avg: PumpStationAvgAggregateOutputType | null
    _sum: PumpStationSumAggregateOutputType | null
    _min: PumpStationMinAggregateOutputType | null
    _max: PumpStationMaxAggregateOutputType | null
  }

  export type PumpStationAvgAggregateOutputType = {
    IdPumpSta: number | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
  }

  export type PumpStationSumAggregateOutputType = {
    IdPumpSta: number | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
  }

  export type PumpStationMinAggregateOutputType = {
    IdPumpSta: number | null
    NameStation: string | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
  }

  export type PumpStationMaxAggregateOutputType = {
    IdPumpSta: number | null
    NameStation: string | null
    KM: number | null
    FIdNet: number | null
    FIdDStation: number | null
    FIdMakhzan: number | null
  }

  export type PumpStationCountAggregateOutputType = {
    IdPumpSta: number
    NameStation: number
    KM: number
    FIdNet: number
    FIdDStation: number
    FIdMakhzan: number
    _all: number
  }


  export type PumpStationAvgAggregateInputType = {
    IdPumpSta?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
  }

  export type PumpStationSumAggregateInputType = {
    IdPumpSta?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
  }

  export type PumpStationMinAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
  }

  export type PumpStationMaxAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
  }

  export type PumpStationCountAggregateInputType = {
    IdPumpSta?: true
    NameStation?: true
    KM?: true
    FIdNet?: true
    FIdDStation?: true
    FIdMakhzan?: true
    _all?: true
  }

  export type PumpStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpStation to aggregate.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PumpStations
    **/
    _count?: true | PumpStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PumpStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PumpStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PumpStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PumpStationMaxAggregateInputType
  }

  export type GetPumpStationAggregateType<T extends PumpStationAggregateArgs> = {
        [P in keyof T & keyof AggregatePumpStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePumpStation[P]>
      : GetScalarType<T[P], AggregatePumpStation[P]>
  }




  export type PumpStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpStationWhereInput
    orderBy?: PumpStationOrderByWithAggregationInput | PumpStationOrderByWithAggregationInput[]
    by: PumpStationScalarFieldEnum[] | PumpStationScalarFieldEnum
    having?: PumpStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PumpStationCountAggregateInputType | true
    _avg?: PumpStationAvgAggregateInputType
    _sum?: PumpStationSumAggregateInputType
    _min?: PumpStationMinAggregateInputType
    _max?: PumpStationMaxAggregateInputType
  }

  export type PumpStationGroupByOutputType = {
    IdPumpSta: number
    NameStation: string
    KM: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan: number | null
    _count: PumpStationCountAggregateOutputType | null
    _avg: PumpStationAvgAggregateOutputType | null
    _sum: PumpStationSumAggregateOutputType | null
    _min: PumpStationMinAggregateOutputType | null
    _max: PumpStationMaxAggregateOutputType | null
  }

  type GetPumpStationGroupByPayload<T extends PumpStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PumpStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PumpStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PumpStationGroupByOutputType[P]>
            : GetScalarType<T[P], PumpStationGroupByOutputType[P]>
        }
      >
    >


  export type PumpStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPumpSta?: boolean
    NameStation?: boolean
    KM?: boolean
    FIdNet?: boolean
    FIdDStation?: boolean
    FIdMakhzan?: boolean
  }, ExtArgs["result"]["pumpStation"]>



  export type PumpStationSelectScalar = {
    IdPumpSta?: boolean
    NameStation?: boolean
    KM?: boolean
    FIdNet?: boolean
    FIdDStation?: boolean
    FIdMakhzan?: boolean
  }

  export type PumpStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdPumpSta" | "NameStation" | "KM" | "FIdNet" | "FIdDStation" | "FIdMakhzan", ExtArgs["result"]["pumpStation"]>

  export type $PumpStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PumpStation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPumpSta: number
      NameStation: string
      KM: number | null
      FIdNet: number
      FIdDStation: number
      FIdMakhzan: number | null
    }, ExtArgs["result"]["pumpStation"]>
    composites: {}
  }

  type PumpStationGetPayload<S extends boolean | null | undefined | PumpStationDefaultArgs> = $Result.GetResult<Prisma.$PumpStationPayload, S>

  type PumpStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PumpStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PumpStationCountAggregateInputType | true
    }

  export interface PumpStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PumpStation'], meta: { name: 'PumpStation' } }
    /**
     * Find zero or one PumpStation that matches the filter.
     * @param {PumpStationFindUniqueArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PumpStationFindUniqueArgs>(args: SelectSubset<T, PumpStationFindUniqueArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PumpStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PumpStationFindUniqueOrThrowArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PumpStationFindUniqueOrThrowArgs>(args: SelectSubset<T, PumpStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PumpStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindFirstArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PumpStationFindFirstArgs>(args?: SelectSubset<T, PumpStationFindFirstArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PumpStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindFirstOrThrowArgs} args - Arguments to find a PumpStation
     * @example
     * // Get one PumpStation
     * const pumpStation = await prisma.pumpStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PumpStationFindFirstOrThrowArgs>(args?: SelectSubset<T, PumpStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PumpStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PumpStations
     * const pumpStations = await prisma.pumpStation.findMany()
     * 
     * // Get first 10 PumpStations
     * const pumpStations = await prisma.pumpStation.findMany({ take: 10 })
     * 
     * // Only select the `IdPumpSta`
     * const pumpStationWithIdPumpStaOnly = await prisma.pumpStation.findMany({ select: { IdPumpSta: true } })
     * 
     */
    findMany<T extends PumpStationFindManyArgs>(args?: SelectSubset<T, PumpStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PumpStation.
     * @param {PumpStationCreateArgs} args - Arguments to create a PumpStation.
     * @example
     * // Create one PumpStation
     * const PumpStation = await prisma.pumpStation.create({
     *   data: {
     *     // ... data to create a PumpStation
     *   }
     * })
     * 
     */
    create<T extends PumpStationCreateArgs>(args: SelectSubset<T, PumpStationCreateArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PumpStations.
     * @param {PumpStationCreateManyArgs} args - Arguments to create many PumpStations.
     * @example
     * // Create many PumpStations
     * const pumpStation = await prisma.pumpStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PumpStationCreateManyArgs>(args?: SelectSubset<T, PumpStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PumpStation.
     * @param {PumpStationDeleteArgs} args - Arguments to delete one PumpStation.
     * @example
     * // Delete one PumpStation
     * const PumpStation = await prisma.pumpStation.delete({
     *   where: {
     *     // ... filter to delete one PumpStation
     *   }
     * })
     * 
     */
    delete<T extends PumpStationDeleteArgs>(args: SelectSubset<T, PumpStationDeleteArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PumpStation.
     * @param {PumpStationUpdateArgs} args - Arguments to update one PumpStation.
     * @example
     * // Update one PumpStation
     * const pumpStation = await prisma.pumpStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PumpStationUpdateArgs>(args: SelectSubset<T, PumpStationUpdateArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PumpStations.
     * @param {PumpStationDeleteManyArgs} args - Arguments to filter PumpStations to delete.
     * @example
     * // Delete a few PumpStations
     * const { count } = await prisma.pumpStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PumpStationDeleteManyArgs>(args?: SelectSubset<T, PumpStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PumpStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PumpStations
     * const pumpStation = await prisma.pumpStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PumpStationUpdateManyArgs>(args: SelectSubset<T, PumpStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PumpStation.
     * @param {PumpStationUpsertArgs} args - Arguments to update or create a PumpStation.
     * @example
     * // Update or create a PumpStation
     * const pumpStation = await prisma.pumpStation.upsert({
     *   create: {
     *     // ... data to create a PumpStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PumpStation we want to update
     *   }
     * })
     */
    upsert<T extends PumpStationUpsertArgs>(args: SelectSubset<T, PumpStationUpsertArgs<ExtArgs>>): Prisma__PumpStationClient<$Result.GetResult<Prisma.$PumpStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PumpStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationCountArgs} args - Arguments to filter PumpStations to count.
     * @example
     * // Count the number of PumpStations
     * const count = await prisma.pumpStation.count({
     *   where: {
     *     // ... the filter for the PumpStations we want to count
     *   }
     * })
    **/
    count<T extends PumpStationCountArgs>(
      args?: Subset<T, PumpStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PumpStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PumpStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PumpStationAggregateArgs>(args: Subset<T, PumpStationAggregateArgs>): Prisma.PrismaPromise<GetPumpStationAggregateType<T>>

    /**
     * Group by PumpStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PumpStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PumpStationGroupByArgs['orderBy'] }
        : { orderBy?: PumpStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PumpStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPumpStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PumpStation model
   */
  readonly fields: PumpStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PumpStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PumpStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PumpStation model
   */ 
  interface PumpStationFieldRefs {
    readonly IdPumpSta: FieldRef<"PumpStation", 'Int'>
    readonly NameStation: FieldRef<"PumpStation", 'String'>
    readonly KM: FieldRef<"PumpStation", 'Int'>
    readonly FIdNet: FieldRef<"PumpStation", 'Int'>
    readonly FIdDStation: FieldRef<"PumpStation", 'Int'>
    readonly FIdMakhzan: FieldRef<"PumpStation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PumpStation findUnique
   */
  export type PumpStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation findUniqueOrThrow
   */
  export type PumpStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation findFirst
   */
  export type PumpStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpStations.
     */
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation findFirstOrThrow
   */
  export type PumpStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter, which PumpStation to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpStations.
     */
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation findMany
   */
  export type PumpStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter, which PumpStations to fetch.
     */
    where?: PumpStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpStations to fetch.
     */
    orderBy?: PumpStationOrderByWithRelationInput | PumpStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PumpStations.
     */
    cursor?: PumpStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpStations.
     */
    skip?: number
    distinct?: PumpStationScalarFieldEnum | PumpStationScalarFieldEnum[]
  }

  /**
   * PumpStation create
   */
  export type PumpStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * The data needed to create a PumpStation.
     */
    data: XOR<PumpStationCreateInput, PumpStationUncheckedCreateInput>
  }

  /**
   * PumpStation createMany
   */
  export type PumpStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PumpStations.
     */
    data: PumpStationCreateManyInput | PumpStationCreateManyInput[]
  }

  /**
   * PumpStation update
   */
  export type PumpStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * The data needed to update a PumpStation.
     */
    data: XOR<PumpStationUpdateInput, PumpStationUncheckedUpdateInput>
    /**
     * Choose, which PumpStation to update.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation updateMany
   */
  export type PumpStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PumpStations.
     */
    data: XOR<PumpStationUpdateManyMutationInput, PumpStationUncheckedUpdateManyInput>
    /**
     * Filter which PumpStations to update
     */
    where?: PumpStationWhereInput
    /**
     * Limit how many PumpStations to update.
     */
    limit?: number
  }

  /**
   * PumpStation upsert
   */
  export type PumpStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * The filter to search for the PumpStation to update in case it exists.
     */
    where: PumpStationWhereUniqueInput
    /**
     * In case the PumpStation found by the `where` argument doesn't exist, create a new PumpStation with this data.
     */
    create: XOR<PumpStationCreateInput, PumpStationUncheckedCreateInput>
    /**
     * In case the PumpStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PumpStationUpdateInput, PumpStationUncheckedUpdateInput>
  }

  /**
   * PumpStation delete
   */
  export type PumpStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
    /**
     * Filter which PumpStation to delete.
     */
    where: PumpStationWhereUniqueInput
  }

  /**
   * PumpStation deleteMany
   */
  export type PumpStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpStations to delete
     */
    where?: PumpStationWhereInput
    /**
     * Limit how many PumpStations to delete.
     */
    limit?: number
  }

  /**
   * PumpStation without action
   */
  export type PumpStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpStation
     */
    select?: PumpStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpStation
     */
    omit?: PumpStationOmit<ExtArgs> | null
  }


  /**
   * Model PumpType
   */

  export type AggregatePumpType = {
    _count: PumpTypeCountAggregateOutputType | null
    _avg: PumpTypeAvgAggregateOutputType | null
    _sum: PumpTypeSumAggregateOutputType | null
    _min: PumpTypeMinAggregateOutputType | null
    _max: PumpTypeMaxAggregateOutputType | null
  }

  export type PumpTypeAvgAggregateOutputType = {
    IdPump: number | null
  }

  export type PumpTypeSumAggregateOutputType = {
    IdPump: number | null
  }

  export type PumpTypeMinAggregateOutputType = {
    IdPump: number | null
    PumpType: string | null
  }

  export type PumpTypeMaxAggregateOutputType = {
    IdPump: number | null
    PumpType: string | null
  }

  export type PumpTypeCountAggregateOutputType = {
    IdPump: number
    PumpType: number
    _all: number
  }


  export type PumpTypeAvgAggregateInputType = {
    IdPump?: true
  }

  export type PumpTypeSumAggregateInputType = {
    IdPump?: true
  }

  export type PumpTypeMinAggregateInputType = {
    IdPump?: true
    PumpType?: true
  }

  export type PumpTypeMaxAggregateInputType = {
    IdPump?: true
    PumpType?: true
  }

  export type PumpTypeCountAggregateInputType = {
    IdPump?: true
    PumpType?: true
    _all?: true
  }

  export type PumpTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpType to aggregate.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PumpTypes
    **/
    _count?: true | PumpTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PumpTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PumpTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PumpTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PumpTypeMaxAggregateInputType
  }

  export type GetPumpTypeAggregateType<T extends PumpTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePumpType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePumpType[P]>
      : GetScalarType<T[P], AggregatePumpType[P]>
  }




  export type PumpTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PumpTypeWhereInput
    orderBy?: PumpTypeOrderByWithAggregationInput | PumpTypeOrderByWithAggregationInput[]
    by: PumpTypeScalarFieldEnum[] | PumpTypeScalarFieldEnum
    having?: PumpTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PumpTypeCountAggregateInputType | true
    _avg?: PumpTypeAvgAggregateInputType
    _sum?: PumpTypeSumAggregateInputType
    _min?: PumpTypeMinAggregateInputType
    _max?: PumpTypeMaxAggregateInputType
  }

  export type PumpTypeGroupByOutputType = {
    IdPump: number
    PumpType: string
    _count: PumpTypeCountAggregateOutputType | null
    _avg: PumpTypeAvgAggregateOutputType | null
    _sum: PumpTypeSumAggregateOutputType | null
    _min: PumpTypeMinAggregateOutputType | null
    _max: PumpTypeMaxAggregateOutputType | null
  }

  type GetPumpTypeGroupByPayload<T extends PumpTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PumpTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PumpTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PumpTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PumpTypeGroupByOutputType[P]>
        }
      >
    >


  export type PumpTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPump?: boolean
    PumpType?: boolean
  }, ExtArgs["result"]["pumpType"]>



  export type PumpTypeSelectScalar = {
    IdPump?: boolean
    PumpType?: boolean
  }

  export type PumpTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdPump" | "PumpType", ExtArgs["result"]["pumpType"]>

  export type $PumpTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PumpType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPump: number
      PumpType: string
    }, ExtArgs["result"]["pumpType"]>
    composites: {}
  }

  type PumpTypeGetPayload<S extends boolean | null | undefined | PumpTypeDefaultArgs> = $Result.GetResult<Prisma.$PumpTypePayload, S>

  type PumpTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PumpTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PumpTypeCountAggregateInputType | true
    }

  export interface PumpTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PumpType'], meta: { name: 'PumpType' } }
    /**
     * Find zero or one PumpType that matches the filter.
     * @param {PumpTypeFindUniqueArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PumpTypeFindUniqueArgs>(args: SelectSubset<T, PumpTypeFindUniqueArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PumpType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PumpTypeFindUniqueOrThrowArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PumpTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PumpTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PumpType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindFirstArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PumpTypeFindFirstArgs>(args?: SelectSubset<T, PumpTypeFindFirstArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PumpType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindFirstOrThrowArgs} args - Arguments to find a PumpType
     * @example
     * // Get one PumpType
     * const pumpType = await prisma.pumpType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PumpTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PumpTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PumpTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PumpTypes
     * const pumpTypes = await prisma.pumpType.findMany()
     * 
     * // Get first 10 PumpTypes
     * const pumpTypes = await prisma.pumpType.findMany({ take: 10 })
     * 
     * // Only select the `IdPump`
     * const pumpTypeWithIdPumpOnly = await prisma.pumpType.findMany({ select: { IdPump: true } })
     * 
     */
    findMany<T extends PumpTypeFindManyArgs>(args?: SelectSubset<T, PumpTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PumpType.
     * @param {PumpTypeCreateArgs} args - Arguments to create a PumpType.
     * @example
     * // Create one PumpType
     * const PumpType = await prisma.pumpType.create({
     *   data: {
     *     // ... data to create a PumpType
     *   }
     * })
     * 
     */
    create<T extends PumpTypeCreateArgs>(args: SelectSubset<T, PumpTypeCreateArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PumpTypes.
     * @param {PumpTypeCreateManyArgs} args - Arguments to create many PumpTypes.
     * @example
     * // Create many PumpTypes
     * const pumpType = await prisma.pumpType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PumpTypeCreateManyArgs>(args?: SelectSubset<T, PumpTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PumpType.
     * @param {PumpTypeDeleteArgs} args - Arguments to delete one PumpType.
     * @example
     * // Delete one PumpType
     * const PumpType = await prisma.pumpType.delete({
     *   where: {
     *     // ... filter to delete one PumpType
     *   }
     * })
     * 
     */
    delete<T extends PumpTypeDeleteArgs>(args: SelectSubset<T, PumpTypeDeleteArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PumpType.
     * @param {PumpTypeUpdateArgs} args - Arguments to update one PumpType.
     * @example
     * // Update one PumpType
     * const pumpType = await prisma.pumpType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PumpTypeUpdateArgs>(args: SelectSubset<T, PumpTypeUpdateArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PumpTypes.
     * @param {PumpTypeDeleteManyArgs} args - Arguments to filter PumpTypes to delete.
     * @example
     * // Delete a few PumpTypes
     * const { count } = await prisma.pumpType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PumpTypeDeleteManyArgs>(args?: SelectSubset<T, PumpTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PumpTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PumpTypes
     * const pumpType = await prisma.pumpType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PumpTypeUpdateManyArgs>(args: SelectSubset<T, PumpTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PumpType.
     * @param {PumpTypeUpsertArgs} args - Arguments to update or create a PumpType.
     * @example
     * // Update or create a PumpType
     * const pumpType = await prisma.pumpType.upsert({
     *   create: {
     *     // ... data to create a PumpType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PumpType we want to update
     *   }
     * })
     */
    upsert<T extends PumpTypeUpsertArgs>(args: SelectSubset<T, PumpTypeUpsertArgs<ExtArgs>>): Prisma__PumpTypeClient<$Result.GetResult<Prisma.$PumpTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PumpTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeCountArgs} args - Arguments to filter PumpTypes to count.
     * @example
     * // Count the number of PumpTypes
     * const count = await prisma.pumpType.count({
     *   where: {
     *     // ... the filter for the PumpTypes we want to count
     *   }
     * })
    **/
    count<T extends PumpTypeCountArgs>(
      args?: Subset<T, PumpTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PumpTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PumpType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PumpTypeAggregateArgs>(args: Subset<T, PumpTypeAggregateArgs>): Prisma.PrismaPromise<GetPumpTypeAggregateType<T>>

    /**
     * Group by PumpType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PumpTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PumpTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PumpTypeGroupByArgs['orderBy'] }
        : { orderBy?: PumpTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PumpTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPumpTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PumpType model
   */
  readonly fields: PumpTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PumpType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PumpTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PumpType model
   */ 
  interface PumpTypeFieldRefs {
    readonly IdPump: FieldRef<"PumpType", 'Int'>
    readonly PumpType: FieldRef<"PumpType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PumpType findUnique
   */
  export type PumpTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType findUniqueOrThrow
   */
  export type PumpTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType findFirst
   */
  export type PumpTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpTypes.
     */
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType findFirstOrThrow
   */
  export type PumpTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter, which PumpType to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PumpTypes.
     */
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType findMany
   */
  export type PumpTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter, which PumpTypes to fetch.
     */
    where?: PumpTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PumpTypes to fetch.
     */
    orderBy?: PumpTypeOrderByWithRelationInput | PumpTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PumpTypes.
     */
    cursor?: PumpTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PumpTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PumpTypes.
     */
    skip?: number
    distinct?: PumpTypeScalarFieldEnum | PumpTypeScalarFieldEnum[]
  }

  /**
   * PumpType create
   */
  export type PumpTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a PumpType.
     */
    data: XOR<PumpTypeCreateInput, PumpTypeUncheckedCreateInput>
  }

  /**
   * PumpType createMany
   */
  export type PumpTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PumpTypes.
     */
    data: PumpTypeCreateManyInput | PumpTypeCreateManyInput[]
  }

  /**
   * PumpType update
   */
  export type PumpTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a PumpType.
     */
    data: XOR<PumpTypeUpdateInput, PumpTypeUncheckedUpdateInput>
    /**
     * Choose, which PumpType to update.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType updateMany
   */
  export type PumpTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PumpTypes.
     */
    data: XOR<PumpTypeUpdateManyMutationInput, PumpTypeUncheckedUpdateManyInput>
    /**
     * Filter which PumpTypes to update
     */
    where?: PumpTypeWhereInput
    /**
     * Limit how many PumpTypes to update.
     */
    limit?: number
  }

  /**
   * PumpType upsert
   */
  export type PumpTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the PumpType to update in case it exists.
     */
    where: PumpTypeWhereUniqueInput
    /**
     * In case the PumpType found by the `where` argument doesn't exist, create a new PumpType with this data.
     */
    create: XOR<PumpTypeCreateInput, PumpTypeUncheckedCreateInput>
    /**
     * In case the PumpType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PumpTypeUpdateInput, PumpTypeUncheckedUpdateInput>
  }

  /**
   * PumpType delete
   */
  export type PumpTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
    /**
     * Filter which PumpType to delete.
     */
    where: PumpTypeWhereUniqueInput
  }

  /**
   * PumpType deleteMany
   */
  export type PumpTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PumpTypes to delete
     */
    where?: PumpTypeWhereInput
    /**
     * Limit how many PumpTypes to delete.
     */
    limit?: number
  }

  /**
   * PumpType without action
   */
  export type PumpTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PumpType
     */
    select?: PumpTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PumpType
     */
    omit?: PumpTypeOmit<ExtArgs> | null
  }


  /**
   * Model RainfallStation
   */

  export type AggregateRainfallStation = {
    _count: RainfallStationCountAggregateOutputType | null
    _avg: RainfallStationAvgAggregateOutputType | null
    _sum: RainfallStationSumAggregateOutputType | null
    _min: RainfallStationMinAggregateOutputType | null
    _max: RainfallStationMaxAggregateOutputType | null
  }

  export type RainfallStationAvgAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationSumAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationMinAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationMaxAggregateOutputType = {
    IdRaiSta: number | null
    FIdWeaSta: number | null
    FIdTrikh: number | null
    FIdRaiTy: number | null
    ErtefaeBaresh: Decimal | null
  }

  export type RainfallStationCountAggregateOutputType = {
    IdRaiSta: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: number
    _all: number
  }


  export type RainfallStationAvgAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationSumAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationMinAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationMaxAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
  }

  export type RainfallStationCountAggregateInputType = {
    IdRaiSta?: true
    FIdWeaSta?: true
    FIdTrikh?: true
    FIdRaiTy?: true
    ErtefaeBaresh?: true
    _all?: true
  }

  export type RainfallStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallStation to aggregate.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainfallStations
    **/
    _count?: true | RainfallStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainfallStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainfallStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainfallStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainfallStationMaxAggregateInputType
  }

  export type GetRainfallStationAggregateType<T extends RainfallStationAggregateArgs> = {
        [P in keyof T & keyof AggregateRainfallStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainfallStation[P]>
      : GetScalarType<T[P], AggregateRainfallStation[P]>
  }




  export type RainfallStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallStationWhereInput
    orderBy?: RainfallStationOrderByWithAggregationInput | RainfallStationOrderByWithAggregationInput[]
    by: RainfallStationScalarFieldEnum[] | RainfallStationScalarFieldEnum
    having?: RainfallStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainfallStationCountAggregateInputType | true
    _avg?: RainfallStationAvgAggregateInputType
    _sum?: RainfallStationSumAggregateInputType
    _min?: RainfallStationMinAggregateInputType
    _max?: RainfallStationMaxAggregateInputType
  }

  export type RainfallStationGroupByOutputType = {
    IdRaiSta: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal
    _count: RainfallStationCountAggregateOutputType | null
    _avg: RainfallStationAvgAggregateOutputType | null
    _sum: RainfallStationSumAggregateOutputType | null
    _min: RainfallStationMinAggregateOutputType | null
    _max: RainfallStationMaxAggregateOutputType | null
  }

  type GetRainfallStationGroupByPayload<T extends RainfallStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainfallStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainfallStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainfallStationGroupByOutputType[P]>
            : GetScalarType<T[P], RainfallStationGroupByOutputType[P]>
        }
      >
    >


  export type RainfallStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRaiSta?: boolean
    FIdWeaSta?: boolean
    FIdTrikh?: boolean
    FIdRaiTy?: boolean
    ErtefaeBaresh?: boolean
  }, ExtArgs["result"]["rainfallStation"]>



  export type RainfallStationSelectScalar = {
    IdRaiSta?: boolean
    FIdWeaSta?: boolean
    FIdTrikh?: boolean
    FIdRaiTy?: boolean
    ErtefaeBaresh?: boolean
  }

  export type RainfallStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRaiSta" | "FIdWeaSta" | "FIdTrikh" | "FIdRaiTy" | "ErtefaeBaresh", ExtArgs["result"]["rainfallStation"]>

  export type $RainfallStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainfallStation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRaiSta: number
      FIdWeaSta: number
      FIdTrikh: number
      FIdRaiTy: number
      ErtefaeBaresh: Prisma.Decimal
    }, ExtArgs["result"]["rainfallStation"]>
    composites: {}
  }

  type RainfallStationGetPayload<S extends boolean | null | undefined | RainfallStationDefaultArgs> = $Result.GetResult<Prisma.$RainfallStationPayload, S>

  type RainfallStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainfallStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainfallStationCountAggregateInputType | true
    }

  export interface RainfallStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainfallStation'], meta: { name: 'RainfallStation' } }
    /**
     * Find zero or one RainfallStation that matches the filter.
     * @param {RainfallStationFindUniqueArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainfallStationFindUniqueArgs>(args: SelectSubset<T, RainfallStationFindUniqueArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RainfallStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainfallStationFindUniqueOrThrowArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainfallStationFindUniqueOrThrowArgs>(args: SelectSubset<T, RainfallStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindFirstArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainfallStationFindFirstArgs>(args?: SelectSubset<T, RainfallStationFindFirstArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindFirstOrThrowArgs} args - Arguments to find a RainfallStation
     * @example
     * // Get one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainfallStationFindFirstOrThrowArgs>(args?: SelectSubset<T, RainfallStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RainfallStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainfallStations
     * const rainfallStations = await prisma.rainfallStation.findMany()
     * 
     * // Get first 10 RainfallStations
     * const rainfallStations = await prisma.rainfallStation.findMany({ take: 10 })
     * 
     * // Only select the `IdRaiSta`
     * const rainfallStationWithIdRaiStaOnly = await prisma.rainfallStation.findMany({ select: { IdRaiSta: true } })
     * 
     */
    findMany<T extends RainfallStationFindManyArgs>(args?: SelectSubset<T, RainfallStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RainfallStation.
     * @param {RainfallStationCreateArgs} args - Arguments to create a RainfallStation.
     * @example
     * // Create one RainfallStation
     * const RainfallStation = await prisma.rainfallStation.create({
     *   data: {
     *     // ... data to create a RainfallStation
     *   }
     * })
     * 
     */
    create<T extends RainfallStationCreateArgs>(args: SelectSubset<T, RainfallStationCreateArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RainfallStations.
     * @param {RainfallStationCreateManyArgs} args - Arguments to create many RainfallStations.
     * @example
     * // Create many RainfallStations
     * const rainfallStation = await prisma.rainfallStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainfallStationCreateManyArgs>(args?: SelectSubset<T, RainfallStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RainfallStation.
     * @param {RainfallStationDeleteArgs} args - Arguments to delete one RainfallStation.
     * @example
     * // Delete one RainfallStation
     * const RainfallStation = await prisma.rainfallStation.delete({
     *   where: {
     *     // ... filter to delete one RainfallStation
     *   }
     * })
     * 
     */
    delete<T extends RainfallStationDeleteArgs>(args: SelectSubset<T, RainfallStationDeleteArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RainfallStation.
     * @param {RainfallStationUpdateArgs} args - Arguments to update one RainfallStation.
     * @example
     * // Update one RainfallStation
     * const rainfallStation = await prisma.rainfallStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainfallStationUpdateArgs>(args: SelectSubset<T, RainfallStationUpdateArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RainfallStations.
     * @param {RainfallStationDeleteManyArgs} args - Arguments to filter RainfallStations to delete.
     * @example
     * // Delete a few RainfallStations
     * const { count } = await prisma.rainfallStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainfallStationDeleteManyArgs>(args?: SelectSubset<T, RainfallStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainfallStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainfallStations
     * const rainfallStation = await prisma.rainfallStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainfallStationUpdateManyArgs>(args: SelectSubset<T, RainfallStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainfallStation.
     * @param {RainfallStationUpsertArgs} args - Arguments to update or create a RainfallStation.
     * @example
     * // Update or create a RainfallStation
     * const rainfallStation = await prisma.rainfallStation.upsert({
     *   create: {
     *     // ... data to create a RainfallStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainfallStation we want to update
     *   }
     * })
     */
    upsert<T extends RainfallStationUpsertArgs>(args: SelectSubset<T, RainfallStationUpsertArgs<ExtArgs>>): Prisma__RainfallStationClient<$Result.GetResult<Prisma.$RainfallStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RainfallStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationCountArgs} args - Arguments to filter RainfallStations to count.
     * @example
     * // Count the number of RainfallStations
     * const count = await prisma.rainfallStation.count({
     *   where: {
     *     // ... the filter for the RainfallStations we want to count
     *   }
     * })
    **/
    count<T extends RainfallStationCountArgs>(
      args?: Subset<T, RainfallStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainfallStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainfallStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainfallStationAggregateArgs>(args: Subset<T, RainfallStationAggregateArgs>): Prisma.PrismaPromise<GetRainfallStationAggregateType<T>>

    /**
     * Group by RainfallStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainfallStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainfallStationGroupByArgs['orderBy'] }
        : { orderBy?: RainfallStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainfallStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainfallStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainfallStation model
   */
  readonly fields: RainfallStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainfallStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainfallStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainfallStation model
   */ 
  interface RainfallStationFieldRefs {
    readonly IdRaiSta: FieldRef<"RainfallStation", 'Int'>
    readonly FIdWeaSta: FieldRef<"RainfallStation", 'Int'>
    readonly FIdTrikh: FieldRef<"RainfallStation", 'Int'>
    readonly FIdRaiTy: FieldRef<"RainfallStation", 'Int'>
    readonly ErtefaeBaresh: FieldRef<"RainfallStation", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * RainfallStation findUnique
   */
  export type RainfallStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation findUniqueOrThrow
   */
  export type RainfallStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation findFirst
   */
  export type RainfallStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallStations.
     */
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation findFirstOrThrow
   */
  export type RainfallStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter, which RainfallStation to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallStations.
     */
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation findMany
   */
  export type RainfallStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter, which RainfallStations to fetch.
     */
    where?: RainfallStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallStations to fetch.
     */
    orderBy?: RainfallStationOrderByWithRelationInput | RainfallStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainfallStations.
     */
    cursor?: RainfallStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallStations.
     */
    skip?: number
    distinct?: RainfallStationScalarFieldEnum | RainfallStationScalarFieldEnum[]
  }

  /**
   * RainfallStation create
   */
  export type RainfallStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * The data needed to create a RainfallStation.
     */
    data: XOR<RainfallStationCreateInput, RainfallStationUncheckedCreateInput>
  }

  /**
   * RainfallStation createMany
   */
  export type RainfallStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainfallStations.
     */
    data: RainfallStationCreateManyInput | RainfallStationCreateManyInput[]
  }

  /**
   * RainfallStation update
   */
  export type RainfallStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * The data needed to update a RainfallStation.
     */
    data: XOR<RainfallStationUpdateInput, RainfallStationUncheckedUpdateInput>
    /**
     * Choose, which RainfallStation to update.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation updateMany
   */
  export type RainfallStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainfallStations.
     */
    data: XOR<RainfallStationUpdateManyMutationInput, RainfallStationUncheckedUpdateManyInput>
    /**
     * Filter which RainfallStations to update
     */
    where?: RainfallStationWhereInput
    /**
     * Limit how many RainfallStations to update.
     */
    limit?: number
  }

  /**
   * RainfallStation upsert
   */
  export type RainfallStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * The filter to search for the RainfallStation to update in case it exists.
     */
    where: RainfallStationWhereUniqueInput
    /**
     * In case the RainfallStation found by the `where` argument doesn't exist, create a new RainfallStation with this data.
     */
    create: XOR<RainfallStationCreateInput, RainfallStationUncheckedCreateInput>
    /**
     * In case the RainfallStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainfallStationUpdateInput, RainfallStationUncheckedUpdateInput>
  }

  /**
   * RainfallStation delete
   */
  export type RainfallStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
    /**
     * Filter which RainfallStation to delete.
     */
    where: RainfallStationWhereUniqueInput
  }

  /**
   * RainfallStation deleteMany
   */
  export type RainfallStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallStations to delete
     */
    where?: RainfallStationWhereInput
    /**
     * Limit how many RainfallStations to delete.
     */
    limit?: number
  }

  /**
   * RainfallStation without action
   */
  export type RainfallStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallStation
     */
    select?: RainfallStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallStation
     */
    omit?: RainfallStationOmit<ExtArgs> | null
  }


  /**
   * Model RainfallType
   */

  export type AggregateRainfallType = {
    _count: RainfallTypeCountAggregateOutputType | null
    _avg: RainfallTypeAvgAggregateOutputType | null
    _sum: RainfallTypeSumAggregateOutputType | null
    _min: RainfallTypeMinAggregateOutputType | null
    _max: RainfallTypeMaxAggregateOutputType | null
  }

  export type RainfallTypeAvgAggregateOutputType = {
    IdRaiTy: number | null
  }

  export type RainfallTypeSumAggregateOutputType = {
    IdRaiTy: number | null
  }

  export type RainfallTypeMinAggregateOutputType = {
    IdRaiTy: number | null
    RainfallType: string | null
  }

  export type RainfallTypeMaxAggregateOutputType = {
    IdRaiTy: number | null
    RainfallType: string | null
  }

  export type RainfallTypeCountAggregateOutputType = {
    IdRaiTy: number
    RainfallType: number
    _all: number
  }


  export type RainfallTypeAvgAggregateInputType = {
    IdRaiTy?: true
  }

  export type RainfallTypeSumAggregateInputType = {
    IdRaiTy?: true
  }

  export type RainfallTypeMinAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
  }

  export type RainfallTypeMaxAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
  }

  export type RainfallTypeCountAggregateInputType = {
    IdRaiTy?: true
    RainfallType?: true
    _all?: true
  }

  export type RainfallTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallType to aggregate.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainfallTypes
    **/
    _count?: true | RainfallTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainfallTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainfallTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainfallTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainfallTypeMaxAggregateInputType
  }

  export type GetRainfallTypeAggregateType<T extends RainfallTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRainfallType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainfallType[P]>
      : GetScalarType<T[P], AggregateRainfallType[P]>
  }




  export type RainfallTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainfallTypeWhereInput
    orderBy?: RainfallTypeOrderByWithAggregationInput | RainfallTypeOrderByWithAggregationInput[]
    by: RainfallTypeScalarFieldEnum[] | RainfallTypeScalarFieldEnum
    having?: RainfallTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainfallTypeCountAggregateInputType | true
    _avg?: RainfallTypeAvgAggregateInputType
    _sum?: RainfallTypeSumAggregateInputType
    _min?: RainfallTypeMinAggregateInputType
    _max?: RainfallTypeMaxAggregateInputType
  }

  export type RainfallTypeGroupByOutputType = {
    IdRaiTy: number
    RainfallType: string
    _count: RainfallTypeCountAggregateOutputType | null
    _avg: RainfallTypeAvgAggregateOutputType | null
    _sum: RainfallTypeSumAggregateOutputType | null
    _min: RainfallTypeMinAggregateOutputType | null
    _max: RainfallTypeMaxAggregateOutputType | null
  }

  type GetRainfallTypeGroupByPayload<T extends RainfallTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainfallTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainfallTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainfallTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RainfallTypeGroupByOutputType[P]>
        }
      >
    >


  export type RainfallTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdRaiTy?: boolean
    RainfallType?: boolean
  }, ExtArgs["result"]["rainfallType"]>



  export type RainfallTypeSelectScalar = {
    IdRaiTy?: boolean
    RainfallType?: boolean
  }

  export type RainfallTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdRaiTy" | "RainfallType", ExtArgs["result"]["rainfallType"]>

  export type $RainfallTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainfallType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdRaiTy: number
      RainfallType: string
    }, ExtArgs["result"]["rainfallType"]>
    composites: {}
  }

  type RainfallTypeGetPayload<S extends boolean | null | undefined | RainfallTypeDefaultArgs> = $Result.GetResult<Prisma.$RainfallTypePayload, S>

  type RainfallTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainfallTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainfallTypeCountAggregateInputType | true
    }

  export interface RainfallTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainfallType'], meta: { name: 'RainfallType' } }
    /**
     * Find zero or one RainfallType that matches the filter.
     * @param {RainfallTypeFindUniqueArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainfallTypeFindUniqueArgs>(args: SelectSubset<T, RainfallTypeFindUniqueArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RainfallType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainfallTypeFindUniqueOrThrowArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainfallTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RainfallTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindFirstArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainfallTypeFindFirstArgs>(args?: SelectSubset<T, RainfallTypeFindFirstArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RainfallType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindFirstOrThrowArgs} args - Arguments to find a RainfallType
     * @example
     * // Get one RainfallType
     * const rainfallType = await prisma.rainfallType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainfallTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RainfallTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RainfallTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainfallTypes
     * const rainfallTypes = await prisma.rainfallType.findMany()
     * 
     * // Get first 10 RainfallTypes
     * const rainfallTypes = await prisma.rainfallType.findMany({ take: 10 })
     * 
     * // Only select the `IdRaiTy`
     * const rainfallTypeWithIdRaiTyOnly = await prisma.rainfallType.findMany({ select: { IdRaiTy: true } })
     * 
     */
    findMany<T extends RainfallTypeFindManyArgs>(args?: SelectSubset<T, RainfallTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RainfallType.
     * @param {RainfallTypeCreateArgs} args - Arguments to create a RainfallType.
     * @example
     * // Create one RainfallType
     * const RainfallType = await prisma.rainfallType.create({
     *   data: {
     *     // ... data to create a RainfallType
     *   }
     * })
     * 
     */
    create<T extends RainfallTypeCreateArgs>(args: SelectSubset<T, RainfallTypeCreateArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RainfallTypes.
     * @param {RainfallTypeCreateManyArgs} args - Arguments to create many RainfallTypes.
     * @example
     * // Create many RainfallTypes
     * const rainfallType = await prisma.rainfallType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainfallTypeCreateManyArgs>(args?: SelectSubset<T, RainfallTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RainfallType.
     * @param {RainfallTypeDeleteArgs} args - Arguments to delete one RainfallType.
     * @example
     * // Delete one RainfallType
     * const RainfallType = await prisma.rainfallType.delete({
     *   where: {
     *     // ... filter to delete one RainfallType
     *   }
     * })
     * 
     */
    delete<T extends RainfallTypeDeleteArgs>(args: SelectSubset<T, RainfallTypeDeleteArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RainfallType.
     * @param {RainfallTypeUpdateArgs} args - Arguments to update one RainfallType.
     * @example
     * // Update one RainfallType
     * const rainfallType = await prisma.rainfallType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainfallTypeUpdateArgs>(args: SelectSubset<T, RainfallTypeUpdateArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RainfallTypes.
     * @param {RainfallTypeDeleteManyArgs} args - Arguments to filter RainfallTypes to delete.
     * @example
     * // Delete a few RainfallTypes
     * const { count } = await prisma.rainfallType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainfallTypeDeleteManyArgs>(args?: SelectSubset<T, RainfallTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainfallTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainfallTypes
     * const rainfallType = await prisma.rainfallType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainfallTypeUpdateManyArgs>(args: SelectSubset<T, RainfallTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainfallType.
     * @param {RainfallTypeUpsertArgs} args - Arguments to update or create a RainfallType.
     * @example
     * // Update or create a RainfallType
     * const rainfallType = await prisma.rainfallType.upsert({
     *   create: {
     *     // ... data to create a RainfallType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainfallType we want to update
     *   }
     * })
     */
    upsert<T extends RainfallTypeUpsertArgs>(args: SelectSubset<T, RainfallTypeUpsertArgs<ExtArgs>>): Prisma__RainfallTypeClient<$Result.GetResult<Prisma.$RainfallTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RainfallTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeCountArgs} args - Arguments to filter RainfallTypes to count.
     * @example
     * // Count the number of RainfallTypes
     * const count = await prisma.rainfallType.count({
     *   where: {
     *     // ... the filter for the RainfallTypes we want to count
     *   }
     * })
    **/
    count<T extends RainfallTypeCountArgs>(
      args?: Subset<T, RainfallTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainfallTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainfallType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainfallTypeAggregateArgs>(args: Subset<T, RainfallTypeAggregateArgs>): Prisma.PrismaPromise<GetRainfallTypeAggregateType<T>>

    /**
     * Group by RainfallType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainfallTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainfallTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainfallTypeGroupByArgs['orderBy'] }
        : { orderBy?: RainfallTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainfallTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainfallTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainfallType model
   */
  readonly fields: RainfallTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainfallType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainfallTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainfallType model
   */ 
  interface RainfallTypeFieldRefs {
    readonly IdRaiTy: FieldRef<"RainfallType", 'Int'>
    readonly RainfallType: FieldRef<"RainfallType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RainfallType findUnique
   */
  export type RainfallTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType findUniqueOrThrow
   */
  export type RainfallTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType findFirst
   */
  export type RainfallTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallTypes.
     */
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType findFirstOrThrow
   */
  export type RainfallTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter, which RainfallType to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainfallTypes.
     */
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType findMany
   */
  export type RainfallTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter, which RainfallTypes to fetch.
     */
    where?: RainfallTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainfallTypes to fetch.
     */
    orderBy?: RainfallTypeOrderByWithRelationInput | RainfallTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainfallTypes.
     */
    cursor?: RainfallTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainfallTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainfallTypes.
     */
    skip?: number
    distinct?: RainfallTypeScalarFieldEnum | RainfallTypeScalarFieldEnum[]
  }

  /**
   * RainfallType create
   */
  export type RainfallTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a RainfallType.
     */
    data: XOR<RainfallTypeCreateInput, RainfallTypeUncheckedCreateInput>
  }

  /**
   * RainfallType createMany
   */
  export type RainfallTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainfallTypes.
     */
    data: RainfallTypeCreateManyInput | RainfallTypeCreateManyInput[]
  }

  /**
   * RainfallType update
   */
  export type RainfallTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a RainfallType.
     */
    data: XOR<RainfallTypeUpdateInput, RainfallTypeUncheckedUpdateInput>
    /**
     * Choose, which RainfallType to update.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType updateMany
   */
  export type RainfallTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainfallTypes.
     */
    data: XOR<RainfallTypeUpdateManyMutationInput, RainfallTypeUncheckedUpdateManyInput>
    /**
     * Filter which RainfallTypes to update
     */
    where?: RainfallTypeWhereInput
    /**
     * Limit how many RainfallTypes to update.
     */
    limit?: number
  }

  /**
   * RainfallType upsert
   */
  export type RainfallTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the RainfallType to update in case it exists.
     */
    where: RainfallTypeWhereUniqueInput
    /**
     * In case the RainfallType found by the `where` argument doesn't exist, create a new RainfallType with this data.
     */
    create: XOR<RainfallTypeCreateInput, RainfallTypeUncheckedCreateInput>
    /**
     * In case the RainfallType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainfallTypeUpdateInput, RainfallTypeUncheckedUpdateInput>
  }

  /**
   * RainfallType delete
   */
  export type RainfallTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
    /**
     * Filter which RainfallType to delete.
     */
    where: RainfallTypeWhereUniqueInput
  }

  /**
   * RainfallType deleteMany
   */
  export type RainfallTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainfallTypes to delete
     */
    where?: RainfallTypeWhereInput
    /**
     * Limit how many RainfallTypes to delete.
     */
    limit?: number
  }

  /**
   * RainfallType without action
   */
  export type RainfallTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainfallType
     */
    select?: RainfallTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainfallType
     */
    omit?: RainfallTypeOmit<ExtArgs> | null
  }


  /**
   * Model SaleZeraee
   */

  export type AggregateSaleZeraee = {
    _count: SaleZeraeeCountAggregateOutputType | null
    _avg: SaleZeraeeAvgAggregateOutputType | null
    _sum: SaleZeraeeSumAggregateOutputType | null
    _min: SaleZeraeeMinAggregateOutputType | null
    _max: SaleZeraeeMaxAggregateOutputType | null
  }

  export type SaleZeraeeAvgAggregateOutputType = {
    IdSal: number | null
  }

  export type SaleZeraeeSumAggregateOutputType = {
    IdSal: number | null
  }

  export type SaleZeraeeMinAggregateOutputType = {
    IdSal: number | null
    SaleZeraee: string | null
  }

  export type SaleZeraeeMaxAggregateOutputType = {
    IdSal: number | null
    SaleZeraee: string | null
  }

  export type SaleZeraeeCountAggregateOutputType = {
    IdSal: number
    SaleZeraee: number
    _all: number
  }


  export type SaleZeraeeAvgAggregateInputType = {
    IdSal?: true
  }

  export type SaleZeraeeSumAggregateInputType = {
    IdSal?: true
  }

  export type SaleZeraeeMinAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
  }

  export type SaleZeraeeMaxAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
  }

  export type SaleZeraeeCountAggregateInputType = {
    IdSal?: true
    SaleZeraee?: true
    _all?: true
  }

  export type SaleZeraeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleZeraee to aggregate.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleZeraees
    **/
    _count?: true | SaleZeraeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleZeraeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleZeraeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleZeraeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleZeraeeMaxAggregateInputType
  }

  export type GetSaleZeraeeAggregateType<T extends SaleZeraeeAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleZeraee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleZeraee[P]>
      : GetScalarType<T[P], AggregateSaleZeraee[P]>
  }




  export type SaleZeraeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleZeraeeWhereInput
    orderBy?: SaleZeraeeOrderByWithAggregationInput | SaleZeraeeOrderByWithAggregationInput[]
    by: SaleZeraeeScalarFieldEnum[] | SaleZeraeeScalarFieldEnum
    having?: SaleZeraeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleZeraeeCountAggregateInputType | true
    _avg?: SaleZeraeeAvgAggregateInputType
    _sum?: SaleZeraeeSumAggregateInputType
    _min?: SaleZeraeeMinAggregateInputType
    _max?: SaleZeraeeMaxAggregateInputType
  }

  export type SaleZeraeeGroupByOutputType = {
    IdSal: number
    SaleZeraee: string
    _count: SaleZeraeeCountAggregateOutputType | null
    _avg: SaleZeraeeAvgAggregateOutputType | null
    _sum: SaleZeraeeSumAggregateOutputType | null
    _min: SaleZeraeeMinAggregateOutputType | null
    _max: SaleZeraeeMaxAggregateOutputType | null
  }

  type GetSaleZeraeeGroupByPayload<T extends SaleZeraeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleZeraeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleZeraeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleZeraeeGroupByOutputType[P]>
            : GetScalarType<T[P], SaleZeraeeGroupByOutputType[P]>
        }
      >
    >


  export type SaleZeraeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSal?: boolean
    SaleZeraee?: boolean
  }, ExtArgs["result"]["saleZeraee"]>



  export type SaleZeraeeSelectScalar = {
    IdSal?: boolean
    SaleZeraee?: boolean
  }

  export type SaleZeraeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSal" | "SaleZeraee", ExtArgs["result"]["saleZeraee"]>

  export type $SaleZeraeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleZeraee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdSal: number
      SaleZeraee: string
    }, ExtArgs["result"]["saleZeraee"]>
    composites: {}
  }

  type SaleZeraeeGetPayload<S extends boolean | null | undefined | SaleZeraeeDefaultArgs> = $Result.GetResult<Prisma.$SaleZeraeePayload, S>

  type SaleZeraeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleZeraeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleZeraeeCountAggregateInputType | true
    }

  export interface SaleZeraeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleZeraee'], meta: { name: 'SaleZeraee' } }
    /**
     * Find zero or one SaleZeraee that matches the filter.
     * @param {SaleZeraeeFindUniqueArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleZeraeeFindUniqueArgs>(args: SelectSubset<T, SaleZeraeeFindUniqueArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SaleZeraee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleZeraeeFindUniqueOrThrowArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleZeraeeFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleZeraeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SaleZeraee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindFirstArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleZeraeeFindFirstArgs>(args?: SelectSubset<T, SaleZeraeeFindFirstArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SaleZeraee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindFirstOrThrowArgs} args - Arguments to find a SaleZeraee
     * @example
     * // Get one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleZeraeeFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleZeraeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SaleZeraees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleZeraees
     * const saleZeraees = await prisma.saleZeraee.findMany()
     * 
     * // Get first 10 SaleZeraees
     * const saleZeraees = await prisma.saleZeraee.findMany({ take: 10 })
     * 
     * // Only select the `IdSal`
     * const saleZeraeeWithIdSalOnly = await prisma.saleZeraee.findMany({ select: { IdSal: true } })
     * 
     */
    findMany<T extends SaleZeraeeFindManyArgs>(args?: SelectSubset<T, SaleZeraeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SaleZeraee.
     * @param {SaleZeraeeCreateArgs} args - Arguments to create a SaleZeraee.
     * @example
     * // Create one SaleZeraee
     * const SaleZeraee = await prisma.saleZeraee.create({
     *   data: {
     *     // ... data to create a SaleZeraee
     *   }
     * })
     * 
     */
    create<T extends SaleZeraeeCreateArgs>(args: SelectSubset<T, SaleZeraeeCreateArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SaleZeraees.
     * @param {SaleZeraeeCreateManyArgs} args - Arguments to create many SaleZeraees.
     * @example
     * // Create many SaleZeraees
     * const saleZeraee = await prisma.saleZeraee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleZeraeeCreateManyArgs>(args?: SelectSubset<T, SaleZeraeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SaleZeraee.
     * @param {SaleZeraeeDeleteArgs} args - Arguments to delete one SaleZeraee.
     * @example
     * // Delete one SaleZeraee
     * const SaleZeraee = await prisma.saleZeraee.delete({
     *   where: {
     *     // ... filter to delete one SaleZeraee
     *   }
     * })
     * 
     */
    delete<T extends SaleZeraeeDeleteArgs>(args: SelectSubset<T, SaleZeraeeDeleteArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SaleZeraee.
     * @param {SaleZeraeeUpdateArgs} args - Arguments to update one SaleZeraee.
     * @example
     * // Update one SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleZeraeeUpdateArgs>(args: SelectSubset<T, SaleZeraeeUpdateArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SaleZeraees.
     * @param {SaleZeraeeDeleteManyArgs} args - Arguments to filter SaleZeraees to delete.
     * @example
     * // Delete a few SaleZeraees
     * const { count } = await prisma.saleZeraee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleZeraeeDeleteManyArgs>(args?: SelectSubset<T, SaleZeraeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleZeraees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleZeraees
     * const saleZeraee = await prisma.saleZeraee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleZeraeeUpdateManyArgs>(args: SelectSubset<T, SaleZeraeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleZeraee.
     * @param {SaleZeraeeUpsertArgs} args - Arguments to update or create a SaleZeraee.
     * @example
     * // Update or create a SaleZeraee
     * const saleZeraee = await prisma.saleZeraee.upsert({
     *   create: {
     *     // ... data to create a SaleZeraee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleZeraee we want to update
     *   }
     * })
     */
    upsert<T extends SaleZeraeeUpsertArgs>(args: SelectSubset<T, SaleZeraeeUpsertArgs<ExtArgs>>): Prisma__SaleZeraeeClient<$Result.GetResult<Prisma.$SaleZeraeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SaleZeraees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeCountArgs} args - Arguments to filter SaleZeraees to count.
     * @example
     * // Count the number of SaleZeraees
     * const count = await prisma.saleZeraee.count({
     *   where: {
     *     // ... the filter for the SaleZeraees we want to count
     *   }
     * })
    **/
    count<T extends SaleZeraeeCountArgs>(
      args?: Subset<T, SaleZeraeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleZeraeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleZeraee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleZeraeeAggregateArgs>(args: Subset<T, SaleZeraeeAggregateArgs>): Prisma.PrismaPromise<GetSaleZeraeeAggregateType<T>>

    /**
     * Group by SaleZeraee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleZeraeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleZeraeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleZeraeeGroupByArgs['orderBy'] }
        : { orderBy?: SaleZeraeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleZeraeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleZeraeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleZeraee model
   */
  readonly fields: SaleZeraeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleZeraee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleZeraeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleZeraee model
   */ 
  interface SaleZeraeeFieldRefs {
    readonly IdSal: FieldRef<"SaleZeraee", 'Int'>
    readonly SaleZeraee: FieldRef<"SaleZeraee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SaleZeraee findUnique
   */
  export type SaleZeraeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee findUniqueOrThrow
   */
  export type SaleZeraeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee findFirst
   */
  export type SaleZeraeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleZeraees.
     */
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee findFirstOrThrow
   */
  export type SaleZeraeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter, which SaleZeraee to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleZeraees.
     */
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee findMany
   */
  export type SaleZeraeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter, which SaleZeraees to fetch.
     */
    where?: SaleZeraeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleZeraees to fetch.
     */
    orderBy?: SaleZeraeeOrderByWithRelationInput | SaleZeraeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleZeraees.
     */
    cursor?: SaleZeraeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleZeraees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleZeraees.
     */
    skip?: number
    distinct?: SaleZeraeeScalarFieldEnum | SaleZeraeeScalarFieldEnum[]
  }

  /**
   * SaleZeraee create
   */
  export type SaleZeraeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * The data needed to create a SaleZeraee.
     */
    data: XOR<SaleZeraeeCreateInput, SaleZeraeeUncheckedCreateInput>
  }

  /**
   * SaleZeraee createMany
   */
  export type SaleZeraeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleZeraees.
     */
    data: SaleZeraeeCreateManyInput | SaleZeraeeCreateManyInput[]
  }

  /**
   * SaleZeraee update
   */
  export type SaleZeraeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * The data needed to update a SaleZeraee.
     */
    data: XOR<SaleZeraeeUpdateInput, SaleZeraeeUncheckedUpdateInput>
    /**
     * Choose, which SaleZeraee to update.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee updateMany
   */
  export type SaleZeraeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleZeraees.
     */
    data: XOR<SaleZeraeeUpdateManyMutationInput, SaleZeraeeUncheckedUpdateManyInput>
    /**
     * Filter which SaleZeraees to update
     */
    where?: SaleZeraeeWhereInput
    /**
     * Limit how many SaleZeraees to update.
     */
    limit?: number
  }

  /**
   * SaleZeraee upsert
   */
  export type SaleZeraeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * The filter to search for the SaleZeraee to update in case it exists.
     */
    where: SaleZeraeeWhereUniqueInput
    /**
     * In case the SaleZeraee found by the `where` argument doesn't exist, create a new SaleZeraee with this data.
     */
    create: XOR<SaleZeraeeCreateInput, SaleZeraeeUncheckedCreateInput>
    /**
     * In case the SaleZeraee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleZeraeeUpdateInput, SaleZeraeeUncheckedUpdateInput>
  }

  /**
   * SaleZeraee delete
   */
  export type SaleZeraeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
    /**
     * Filter which SaleZeraee to delete.
     */
    where: SaleZeraeeWhereUniqueInput
  }

  /**
   * SaleZeraee deleteMany
   */
  export type SaleZeraeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleZeraees to delete
     */
    where?: SaleZeraeeWhereInput
    /**
     * Limit how many SaleZeraees to delete.
     */
    limit?: number
  }

  /**
   * SaleZeraee without action
   */
  export type SaleZeraeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleZeraee
     */
    select?: SaleZeraeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleZeraee
     */
    omit?: SaleZeraeeOmit<ExtArgs> | null
  }


  /**
   * Model SeghliPump
   */

  export type AggregateSeghliPump = {
    _count: SeghliPumpCountAggregateOutputType | null
    _avg: SeghliPumpAvgAggregateOutputType | null
    _sum: SeghliPumpSumAggregateOutputType | null
    _min: SeghliPumpMinAggregateOutputType | null
    _max: SeghliPumpMaxAggregateOutputType | null
  }

  export type SeghliPumpAvgAggregateOutputType = {
    IdSePu: number | null
  }

  export type SeghliPumpSumAggregateOutputType = {
    IdSePu: number | null
  }

  export type SeghliPumpMinAggregateOutputType = {
    IdSePu: number | null
    SeghliPump: string | null
  }

  export type SeghliPumpMaxAggregateOutputType = {
    IdSePu: number | null
    SeghliPump: string | null
  }

  export type SeghliPumpCountAggregateOutputType = {
    IdSePu: number
    SeghliPump: number
    _all: number
  }


  export type SeghliPumpAvgAggregateInputType = {
    IdSePu?: true
  }

  export type SeghliPumpSumAggregateInputType = {
    IdSePu?: true
  }

  export type SeghliPumpMinAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
  }

  export type SeghliPumpMaxAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
  }

  export type SeghliPumpCountAggregateInputType = {
    IdSePu?: true
    SeghliPump?: true
    _all?: true
  }

  export type SeghliPumpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeghliPump to aggregate.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeghliPumps
    **/
    _count?: true | SeghliPumpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeghliPumpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeghliPumpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeghliPumpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeghliPumpMaxAggregateInputType
  }

  export type GetSeghliPumpAggregateType<T extends SeghliPumpAggregateArgs> = {
        [P in keyof T & keyof AggregateSeghliPump]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeghliPump[P]>
      : GetScalarType<T[P], AggregateSeghliPump[P]>
  }




  export type SeghliPumpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeghliPumpWhereInput
    orderBy?: SeghliPumpOrderByWithAggregationInput | SeghliPumpOrderByWithAggregationInput[]
    by: SeghliPumpScalarFieldEnum[] | SeghliPumpScalarFieldEnum
    having?: SeghliPumpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeghliPumpCountAggregateInputType | true
    _avg?: SeghliPumpAvgAggregateInputType
    _sum?: SeghliPumpSumAggregateInputType
    _min?: SeghliPumpMinAggregateInputType
    _max?: SeghliPumpMaxAggregateInputType
  }

  export type SeghliPumpGroupByOutputType = {
    IdSePu: number
    SeghliPump: string
    _count: SeghliPumpCountAggregateOutputType | null
    _avg: SeghliPumpAvgAggregateOutputType | null
    _sum: SeghliPumpSumAggregateOutputType | null
    _min: SeghliPumpMinAggregateOutputType | null
    _max: SeghliPumpMaxAggregateOutputType | null
  }

  type GetSeghliPumpGroupByPayload<T extends SeghliPumpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeghliPumpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeghliPumpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeghliPumpGroupByOutputType[P]>
            : GetScalarType<T[P], SeghliPumpGroupByOutputType[P]>
        }
      >
    >


  export type SeghliPumpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSePu?: boolean
    SeghliPump?: boolean
  }, ExtArgs["result"]["seghliPump"]>



  export type SeghliPumpSelectScalar = {
    IdSePu?: boolean
    SeghliPump?: boolean
  }

  export type SeghliPumpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSePu" | "SeghliPump", ExtArgs["result"]["seghliPump"]>

  export type $SeghliPumpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeghliPump"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdSePu: number
      SeghliPump: string
    }, ExtArgs["result"]["seghliPump"]>
    composites: {}
  }

  type SeghliPumpGetPayload<S extends boolean | null | undefined | SeghliPumpDefaultArgs> = $Result.GetResult<Prisma.$SeghliPumpPayload, S>

  type SeghliPumpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeghliPumpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeghliPumpCountAggregateInputType | true
    }

  export interface SeghliPumpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeghliPump'], meta: { name: 'SeghliPump' } }
    /**
     * Find zero or one SeghliPump that matches the filter.
     * @param {SeghliPumpFindUniqueArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeghliPumpFindUniqueArgs>(args: SelectSubset<T, SeghliPumpFindUniqueArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SeghliPump that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeghliPumpFindUniqueOrThrowArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeghliPumpFindUniqueOrThrowArgs>(args: SelectSubset<T, SeghliPumpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SeghliPump that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindFirstArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeghliPumpFindFirstArgs>(args?: SelectSubset<T, SeghliPumpFindFirstArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SeghliPump that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindFirstOrThrowArgs} args - Arguments to find a SeghliPump
     * @example
     * // Get one SeghliPump
     * const seghliPump = await prisma.seghliPump.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeghliPumpFindFirstOrThrowArgs>(args?: SelectSubset<T, SeghliPumpFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SeghliPumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeghliPumps
     * const seghliPumps = await prisma.seghliPump.findMany()
     * 
     * // Get first 10 SeghliPumps
     * const seghliPumps = await prisma.seghliPump.findMany({ take: 10 })
     * 
     * // Only select the `IdSePu`
     * const seghliPumpWithIdSePuOnly = await prisma.seghliPump.findMany({ select: { IdSePu: true } })
     * 
     */
    findMany<T extends SeghliPumpFindManyArgs>(args?: SelectSubset<T, SeghliPumpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SeghliPump.
     * @param {SeghliPumpCreateArgs} args - Arguments to create a SeghliPump.
     * @example
     * // Create one SeghliPump
     * const SeghliPump = await prisma.seghliPump.create({
     *   data: {
     *     // ... data to create a SeghliPump
     *   }
     * })
     * 
     */
    create<T extends SeghliPumpCreateArgs>(args: SelectSubset<T, SeghliPumpCreateArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SeghliPumps.
     * @param {SeghliPumpCreateManyArgs} args - Arguments to create many SeghliPumps.
     * @example
     * // Create many SeghliPumps
     * const seghliPump = await prisma.seghliPump.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeghliPumpCreateManyArgs>(args?: SelectSubset<T, SeghliPumpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeghliPump.
     * @param {SeghliPumpDeleteArgs} args - Arguments to delete one SeghliPump.
     * @example
     * // Delete one SeghliPump
     * const SeghliPump = await prisma.seghliPump.delete({
     *   where: {
     *     // ... filter to delete one SeghliPump
     *   }
     * })
     * 
     */
    delete<T extends SeghliPumpDeleteArgs>(args: SelectSubset<T, SeghliPumpDeleteArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SeghliPump.
     * @param {SeghliPumpUpdateArgs} args - Arguments to update one SeghliPump.
     * @example
     * // Update one SeghliPump
     * const seghliPump = await prisma.seghliPump.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeghliPumpUpdateArgs>(args: SelectSubset<T, SeghliPumpUpdateArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SeghliPumps.
     * @param {SeghliPumpDeleteManyArgs} args - Arguments to filter SeghliPumps to delete.
     * @example
     * // Delete a few SeghliPumps
     * const { count } = await prisma.seghliPump.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeghliPumpDeleteManyArgs>(args?: SelectSubset<T, SeghliPumpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeghliPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeghliPumps
     * const seghliPump = await prisma.seghliPump.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeghliPumpUpdateManyArgs>(args: SelectSubset<T, SeghliPumpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeghliPump.
     * @param {SeghliPumpUpsertArgs} args - Arguments to update or create a SeghliPump.
     * @example
     * // Update or create a SeghliPump
     * const seghliPump = await prisma.seghliPump.upsert({
     *   create: {
     *     // ... data to create a SeghliPump
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeghliPump we want to update
     *   }
     * })
     */
    upsert<T extends SeghliPumpUpsertArgs>(args: SelectSubset<T, SeghliPumpUpsertArgs<ExtArgs>>): Prisma__SeghliPumpClient<$Result.GetResult<Prisma.$SeghliPumpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SeghliPumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpCountArgs} args - Arguments to filter SeghliPumps to count.
     * @example
     * // Count the number of SeghliPumps
     * const count = await prisma.seghliPump.count({
     *   where: {
     *     // ... the filter for the SeghliPumps we want to count
     *   }
     * })
    **/
    count<T extends SeghliPumpCountArgs>(
      args?: Subset<T, SeghliPumpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeghliPumpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeghliPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeghliPumpAggregateArgs>(args: Subset<T, SeghliPumpAggregateArgs>): Prisma.PrismaPromise<GetSeghliPumpAggregateType<T>>

    /**
     * Group by SeghliPump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeghliPumpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeghliPumpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeghliPumpGroupByArgs['orderBy'] }
        : { orderBy?: SeghliPumpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeghliPumpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeghliPumpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeghliPump model
   */
  readonly fields: SeghliPumpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeghliPump.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeghliPumpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeghliPump model
   */ 
  interface SeghliPumpFieldRefs {
    readonly IdSePu: FieldRef<"SeghliPump", 'Int'>
    readonly SeghliPump: FieldRef<"SeghliPump", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeghliPump findUnique
   */
  export type SeghliPumpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump findUniqueOrThrow
   */
  export type SeghliPumpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump findFirst
   */
  export type SeghliPumpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeghliPumps.
     */
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump findFirstOrThrow
   */
  export type SeghliPumpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter, which SeghliPump to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeghliPumps.
     */
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump findMany
   */
  export type SeghliPumpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter, which SeghliPumps to fetch.
     */
    where?: SeghliPumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeghliPumps to fetch.
     */
    orderBy?: SeghliPumpOrderByWithRelationInput | SeghliPumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeghliPumps.
     */
    cursor?: SeghliPumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeghliPumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeghliPumps.
     */
    skip?: number
    distinct?: SeghliPumpScalarFieldEnum | SeghliPumpScalarFieldEnum[]
  }

  /**
   * SeghliPump create
   */
  export type SeghliPumpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * The data needed to create a SeghliPump.
     */
    data: XOR<SeghliPumpCreateInput, SeghliPumpUncheckedCreateInput>
  }

  /**
   * SeghliPump createMany
   */
  export type SeghliPumpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeghliPumps.
     */
    data: SeghliPumpCreateManyInput | SeghliPumpCreateManyInput[]
  }

  /**
   * SeghliPump update
   */
  export type SeghliPumpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * The data needed to update a SeghliPump.
     */
    data: XOR<SeghliPumpUpdateInput, SeghliPumpUncheckedUpdateInput>
    /**
     * Choose, which SeghliPump to update.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump updateMany
   */
  export type SeghliPumpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeghliPumps.
     */
    data: XOR<SeghliPumpUpdateManyMutationInput, SeghliPumpUncheckedUpdateManyInput>
    /**
     * Filter which SeghliPumps to update
     */
    where?: SeghliPumpWhereInput
    /**
     * Limit how many SeghliPumps to update.
     */
    limit?: number
  }

  /**
   * SeghliPump upsert
   */
  export type SeghliPumpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * The filter to search for the SeghliPump to update in case it exists.
     */
    where: SeghliPumpWhereUniqueInput
    /**
     * In case the SeghliPump found by the `where` argument doesn't exist, create a new SeghliPump with this data.
     */
    create: XOR<SeghliPumpCreateInput, SeghliPumpUncheckedCreateInput>
    /**
     * In case the SeghliPump was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeghliPumpUpdateInput, SeghliPumpUncheckedUpdateInput>
  }

  /**
   * SeghliPump delete
   */
  export type SeghliPumpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
    /**
     * Filter which SeghliPump to delete.
     */
    where: SeghliPumpWhereUniqueInput
  }

  /**
   * SeghliPump deleteMany
   */
  export type SeghliPumpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeghliPumps to delete
     */
    where?: SeghliPumpWhereInput
    /**
     * Limit how many SeghliPumps to delete.
     */
    limit?: number
  }

  /**
   * SeghliPump without action
   */
  export type SeghliPumpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeghliPump
     */
    select?: SeghliPumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeghliPump
     */
    omit?: SeghliPumpOmit<ExtArgs> | null
  }


  /**
   * Model SystemPart
   */

  export type AggregateSystemPart = {
    _count: SystemPartCountAggregateOutputType | null
    _avg: SystemPartAvgAggregateOutputType | null
    _sum: SystemPartSumAggregateOutputType | null
    _min: SystemPartMinAggregateOutputType | null
    _max: SystemPartMaxAggregateOutputType | null
  }

  export type SystemPartAvgAggregateOutputType = {
    IdSP: number | null
    KM: number | null
  }

  export type SystemPartSumAggregateOutputType = {
    IdSP: number | null
    KM: number | null
  }

  export type SystemPartMinAggregateOutputType = {
    IdSP: number | null
    Part: string | null
    KM: number | null
  }

  export type SystemPartMaxAggregateOutputType = {
    IdSP: number | null
    Part: string | null
    KM: number | null
  }

  export type SystemPartCountAggregateOutputType = {
    IdSP: number
    Part: number
    KM: number
    _all: number
  }


  export type SystemPartAvgAggregateInputType = {
    IdSP?: true
    KM?: true
  }

  export type SystemPartSumAggregateInputType = {
    IdSP?: true
    KM?: true
  }

  export type SystemPartMinAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
  }

  export type SystemPartMaxAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
  }

  export type SystemPartCountAggregateInputType = {
    IdSP?: true
    Part?: true
    KM?: true
    _all?: true
  }

  export type SystemPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPart to aggregate.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemParts
    **/
    _count?: true | SystemPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemPartMaxAggregateInputType
  }

  export type GetSystemPartAggregateType<T extends SystemPartAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemPart[P]>
      : GetScalarType<T[P], AggregateSystemPart[P]>
  }




  export type SystemPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemPartWhereInput
    orderBy?: SystemPartOrderByWithAggregationInput | SystemPartOrderByWithAggregationInput[]
    by: SystemPartScalarFieldEnum[] | SystemPartScalarFieldEnum
    having?: SystemPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemPartCountAggregateInputType | true
    _avg?: SystemPartAvgAggregateInputType
    _sum?: SystemPartSumAggregateInputType
    _min?: SystemPartMinAggregateInputType
    _max?: SystemPartMaxAggregateInputType
  }

  export type SystemPartGroupByOutputType = {
    IdSP: number
    Part: string
    KM: number
    _count: SystemPartCountAggregateOutputType | null
    _avg: SystemPartAvgAggregateOutputType | null
    _sum: SystemPartSumAggregateOutputType | null
    _min: SystemPartMinAggregateOutputType | null
    _max: SystemPartMaxAggregateOutputType | null
  }

  type GetSystemPartGroupByPayload<T extends SystemPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemPartGroupByOutputType[P]>
            : GetScalarType<T[P], SystemPartGroupByOutputType[P]>
        }
      >
    >


  export type SystemPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSP?: boolean
    Part?: boolean
    KM?: boolean
  }, ExtArgs["result"]["systemPart"]>



  export type SystemPartSelectScalar = {
    IdSP?: boolean
    Part?: boolean
    KM?: boolean
  }

  export type SystemPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdSP" | "Part" | "KM", ExtArgs["result"]["systemPart"]>

  export type $SystemPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemPart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdSP: number
      Part: string
      KM: number
    }, ExtArgs["result"]["systemPart"]>
    composites: {}
  }

  type SystemPartGetPayload<S extends boolean | null | undefined | SystemPartDefaultArgs> = $Result.GetResult<Prisma.$SystemPartPayload, S>

  type SystemPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemPartCountAggregateInputType | true
    }

  export interface SystemPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemPart'], meta: { name: 'SystemPart' } }
    /**
     * Find zero or one SystemPart that matches the filter.
     * @param {SystemPartFindUniqueArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemPartFindUniqueArgs>(args: SelectSubset<T, SystemPartFindUniqueArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SystemPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemPartFindUniqueOrThrowArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemPartFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SystemPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindFirstArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemPartFindFirstArgs>(args?: SelectSubset<T, SystemPartFindFirstArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SystemPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindFirstOrThrowArgs} args - Arguments to find a SystemPart
     * @example
     * // Get one SystemPart
     * const systemPart = await prisma.systemPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemPartFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SystemParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemParts
     * const systemParts = await prisma.systemPart.findMany()
     * 
     * // Get first 10 SystemParts
     * const systemParts = await prisma.systemPart.findMany({ take: 10 })
     * 
     * // Only select the `IdSP`
     * const systemPartWithIdSPOnly = await prisma.systemPart.findMany({ select: { IdSP: true } })
     * 
     */
    findMany<T extends SystemPartFindManyArgs>(args?: SelectSubset<T, SystemPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SystemPart.
     * @param {SystemPartCreateArgs} args - Arguments to create a SystemPart.
     * @example
     * // Create one SystemPart
     * const SystemPart = await prisma.systemPart.create({
     *   data: {
     *     // ... data to create a SystemPart
     *   }
     * })
     * 
     */
    create<T extends SystemPartCreateArgs>(args: SelectSubset<T, SystemPartCreateArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SystemParts.
     * @param {SystemPartCreateManyArgs} args - Arguments to create many SystemParts.
     * @example
     * // Create many SystemParts
     * const systemPart = await prisma.systemPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemPartCreateManyArgs>(args?: SelectSubset<T, SystemPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemPart.
     * @param {SystemPartDeleteArgs} args - Arguments to delete one SystemPart.
     * @example
     * // Delete one SystemPart
     * const SystemPart = await prisma.systemPart.delete({
     *   where: {
     *     // ... filter to delete one SystemPart
     *   }
     * })
     * 
     */
    delete<T extends SystemPartDeleteArgs>(args: SelectSubset<T, SystemPartDeleteArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SystemPart.
     * @param {SystemPartUpdateArgs} args - Arguments to update one SystemPart.
     * @example
     * // Update one SystemPart
     * const systemPart = await prisma.systemPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemPartUpdateArgs>(args: SelectSubset<T, SystemPartUpdateArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SystemParts.
     * @param {SystemPartDeleteManyArgs} args - Arguments to filter SystemParts to delete.
     * @example
     * // Delete a few SystemParts
     * const { count } = await prisma.systemPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemPartDeleteManyArgs>(args?: SelectSubset<T, SystemPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemParts
     * const systemPart = await prisma.systemPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemPartUpdateManyArgs>(args: SelectSubset<T, SystemPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemPart.
     * @param {SystemPartUpsertArgs} args - Arguments to update or create a SystemPart.
     * @example
     * // Update or create a SystemPart
     * const systemPart = await prisma.systemPart.upsert({
     *   create: {
     *     // ... data to create a SystemPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemPart we want to update
     *   }
     * })
     */
    upsert<T extends SystemPartUpsertArgs>(args: SelectSubset<T, SystemPartUpsertArgs<ExtArgs>>): Prisma__SystemPartClient<$Result.GetResult<Prisma.$SystemPartPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SystemParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartCountArgs} args - Arguments to filter SystemParts to count.
     * @example
     * // Count the number of SystemParts
     * const count = await prisma.systemPart.count({
     *   where: {
     *     // ... the filter for the SystemParts we want to count
     *   }
     * })
    **/
    count<T extends SystemPartCountArgs>(
      args?: Subset<T, SystemPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemPartAggregateArgs>(args: Subset<T, SystemPartAggregateArgs>): Prisma.PrismaPromise<GetSystemPartAggregateType<T>>

    /**
     * Group by SystemPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemPartGroupByArgs['orderBy'] }
        : { orderBy?: SystemPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemPart model
   */
  readonly fields: SystemPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemPart model
   */ 
  interface SystemPartFieldRefs {
    readonly IdSP: FieldRef<"SystemPart", 'Int'>
    readonly Part: FieldRef<"SystemPart", 'String'>
    readonly KM: FieldRef<"SystemPart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SystemPart findUnique
   */
  export type SystemPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart findUniqueOrThrow
   */
  export type SystemPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart findFirst
   */
  export type SystemPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemParts.
     */
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart findFirstOrThrow
   */
  export type SystemPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter, which SystemPart to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemParts.
     */
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart findMany
   */
  export type SystemPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter, which SystemParts to fetch.
     */
    where?: SystemPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemParts to fetch.
     */
    orderBy?: SystemPartOrderByWithRelationInput | SystemPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemParts.
     */
    cursor?: SystemPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemParts.
     */
    skip?: number
    distinct?: SystemPartScalarFieldEnum | SystemPartScalarFieldEnum[]
  }

  /**
   * SystemPart create
   */
  export type SystemPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemPart.
     */
    data: XOR<SystemPartCreateInput, SystemPartUncheckedCreateInput>
  }

  /**
   * SystemPart createMany
   */
  export type SystemPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemParts.
     */
    data: SystemPartCreateManyInput | SystemPartCreateManyInput[]
  }

  /**
   * SystemPart update
   */
  export type SystemPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemPart.
     */
    data: XOR<SystemPartUpdateInput, SystemPartUncheckedUpdateInput>
    /**
     * Choose, which SystemPart to update.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart updateMany
   */
  export type SystemPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemParts.
     */
    data: XOR<SystemPartUpdateManyMutationInput, SystemPartUncheckedUpdateManyInput>
    /**
     * Filter which SystemParts to update
     */
    where?: SystemPartWhereInput
    /**
     * Limit how many SystemParts to update.
     */
    limit?: number
  }

  /**
   * SystemPart upsert
   */
  export type SystemPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemPart to update in case it exists.
     */
    where: SystemPartWhereUniqueInput
    /**
     * In case the SystemPart found by the `where` argument doesn't exist, create a new SystemPart with this data.
     */
    create: XOR<SystemPartCreateInput, SystemPartUncheckedCreateInput>
    /**
     * In case the SystemPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemPartUpdateInput, SystemPartUncheckedUpdateInput>
  }

  /**
   * SystemPart delete
   */
  export type SystemPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
    /**
     * Filter which SystemPart to delete.
     */
    where: SystemPartWhereUniqueInput
  }

  /**
   * SystemPart deleteMany
   */
  export type SystemPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemParts to delete
     */
    where?: SystemPartWhereInput
    /**
     * Limit how many SystemParts to delete.
     */
    limit?: number
  }

  /**
   * SystemPart without action
   */
  export type SystemPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPart
     */
    select?: SystemPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPart
     */
    omit?: SystemPartOmit<ExtArgs> | null
  }


  /**
   * Model TakhlieMakhzan
   */

  export type AggregateTakhlieMakhzan = {
    _count: TakhlieMakhzanCountAggregateOutputType | null
    _avg: TakhlieMakhzanAvgAggregateOutputType | null
    _sum: TakhlieMakhzanSumAggregateOutputType | null
    _min: TakhlieMakhzanMinAggregateOutputType | null
    _max: TakhlieMakhzanMaxAggregateOutputType | null
  }

  export type TakhlieMakhzanAvgAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanSumAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanMinAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanMaxAggregateOutputType = {
    IdTakhlie: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Takhlie: number | null
  }

  export type TakhlieMakhzanCountAggregateOutputType = {
    IdTakhlie: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
    _all: number
  }


  export type TakhlieMakhzanAvgAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanSumAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanMinAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanMaxAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
  }

  export type TakhlieMakhzanCountAggregateInputType = {
    IdTakhlie?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Takhlie?: true
    _all?: true
  }

  export type TakhlieMakhzanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakhlieMakhzan to aggregate.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TakhlieMakhzans
    **/
    _count?: true | TakhlieMakhzanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TakhlieMakhzanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TakhlieMakhzanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakhlieMakhzanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakhlieMakhzanMaxAggregateInputType
  }

  export type GetTakhlieMakhzanAggregateType<T extends TakhlieMakhzanAggregateArgs> = {
        [P in keyof T & keyof AggregateTakhlieMakhzan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakhlieMakhzan[P]>
      : GetScalarType<T[P], AggregateTakhlieMakhzan[P]>
  }




  export type TakhlieMakhzanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakhlieMakhzanWhereInput
    orderBy?: TakhlieMakhzanOrderByWithAggregationInput | TakhlieMakhzanOrderByWithAggregationInput[]
    by: TakhlieMakhzanScalarFieldEnum[] | TakhlieMakhzanScalarFieldEnum
    having?: TakhlieMakhzanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakhlieMakhzanCountAggregateInputType | true
    _avg?: TakhlieMakhzanAvgAggregateInputType
    _sum?: TakhlieMakhzanSumAggregateInputType
    _min?: TakhlieMakhzanMinAggregateInputType
    _max?: TakhlieMakhzanMaxAggregateInputType
  }

  export type TakhlieMakhzanGroupByOutputType = {
    IdTakhlie: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
    _count: TakhlieMakhzanCountAggregateOutputType | null
    _avg: TakhlieMakhzanAvgAggregateOutputType | null
    _sum: TakhlieMakhzanSumAggregateOutputType | null
    _min: TakhlieMakhzanMinAggregateOutputType | null
    _max: TakhlieMakhzanMaxAggregateOutputType | null
  }

  type GetTakhlieMakhzanGroupByPayload<T extends TakhlieMakhzanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakhlieMakhzanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakhlieMakhzanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakhlieMakhzanGroupByOutputType[P]>
            : GetScalarType<T[P], TakhlieMakhzanGroupByOutputType[P]>
        }
      >
    >


  export type TakhlieMakhzanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTakhlie?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Takhlie?: boolean
  }, ExtArgs["result"]["takhlieMakhzan"]>



  export type TakhlieMakhzanSelectScalar = {
    IdTakhlie?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Takhlie?: boolean
  }

  export type TakhlieMakhzanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTakhlie" | "FIdRanesh" | "FIdTarDor" | "Takhlie", ExtArgs["result"]["takhlieMakhzan"]>

  export type $TakhlieMakhzanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TakhlieMakhzan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTakhlie: number
      FIdRanesh: number
      FIdTarDor: number
      Takhlie: number
    }, ExtArgs["result"]["takhlieMakhzan"]>
    composites: {}
  }

  type TakhlieMakhzanGetPayload<S extends boolean | null | undefined | TakhlieMakhzanDefaultArgs> = $Result.GetResult<Prisma.$TakhlieMakhzanPayload, S>

  type TakhlieMakhzanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakhlieMakhzanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakhlieMakhzanCountAggregateInputType | true
    }

  export interface TakhlieMakhzanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TakhlieMakhzan'], meta: { name: 'TakhlieMakhzan' } }
    /**
     * Find zero or one TakhlieMakhzan that matches the filter.
     * @param {TakhlieMakhzanFindUniqueArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakhlieMakhzanFindUniqueArgs>(args: SelectSubset<T, TakhlieMakhzanFindUniqueArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TakhlieMakhzan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakhlieMakhzanFindUniqueOrThrowArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakhlieMakhzanFindUniqueOrThrowArgs>(args: SelectSubset<T, TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TakhlieMakhzan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindFirstArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakhlieMakhzanFindFirstArgs>(args?: SelectSubset<T, TakhlieMakhzanFindFirstArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TakhlieMakhzan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindFirstOrThrowArgs} args - Arguments to find a TakhlieMakhzan
     * @example
     * // Get one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakhlieMakhzanFindFirstOrThrowArgs>(args?: SelectSubset<T, TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TakhlieMakhzans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TakhlieMakhzans
     * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany()
     * 
     * // Get first 10 TakhlieMakhzans
     * const takhlieMakhzans = await prisma.takhlieMakhzan.findMany({ take: 10 })
     * 
     * // Only select the `IdTakhlie`
     * const takhlieMakhzanWithIdTakhlieOnly = await prisma.takhlieMakhzan.findMany({ select: { IdTakhlie: true } })
     * 
     */
    findMany<T extends TakhlieMakhzanFindManyArgs>(args?: SelectSubset<T, TakhlieMakhzanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TakhlieMakhzan.
     * @param {TakhlieMakhzanCreateArgs} args - Arguments to create a TakhlieMakhzan.
     * @example
     * // Create one TakhlieMakhzan
     * const TakhlieMakhzan = await prisma.takhlieMakhzan.create({
     *   data: {
     *     // ... data to create a TakhlieMakhzan
     *   }
     * })
     * 
     */
    create<T extends TakhlieMakhzanCreateArgs>(args: SelectSubset<T, TakhlieMakhzanCreateArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TakhlieMakhzans.
     * @param {TakhlieMakhzanCreateManyArgs} args - Arguments to create many TakhlieMakhzans.
     * @example
     * // Create many TakhlieMakhzans
     * const takhlieMakhzan = await prisma.takhlieMakhzan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakhlieMakhzanCreateManyArgs>(args?: SelectSubset<T, TakhlieMakhzanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TakhlieMakhzan.
     * @param {TakhlieMakhzanDeleteArgs} args - Arguments to delete one TakhlieMakhzan.
     * @example
     * // Delete one TakhlieMakhzan
     * const TakhlieMakhzan = await prisma.takhlieMakhzan.delete({
     *   where: {
     *     // ... filter to delete one TakhlieMakhzan
     *   }
     * })
     * 
     */
    delete<T extends TakhlieMakhzanDeleteArgs>(args: SelectSubset<T, TakhlieMakhzanDeleteArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TakhlieMakhzan.
     * @param {TakhlieMakhzanUpdateArgs} args - Arguments to update one TakhlieMakhzan.
     * @example
     * // Update one TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakhlieMakhzanUpdateArgs>(args: SelectSubset<T, TakhlieMakhzanUpdateArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TakhlieMakhzans.
     * @param {TakhlieMakhzanDeleteManyArgs} args - Arguments to filter TakhlieMakhzans to delete.
     * @example
     * // Delete a few TakhlieMakhzans
     * const { count } = await prisma.takhlieMakhzan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakhlieMakhzanDeleteManyArgs>(args?: SelectSubset<T, TakhlieMakhzanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakhlieMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TakhlieMakhzans
     * const takhlieMakhzan = await prisma.takhlieMakhzan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakhlieMakhzanUpdateManyArgs>(args: SelectSubset<T, TakhlieMakhzanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TakhlieMakhzan.
     * @param {TakhlieMakhzanUpsertArgs} args - Arguments to update or create a TakhlieMakhzan.
     * @example
     * // Update or create a TakhlieMakhzan
     * const takhlieMakhzan = await prisma.takhlieMakhzan.upsert({
     *   create: {
     *     // ... data to create a TakhlieMakhzan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TakhlieMakhzan we want to update
     *   }
     * })
     */
    upsert<T extends TakhlieMakhzanUpsertArgs>(args: SelectSubset<T, TakhlieMakhzanUpsertArgs<ExtArgs>>): Prisma__TakhlieMakhzanClient<$Result.GetResult<Prisma.$TakhlieMakhzanPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TakhlieMakhzans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanCountArgs} args - Arguments to filter TakhlieMakhzans to count.
     * @example
     * // Count the number of TakhlieMakhzans
     * const count = await prisma.takhlieMakhzan.count({
     *   where: {
     *     // ... the filter for the TakhlieMakhzans we want to count
     *   }
     * })
    **/
    count<T extends TakhlieMakhzanCountArgs>(
      args?: Subset<T, TakhlieMakhzanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakhlieMakhzanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TakhlieMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakhlieMakhzanAggregateArgs>(args: Subset<T, TakhlieMakhzanAggregateArgs>): Prisma.PrismaPromise<GetTakhlieMakhzanAggregateType<T>>

    /**
     * Group by TakhlieMakhzan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakhlieMakhzanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakhlieMakhzanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakhlieMakhzanGroupByArgs['orderBy'] }
        : { orderBy?: TakhlieMakhzanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakhlieMakhzanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakhlieMakhzanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TakhlieMakhzan model
   */
  readonly fields: TakhlieMakhzanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TakhlieMakhzan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakhlieMakhzanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TakhlieMakhzan model
   */ 
  interface TakhlieMakhzanFieldRefs {
    readonly IdTakhlie: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly FIdRanesh: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly FIdTarDor: FieldRef<"TakhlieMakhzan", 'Int'>
    readonly Takhlie: FieldRef<"TakhlieMakhzan", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TakhlieMakhzan findUnique
   */
  export type TakhlieMakhzanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan findUniqueOrThrow
   */
  export type TakhlieMakhzanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan findFirst
   */
  export type TakhlieMakhzanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakhlieMakhzans.
     */
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan findFirstOrThrow
   */
  export type TakhlieMakhzanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzan to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakhlieMakhzans.
     */
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan findMany
   */
  export type TakhlieMakhzanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter, which TakhlieMakhzans to fetch.
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakhlieMakhzans to fetch.
     */
    orderBy?: TakhlieMakhzanOrderByWithRelationInput | TakhlieMakhzanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TakhlieMakhzans.
     */
    cursor?: TakhlieMakhzanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakhlieMakhzans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakhlieMakhzans.
     */
    skip?: number
    distinct?: TakhlieMakhzanScalarFieldEnum | TakhlieMakhzanScalarFieldEnum[]
  }

  /**
   * TakhlieMakhzan create
   */
  export type TakhlieMakhzanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * The data needed to create a TakhlieMakhzan.
     */
    data: XOR<TakhlieMakhzanCreateInput, TakhlieMakhzanUncheckedCreateInput>
  }

  /**
   * TakhlieMakhzan createMany
   */
  export type TakhlieMakhzanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TakhlieMakhzans.
     */
    data: TakhlieMakhzanCreateManyInput | TakhlieMakhzanCreateManyInput[]
  }

  /**
   * TakhlieMakhzan update
   */
  export type TakhlieMakhzanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * The data needed to update a TakhlieMakhzan.
     */
    data: XOR<TakhlieMakhzanUpdateInput, TakhlieMakhzanUncheckedUpdateInput>
    /**
     * Choose, which TakhlieMakhzan to update.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan updateMany
   */
  export type TakhlieMakhzanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TakhlieMakhzans.
     */
    data: XOR<TakhlieMakhzanUpdateManyMutationInput, TakhlieMakhzanUncheckedUpdateManyInput>
    /**
     * Filter which TakhlieMakhzans to update
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * Limit how many TakhlieMakhzans to update.
     */
    limit?: number
  }

  /**
   * TakhlieMakhzan upsert
   */
  export type TakhlieMakhzanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * The filter to search for the TakhlieMakhzan to update in case it exists.
     */
    where: TakhlieMakhzanWhereUniqueInput
    /**
     * In case the TakhlieMakhzan found by the `where` argument doesn't exist, create a new TakhlieMakhzan with this data.
     */
    create: XOR<TakhlieMakhzanCreateInput, TakhlieMakhzanUncheckedCreateInput>
    /**
     * In case the TakhlieMakhzan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakhlieMakhzanUpdateInput, TakhlieMakhzanUncheckedUpdateInput>
  }

  /**
   * TakhlieMakhzan delete
   */
  export type TakhlieMakhzanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
    /**
     * Filter which TakhlieMakhzan to delete.
     */
    where: TakhlieMakhzanWhereUniqueInput
  }

  /**
   * TakhlieMakhzan deleteMany
   */
  export type TakhlieMakhzanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakhlieMakhzans to delete
     */
    where?: TakhlieMakhzanWhereInput
    /**
     * Limit how many TakhlieMakhzans to delete.
     */
    limit?: number
  }

  /**
   * TakhlieMakhzan without action
   */
  export type TakhlieMakhzanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakhlieMakhzan
     */
    select?: TakhlieMakhzanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakhlieMakhzan
     */
    omit?: TakhlieMakhzanOmit<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestSumAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestMinAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestMaxAggregateOutputType = {
    IdTest: number | null
    FIdRanesh: number | null
    FIdTarDor: number | null
    Test: number | null
  }

  export type TestCountAggregateOutputType = {
    IdTest: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestSumAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestMinAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestMaxAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
  }

  export type TestCountAggregateInputType = {
    IdTest?: true
    FIdRanesh?: true
    FIdTarDor?: true
    Test?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    IdTest: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTest?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Test?: boolean
  }, ExtArgs["result"]["test"]>



  export type TestSelectScalar = {
    IdTest?: boolean
    FIdRanesh?: boolean
    FIdTarDor?: boolean
    Test?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTest" | "FIdRanesh" | "FIdTarDor" | "Test", ExtArgs["result"]["test"]>

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTest: number
      FIdRanesh: number
      FIdTarDor: number
      Test: number
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `IdTest`
     * const testWithIdTestOnly = await prisma.test.findMany({ select: { IdTest: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */ 
  interface TestFieldRefs {
    readonly IdTest: FieldRef<"Test", 'Int'>
    readonly FIdRanesh: FieldRef<"Test", 'Int'>
    readonly FIdTarDor: FieldRef<"Test", 'Int'>
    readonly Test: FieldRef<"Test", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
  }


  /**
   * Model TrikhDoreKesht
   */

  export type AggregateTrikhDoreKesht = {
    _count: TrikhDoreKeshtCountAggregateOutputType | null
    _avg: TrikhDoreKeshtAvgAggregateOutputType | null
    _sum: TrikhDoreKeshtSumAggregateOutputType | null
    _min: TrikhDoreKeshtMinAggregateOutputType | null
    _max: TrikhDoreKeshtMaxAggregateOutputType | null
  }

  export type TrikhDoreKeshtAvgAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type TrikhDoreKeshtSumAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
  }

  export type TrikhDoreKeshtMinAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Trikh: Date | null
    TrikhKhorshidi: string | null
  }

  export type TrikhDoreKeshtMaxAggregateOutputType = {
    IdTarDor: number | null
    FIdSal: number | null
    FIdDore: number | null
    Trikh: Date | null
    TrikhKhorshidi: string | null
  }

  export type TrikhDoreKeshtCountAggregateOutputType = {
    IdTarDor: number
    FIdSal: number
    FIdDore: number
    Trikh: number
    TrikhKhorshidi: number
    _all: number
  }


  export type TrikhDoreKeshtAvgAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type TrikhDoreKeshtSumAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
  }

  export type TrikhDoreKeshtMinAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
  }

  export type TrikhDoreKeshtMaxAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
  }

  export type TrikhDoreKeshtCountAggregateInputType = {
    IdTarDor?: true
    FIdSal?: true
    FIdDore?: true
    Trikh?: true
    TrikhKhorshidi?: true
    _all?: true
  }

  export type TrikhDoreKeshtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrikhDoreKesht to aggregate.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrikhDoreKeshts
    **/
    _count?: true | TrikhDoreKeshtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrikhDoreKeshtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrikhDoreKeshtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrikhDoreKeshtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrikhDoreKeshtMaxAggregateInputType
  }

  export type GetTrikhDoreKeshtAggregateType<T extends TrikhDoreKeshtAggregateArgs> = {
        [P in keyof T & keyof AggregateTrikhDoreKesht]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrikhDoreKesht[P]>
      : GetScalarType<T[P], AggregateTrikhDoreKesht[P]>
  }




  export type TrikhDoreKeshtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrikhDoreKeshtWhereInput
    orderBy?: TrikhDoreKeshtOrderByWithAggregationInput | TrikhDoreKeshtOrderByWithAggregationInput[]
    by: TrikhDoreKeshtScalarFieldEnum[] | TrikhDoreKeshtScalarFieldEnum
    having?: TrikhDoreKeshtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrikhDoreKeshtCountAggregateInputType | true
    _avg?: TrikhDoreKeshtAvgAggregateInputType
    _sum?: TrikhDoreKeshtSumAggregateInputType
    _min?: TrikhDoreKeshtMinAggregateInputType
    _max?: TrikhDoreKeshtMaxAggregateInputType
  }

  export type TrikhDoreKeshtGroupByOutputType = {
    IdTarDor: number
    FIdSal: number
    FIdDore: number
    Trikh: Date
    TrikhKhorshidi: string
    _count: TrikhDoreKeshtCountAggregateOutputType | null
    _avg: TrikhDoreKeshtAvgAggregateOutputType | null
    _sum: TrikhDoreKeshtSumAggregateOutputType | null
    _min: TrikhDoreKeshtMinAggregateOutputType | null
    _max: TrikhDoreKeshtMaxAggregateOutputType | null
  }

  type GetTrikhDoreKeshtGroupByPayload<T extends TrikhDoreKeshtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrikhDoreKeshtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrikhDoreKeshtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrikhDoreKeshtGroupByOutputType[P]>
            : GetScalarType<T[P], TrikhDoreKeshtGroupByOutputType[P]>
        }
      >
    >


  export type TrikhDoreKeshtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTarDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Trikh?: boolean
    TrikhKhorshidi?: boolean
  }, ExtArgs["result"]["trikhDoreKesht"]>



  export type TrikhDoreKeshtSelectScalar = {
    IdTarDor?: boolean
    FIdSal?: boolean
    FIdDore?: boolean
    Trikh?: boolean
    TrikhKhorshidi?: boolean
  }

  export type TrikhDoreKeshtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdTarDor" | "FIdSal" | "FIdDore" | "Trikh" | "TrikhKhorshidi", ExtArgs["result"]["trikhDoreKesht"]>

  export type $TrikhDoreKeshtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrikhDoreKesht"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTarDor: number
      FIdSal: number
      FIdDore: number
      Trikh: Date
      TrikhKhorshidi: string
    }, ExtArgs["result"]["trikhDoreKesht"]>
    composites: {}
  }

  type TrikhDoreKeshtGetPayload<S extends boolean | null | undefined | TrikhDoreKeshtDefaultArgs> = $Result.GetResult<Prisma.$TrikhDoreKeshtPayload, S>

  type TrikhDoreKeshtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrikhDoreKeshtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrikhDoreKeshtCountAggregateInputType | true
    }

  export interface TrikhDoreKeshtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrikhDoreKesht'], meta: { name: 'TrikhDoreKesht' } }
    /**
     * Find zero or one TrikhDoreKesht that matches the filter.
     * @param {TrikhDoreKeshtFindUniqueArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrikhDoreKeshtFindUniqueArgs>(args: SelectSubset<T, TrikhDoreKeshtFindUniqueArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TrikhDoreKesht that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrikhDoreKeshtFindUniqueOrThrowArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrikhDoreKeshtFindUniqueOrThrowArgs>(args: SelectSubset<T, TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TrikhDoreKesht that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindFirstArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrikhDoreKeshtFindFirstArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindFirstArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TrikhDoreKesht that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindFirstOrThrowArgs} args - Arguments to find a TrikhDoreKesht
     * @example
     * // Get one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrikhDoreKeshtFindFirstOrThrowArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TrikhDoreKeshts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrikhDoreKeshts
     * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany()
     * 
     * // Get first 10 TrikhDoreKeshts
     * const trikhDoreKeshts = await prisma.trikhDoreKesht.findMany({ take: 10 })
     * 
     * // Only select the `IdTarDor`
     * const trikhDoreKeshtWithIdTarDorOnly = await prisma.trikhDoreKesht.findMany({ select: { IdTarDor: true } })
     * 
     */
    findMany<T extends TrikhDoreKeshtFindManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TrikhDoreKesht.
     * @param {TrikhDoreKeshtCreateArgs} args - Arguments to create a TrikhDoreKesht.
     * @example
     * // Create one TrikhDoreKesht
     * const TrikhDoreKesht = await prisma.trikhDoreKesht.create({
     *   data: {
     *     // ... data to create a TrikhDoreKesht
     *   }
     * })
     * 
     */
    create<T extends TrikhDoreKeshtCreateArgs>(args: SelectSubset<T, TrikhDoreKeshtCreateArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TrikhDoreKeshts.
     * @param {TrikhDoreKeshtCreateManyArgs} args - Arguments to create many TrikhDoreKeshts.
     * @example
     * // Create many TrikhDoreKeshts
     * const trikhDoreKesht = await prisma.trikhDoreKesht.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrikhDoreKeshtCreateManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrikhDoreKesht.
     * @param {TrikhDoreKeshtDeleteArgs} args - Arguments to delete one TrikhDoreKesht.
     * @example
     * // Delete one TrikhDoreKesht
     * const TrikhDoreKesht = await prisma.trikhDoreKesht.delete({
     *   where: {
     *     // ... filter to delete one TrikhDoreKesht
     *   }
     * })
     * 
     */
    delete<T extends TrikhDoreKeshtDeleteArgs>(args: SelectSubset<T, TrikhDoreKeshtDeleteArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TrikhDoreKesht.
     * @param {TrikhDoreKeshtUpdateArgs} args - Arguments to update one TrikhDoreKesht.
     * @example
     * // Update one TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrikhDoreKeshtUpdateArgs>(args: SelectSubset<T, TrikhDoreKeshtUpdateArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TrikhDoreKeshts.
     * @param {TrikhDoreKeshtDeleteManyArgs} args - Arguments to filter TrikhDoreKeshts to delete.
     * @example
     * // Delete a few TrikhDoreKeshts
     * const { count } = await prisma.trikhDoreKesht.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrikhDoreKeshtDeleteManyArgs>(args?: SelectSubset<T, TrikhDoreKeshtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrikhDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrikhDoreKeshts
     * const trikhDoreKesht = await prisma.trikhDoreKesht.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrikhDoreKeshtUpdateManyArgs>(args: SelectSubset<T, TrikhDoreKeshtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrikhDoreKesht.
     * @param {TrikhDoreKeshtUpsertArgs} args - Arguments to update or create a TrikhDoreKesht.
     * @example
     * // Update or create a TrikhDoreKesht
     * const trikhDoreKesht = await prisma.trikhDoreKesht.upsert({
     *   create: {
     *     // ... data to create a TrikhDoreKesht
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrikhDoreKesht we want to update
     *   }
     * })
     */
    upsert<T extends TrikhDoreKeshtUpsertArgs>(args: SelectSubset<T, TrikhDoreKeshtUpsertArgs<ExtArgs>>): Prisma__TrikhDoreKeshtClient<$Result.GetResult<Prisma.$TrikhDoreKeshtPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TrikhDoreKeshts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtCountArgs} args - Arguments to filter TrikhDoreKeshts to count.
     * @example
     * // Count the number of TrikhDoreKeshts
     * const count = await prisma.trikhDoreKesht.count({
     *   where: {
     *     // ... the filter for the TrikhDoreKeshts we want to count
     *   }
     * })
    **/
    count<T extends TrikhDoreKeshtCountArgs>(
      args?: Subset<T, TrikhDoreKeshtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrikhDoreKeshtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrikhDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrikhDoreKeshtAggregateArgs>(args: Subset<T, TrikhDoreKeshtAggregateArgs>): Prisma.PrismaPromise<GetTrikhDoreKeshtAggregateType<T>>

    /**
     * Group by TrikhDoreKesht.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrikhDoreKeshtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrikhDoreKeshtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrikhDoreKeshtGroupByArgs['orderBy'] }
        : { orderBy?: TrikhDoreKeshtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrikhDoreKeshtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrikhDoreKeshtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrikhDoreKesht model
   */
  readonly fields: TrikhDoreKeshtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrikhDoreKesht.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrikhDoreKeshtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrikhDoreKesht model
   */ 
  interface TrikhDoreKeshtFieldRefs {
    readonly IdTarDor: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly FIdSal: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly FIdDore: FieldRef<"TrikhDoreKesht", 'Int'>
    readonly Trikh: FieldRef<"TrikhDoreKesht", 'DateTime'>
    readonly TrikhKhorshidi: FieldRef<"TrikhDoreKesht", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrikhDoreKesht findUnique
   */
  export type TrikhDoreKeshtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht findUniqueOrThrow
   */
  export type TrikhDoreKeshtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht findFirst
   */
  export type TrikhDoreKeshtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrikhDoreKeshts.
     */
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht findFirstOrThrow
   */
  export type TrikhDoreKeshtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKesht to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrikhDoreKeshts.
     */
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht findMany
   */
  export type TrikhDoreKeshtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter, which TrikhDoreKeshts to fetch.
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrikhDoreKeshts to fetch.
     */
    orderBy?: TrikhDoreKeshtOrderByWithRelationInput | TrikhDoreKeshtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrikhDoreKeshts.
     */
    cursor?: TrikhDoreKeshtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrikhDoreKeshts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrikhDoreKeshts.
     */
    skip?: number
    distinct?: TrikhDoreKeshtScalarFieldEnum | TrikhDoreKeshtScalarFieldEnum[]
  }

  /**
   * TrikhDoreKesht create
   */
  export type TrikhDoreKeshtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * The data needed to create a TrikhDoreKesht.
     */
    data: XOR<TrikhDoreKeshtCreateInput, TrikhDoreKeshtUncheckedCreateInput>
  }

  /**
   * TrikhDoreKesht createMany
   */
  export type TrikhDoreKeshtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrikhDoreKeshts.
     */
    data: TrikhDoreKeshtCreateManyInput | TrikhDoreKeshtCreateManyInput[]
  }

  /**
   * TrikhDoreKesht update
   */
  export type TrikhDoreKeshtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * The data needed to update a TrikhDoreKesht.
     */
    data: XOR<TrikhDoreKeshtUpdateInput, TrikhDoreKeshtUncheckedUpdateInput>
    /**
     * Choose, which TrikhDoreKesht to update.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht updateMany
   */
  export type TrikhDoreKeshtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrikhDoreKeshts.
     */
    data: XOR<TrikhDoreKeshtUpdateManyMutationInput, TrikhDoreKeshtUncheckedUpdateManyInput>
    /**
     * Filter which TrikhDoreKeshts to update
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * Limit how many TrikhDoreKeshts to update.
     */
    limit?: number
  }

  /**
   * TrikhDoreKesht upsert
   */
  export type TrikhDoreKeshtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * The filter to search for the TrikhDoreKesht to update in case it exists.
     */
    where: TrikhDoreKeshtWhereUniqueInput
    /**
     * In case the TrikhDoreKesht found by the `where` argument doesn't exist, create a new TrikhDoreKesht with this data.
     */
    create: XOR<TrikhDoreKeshtCreateInput, TrikhDoreKeshtUncheckedCreateInput>
    /**
     * In case the TrikhDoreKesht was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrikhDoreKeshtUpdateInput, TrikhDoreKeshtUncheckedUpdateInput>
  }

  /**
   * TrikhDoreKesht delete
   */
  export type TrikhDoreKeshtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
    /**
     * Filter which TrikhDoreKesht to delete.
     */
    where: TrikhDoreKeshtWhereUniqueInput
  }

  /**
   * TrikhDoreKesht deleteMany
   */
  export type TrikhDoreKeshtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrikhDoreKeshts to delete
     */
    where?: TrikhDoreKeshtWhereInput
    /**
     * Limit how many TrikhDoreKeshts to delete.
     */
    limit?: number
  }

  /**
   * TrikhDoreKesht without action
   */
  export type TrikhDoreKeshtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrikhDoreKesht
     */
    select?: TrikhDoreKeshtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrikhDoreKesht
     */
    omit?: TrikhDoreKeshtOmit<ExtArgs> | null
  }


  /**
   * Model WeatherStation
   */

  export type AggregateWeatherStation = {
    _count: WeatherStationCountAggregateOutputType | null
    _avg: WeatherStationAvgAggregateOutputType | null
    _sum: WeatherStationSumAggregateOutputType | null
    _min: WeatherStationMinAggregateOutputType | null
    _max: WeatherStationMaxAggregateOutputType | null
  }

  export type WeatherStationAvgAggregateOutputType = {
    IdWeaSta: number | null
  }

  export type WeatherStationSumAggregateOutputType = {
    IdWeaSta: number | null
  }

  export type WeatherStationMinAggregateOutputType = {
    IdWeaSta: number | null
    Station: string | null
  }

  export type WeatherStationMaxAggregateOutputType = {
    IdWeaSta: number | null
    Station: string | null
  }

  export type WeatherStationCountAggregateOutputType = {
    IdWeaSta: number
    Station: number
    _all: number
  }


  export type WeatherStationAvgAggregateInputType = {
    IdWeaSta?: true
  }

  export type WeatherStationSumAggregateInputType = {
    IdWeaSta?: true
  }

  export type WeatherStationMinAggregateInputType = {
    IdWeaSta?: true
    Station?: true
  }

  export type WeatherStationMaxAggregateInputType = {
    IdWeaSta?: true
    Station?: true
  }

  export type WeatherStationCountAggregateInputType = {
    IdWeaSta?: true
    Station?: true
    _all?: true
  }

  export type WeatherStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherStation to aggregate.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherStations
    **/
    _count?: true | WeatherStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherStationMaxAggregateInputType
  }

  export type GetWeatherStationAggregateType<T extends WeatherStationAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherStation[P]>
      : GetScalarType<T[P], AggregateWeatherStation[P]>
  }




  export type WeatherStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherStationWhereInput
    orderBy?: WeatherStationOrderByWithAggregationInput | WeatherStationOrderByWithAggregationInput[]
    by: WeatherStationScalarFieldEnum[] | WeatherStationScalarFieldEnum
    having?: WeatherStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherStationCountAggregateInputType | true
    _avg?: WeatherStationAvgAggregateInputType
    _sum?: WeatherStationSumAggregateInputType
    _min?: WeatherStationMinAggregateInputType
    _max?: WeatherStationMaxAggregateInputType
  }

  export type WeatherStationGroupByOutputType = {
    IdWeaSta: number
    Station: string
    _count: WeatherStationCountAggregateOutputType | null
    _avg: WeatherStationAvgAggregateOutputType | null
    _sum: WeatherStationSumAggregateOutputType | null
    _min: WeatherStationMinAggregateOutputType | null
    _max: WeatherStationMaxAggregateOutputType | null
  }

  type GetWeatherStationGroupByPayload<T extends WeatherStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherStationGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherStationGroupByOutputType[P]>
        }
      >
    >


  export type WeatherStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdWeaSta?: boolean
    Station?: boolean
  }, ExtArgs["result"]["weatherStation"]>



  export type WeatherStationSelectScalar = {
    IdWeaSta?: boolean
    Station?: boolean
  }

  export type WeatherStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"IdWeaSta" | "Station", ExtArgs["result"]["weatherStation"]>

  export type $WeatherStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherStation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdWeaSta: number
      Station: string
    }, ExtArgs["result"]["weatherStation"]>
    composites: {}
  }

  type WeatherStationGetPayload<S extends boolean | null | undefined | WeatherStationDefaultArgs> = $Result.GetResult<Prisma.$WeatherStationPayload, S>

  type WeatherStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherStationCountAggregateInputType | true
    }

  export interface WeatherStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherStation'], meta: { name: 'WeatherStation' } }
    /**
     * Find zero or one WeatherStation that matches the filter.
     * @param {WeatherStationFindUniqueArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherStationFindUniqueArgs>(args: SelectSubset<T, WeatherStationFindUniqueArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WeatherStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherStationFindUniqueOrThrowArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherStationFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindFirstArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherStationFindFirstArgs>(args?: SelectSubset<T, WeatherStationFindFirstArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindFirstOrThrowArgs} args - Arguments to find a WeatherStation
     * @example
     * // Get one WeatherStation
     * const weatherStation = await prisma.weatherStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherStationFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WeatherStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherStations
     * const weatherStations = await prisma.weatherStation.findMany()
     * 
     * // Get first 10 WeatherStations
     * const weatherStations = await prisma.weatherStation.findMany({ take: 10 })
     * 
     * // Only select the `IdWeaSta`
     * const weatherStationWithIdWeaStaOnly = await prisma.weatherStation.findMany({ select: { IdWeaSta: true } })
     * 
     */
    findMany<T extends WeatherStationFindManyArgs>(args?: SelectSubset<T, WeatherStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WeatherStation.
     * @param {WeatherStationCreateArgs} args - Arguments to create a WeatherStation.
     * @example
     * // Create one WeatherStation
     * const WeatherStation = await prisma.weatherStation.create({
     *   data: {
     *     // ... data to create a WeatherStation
     *   }
     * })
     * 
     */
    create<T extends WeatherStationCreateArgs>(args: SelectSubset<T, WeatherStationCreateArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WeatherStations.
     * @param {WeatherStationCreateManyArgs} args - Arguments to create many WeatherStations.
     * @example
     * // Create many WeatherStations
     * const weatherStation = await prisma.weatherStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherStationCreateManyArgs>(args?: SelectSubset<T, WeatherStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WeatherStation.
     * @param {WeatherStationDeleteArgs} args - Arguments to delete one WeatherStation.
     * @example
     * // Delete one WeatherStation
     * const WeatherStation = await prisma.weatherStation.delete({
     *   where: {
     *     // ... filter to delete one WeatherStation
     *   }
     * })
     * 
     */
    delete<T extends WeatherStationDeleteArgs>(args: SelectSubset<T, WeatherStationDeleteArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WeatherStation.
     * @param {WeatherStationUpdateArgs} args - Arguments to update one WeatherStation.
     * @example
     * // Update one WeatherStation
     * const weatherStation = await prisma.weatherStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherStationUpdateArgs>(args: SelectSubset<T, WeatherStationUpdateArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WeatherStations.
     * @param {WeatherStationDeleteManyArgs} args - Arguments to filter WeatherStations to delete.
     * @example
     * // Delete a few WeatherStations
     * const { count } = await prisma.weatherStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherStationDeleteManyArgs>(args?: SelectSubset<T, WeatherStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherStations
     * const weatherStation = await prisma.weatherStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherStationUpdateManyArgs>(args: SelectSubset<T, WeatherStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeatherStation.
     * @param {WeatherStationUpsertArgs} args - Arguments to update or create a WeatherStation.
     * @example
     * // Update or create a WeatherStation
     * const weatherStation = await prisma.weatherStation.upsert({
     *   create: {
     *     // ... data to create a WeatherStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherStation we want to update
     *   }
     * })
     */
    upsert<T extends WeatherStationUpsertArgs>(args: SelectSubset<T, WeatherStationUpsertArgs<ExtArgs>>): Prisma__WeatherStationClient<$Result.GetResult<Prisma.$WeatherStationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WeatherStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationCountArgs} args - Arguments to filter WeatherStations to count.
     * @example
     * // Count the number of WeatherStations
     * const count = await prisma.weatherStation.count({
     *   where: {
     *     // ... the filter for the WeatherStations we want to count
     *   }
     * })
    **/
    count<T extends WeatherStationCountArgs>(
      args?: Subset<T, WeatherStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherStationAggregateArgs>(args: Subset<T, WeatherStationAggregateArgs>): Prisma.PrismaPromise<GetWeatherStationAggregateType<T>>

    /**
     * Group by WeatherStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherStationGroupByArgs['orderBy'] }
        : { orderBy?: WeatherStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherStation model
   */
  readonly fields: WeatherStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherStation model
   */ 
  interface WeatherStationFieldRefs {
    readonly IdWeaSta: FieldRef<"WeatherStation", 'Int'>
    readonly Station: FieldRef<"WeatherStation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeatherStation findUnique
   */
  export type WeatherStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation findUniqueOrThrow
   */
  export type WeatherStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation findFirst
   */
  export type WeatherStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherStations.
     */
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation findFirstOrThrow
   */
  export type WeatherStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter, which WeatherStation to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherStations.
     */
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation findMany
   */
  export type WeatherStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter, which WeatherStations to fetch.
     */
    where?: WeatherStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherStations to fetch.
     */
    orderBy?: WeatherStationOrderByWithRelationInput | WeatherStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherStations.
     */
    cursor?: WeatherStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherStations.
     */
    skip?: number
    distinct?: WeatherStationScalarFieldEnum | WeatherStationScalarFieldEnum[]
  }

  /**
   * WeatherStation create
   */
  export type WeatherStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * The data needed to create a WeatherStation.
     */
    data: XOR<WeatherStationCreateInput, WeatherStationUncheckedCreateInput>
  }

  /**
   * WeatherStation createMany
   */
  export type WeatherStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherStations.
     */
    data: WeatherStationCreateManyInput | WeatherStationCreateManyInput[]
  }

  /**
   * WeatherStation update
   */
  export type WeatherStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * The data needed to update a WeatherStation.
     */
    data: XOR<WeatherStationUpdateInput, WeatherStationUncheckedUpdateInput>
    /**
     * Choose, which WeatherStation to update.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation updateMany
   */
  export type WeatherStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherStations.
     */
    data: XOR<WeatherStationUpdateManyMutationInput, WeatherStationUncheckedUpdateManyInput>
    /**
     * Filter which WeatherStations to update
     */
    where?: WeatherStationWhereInput
    /**
     * Limit how many WeatherStations to update.
     */
    limit?: number
  }

  /**
   * WeatherStation upsert
   */
  export type WeatherStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * The filter to search for the WeatherStation to update in case it exists.
     */
    where: WeatherStationWhereUniqueInput
    /**
     * In case the WeatherStation found by the `where` argument doesn't exist, create a new WeatherStation with this data.
     */
    create: XOR<WeatherStationCreateInput, WeatherStationUncheckedCreateInput>
    /**
     * In case the WeatherStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherStationUpdateInput, WeatherStationUncheckedUpdateInput>
  }

  /**
   * WeatherStation delete
   */
  export type WeatherStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
    /**
     * Filter which WeatherStation to delete.
     */
    where: WeatherStationWhereUniqueInput
  }

  /**
   * WeatherStation deleteMany
   */
  export type WeatherStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherStations to delete
     */
    where?: WeatherStationWhereInput
    /**
     * Limit how many WeatherStations to delete.
     */
    limit?: number
  }

  /**
   * WeatherStation without action
   */
  export type WeatherStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherStation
     */
    select?: WeatherStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherStation
     */
    omit?: WeatherStationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AbadeMakhzanScalarFieldEnum: {
    IdMakhzan: 'IdMakhzan',
    TooleBala: 'TooleBala',
    ArzeBala: 'ArzeBala',
    TooleKaf: 'TooleKaf',
    ArzeKaf: 'ArzeKaf',
    Omgh: 'Omgh',
    HajmMohasebat: 'HajmMohasebat',
    HadeaghalHajm: 'HadeaghalHajm',
    NameStation: 'NameStation'
  };

  export type AbadeMakhzanScalarFieldEnum = (typeof AbadeMakhzanScalarFieldEnum)[keyof typeof AbadeMakhzanScalarFieldEnum]


  export const AbgirScalarFieldEnum: {
    IdKontor: 'IdKontor',
    FIdRanesh: 'FIdRanesh',
    Abgir: 'Abgir'
  };

  export type AbgirScalarFieldEnum = (typeof AbgirScalarFieldEnum)[keyof typeof AbgirScalarFieldEnum]


  export const AtashSooziScalarFieldEnum: {
    IdAtash: 'IdAtash',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    AtashSoozi: 'AtashSoozi'
  };

  export type AtashSooziScalarFieldEnum = (typeof AtashSooziScalarFieldEnum)[keyof typeof AtashSooziScalarFieldEnum]


  export const BahrebardairProgramScalarFieldEnum: {
    IdProgram: 'IdProgram',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Tedad: 'Tedad',
    Shorooe: 'Shorooe',
    Paian: 'Paian'
  };

  export type BahrebardairProgramScalarFieldEnum = (typeof BahrebardairProgramScalarFieldEnum)[keyof typeof BahrebardairProgramScalarFieldEnum]


  export const BahrebardariKeshtDoreScalarFieldEnum: {
    IdBahDor: 'IdBahDor',
    FIdSal: 'FIdSal',
    FIdDore: 'FIdDore',
    FIdRanesh: 'FIdRanesh',
    FIdNoeM: 'FIdNoeM',
    Area: 'Area'
  };

  export type BahrebardariKeshtDoreScalarFieldEnum = (typeof BahrebardariKeshtDoreScalarFieldEnum)[keyof typeof BahrebardariKeshtDoreScalarFieldEnum]


  export const BahrebardariTaghvimScalarFieldEnum: {
    IdTag: 'IdTag',
    FIdTarDor: 'FIdTarDor',
    FIdRanesh: 'FIdRanesh',
    Taghvim: 'Taghvim'
  };

  export type BahrebardariTaghvimScalarFieldEnum = (typeof BahrebardariTaghvimScalarFieldEnum)[keyof typeof BahrebardariTaghvimScalarFieldEnum]


  export const BareshMotaleatScalarFieldEnum: {
    IdBarMot: 'IdBarMot',
    FIdNet: 'FIdNet',
    FIdMah: 'FIdMah',
    BareshMotaleat: 'BareshMotaleat'
  };

  export type BareshMotaleatScalarFieldEnum = (typeof BareshMotaleatScalarFieldEnum)[keyof typeof BareshMotaleatScalarFieldEnum]


  export const DarajePipeScalarFieldEnum: {
    IdDPipe: 'IdDPipe',
    DarajePipe: 'DarajePipe'
  };

  export type DarajePipeScalarFieldEnum = (typeof DarajePipeScalarFieldEnum)[keyof typeof DarajePipeScalarFieldEnum]


  export const DarjeStationScalarFieldEnum: {
    IdDStation: 'IdDStation',
    DarajeStation: 'DarajeStation'
  };

  export type DarjeStationScalarFieldEnum = (typeof DarjeStationScalarFieldEnum)[keyof typeof DarjeStationScalarFieldEnum]


  export const DoreKeshtScalarFieldEnum: {
    IdDore: 'IdDore',
    Dore: 'Dore'
  };

  export type DoreKeshtScalarFieldEnum = (typeof DoreKeshtScalarFieldEnum)[keyof typeof DoreKeshtScalarFieldEnum]


  export const EshtebahAvamelScalarFieldEnum: {
    IdEsht: 'IdEsht',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Eshtebah: 'Eshtebah'
  };

  export type EshtebahAvamelScalarFieldEnum = (typeof EshtebahAvamelScalarFieldEnum)[keyof typeof EshtebahAvamelScalarFieldEnum]


  export const FlowBehboodScalarFieldEnum: {
    IdBehbood: 'IdBehbood',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Flow: 'Flow'
  };

  export type FlowBehboodScalarFieldEnum = (typeof FlowBehboodScalarFieldEnum)[keyof typeof FlowBehboodScalarFieldEnum]


  export const FlowmeterScalarFieldEnum: {
    IdFIT: 'IdFIT',
    FIdRanesh: 'FIdRanesh',
    FIdTrikh: 'FIdTrikh',
    Flowmeter: 'Flowmeter'
  };

  export type FlowmeterScalarFieldEnum = (typeof FlowmeterScalarFieldEnum)[keyof typeof FlowmeterScalarFieldEnum]


  export const KhatRaneshScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    RaneshName: 'RaneshName',
    FIdPumpSta: 'FIdPumpSta',
    FIdDPipe: 'FIdDPipe',
    FIdSePu: 'FIdSePu',
    FIdMeasuring: 'FIdMeasuring'
  };

  export type KhatRaneshScalarFieldEnum = (typeof KhatRaneshScalarFieldEnum)[keyof typeof KhatRaneshScalarFieldEnum]


  export const KhatRaneshAreaScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    FIdLand: 'FIdLand',
    FIdNet: 'FIdNet',
    Area: 'Area'
  };

  export type KhatRaneshAreaScalarFieldEnum = (typeof KhatRaneshAreaScalarFieldEnum)[keyof typeof KhatRaneshAreaScalarFieldEnum]


  export const KhatRaneshPumpScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    ModelPump: 'ModelPump',
    FIdPump: 'FIdPump',
    TedadPump: 'TedadPump',
    DebiPomp: 'DebiPomp',
    FesharPump: 'FesharPump',
    Randeman: 'Randeman',
    TavaneNami: 'TavaneNami',
    TavaneJazbi: 'TavaneJazbi',
    Voltazh: 'Voltazh',
    DoreMotor: 'DoreMotor',
    FeshareMakesh: 'FeshareMakesh',
    FeshareRanesh: 'FeshareRanesh',
    SizeMakesh: 'SizeMakesh',
    SizeRanesh: 'SizeRanesh',
    SizeKolektor: 'SizeKolektor',
    SizeShireKolektor: 'SizeShireKolektor'
  };

  export type KhatRaneshPumpScalarFieldEnum = (typeof KhatRaneshPumpScalarFieldEnum)[keyof typeof KhatRaneshPumpScalarFieldEnum]


  export const KhatRaneshSegliScalarFieldEnum: {
    IdRanesh: 'IdRanesh',
    FIdRanesh: 'FIdRanesh',
    Zarfiat: 'Zarfiat'
  };

  export type KhatRaneshSegliScalarFieldEnum = (typeof KhatRaneshSegliScalarFieldEnum)[keyof typeof KhatRaneshSegliScalarFieldEnum]


  export const KontorScalarFieldEnum: {
    IdKon: 'IdKon',
    FIdKontor: 'FIdKontor',
    FIdTarDor: 'FIdTarDor',
    Kontor: 'Kontor'
  };

  export type KontorScalarFieldEnum = (typeof KontorScalarFieldEnum)[keyof typeof KontorScalarFieldEnum]


  export const LandScalarFieldEnum: {
    IdLand: 'IdLand',
    Land: 'Land'
  };

  export type LandScalarFieldEnum = (typeof LandScalarFieldEnum)[keyof typeof LandScalarFieldEnum]


  export const MahScalarFieldEnum: {
    IdMah: 'IdMah',
    Mah: 'Mah'
  };

  export type MahScalarFieldEnum = (typeof MahScalarFieldEnum)[keyof typeof MahScalarFieldEnum]


  export const MeasuringToolScalarFieldEnum: {
    IdMeasuring: 'IdMeasuring',
    MeasuringTool: 'MeasuringTool',
    Precision: 'Precision'
  };

  export type MeasuringToolScalarFieldEnum = (typeof MeasuringToolScalarFieldEnum)[keyof typeof MeasuringToolScalarFieldEnum]


  export const NashtShabakeScalarFieldEnum: {
    IdNasht: 'IdNasht',
    FIdRanesh: 'FIdRanesh',
    FIdTriDor: 'FIdTriDor',
    NashtShabake: 'NashtShabake'
  };

  export type NashtShabakeScalarFieldEnum = (typeof NashtShabakeScalarFieldEnum)[keyof typeof NashtShabakeScalarFieldEnum]


  export const NetworkScalarFieldEnum: {
    IdNet: 'IdNet',
    Network: 'Network',
    FIdSP: 'FIdSP'
  };

  export type NetworkScalarFieldEnum = (typeof NetworkScalarFieldEnum)[keyof typeof NetworkScalarFieldEnum]


  export const NoeKeshtScalarFieldEnum: {
    IdNoeK: 'IdNoeK',
    Kesht: 'Kesht'
  };

  export type NoeKeshtScalarFieldEnum = (typeof NoeKeshtScalarFieldEnum)[keyof typeof NoeKeshtScalarFieldEnum]


  export const NoeMahsoolScalarFieldEnum: {
    IdNoeM: 'IdNoeM',
    Mahsool: 'Mahsool',
    FIdNoeK: 'FIdNoeK'
  };

  export type NoeMahsoolScalarFieldEnum = (typeof NoeMahsoolScalarFieldEnum)[keyof typeof NoeMahsoolScalarFieldEnum]


  export const NonFITScalarFieldEnum: {
    IdNonFIT: 'IdNonFIT',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    VOLUM: 'VOLUM'
  };

  export type NonFITScalarFieldEnum = (typeof NonFITScalarFieldEnum)[keyof typeof NonFITScalarFieldEnum]


  export const PumpStationScalarFieldEnum: {
    IdPumpSta: 'IdPumpSta',
    NameStation: 'NameStation',
    KM: 'KM',
    FIdNet: 'FIdNet',
    FIdDStation: 'FIdDStation',
    FIdMakhzan: 'FIdMakhzan'
  };

  export type PumpStationScalarFieldEnum = (typeof PumpStationScalarFieldEnum)[keyof typeof PumpStationScalarFieldEnum]


  export const PumpTypeScalarFieldEnum: {
    IdPump: 'IdPump',
    PumpType: 'PumpType'
  };

  export type PumpTypeScalarFieldEnum = (typeof PumpTypeScalarFieldEnum)[keyof typeof PumpTypeScalarFieldEnum]


  export const RainfallStationScalarFieldEnum: {
    IdRaiSta: 'IdRaiSta',
    FIdWeaSta: 'FIdWeaSta',
    FIdTrikh: 'FIdTrikh',
    FIdRaiTy: 'FIdRaiTy',
    ErtefaeBaresh: 'ErtefaeBaresh'
  };

  export type RainfallStationScalarFieldEnum = (typeof RainfallStationScalarFieldEnum)[keyof typeof RainfallStationScalarFieldEnum]


  export const RainfallTypeScalarFieldEnum: {
    IdRaiTy: 'IdRaiTy',
    RainfallType: 'RainfallType'
  };

  export type RainfallTypeScalarFieldEnum = (typeof RainfallTypeScalarFieldEnum)[keyof typeof RainfallTypeScalarFieldEnum]


  export const SaleZeraeeScalarFieldEnum: {
    IdSal: 'IdSal',
    SaleZeraee: 'SaleZeraee'
  };

  export type SaleZeraeeScalarFieldEnum = (typeof SaleZeraeeScalarFieldEnum)[keyof typeof SaleZeraeeScalarFieldEnum]


  export const SeghliPumpScalarFieldEnum: {
    IdSePu: 'IdSePu',
    SeghliPump: 'SeghliPump'
  };

  export type SeghliPumpScalarFieldEnum = (typeof SeghliPumpScalarFieldEnum)[keyof typeof SeghliPumpScalarFieldEnum]


  export const SystemPartScalarFieldEnum: {
    IdSP: 'IdSP',
    Part: 'Part',
    KM: 'KM'
  };

  export type SystemPartScalarFieldEnum = (typeof SystemPartScalarFieldEnum)[keyof typeof SystemPartScalarFieldEnum]


  export const TakhlieMakhzanScalarFieldEnum: {
    IdTakhlie: 'IdTakhlie',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Takhlie: 'Takhlie'
  };

  export type TakhlieMakhzanScalarFieldEnum = (typeof TakhlieMakhzanScalarFieldEnum)[keyof typeof TakhlieMakhzanScalarFieldEnum]


  export const TestScalarFieldEnum: {
    IdTest: 'IdTest',
    FIdRanesh: 'FIdRanesh',
    FIdTarDor: 'FIdTarDor',
    Test: 'Test'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TrikhDoreKeshtScalarFieldEnum: {
    IdTarDor: 'IdTarDor',
    FIdSal: 'FIdSal',
    FIdDore: 'FIdDore',
    Trikh: 'Trikh',
    TrikhKhorshidi: 'TrikhKhorshidi'
  };

  export type TrikhDoreKeshtScalarFieldEnum = (typeof TrikhDoreKeshtScalarFieldEnum)[keyof typeof TrikhDoreKeshtScalarFieldEnum]


  export const WeatherStationScalarFieldEnum: {
    IdWeaSta: 'IdWeaSta',
    Station: 'Station'
  };

  export type WeatherStationScalarFieldEnum = (typeof WeatherStationScalarFieldEnum)[keyof typeof WeatherStationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AbadeMakhzanWhereInput = {
    AND?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    OR?: AbadeMakhzanWhereInput[]
    NOT?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    IdMakhzan?: IntFilter<"AbadeMakhzan"> | number
    TooleBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringFilter<"AbadeMakhzan"> | string
  }

  export type AbadeMakhzanOrderByWithRelationInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrderInput | SortOrder
    ArzeBala?: SortOrderInput | SortOrder
    TooleKaf?: SortOrderInput | SortOrder
    ArzeKaf?: SortOrderInput | SortOrder
    Omgh?: SortOrderInput | SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrderInput | SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanWhereUniqueInput = Prisma.AtLeast<{
    IdMakhzan?: number
    AND?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    OR?: AbadeMakhzanWhereInput[]
    NOT?: AbadeMakhzanWhereInput | AbadeMakhzanWhereInput[]
    TooleBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringFilter<"AbadeMakhzan"> | string
  }, "IdMakhzan">

  export type AbadeMakhzanOrderByWithAggregationInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrderInput | SortOrder
    ArzeBala?: SortOrderInput | SortOrder
    TooleKaf?: SortOrderInput | SortOrder
    ArzeKaf?: SortOrderInput | SortOrder
    Omgh?: SortOrderInput | SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrderInput | SortOrder
    NameStation?: SortOrder
    _count?: AbadeMakhzanCountOrderByAggregateInput
    _avg?: AbadeMakhzanAvgOrderByAggregateInput
    _max?: AbadeMakhzanMaxOrderByAggregateInput
    _min?: AbadeMakhzanMinOrderByAggregateInput
    _sum?: AbadeMakhzanSumOrderByAggregateInput
  }

  export type AbadeMakhzanScalarWhereWithAggregatesInput = {
    AND?: AbadeMakhzanScalarWhereWithAggregatesInput | AbadeMakhzanScalarWhereWithAggregatesInput[]
    OR?: AbadeMakhzanScalarWhereWithAggregatesInput[]
    NOT?: AbadeMakhzanScalarWhereWithAggregatesInput | AbadeMakhzanScalarWhereWithAggregatesInput[]
    IdMakhzan?: IntWithAggregatesFilter<"AbadeMakhzan"> | number
    TooleBala?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    Omgh?: DecimalNullableWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalWithAggregatesFilter<"AbadeMakhzan"> | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: IntNullableWithAggregatesFilter<"AbadeMakhzan"> | number | null
    NameStation?: StringWithAggregatesFilter<"AbadeMakhzan"> | string
  }

  export type AbgirWhereInput = {
    AND?: AbgirWhereInput | AbgirWhereInput[]
    OR?: AbgirWhereInput[]
    NOT?: AbgirWhereInput | AbgirWhereInput[]
    IdKontor?: IntFilter<"Abgir"> | number
    FIdRanesh?: IntFilter<"Abgir"> | number
    Abgir?: StringFilter<"Abgir"> | string
  }

  export type AbgirOrderByWithRelationInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirWhereUniqueInput = Prisma.AtLeast<{
    IdKontor?: number
    AND?: AbgirWhereInput | AbgirWhereInput[]
    OR?: AbgirWhereInput[]
    NOT?: AbgirWhereInput | AbgirWhereInput[]
    FIdRanesh?: IntFilter<"Abgir"> | number
    Abgir?: StringFilter<"Abgir"> | string
  }, "IdKontor">

  export type AbgirOrderByWithAggregationInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
    _count?: AbgirCountOrderByAggregateInput
    _avg?: AbgirAvgOrderByAggregateInput
    _max?: AbgirMaxOrderByAggregateInput
    _min?: AbgirMinOrderByAggregateInput
    _sum?: AbgirSumOrderByAggregateInput
  }

  export type AbgirScalarWhereWithAggregatesInput = {
    AND?: AbgirScalarWhereWithAggregatesInput | AbgirScalarWhereWithAggregatesInput[]
    OR?: AbgirScalarWhereWithAggregatesInput[]
    NOT?: AbgirScalarWhereWithAggregatesInput | AbgirScalarWhereWithAggregatesInput[]
    IdKontor?: IntWithAggregatesFilter<"Abgir"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Abgir"> | number
    Abgir?: StringWithAggregatesFilter<"Abgir"> | string
  }

  export type AtashSooziWhereInput = {
    AND?: AtashSooziWhereInput | AtashSooziWhereInput[]
    OR?: AtashSooziWhereInput[]
    NOT?: AtashSooziWhereInput | AtashSooziWhereInput[]
    IdAtash?: IntFilter<"AtashSoozi"> | number
    FIdRanesh?: IntNullableFilter<"AtashSoozi"> | number | null
    FIdTarDor?: IntNullableFilter<"AtashSoozi"> | number | null
    AtashSoozi?: IntNullableFilter<"AtashSoozi"> | number | null
  }

  export type AtashSooziOrderByWithRelationInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrderInput | SortOrder
    FIdTarDor?: SortOrderInput | SortOrder
    AtashSoozi?: SortOrderInput | SortOrder
  }

  export type AtashSooziWhereUniqueInput = Prisma.AtLeast<{
    IdAtash?: number
    AND?: AtashSooziWhereInput | AtashSooziWhereInput[]
    OR?: AtashSooziWhereInput[]
    NOT?: AtashSooziWhereInput | AtashSooziWhereInput[]
    FIdRanesh?: IntNullableFilter<"AtashSoozi"> | number | null
    FIdTarDor?: IntNullableFilter<"AtashSoozi"> | number | null
    AtashSoozi?: IntNullableFilter<"AtashSoozi"> | number | null
  }, "IdAtash">

  export type AtashSooziOrderByWithAggregationInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrderInput | SortOrder
    FIdTarDor?: SortOrderInput | SortOrder
    AtashSoozi?: SortOrderInput | SortOrder
    _count?: AtashSooziCountOrderByAggregateInput
    _avg?: AtashSooziAvgOrderByAggregateInput
    _max?: AtashSooziMaxOrderByAggregateInput
    _min?: AtashSooziMinOrderByAggregateInput
    _sum?: AtashSooziSumOrderByAggregateInput
  }

  export type AtashSooziScalarWhereWithAggregatesInput = {
    AND?: AtashSooziScalarWhereWithAggregatesInput | AtashSooziScalarWhereWithAggregatesInput[]
    OR?: AtashSooziScalarWhereWithAggregatesInput[]
    NOT?: AtashSooziScalarWhereWithAggregatesInput | AtashSooziScalarWhereWithAggregatesInput[]
    IdAtash?: IntWithAggregatesFilter<"AtashSoozi"> | number
    FIdRanesh?: IntNullableWithAggregatesFilter<"AtashSoozi"> | number | null
    FIdTarDor?: IntNullableWithAggregatesFilter<"AtashSoozi"> | number | null
    AtashSoozi?: IntNullableWithAggregatesFilter<"AtashSoozi"> | number | null
  }

  export type BahrebardairProgramWhereInput = {
    AND?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    OR?: BahrebardairProgramWhereInput[]
    NOT?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    IdProgram?: IntFilter<"BahrebardairProgram"> | number
    FIdRanesh?: IntFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgram"> | number
    Tedad?: IntFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
  }

  export type BahrebardairProgramOrderByWithRelationInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
  }

  export type BahrebardairProgramWhereUniqueInput = Prisma.AtLeast<{
    IdProgram?: number
    AND?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    OR?: BahrebardairProgramWhereInput[]
    NOT?: BahrebardairProgramWhereInput | BahrebardairProgramWhereInput[]
    FIdRanesh?: IntFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntFilter<"BahrebardairProgram"> | number
    Tedad?: IntFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableFilter<"BahrebardairProgram"> | Date | string | null
  }, "IdProgram">

  export type BahrebardairProgramOrderByWithAggregationInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrderInput | SortOrder
    Paian?: SortOrderInput | SortOrder
    _count?: BahrebardairProgramCountOrderByAggregateInput
    _avg?: BahrebardairProgramAvgOrderByAggregateInput
    _max?: BahrebardairProgramMaxOrderByAggregateInput
    _min?: BahrebardairProgramMinOrderByAggregateInput
    _sum?: BahrebardairProgramSumOrderByAggregateInput
  }

  export type BahrebardairProgramScalarWhereWithAggregatesInput = {
    AND?: BahrebardairProgramScalarWhereWithAggregatesInput | BahrebardairProgramScalarWhereWithAggregatesInput[]
    OR?: BahrebardairProgramScalarWhereWithAggregatesInput[]
    NOT?: BahrebardairProgramScalarWhereWithAggregatesInput | BahrebardairProgramScalarWhereWithAggregatesInput[]
    IdProgram?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    FIdTarDor?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    Tedad?: IntWithAggregatesFilter<"BahrebardairProgram"> | number
    Shorooe?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgram"> | Date | string | null
    Paian?: DateTimeNullableWithAggregatesFilter<"BahrebardairProgram"> | Date | string | null
  }

  export type BahrebardariKeshtDoreWhereInput = {
    AND?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    OR?: BahrebardariKeshtDoreWhereInput[]
    NOT?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    IdBahDor?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdSal?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdDore?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreOrderByWithRelationInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreWhereUniqueInput = Prisma.AtLeast<{
    IdBahDor?: number
    AND?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    OR?: BahrebardariKeshtDoreWhereInput[]
    NOT?: BahrebardariKeshtDoreWhereInput | BahrebardariKeshtDoreWhereInput[]
    FIdSal?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdDore?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
  }, "IdBahDor">

  export type BahrebardariKeshtDoreOrderByWithAggregationInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
    _count?: BahrebardariKeshtDoreCountOrderByAggregateInput
    _avg?: BahrebardariKeshtDoreAvgOrderByAggregateInput
    _max?: BahrebardariKeshtDoreMaxOrderByAggregateInput
    _min?: BahrebardariKeshtDoreMinOrderByAggregateInput
    _sum?: BahrebardariKeshtDoreSumOrderByAggregateInput
  }

  export type BahrebardariKeshtDoreScalarWhereWithAggregatesInput = {
    AND?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput | BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    OR?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    NOT?: BahrebardariKeshtDoreScalarWhereWithAggregatesInput | BahrebardariKeshtDoreScalarWhereWithAggregatesInput[]
    IdBahDor?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdSal?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdDore?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    FIdNoeM?: IntWithAggregatesFilter<"BahrebardariKeshtDore"> | number
    Area?: DecimalWithAggregatesFilter<"BahrebardariKeshtDore"> | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimWhereInput = {
    AND?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    OR?: BahrebardariTaghvimWhereInput[]
    NOT?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    IdTag?: IntFilter<"BahrebardariTaghvim"> | number
    FIdTarDor?: IntFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimOrderByWithRelationInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimWhereUniqueInput = Prisma.AtLeast<{
    IdTag?: number
    AND?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    OR?: BahrebardariTaghvimWhereInput[]
    NOT?: BahrebardariTaghvimWhereInput | BahrebardariTaghvimWhereInput[]
    FIdTarDor?: IntFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
  }, "IdTag">

  export type BahrebardariTaghvimOrderByWithAggregationInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
    _count?: BahrebardariTaghvimCountOrderByAggregateInput
    _avg?: BahrebardariTaghvimAvgOrderByAggregateInput
    _max?: BahrebardariTaghvimMaxOrderByAggregateInput
    _min?: BahrebardariTaghvimMinOrderByAggregateInput
    _sum?: BahrebardariTaghvimSumOrderByAggregateInput
  }

  export type BahrebardariTaghvimScalarWhereWithAggregatesInput = {
    AND?: BahrebardariTaghvimScalarWhereWithAggregatesInput | BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    OR?: BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    NOT?: BahrebardariTaghvimScalarWhereWithAggregatesInput | BahrebardariTaghvimScalarWhereWithAggregatesInput[]
    IdTag?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    FIdTarDor?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    FIdRanesh?: IntWithAggregatesFilter<"BahrebardariTaghvim"> | number
    Taghvim?: DecimalWithAggregatesFilter<"BahrebardariTaghvim"> | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatWhereInput = {
    AND?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    OR?: BareshMotaleatWhereInput[]
    NOT?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    IdBarMot?: IntFilter<"BareshMotaleat"> | number
    FIdNet?: IntFilter<"BareshMotaleat"> | number
    FIdMah?: IntFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatOrderByWithRelationInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatWhereUniqueInput = Prisma.AtLeast<{
    IdBarMot?: number
    AND?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    OR?: BareshMotaleatWhereInput[]
    NOT?: BareshMotaleatWhereInput | BareshMotaleatWhereInput[]
    FIdNet?: IntFilter<"BareshMotaleat"> | number
    FIdMah?: IntFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
  }, "IdBarMot">

  export type BareshMotaleatOrderByWithAggregationInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
    _count?: BareshMotaleatCountOrderByAggregateInput
    _avg?: BareshMotaleatAvgOrderByAggregateInput
    _max?: BareshMotaleatMaxOrderByAggregateInput
    _min?: BareshMotaleatMinOrderByAggregateInput
    _sum?: BareshMotaleatSumOrderByAggregateInput
  }

  export type BareshMotaleatScalarWhereWithAggregatesInput = {
    AND?: BareshMotaleatScalarWhereWithAggregatesInput | BareshMotaleatScalarWhereWithAggregatesInput[]
    OR?: BareshMotaleatScalarWhereWithAggregatesInput[]
    NOT?: BareshMotaleatScalarWhereWithAggregatesInput | BareshMotaleatScalarWhereWithAggregatesInput[]
    IdBarMot?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    FIdNet?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    FIdMah?: IntWithAggregatesFilter<"BareshMotaleat"> | number
    BareshMotaleat?: DecimalWithAggregatesFilter<"BareshMotaleat"> | Decimal | DecimalJsLike | number | string
  }

  export type DarajePipeWhereInput = {
    AND?: DarajePipeWhereInput | DarajePipeWhereInput[]
    OR?: DarajePipeWhereInput[]
    NOT?: DarajePipeWhereInput | DarajePipeWhereInput[]
    IdDPipe?: IntFilter<"DarajePipe"> | number
    DarajePipe?: StringFilter<"DarajePipe"> | string
  }

  export type DarajePipeOrderByWithRelationInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeWhereUniqueInput = Prisma.AtLeast<{
    IdDPipe?: number
    AND?: DarajePipeWhereInput | DarajePipeWhereInput[]
    OR?: DarajePipeWhereInput[]
    NOT?: DarajePipeWhereInput | DarajePipeWhereInput[]
    DarajePipe?: StringFilter<"DarajePipe"> | string
  }, "IdDPipe">

  export type DarajePipeOrderByWithAggregationInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
    _count?: DarajePipeCountOrderByAggregateInput
    _avg?: DarajePipeAvgOrderByAggregateInput
    _max?: DarajePipeMaxOrderByAggregateInput
    _min?: DarajePipeMinOrderByAggregateInput
    _sum?: DarajePipeSumOrderByAggregateInput
  }

  export type DarajePipeScalarWhereWithAggregatesInput = {
    AND?: DarajePipeScalarWhereWithAggregatesInput | DarajePipeScalarWhereWithAggregatesInput[]
    OR?: DarajePipeScalarWhereWithAggregatesInput[]
    NOT?: DarajePipeScalarWhereWithAggregatesInput | DarajePipeScalarWhereWithAggregatesInput[]
    IdDPipe?: IntWithAggregatesFilter<"DarajePipe"> | number
    DarajePipe?: StringWithAggregatesFilter<"DarajePipe"> | string
  }

  export type DarjeStationWhereInput = {
    AND?: DarjeStationWhereInput | DarjeStationWhereInput[]
    OR?: DarjeStationWhereInput[]
    NOT?: DarjeStationWhereInput | DarjeStationWhereInput[]
    IdDStation?: IntFilter<"DarjeStation"> | number
    DarajeStation?: StringFilter<"DarjeStation"> | string
  }

  export type DarjeStationOrderByWithRelationInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationWhereUniqueInput = Prisma.AtLeast<{
    IdDStation?: number
    AND?: DarjeStationWhereInput | DarjeStationWhereInput[]
    OR?: DarjeStationWhereInput[]
    NOT?: DarjeStationWhereInput | DarjeStationWhereInput[]
    DarajeStation?: StringFilter<"DarjeStation"> | string
  }, "IdDStation">

  export type DarjeStationOrderByWithAggregationInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
    _count?: DarjeStationCountOrderByAggregateInput
    _avg?: DarjeStationAvgOrderByAggregateInput
    _max?: DarjeStationMaxOrderByAggregateInput
    _min?: DarjeStationMinOrderByAggregateInput
    _sum?: DarjeStationSumOrderByAggregateInput
  }

  export type DarjeStationScalarWhereWithAggregatesInput = {
    AND?: DarjeStationScalarWhereWithAggregatesInput | DarjeStationScalarWhereWithAggregatesInput[]
    OR?: DarjeStationScalarWhereWithAggregatesInput[]
    NOT?: DarjeStationScalarWhereWithAggregatesInput | DarjeStationScalarWhereWithAggregatesInput[]
    IdDStation?: IntWithAggregatesFilter<"DarjeStation"> | number
    DarajeStation?: StringWithAggregatesFilter<"DarjeStation"> | string
  }

  export type DoreKeshtWhereInput = {
    AND?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    OR?: DoreKeshtWhereInput[]
    NOT?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    IdDore?: IntFilter<"DoreKesht"> | number
    Dore?: StringFilter<"DoreKesht"> | string
  }

  export type DoreKeshtOrderByWithRelationInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdDore?: number
    AND?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    OR?: DoreKeshtWhereInput[]
    NOT?: DoreKeshtWhereInput | DoreKeshtWhereInput[]
    Dore?: StringFilter<"DoreKesht"> | string
  }, "IdDore">

  export type DoreKeshtOrderByWithAggregationInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
    _count?: DoreKeshtCountOrderByAggregateInput
    _avg?: DoreKeshtAvgOrderByAggregateInput
    _max?: DoreKeshtMaxOrderByAggregateInput
    _min?: DoreKeshtMinOrderByAggregateInput
    _sum?: DoreKeshtSumOrderByAggregateInput
  }

  export type DoreKeshtScalarWhereWithAggregatesInput = {
    AND?: DoreKeshtScalarWhereWithAggregatesInput | DoreKeshtScalarWhereWithAggregatesInput[]
    OR?: DoreKeshtScalarWhereWithAggregatesInput[]
    NOT?: DoreKeshtScalarWhereWithAggregatesInput | DoreKeshtScalarWhereWithAggregatesInput[]
    IdDore?: IntWithAggregatesFilter<"DoreKesht"> | number
    Dore?: StringWithAggregatesFilter<"DoreKesht"> | string
  }

  export type EshtebahAvamelWhereInput = {
    AND?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    OR?: EshtebahAvamelWhereInput[]
    NOT?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    IdEsht?: IntFilter<"EshtebahAvamel"> | number
    FIdRanesh?: IntFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntFilter<"EshtebahAvamel"> | number
  }

  export type EshtebahAvamelOrderByWithRelationInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelWhereUniqueInput = Prisma.AtLeast<{
    IdEsht?: number
    AND?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    OR?: EshtebahAvamelWhereInput[]
    NOT?: EshtebahAvamelWhereInput | EshtebahAvamelWhereInput[]
    FIdRanesh?: IntFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntFilter<"EshtebahAvamel"> | number
  }, "IdEsht">

  export type EshtebahAvamelOrderByWithAggregationInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
    _count?: EshtebahAvamelCountOrderByAggregateInput
    _avg?: EshtebahAvamelAvgOrderByAggregateInput
    _max?: EshtebahAvamelMaxOrderByAggregateInput
    _min?: EshtebahAvamelMinOrderByAggregateInput
    _sum?: EshtebahAvamelSumOrderByAggregateInput
  }

  export type EshtebahAvamelScalarWhereWithAggregatesInput = {
    AND?: EshtebahAvamelScalarWhereWithAggregatesInput | EshtebahAvamelScalarWhereWithAggregatesInput[]
    OR?: EshtebahAvamelScalarWhereWithAggregatesInput[]
    NOT?: EshtebahAvamelScalarWhereWithAggregatesInput | EshtebahAvamelScalarWhereWithAggregatesInput[]
    IdEsht?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    FIdRanesh?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    FIdTarDor?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
    Eshtebah?: IntWithAggregatesFilter<"EshtebahAvamel"> | number
  }

  export type FlowBehboodWhereInput = {
    AND?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    OR?: FlowBehboodWhereInput[]
    NOT?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    IdBehbood?: IntFilter<"FlowBehbood"> | number
    FIdRanesh?: IntFilter<"FlowBehbood"> | number
    FIdTarDor?: IntFilter<"FlowBehbood"> | number
    Flow?: IntFilter<"FlowBehbood"> | number
  }

  export type FlowBehboodOrderByWithRelationInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodWhereUniqueInput = Prisma.AtLeast<{
    IdBehbood?: number
    AND?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    OR?: FlowBehboodWhereInput[]
    NOT?: FlowBehboodWhereInput | FlowBehboodWhereInput[]
    FIdRanesh?: IntFilter<"FlowBehbood"> | number
    FIdTarDor?: IntFilter<"FlowBehbood"> | number
    Flow?: IntFilter<"FlowBehbood"> | number
  }, "IdBehbood">

  export type FlowBehboodOrderByWithAggregationInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
    _count?: FlowBehboodCountOrderByAggregateInput
    _avg?: FlowBehboodAvgOrderByAggregateInput
    _max?: FlowBehboodMaxOrderByAggregateInput
    _min?: FlowBehboodMinOrderByAggregateInput
    _sum?: FlowBehboodSumOrderByAggregateInput
  }

  export type FlowBehboodScalarWhereWithAggregatesInput = {
    AND?: FlowBehboodScalarWhereWithAggregatesInput | FlowBehboodScalarWhereWithAggregatesInput[]
    OR?: FlowBehboodScalarWhereWithAggregatesInput[]
    NOT?: FlowBehboodScalarWhereWithAggregatesInput | FlowBehboodScalarWhereWithAggregatesInput[]
    IdBehbood?: IntWithAggregatesFilter<"FlowBehbood"> | number
    FIdRanesh?: IntWithAggregatesFilter<"FlowBehbood"> | number
    FIdTarDor?: IntWithAggregatesFilter<"FlowBehbood"> | number
    Flow?: IntWithAggregatesFilter<"FlowBehbood"> | number
  }

  export type FlowmeterWhereInput = {
    AND?: FlowmeterWhereInput | FlowmeterWhereInput[]
    OR?: FlowmeterWhereInput[]
    NOT?: FlowmeterWhereInput | FlowmeterWhereInput[]
    IdFIT?: IntFilter<"Flowmeter"> | number
    FIdRanesh?: IntFilter<"Flowmeter"> | number
    FIdTrikh?: IntFilter<"Flowmeter"> | number
    Flowmeter?: FloatFilter<"Flowmeter"> | number
  }

  export type FlowmeterOrderByWithRelationInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterWhereUniqueInput = Prisma.AtLeast<{
    IdFIT?: number
    AND?: FlowmeterWhereInput | FlowmeterWhereInput[]
    OR?: FlowmeterWhereInput[]
    NOT?: FlowmeterWhereInput | FlowmeterWhereInput[]
    FIdRanesh?: IntFilter<"Flowmeter"> | number
    FIdTrikh?: IntFilter<"Flowmeter"> | number
    Flowmeter?: FloatFilter<"Flowmeter"> | number
  }, "IdFIT">

  export type FlowmeterOrderByWithAggregationInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
    _count?: FlowmeterCountOrderByAggregateInput
    _avg?: FlowmeterAvgOrderByAggregateInput
    _max?: FlowmeterMaxOrderByAggregateInput
    _min?: FlowmeterMinOrderByAggregateInput
    _sum?: FlowmeterSumOrderByAggregateInput
  }

  export type FlowmeterScalarWhereWithAggregatesInput = {
    AND?: FlowmeterScalarWhereWithAggregatesInput | FlowmeterScalarWhereWithAggregatesInput[]
    OR?: FlowmeterScalarWhereWithAggregatesInput[]
    NOT?: FlowmeterScalarWhereWithAggregatesInput | FlowmeterScalarWhereWithAggregatesInput[]
    IdFIT?: IntWithAggregatesFilter<"Flowmeter"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Flowmeter"> | number
    FIdTrikh?: IntWithAggregatesFilter<"Flowmeter"> | number
    Flowmeter?: FloatWithAggregatesFilter<"Flowmeter"> | number
  }

  export type KhatRaneshWhereInput = {
    AND?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    OR?: KhatRaneshWhereInput[]
    NOT?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    IdRanesh?: IntFilter<"KhatRanesh"> | number
    RaneshName?: StringFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntFilter<"KhatRanesh"> | number
    FIdDPipe?: IntFilter<"KhatRanesh"> | number
    FIdSePu?: IntFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntFilter<"KhatRanesh"> | number
  }

  export type KhatRaneshOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    OR?: KhatRaneshWhereInput[]
    NOT?: KhatRaneshWhereInput | KhatRaneshWhereInput[]
    RaneshName?: StringFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntFilter<"KhatRanesh"> | number
    FIdDPipe?: IntFilter<"KhatRanesh"> | number
    FIdSePu?: IntFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntFilter<"KhatRanesh"> | number
  }, "IdRanesh">

  export type KhatRaneshOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
    _count?: KhatRaneshCountOrderByAggregateInput
    _avg?: KhatRaneshAvgOrderByAggregateInput
    _max?: KhatRaneshMaxOrderByAggregateInput
    _min?: KhatRaneshMinOrderByAggregateInput
    _sum?: KhatRaneshSumOrderByAggregateInput
  }

  export type KhatRaneshScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshScalarWhereWithAggregatesInput | KhatRaneshScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshScalarWhereWithAggregatesInput | KhatRaneshScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRanesh"> | number
    RaneshName?: StringWithAggregatesFilter<"KhatRanesh"> | string
    FIdPumpSta?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdDPipe?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdSePu?: IntWithAggregatesFilter<"KhatRanesh"> | number
    FIdMeasuring?: IntWithAggregatesFilter<"KhatRanesh"> | number
  }

  export type KhatRaneshAreaWhereInput = {
    AND?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    OR?: KhatRaneshAreaWhereInput[]
    NOT?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdLand?: IntFilter<"KhatRaneshArea"> | number
    FIdNet?: IntFilter<"KhatRaneshArea"> | number
    Area?: DecimalFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    OR?: KhatRaneshAreaWhereInput[]
    NOT?: KhatRaneshAreaWhereInput | KhatRaneshAreaWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshArea"> | number
    FIdLand?: IntFilter<"KhatRaneshArea"> | number
    FIdNet?: IntFilter<"KhatRaneshArea"> | number
    Area?: DecimalFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
  }, "IdRanesh">

  export type KhatRaneshAreaOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
    _count?: KhatRaneshAreaCountOrderByAggregateInput
    _avg?: KhatRaneshAreaAvgOrderByAggregateInput
    _max?: KhatRaneshAreaMaxOrderByAggregateInput
    _min?: KhatRaneshAreaMinOrderByAggregateInput
    _sum?: KhatRaneshAreaSumOrderByAggregateInput
  }

  export type KhatRaneshAreaScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshAreaScalarWhereWithAggregatesInput | KhatRaneshAreaScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshAreaScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshAreaScalarWhereWithAggregatesInput | KhatRaneshAreaScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdLand?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    FIdNet?: IntWithAggregatesFilter<"KhatRaneshArea"> | number
    Area?: DecimalWithAggregatesFilter<"KhatRaneshArea"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpWhereInput = {
    AND?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    OR?: KhatRaneshPumpWhereInput[]
    NOT?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshPump"> | number
    FIdRanesh?: IntFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntFilter<"KhatRaneshPump"> | number
  }

  export type KhatRaneshPumpOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrderInput | SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrderInput | SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    OR?: KhatRaneshPumpWhereInput[]
    NOT?: KhatRaneshPumpWhereInput | KhatRaneshPumpWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntFilter<"KhatRaneshPump"> | number
  }, "IdRanesh">

  export type KhatRaneshPumpOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrderInput | SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrderInput | SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
    _count?: KhatRaneshPumpCountOrderByAggregateInput
    _avg?: KhatRaneshPumpAvgOrderByAggregateInput
    _max?: KhatRaneshPumpMaxOrderByAggregateInput
    _min?: KhatRaneshPumpMinOrderByAggregateInput
    _sum?: KhatRaneshPumpSumOrderByAggregateInput
  }

  export type KhatRaneshPumpScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshPumpScalarWhereWithAggregatesInput | KhatRaneshPumpScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshPumpScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshPumpScalarWhereWithAggregatesInput | KhatRaneshPumpScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    ModelPump?: StringNullableWithAggregatesFilter<"KhatRaneshPump"> | string | null
    FIdPump?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    TedadPump?: IntNullableWithAggregatesFilter<"KhatRaneshPump"> | number | null
    DebiPomp?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Randeman?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    TavaneNami?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalWithAggregatesFilter<"KhatRaneshPump"> | Decimal | DecimalJsLike | number | string
    Voltazh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    DoreMotor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FeshareMakesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    FeshareRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeMakesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeRanesh?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeKolektor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
    SizeShireKolektor?: IntWithAggregatesFilter<"KhatRaneshPump"> | number
  }

  export type KhatRaneshSegliWhereInput = {
    AND?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    OR?: KhatRaneshSegliWhereInput[]
    NOT?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    IdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    FIdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliOrderByWithRelationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliWhereUniqueInput = Prisma.AtLeast<{
    IdRanesh?: number
    AND?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    OR?: KhatRaneshSegliWhereInput[]
    NOT?: KhatRaneshSegliWhereInput | KhatRaneshSegliWhereInput[]
    FIdRanesh?: IntFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
  }, "IdRanesh">

  export type KhatRaneshSegliOrderByWithAggregationInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
    _count?: KhatRaneshSegliCountOrderByAggregateInput
    _avg?: KhatRaneshSegliAvgOrderByAggregateInput
    _max?: KhatRaneshSegliMaxOrderByAggregateInput
    _min?: KhatRaneshSegliMinOrderByAggregateInput
    _sum?: KhatRaneshSegliSumOrderByAggregateInput
  }

  export type KhatRaneshSegliScalarWhereWithAggregatesInput = {
    AND?: KhatRaneshSegliScalarWhereWithAggregatesInput | KhatRaneshSegliScalarWhereWithAggregatesInput[]
    OR?: KhatRaneshSegliScalarWhereWithAggregatesInput[]
    NOT?: KhatRaneshSegliScalarWhereWithAggregatesInput | KhatRaneshSegliScalarWhereWithAggregatesInput[]
    IdRanesh?: IntWithAggregatesFilter<"KhatRaneshSegli"> | number
    FIdRanesh?: IntWithAggregatesFilter<"KhatRaneshSegli"> | number
    Zarfiat?: DecimalWithAggregatesFilter<"KhatRaneshSegli"> | Decimal | DecimalJsLike | number | string
  }

  export type KontorWhereInput = {
    AND?: KontorWhereInput | KontorWhereInput[]
    OR?: KontorWhereInput[]
    NOT?: KontorWhereInput | KontorWhereInput[]
    IdKon?: IntFilter<"Kontor"> | number
    FIdKontor?: IntFilter<"Kontor"> | number
    FIdTarDor?: IntFilter<"Kontor"> | number
    Kontor?: IntFilter<"Kontor"> | number
  }

  export type KontorOrderByWithRelationInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorWhereUniqueInput = Prisma.AtLeast<{
    IdKon?: number
    AND?: KontorWhereInput | KontorWhereInput[]
    OR?: KontorWhereInput[]
    NOT?: KontorWhereInput | KontorWhereInput[]
    FIdKontor?: IntFilter<"Kontor"> | number
    FIdTarDor?: IntFilter<"Kontor"> | number
    Kontor?: IntFilter<"Kontor"> | number
  }, "IdKon">

  export type KontorOrderByWithAggregationInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
    _count?: KontorCountOrderByAggregateInput
    _avg?: KontorAvgOrderByAggregateInput
    _max?: KontorMaxOrderByAggregateInput
    _min?: KontorMinOrderByAggregateInput
    _sum?: KontorSumOrderByAggregateInput
  }

  export type KontorScalarWhereWithAggregatesInput = {
    AND?: KontorScalarWhereWithAggregatesInput | KontorScalarWhereWithAggregatesInput[]
    OR?: KontorScalarWhereWithAggregatesInput[]
    NOT?: KontorScalarWhereWithAggregatesInput | KontorScalarWhereWithAggregatesInput[]
    IdKon?: IntWithAggregatesFilter<"Kontor"> | number
    FIdKontor?: IntWithAggregatesFilter<"Kontor"> | number
    FIdTarDor?: IntWithAggregatesFilter<"Kontor"> | number
    Kontor?: IntWithAggregatesFilter<"Kontor"> | number
  }

  export type LandWhereInput = {
    AND?: LandWhereInput | LandWhereInput[]
    OR?: LandWhereInput[]
    NOT?: LandWhereInput | LandWhereInput[]
    IdLand?: IntFilter<"Land"> | number
    Land?: StringFilter<"Land"> | string
  }

  export type LandOrderByWithRelationInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandWhereUniqueInput = Prisma.AtLeast<{
    IdLand?: number
    AND?: LandWhereInput | LandWhereInput[]
    OR?: LandWhereInput[]
    NOT?: LandWhereInput | LandWhereInput[]
    Land?: StringFilter<"Land"> | string
  }, "IdLand">

  export type LandOrderByWithAggregationInput = {
    IdLand?: SortOrder
    Land?: SortOrder
    _count?: LandCountOrderByAggregateInput
    _avg?: LandAvgOrderByAggregateInput
    _max?: LandMaxOrderByAggregateInput
    _min?: LandMinOrderByAggregateInput
    _sum?: LandSumOrderByAggregateInput
  }

  export type LandScalarWhereWithAggregatesInput = {
    AND?: LandScalarWhereWithAggregatesInput | LandScalarWhereWithAggregatesInput[]
    OR?: LandScalarWhereWithAggregatesInput[]
    NOT?: LandScalarWhereWithAggregatesInput | LandScalarWhereWithAggregatesInput[]
    IdLand?: IntWithAggregatesFilter<"Land"> | number
    Land?: StringWithAggregatesFilter<"Land"> | string
  }

  export type MahWhereInput = {
    AND?: MahWhereInput | MahWhereInput[]
    OR?: MahWhereInput[]
    NOT?: MahWhereInput | MahWhereInput[]
    IdMah?: IntFilter<"Mah"> | number
    Mah?: StringFilter<"Mah"> | string
  }

  export type MahOrderByWithRelationInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahWhereUniqueInput = Prisma.AtLeast<{
    IdMah?: number
    AND?: MahWhereInput | MahWhereInput[]
    OR?: MahWhereInput[]
    NOT?: MahWhereInput | MahWhereInput[]
    Mah?: StringFilter<"Mah"> | string
  }, "IdMah">

  export type MahOrderByWithAggregationInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
    _count?: MahCountOrderByAggregateInput
    _avg?: MahAvgOrderByAggregateInput
    _max?: MahMaxOrderByAggregateInput
    _min?: MahMinOrderByAggregateInput
    _sum?: MahSumOrderByAggregateInput
  }

  export type MahScalarWhereWithAggregatesInput = {
    AND?: MahScalarWhereWithAggregatesInput | MahScalarWhereWithAggregatesInput[]
    OR?: MahScalarWhereWithAggregatesInput[]
    NOT?: MahScalarWhereWithAggregatesInput | MahScalarWhereWithAggregatesInput[]
    IdMah?: IntWithAggregatesFilter<"Mah"> | number
    Mah?: StringWithAggregatesFilter<"Mah"> | string
  }

  export type MeasuringToolWhereInput = {
    AND?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    OR?: MeasuringToolWhereInput[]
    NOT?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    IdMeasuring?: IntFilter<"MeasuringTool"> | number
    MeasuringTool?: StringFilter<"MeasuringTool"> | string
    Precision?: StringFilter<"MeasuringTool"> | string
  }

  export type MeasuringToolOrderByWithRelationInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolWhereUniqueInput = Prisma.AtLeast<{
    IdMeasuring?: number
    AND?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    OR?: MeasuringToolWhereInput[]
    NOT?: MeasuringToolWhereInput | MeasuringToolWhereInput[]
    MeasuringTool?: StringFilter<"MeasuringTool"> | string
    Precision?: StringFilter<"MeasuringTool"> | string
  }, "IdMeasuring">

  export type MeasuringToolOrderByWithAggregationInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
    _count?: MeasuringToolCountOrderByAggregateInput
    _avg?: MeasuringToolAvgOrderByAggregateInput
    _max?: MeasuringToolMaxOrderByAggregateInput
    _min?: MeasuringToolMinOrderByAggregateInput
    _sum?: MeasuringToolSumOrderByAggregateInput
  }

  export type MeasuringToolScalarWhereWithAggregatesInput = {
    AND?: MeasuringToolScalarWhereWithAggregatesInput | MeasuringToolScalarWhereWithAggregatesInput[]
    OR?: MeasuringToolScalarWhereWithAggregatesInput[]
    NOT?: MeasuringToolScalarWhereWithAggregatesInput | MeasuringToolScalarWhereWithAggregatesInput[]
    IdMeasuring?: IntWithAggregatesFilter<"MeasuringTool"> | number
    MeasuringTool?: StringWithAggregatesFilter<"MeasuringTool"> | string
    Precision?: StringWithAggregatesFilter<"MeasuringTool"> | string
  }

  export type NashtShabakeWhereInput = {
    AND?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    OR?: NashtShabakeWhereInput[]
    NOT?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    IdNasht?: IntFilter<"NashtShabake"> | number
    FIdRanesh?: IntFilter<"NashtShabake"> | number
    FIdTriDor?: IntFilter<"NashtShabake"> | number
    NashtShabake?: IntFilter<"NashtShabake"> | number
  }

  export type NashtShabakeOrderByWithRelationInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeWhereUniqueInput = Prisma.AtLeast<{
    IdNasht?: number
    AND?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    OR?: NashtShabakeWhereInput[]
    NOT?: NashtShabakeWhereInput | NashtShabakeWhereInput[]
    FIdRanesh?: IntFilter<"NashtShabake"> | number
    FIdTriDor?: IntFilter<"NashtShabake"> | number
    NashtShabake?: IntFilter<"NashtShabake"> | number
  }, "IdNasht">

  export type NashtShabakeOrderByWithAggregationInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
    _count?: NashtShabakeCountOrderByAggregateInput
    _avg?: NashtShabakeAvgOrderByAggregateInput
    _max?: NashtShabakeMaxOrderByAggregateInput
    _min?: NashtShabakeMinOrderByAggregateInput
    _sum?: NashtShabakeSumOrderByAggregateInput
  }

  export type NashtShabakeScalarWhereWithAggregatesInput = {
    AND?: NashtShabakeScalarWhereWithAggregatesInput | NashtShabakeScalarWhereWithAggregatesInput[]
    OR?: NashtShabakeScalarWhereWithAggregatesInput[]
    NOT?: NashtShabakeScalarWhereWithAggregatesInput | NashtShabakeScalarWhereWithAggregatesInput[]
    IdNasht?: IntWithAggregatesFilter<"NashtShabake"> | number
    FIdRanesh?: IntWithAggregatesFilter<"NashtShabake"> | number
    FIdTriDor?: IntWithAggregatesFilter<"NashtShabake"> | number
    NashtShabake?: IntWithAggregatesFilter<"NashtShabake"> | number
  }

  export type NetworkWhereInput = {
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    IdNet?: IntFilter<"Network"> | number
    Network?: StringFilter<"Network"> | string
    FIdSP?: IntFilter<"Network"> | number
  }

  export type NetworkOrderByWithRelationInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkWhereUniqueInput = Prisma.AtLeast<{
    IdNet?: number
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    Network?: StringFilter<"Network"> | string
    FIdSP?: IntFilter<"Network"> | number
  }, "IdNet">

  export type NetworkOrderByWithAggregationInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
    _count?: NetworkCountOrderByAggregateInput
    _avg?: NetworkAvgOrderByAggregateInput
    _max?: NetworkMaxOrderByAggregateInput
    _min?: NetworkMinOrderByAggregateInput
    _sum?: NetworkSumOrderByAggregateInput
  }

  export type NetworkScalarWhereWithAggregatesInput = {
    AND?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    OR?: NetworkScalarWhereWithAggregatesInput[]
    NOT?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    IdNet?: IntWithAggregatesFilter<"Network"> | number
    Network?: StringWithAggregatesFilter<"Network"> | string
    FIdSP?: IntWithAggregatesFilter<"Network"> | number
  }

  export type NoeKeshtWhereInput = {
    AND?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    OR?: NoeKeshtWhereInput[]
    NOT?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    IdNoeK?: IntFilter<"NoeKesht"> | number
    Kesht?: StringFilter<"NoeKesht"> | string
  }

  export type NoeKeshtOrderByWithRelationInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdNoeK?: number
    AND?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    OR?: NoeKeshtWhereInput[]
    NOT?: NoeKeshtWhereInput | NoeKeshtWhereInput[]
    Kesht?: StringFilter<"NoeKesht"> | string
  }, "IdNoeK">

  export type NoeKeshtOrderByWithAggregationInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
    _count?: NoeKeshtCountOrderByAggregateInput
    _avg?: NoeKeshtAvgOrderByAggregateInput
    _max?: NoeKeshtMaxOrderByAggregateInput
    _min?: NoeKeshtMinOrderByAggregateInput
    _sum?: NoeKeshtSumOrderByAggregateInput
  }

  export type NoeKeshtScalarWhereWithAggregatesInput = {
    AND?: NoeKeshtScalarWhereWithAggregatesInput | NoeKeshtScalarWhereWithAggregatesInput[]
    OR?: NoeKeshtScalarWhereWithAggregatesInput[]
    NOT?: NoeKeshtScalarWhereWithAggregatesInput | NoeKeshtScalarWhereWithAggregatesInput[]
    IdNoeK?: IntWithAggregatesFilter<"NoeKesht"> | number
    Kesht?: StringWithAggregatesFilter<"NoeKesht"> | string
  }

  export type NoeMahsoolWhereInput = {
    AND?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    OR?: NoeMahsoolWhereInput[]
    NOT?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    IdNoeM?: IntFilter<"NoeMahsool"> | number
    Mahsool?: StringFilter<"NoeMahsool"> | string
    FIdNoeK?: IntFilter<"NoeMahsool"> | number
  }

  export type NoeMahsoolOrderByWithRelationInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolWhereUniqueInput = Prisma.AtLeast<{
    IdNoeM?: number
    AND?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    OR?: NoeMahsoolWhereInput[]
    NOT?: NoeMahsoolWhereInput | NoeMahsoolWhereInput[]
    Mahsool?: StringFilter<"NoeMahsool"> | string
    FIdNoeK?: IntFilter<"NoeMahsool"> | number
  }, "IdNoeM">

  export type NoeMahsoolOrderByWithAggregationInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
    _count?: NoeMahsoolCountOrderByAggregateInput
    _avg?: NoeMahsoolAvgOrderByAggregateInput
    _max?: NoeMahsoolMaxOrderByAggregateInput
    _min?: NoeMahsoolMinOrderByAggregateInput
    _sum?: NoeMahsoolSumOrderByAggregateInput
  }

  export type NoeMahsoolScalarWhereWithAggregatesInput = {
    AND?: NoeMahsoolScalarWhereWithAggregatesInput | NoeMahsoolScalarWhereWithAggregatesInput[]
    OR?: NoeMahsoolScalarWhereWithAggregatesInput[]
    NOT?: NoeMahsoolScalarWhereWithAggregatesInput | NoeMahsoolScalarWhereWithAggregatesInput[]
    IdNoeM?: IntWithAggregatesFilter<"NoeMahsool"> | number
    Mahsool?: StringWithAggregatesFilter<"NoeMahsool"> | string
    FIdNoeK?: IntWithAggregatesFilter<"NoeMahsool"> | number
  }

  export type NonFITWhereInput = {
    AND?: NonFITWhereInput | NonFITWhereInput[]
    OR?: NonFITWhereInput[]
    NOT?: NonFITWhereInput | NonFITWhereInput[]
    IdNonFIT?: IntFilter<"NonFIT"> | number
    FIdRanesh?: IntFilter<"NonFIT"> | number
    FIdTarDor?: IntFilter<"NonFIT"> | number
    VOLUM?: IntFilter<"NonFIT"> | number
  }

  export type NonFITOrderByWithRelationInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITWhereUniqueInput = Prisma.AtLeast<{
    IdNonFIT?: number
    AND?: NonFITWhereInput | NonFITWhereInput[]
    OR?: NonFITWhereInput[]
    NOT?: NonFITWhereInput | NonFITWhereInput[]
    FIdRanesh?: IntFilter<"NonFIT"> | number
    FIdTarDor?: IntFilter<"NonFIT"> | number
    VOLUM?: IntFilter<"NonFIT"> | number
  }, "IdNonFIT">

  export type NonFITOrderByWithAggregationInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
    _count?: NonFITCountOrderByAggregateInput
    _avg?: NonFITAvgOrderByAggregateInput
    _max?: NonFITMaxOrderByAggregateInput
    _min?: NonFITMinOrderByAggregateInput
    _sum?: NonFITSumOrderByAggregateInput
  }

  export type NonFITScalarWhereWithAggregatesInput = {
    AND?: NonFITScalarWhereWithAggregatesInput | NonFITScalarWhereWithAggregatesInput[]
    OR?: NonFITScalarWhereWithAggregatesInput[]
    NOT?: NonFITScalarWhereWithAggregatesInput | NonFITScalarWhereWithAggregatesInput[]
    IdNonFIT?: IntWithAggregatesFilter<"NonFIT"> | number
    FIdRanesh?: IntWithAggregatesFilter<"NonFIT"> | number
    FIdTarDor?: IntWithAggregatesFilter<"NonFIT"> | number
    VOLUM?: IntWithAggregatesFilter<"NonFIT"> | number
  }

  export type PumpStationWhereInput = {
    AND?: PumpStationWhereInput | PumpStationWhereInput[]
    OR?: PumpStationWhereInput[]
    NOT?: PumpStationWhereInput | PumpStationWhereInput[]
    IdPumpSta?: IntFilter<"PumpStation"> | number
    NameStation?: StringFilter<"PumpStation"> | string
    KM?: IntNullableFilter<"PumpStation"> | number | null
    FIdNet?: IntFilter<"PumpStation"> | number
    FIdDStation?: IntFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableFilter<"PumpStation"> | number | null
  }

  export type PumpStationOrderByWithRelationInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrderInput | SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrderInput | SortOrder
  }

  export type PumpStationWhereUniqueInput = Prisma.AtLeast<{
    IdPumpSta?: number
    AND?: PumpStationWhereInput | PumpStationWhereInput[]
    OR?: PumpStationWhereInput[]
    NOT?: PumpStationWhereInput | PumpStationWhereInput[]
    NameStation?: StringFilter<"PumpStation"> | string
    KM?: IntNullableFilter<"PumpStation"> | number | null
    FIdNet?: IntFilter<"PumpStation"> | number
    FIdDStation?: IntFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableFilter<"PumpStation"> | number | null
  }, "IdPumpSta">

  export type PumpStationOrderByWithAggregationInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrderInput | SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrderInput | SortOrder
    _count?: PumpStationCountOrderByAggregateInput
    _avg?: PumpStationAvgOrderByAggregateInput
    _max?: PumpStationMaxOrderByAggregateInput
    _min?: PumpStationMinOrderByAggregateInput
    _sum?: PumpStationSumOrderByAggregateInput
  }

  export type PumpStationScalarWhereWithAggregatesInput = {
    AND?: PumpStationScalarWhereWithAggregatesInput | PumpStationScalarWhereWithAggregatesInput[]
    OR?: PumpStationScalarWhereWithAggregatesInput[]
    NOT?: PumpStationScalarWhereWithAggregatesInput | PumpStationScalarWhereWithAggregatesInput[]
    IdPumpSta?: IntWithAggregatesFilter<"PumpStation"> | number
    NameStation?: StringWithAggregatesFilter<"PumpStation"> | string
    KM?: IntNullableWithAggregatesFilter<"PumpStation"> | number | null
    FIdNet?: IntWithAggregatesFilter<"PumpStation"> | number
    FIdDStation?: IntWithAggregatesFilter<"PumpStation"> | number
    FIdMakhzan?: IntNullableWithAggregatesFilter<"PumpStation"> | number | null
  }

  export type PumpTypeWhereInput = {
    AND?: PumpTypeWhereInput | PumpTypeWhereInput[]
    OR?: PumpTypeWhereInput[]
    NOT?: PumpTypeWhereInput | PumpTypeWhereInput[]
    IdPump?: IntFilter<"PumpType"> | number
    PumpType?: StringFilter<"PumpType"> | string
  }

  export type PumpTypeOrderByWithRelationInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeWhereUniqueInput = Prisma.AtLeast<{
    IdPump?: number
    AND?: PumpTypeWhereInput | PumpTypeWhereInput[]
    OR?: PumpTypeWhereInput[]
    NOT?: PumpTypeWhereInput | PumpTypeWhereInput[]
    PumpType?: StringFilter<"PumpType"> | string
  }, "IdPump">

  export type PumpTypeOrderByWithAggregationInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
    _count?: PumpTypeCountOrderByAggregateInput
    _avg?: PumpTypeAvgOrderByAggregateInput
    _max?: PumpTypeMaxOrderByAggregateInput
    _min?: PumpTypeMinOrderByAggregateInput
    _sum?: PumpTypeSumOrderByAggregateInput
  }

  export type PumpTypeScalarWhereWithAggregatesInput = {
    AND?: PumpTypeScalarWhereWithAggregatesInput | PumpTypeScalarWhereWithAggregatesInput[]
    OR?: PumpTypeScalarWhereWithAggregatesInput[]
    NOT?: PumpTypeScalarWhereWithAggregatesInput | PumpTypeScalarWhereWithAggregatesInput[]
    IdPump?: IntWithAggregatesFilter<"PumpType"> | number
    PumpType?: StringWithAggregatesFilter<"PumpType"> | string
  }

  export type RainfallStationWhereInput = {
    AND?: RainfallStationWhereInput | RainfallStationWhereInput[]
    OR?: RainfallStationWhereInput[]
    NOT?: RainfallStationWhereInput | RainfallStationWhereInput[]
    IdRaiSta?: IntFilter<"RainfallStation"> | number
    FIdWeaSta?: IntFilter<"RainfallStation"> | number
    FIdTrikh?: IntFilter<"RainfallStation"> | number
    FIdRaiTy?: IntFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationOrderByWithRelationInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationWhereUniqueInput = Prisma.AtLeast<{
    IdRaiSta?: number
    AND?: RainfallStationWhereInput | RainfallStationWhereInput[]
    OR?: RainfallStationWhereInput[]
    NOT?: RainfallStationWhereInput | RainfallStationWhereInput[]
    FIdWeaSta?: IntFilter<"RainfallStation"> | number
    FIdTrikh?: IntFilter<"RainfallStation"> | number
    FIdRaiTy?: IntFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
  }, "IdRaiSta">

  export type RainfallStationOrderByWithAggregationInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
    _count?: RainfallStationCountOrderByAggregateInput
    _avg?: RainfallStationAvgOrderByAggregateInput
    _max?: RainfallStationMaxOrderByAggregateInput
    _min?: RainfallStationMinOrderByAggregateInput
    _sum?: RainfallStationSumOrderByAggregateInput
  }

  export type RainfallStationScalarWhereWithAggregatesInput = {
    AND?: RainfallStationScalarWhereWithAggregatesInput | RainfallStationScalarWhereWithAggregatesInput[]
    OR?: RainfallStationScalarWhereWithAggregatesInput[]
    NOT?: RainfallStationScalarWhereWithAggregatesInput | RainfallStationScalarWhereWithAggregatesInput[]
    IdRaiSta?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdWeaSta?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdTrikh?: IntWithAggregatesFilter<"RainfallStation"> | number
    FIdRaiTy?: IntWithAggregatesFilter<"RainfallStation"> | number
    ErtefaeBaresh?: DecimalWithAggregatesFilter<"RainfallStation"> | Decimal | DecimalJsLike | number | string
  }

  export type RainfallTypeWhereInput = {
    AND?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    OR?: RainfallTypeWhereInput[]
    NOT?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    IdRaiTy?: IntFilter<"RainfallType"> | number
    RainfallType?: StringFilter<"RainfallType"> | string
  }

  export type RainfallTypeOrderByWithRelationInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeWhereUniqueInput = Prisma.AtLeast<{
    IdRaiTy?: number
    AND?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    OR?: RainfallTypeWhereInput[]
    NOT?: RainfallTypeWhereInput | RainfallTypeWhereInput[]
    RainfallType?: StringFilter<"RainfallType"> | string
  }, "IdRaiTy">

  export type RainfallTypeOrderByWithAggregationInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
    _count?: RainfallTypeCountOrderByAggregateInput
    _avg?: RainfallTypeAvgOrderByAggregateInput
    _max?: RainfallTypeMaxOrderByAggregateInput
    _min?: RainfallTypeMinOrderByAggregateInput
    _sum?: RainfallTypeSumOrderByAggregateInput
  }

  export type RainfallTypeScalarWhereWithAggregatesInput = {
    AND?: RainfallTypeScalarWhereWithAggregatesInput | RainfallTypeScalarWhereWithAggregatesInput[]
    OR?: RainfallTypeScalarWhereWithAggregatesInput[]
    NOT?: RainfallTypeScalarWhereWithAggregatesInput | RainfallTypeScalarWhereWithAggregatesInput[]
    IdRaiTy?: IntWithAggregatesFilter<"RainfallType"> | number
    RainfallType?: StringWithAggregatesFilter<"RainfallType"> | string
  }

  export type SaleZeraeeWhereInput = {
    AND?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    OR?: SaleZeraeeWhereInput[]
    NOT?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    IdSal?: IntFilter<"SaleZeraee"> | number
    SaleZeraee?: StringFilter<"SaleZeraee"> | string
  }

  export type SaleZeraeeOrderByWithRelationInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeWhereUniqueInput = Prisma.AtLeast<{
    IdSal?: number
    AND?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    OR?: SaleZeraeeWhereInput[]
    NOT?: SaleZeraeeWhereInput | SaleZeraeeWhereInput[]
    SaleZeraee?: StringFilter<"SaleZeraee"> | string
  }, "IdSal">

  export type SaleZeraeeOrderByWithAggregationInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
    _count?: SaleZeraeeCountOrderByAggregateInput
    _avg?: SaleZeraeeAvgOrderByAggregateInput
    _max?: SaleZeraeeMaxOrderByAggregateInput
    _min?: SaleZeraeeMinOrderByAggregateInput
    _sum?: SaleZeraeeSumOrderByAggregateInput
  }

  export type SaleZeraeeScalarWhereWithAggregatesInput = {
    AND?: SaleZeraeeScalarWhereWithAggregatesInput | SaleZeraeeScalarWhereWithAggregatesInput[]
    OR?: SaleZeraeeScalarWhereWithAggregatesInput[]
    NOT?: SaleZeraeeScalarWhereWithAggregatesInput | SaleZeraeeScalarWhereWithAggregatesInput[]
    IdSal?: IntWithAggregatesFilter<"SaleZeraee"> | number
    SaleZeraee?: StringWithAggregatesFilter<"SaleZeraee"> | string
  }

  export type SeghliPumpWhereInput = {
    AND?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    OR?: SeghliPumpWhereInput[]
    NOT?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    IdSePu?: IntFilter<"SeghliPump"> | number
    SeghliPump?: StringFilter<"SeghliPump"> | string
  }

  export type SeghliPumpOrderByWithRelationInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpWhereUniqueInput = Prisma.AtLeast<{
    IdSePu?: number
    AND?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    OR?: SeghliPumpWhereInput[]
    NOT?: SeghliPumpWhereInput | SeghliPumpWhereInput[]
    SeghliPump?: StringFilter<"SeghliPump"> | string
  }, "IdSePu">

  export type SeghliPumpOrderByWithAggregationInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
    _count?: SeghliPumpCountOrderByAggregateInput
    _avg?: SeghliPumpAvgOrderByAggregateInput
    _max?: SeghliPumpMaxOrderByAggregateInput
    _min?: SeghliPumpMinOrderByAggregateInput
    _sum?: SeghliPumpSumOrderByAggregateInput
  }

  export type SeghliPumpScalarWhereWithAggregatesInput = {
    AND?: SeghliPumpScalarWhereWithAggregatesInput | SeghliPumpScalarWhereWithAggregatesInput[]
    OR?: SeghliPumpScalarWhereWithAggregatesInput[]
    NOT?: SeghliPumpScalarWhereWithAggregatesInput | SeghliPumpScalarWhereWithAggregatesInput[]
    IdSePu?: IntWithAggregatesFilter<"SeghliPump"> | number
    SeghliPump?: StringWithAggregatesFilter<"SeghliPump"> | string
  }

  export type SystemPartWhereInput = {
    AND?: SystemPartWhereInput | SystemPartWhereInput[]
    OR?: SystemPartWhereInput[]
    NOT?: SystemPartWhereInput | SystemPartWhereInput[]
    IdSP?: IntFilter<"SystemPart"> | number
    Part?: StringFilter<"SystemPart"> | string
    KM?: IntFilter<"SystemPart"> | number
  }

  export type SystemPartOrderByWithRelationInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartWhereUniqueInput = Prisma.AtLeast<{
    IdSP?: number
    AND?: SystemPartWhereInput | SystemPartWhereInput[]
    OR?: SystemPartWhereInput[]
    NOT?: SystemPartWhereInput | SystemPartWhereInput[]
    Part?: StringFilter<"SystemPart"> | string
    KM?: IntFilter<"SystemPart"> | number
  }, "IdSP">

  export type SystemPartOrderByWithAggregationInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
    _count?: SystemPartCountOrderByAggregateInput
    _avg?: SystemPartAvgOrderByAggregateInput
    _max?: SystemPartMaxOrderByAggregateInput
    _min?: SystemPartMinOrderByAggregateInput
    _sum?: SystemPartSumOrderByAggregateInput
  }

  export type SystemPartScalarWhereWithAggregatesInput = {
    AND?: SystemPartScalarWhereWithAggregatesInput | SystemPartScalarWhereWithAggregatesInput[]
    OR?: SystemPartScalarWhereWithAggregatesInput[]
    NOT?: SystemPartScalarWhereWithAggregatesInput | SystemPartScalarWhereWithAggregatesInput[]
    IdSP?: IntWithAggregatesFilter<"SystemPart"> | number
    Part?: StringWithAggregatesFilter<"SystemPart"> | string
    KM?: IntWithAggregatesFilter<"SystemPart"> | number
  }

  export type TakhlieMakhzanWhereInput = {
    AND?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    OR?: TakhlieMakhzanWhereInput[]
    NOT?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    IdTakhlie?: IntFilter<"TakhlieMakhzan"> | number
    FIdRanesh?: IntFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntFilter<"TakhlieMakhzan"> | number
  }

  export type TakhlieMakhzanOrderByWithRelationInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanWhereUniqueInput = Prisma.AtLeast<{
    IdTakhlie?: number
    AND?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    OR?: TakhlieMakhzanWhereInput[]
    NOT?: TakhlieMakhzanWhereInput | TakhlieMakhzanWhereInput[]
    FIdRanesh?: IntFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntFilter<"TakhlieMakhzan"> | number
  }, "IdTakhlie">

  export type TakhlieMakhzanOrderByWithAggregationInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
    _count?: TakhlieMakhzanCountOrderByAggregateInput
    _avg?: TakhlieMakhzanAvgOrderByAggregateInput
    _max?: TakhlieMakhzanMaxOrderByAggregateInput
    _min?: TakhlieMakhzanMinOrderByAggregateInput
    _sum?: TakhlieMakhzanSumOrderByAggregateInput
  }

  export type TakhlieMakhzanScalarWhereWithAggregatesInput = {
    AND?: TakhlieMakhzanScalarWhereWithAggregatesInput | TakhlieMakhzanScalarWhereWithAggregatesInput[]
    OR?: TakhlieMakhzanScalarWhereWithAggregatesInput[]
    NOT?: TakhlieMakhzanScalarWhereWithAggregatesInput | TakhlieMakhzanScalarWhereWithAggregatesInput[]
    IdTakhlie?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    FIdRanesh?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    FIdTarDor?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
    Takhlie?: IntWithAggregatesFilter<"TakhlieMakhzan"> | number
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    IdTest?: IntFilter<"Test"> | number
    FIdRanesh?: IntFilter<"Test"> | number
    FIdTarDor?: IntFilter<"Test"> | number
    Test?: IntFilter<"Test"> | number
  }

  export type TestOrderByWithRelationInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    IdTest?: number
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    FIdRanesh?: IntFilter<"Test"> | number
    FIdTarDor?: IntFilter<"Test"> | number
    Test?: IntFilter<"Test"> | number
  }, "IdTest">

  export type TestOrderByWithAggregationInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    IdTest?: IntWithAggregatesFilter<"Test"> | number
    FIdRanesh?: IntWithAggregatesFilter<"Test"> | number
    FIdTarDor?: IntWithAggregatesFilter<"Test"> | number
    Test?: IntWithAggregatesFilter<"Test"> | number
  }

  export type TrikhDoreKeshtWhereInput = {
    AND?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    OR?: TrikhDoreKeshtWhereInput[]
    NOT?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    IdTarDor?: IntFilter<"TrikhDoreKesht"> | number
    FIdSal?: IntFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringFilter<"TrikhDoreKesht"> | string
  }

  export type TrikhDoreKeshtOrderByWithRelationInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
  }

  export type TrikhDoreKeshtWhereUniqueInput = Prisma.AtLeast<{
    IdTarDor?: number
    AND?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    OR?: TrikhDoreKeshtWhereInput[]
    NOT?: TrikhDoreKeshtWhereInput | TrikhDoreKeshtWhereInput[]
    FIdSal?: IntFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringFilter<"TrikhDoreKesht"> | string
  }, "IdTarDor">

  export type TrikhDoreKeshtOrderByWithAggregationInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
    _count?: TrikhDoreKeshtCountOrderByAggregateInput
    _avg?: TrikhDoreKeshtAvgOrderByAggregateInput
    _max?: TrikhDoreKeshtMaxOrderByAggregateInput
    _min?: TrikhDoreKeshtMinOrderByAggregateInput
    _sum?: TrikhDoreKeshtSumOrderByAggregateInput
  }

  export type TrikhDoreKeshtScalarWhereWithAggregatesInput = {
    AND?: TrikhDoreKeshtScalarWhereWithAggregatesInput | TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    OR?: TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    NOT?: TrikhDoreKeshtScalarWhereWithAggregatesInput | TrikhDoreKeshtScalarWhereWithAggregatesInput[]
    IdTarDor?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    FIdSal?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    FIdDore?: IntWithAggregatesFilter<"TrikhDoreKesht"> | number
    Trikh?: DateTimeWithAggregatesFilter<"TrikhDoreKesht"> | Date | string
    TrikhKhorshidi?: StringWithAggregatesFilter<"TrikhDoreKesht"> | string
  }

  export type WeatherStationWhereInput = {
    AND?: WeatherStationWhereInput | WeatherStationWhereInput[]
    OR?: WeatherStationWhereInput[]
    NOT?: WeatherStationWhereInput | WeatherStationWhereInput[]
    IdWeaSta?: IntFilter<"WeatherStation"> | number
    Station?: StringFilter<"WeatherStation"> | string
  }

  export type WeatherStationOrderByWithRelationInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationWhereUniqueInput = Prisma.AtLeast<{
    IdWeaSta?: number
    AND?: WeatherStationWhereInput | WeatherStationWhereInput[]
    OR?: WeatherStationWhereInput[]
    NOT?: WeatherStationWhereInput | WeatherStationWhereInput[]
    Station?: StringFilter<"WeatherStation"> | string
  }, "IdWeaSta">

  export type WeatherStationOrderByWithAggregationInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
    _count?: WeatherStationCountOrderByAggregateInput
    _avg?: WeatherStationAvgOrderByAggregateInput
    _max?: WeatherStationMaxOrderByAggregateInput
    _min?: WeatherStationMinOrderByAggregateInput
    _sum?: WeatherStationSumOrderByAggregateInput
  }

  export type WeatherStationScalarWhereWithAggregatesInput = {
    AND?: WeatherStationScalarWhereWithAggregatesInput | WeatherStationScalarWhereWithAggregatesInput[]
    OR?: WeatherStationScalarWhereWithAggregatesInput[]
    NOT?: WeatherStationScalarWhereWithAggregatesInput | WeatherStationScalarWhereWithAggregatesInput[]
    IdWeaSta?: IntWithAggregatesFilter<"WeatherStation"> | number
    Station?: StringWithAggregatesFilter<"WeatherStation"> | string
  }

  export type AbadeMakhzanCreateInput = {
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanUncheckedCreateInput = {
    IdMakhzan?: number
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanUpdateInput = {
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbadeMakhzanUncheckedUpdateInput = {
    IdMakhzan?: IntFieldUpdateOperationsInput | number
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbadeMakhzanCreateManyInput = {
    TooleBala?: Decimal | DecimalJsLike | number | string | null
    ArzeBala?: Decimal | DecimalJsLike | number | string | null
    TooleKaf?: Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: Decimal | DecimalJsLike | number | string | null
    Omgh?: Decimal | DecimalJsLike | number | string | null
    HajmMohasebat: Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: number | null
    NameStation: string
  }

  export type AbadeMakhzanUpdateManyMutationInput = {
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbadeMakhzanUncheckedUpdateManyInput = {
    IdMakhzan?: IntFieldUpdateOperationsInput | number
    TooleBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeBala?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TooleKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ArzeKaf?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Omgh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HajmMohasebat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    HadeaghalHajm?: NullableIntFieldUpdateOperationsInput | number | null
    NameStation?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirCreateInput = {
    FIdRanesh: number
    Abgir: string
  }

  export type AbgirUncheckedCreateInput = {
    IdKontor?: number
    FIdRanesh: number
    Abgir: string
  }

  export type AbgirUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirUncheckedUpdateInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirCreateManyInput = {
    FIdRanesh: number
    Abgir: string
  }

  export type AbgirUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type AbgirUncheckedUpdateManyInput = {
    IdKontor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Abgir?: StringFieldUpdateOperationsInput | string
  }

  export type AtashSooziCreateInput = {
    IdAtash: number
    FIdRanesh?: number | null
    FIdTarDor?: number | null
    AtashSoozi?: number | null
  }

  export type AtashSooziUncheckedCreateInput = {
    IdAtash: number
    FIdRanesh?: number | null
    FIdTarDor?: number | null
    AtashSoozi?: number | null
  }

  export type AtashSooziUpdateInput = {
    IdAtash?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: NullableIntFieldUpdateOperationsInput | number | null
    FIdTarDor?: NullableIntFieldUpdateOperationsInput | number | null
    AtashSoozi?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AtashSooziUncheckedUpdateInput = {
    IdAtash?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: NullableIntFieldUpdateOperationsInput | number | null
    FIdTarDor?: NullableIntFieldUpdateOperationsInput | number | null
    AtashSoozi?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AtashSooziCreateManyInput = {
    IdAtash: number
    FIdRanesh?: number | null
    FIdTarDor?: number | null
    AtashSoozi?: number | null
  }

  export type AtashSooziUpdateManyMutationInput = {
    IdAtash?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: NullableIntFieldUpdateOperationsInput | number | null
    FIdTarDor?: NullableIntFieldUpdateOperationsInput | number | null
    AtashSoozi?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AtashSooziUncheckedUpdateManyInput = {
    IdAtash?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: NullableIntFieldUpdateOperationsInput | number | null
    FIdTarDor?: NullableIntFieldUpdateOperationsInput | number | null
    AtashSoozi?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BahrebardairProgramCreateInput = {
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramUncheckedCreateInput = {
    IdProgram?: number
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramUncheckedUpdateInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Tedad: number
    Shorooe?: Date | string | null
    Paian?: Date | string | null
  }

  export type BahrebardairProgramUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardairProgramUncheckedUpdateManyInput = {
    IdProgram?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Tedad?: IntFieldUpdateOperationsInput | number
    Shorooe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Paian?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BahrebardariKeshtDoreCreateInput = {
    FIdSal: number
    FIdDore: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedCreateInput = {
    IdBahDor?: number
    FIdSal: number
    FIdDore: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateInput = {
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreCreateManyInput = {
    FIdSal: number
    FIdDore: number
    FIdRanesh: number
    FIdNoeM: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUpdateManyMutationInput = {
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariKeshtDoreUncheckedUpdateManyInput = {
    IdBahDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdNoeM?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateInput = {
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedCreateInput = {
    IdTag?: number
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpdateInput = {
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedUpdateInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimCreateManyInput = {
    FIdTarDor: number
    FIdRanesh: number
    Taghvim: Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUpdateManyMutationInput = {
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BahrebardariTaghvimUncheckedUpdateManyInput = {
    IdTag?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Taghvim?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateInput = {
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedCreateInput = {
    IdBarMot?: number
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUpdateInput = {
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedUpdateInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatCreateManyInput = {
    FIdNet: number
    FIdMah: number
    BareshMotaleat: Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUpdateManyMutationInput = {
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BareshMotaleatUncheckedUpdateManyInput = {
    IdBarMot?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdMah?: IntFieldUpdateOperationsInput | number
    BareshMotaleat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DarajePipeCreateInput = {
    DarajePipe: string
  }

  export type DarajePipeUncheckedCreateInput = {
    IdDPipe?: number
    DarajePipe: string
  }

  export type DarajePipeUpdateInput = {
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarajePipeUncheckedUpdateInput = {
    IdDPipe?: IntFieldUpdateOperationsInput | number
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarajePipeCreateManyInput = {
    DarajePipe: string
  }

  export type DarajePipeUpdateManyMutationInput = {
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarajePipeUncheckedUpdateManyInput = {
    IdDPipe?: IntFieldUpdateOperationsInput | number
    DarajePipe?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationCreateInput = {
    DarajeStation: string
  }

  export type DarjeStationUncheckedCreateInput = {
    IdDStation?: number
    DarajeStation: string
  }

  export type DarjeStationUpdateInput = {
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationUncheckedUpdateInput = {
    IdDStation?: IntFieldUpdateOperationsInput | number
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationCreateManyInput = {
    DarajeStation: string
  }

  export type DarjeStationUpdateManyMutationInput = {
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DarjeStationUncheckedUpdateManyInput = {
    IdDStation?: IntFieldUpdateOperationsInput | number
    DarajeStation?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtCreateInput = {
    Dore: string
  }

  export type DoreKeshtUncheckedCreateInput = {
    IdDore?: number
    Dore: string
  }

  export type DoreKeshtUpdateInput = {
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtUncheckedUpdateInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtCreateManyInput = {
    Dore: string
  }

  export type DoreKeshtUpdateManyMutationInput = {
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type DoreKeshtUncheckedUpdateManyInput = {
    IdDore?: IntFieldUpdateOperationsInput | number
    Dore?: StringFieldUpdateOperationsInput | string
  }

  export type EshtebahAvamelCreateInput = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelUncheckedCreateInput = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelUpdateInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelUncheckedUpdateInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelCreateManyInput = {
    IdEsht: number
    FIdRanesh: number
    FIdTarDor: number
    Eshtebah: number
  }

  export type EshtebahAvamelUpdateManyMutationInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type EshtebahAvamelUncheckedUpdateManyInput = {
    IdEsht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Eshtebah?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodCreateInput = {
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodUncheckedCreateInput = {
    IdBehbood?: number
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUncheckedUpdateInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Flow: number
  }

  export type FlowBehboodUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowBehboodUncheckedUpdateManyInput = {
    IdBehbood?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Flow?: IntFieldUpdateOperationsInput | number
  }

  export type FlowmeterCreateInput = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterUncheckedCreateInput = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterUpdateInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterUncheckedUpdateInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterCreateManyInput = {
    IdFIT: number
    FIdRanesh: number
    FIdTrikh: number
    Flowmeter: number
  }

  export type FlowmeterUpdateManyMutationInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type FlowmeterUncheckedUpdateManyInput = {
    IdFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    Flowmeter?: FloatFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
  }

  export type KhatRaneshUncheckedCreateInput = {
    IdRanesh?: number
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
  }

  export type KhatRaneshUpdateInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshCreateManyInput = {
    RaneshName: string
    FIdPumpSta: number
    FIdDPipe: number
    FIdSePu: number
    FIdMeasuring: number
  }

  export type KhatRaneshUpdateManyMutationInput = {
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    RaneshName?: StringFieldUpdateOperationsInput | string
    FIdPumpSta?: IntFieldUpdateOperationsInput | number
    FIdDPipe?: IntFieldUpdateOperationsInput | number
    FIdSePu?: IntFieldUpdateOperationsInput | number
    FIdMeasuring?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshAreaCreateInput = {
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaCreateManyInput = {
    FIdRanesh: number
    FIdLand: number
    FIdNet: number
    Area: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshAreaUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdLand?: IntFieldUpdateOperationsInput | number
    FIdNet?: IntFieldUpdateOperationsInput | number
    Area?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshPumpCreateInput = {
    FIdRanesh: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpCreateManyInput = {
    FIdRanesh: number
    ModelPump?: string | null
    FIdPump: number
    TedadPump?: number | null
    DebiPomp: Decimal | DecimalJsLike | number | string
    FesharPump: Decimal | DecimalJsLike | number | string
    Randeman: number
    TavaneNami: Decimal | DecimalJsLike | number | string
    TavaneJazbi: Decimal | DecimalJsLike | number | string
    Voltazh: number
    DoreMotor: number
    FeshareMakesh: number
    FeshareRanesh: number
    SizeMakesh: number
    SizeRanesh: number
    SizeKolektor: number
    SizeShireKolektor: number
  }

  export type KhatRaneshPumpUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshPumpUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    ModelPump?: NullableStringFieldUpdateOperationsInput | string | null
    FIdPump?: IntFieldUpdateOperationsInput | number
    TedadPump?: NullableIntFieldUpdateOperationsInput | number | null
    DebiPomp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FesharPump?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Randeman?: IntFieldUpdateOperationsInput | number
    TavaneNami?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TavaneJazbi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Voltazh?: IntFieldUpdateOperationsInput | number
    DoreMotor?: IntFieldUpdateOperationsInput | number
    FeshareMakesh?: IntFieldUpdateOperationsInput | number
    FeshareRanesh?: IntFieldUpdateOperationsInput | number
    SizeMakesh?: IntFieldUpdateOperationsInput | number
    SizeRanesh?: IntFieldUpdateOperationsInput | number
    SizeKolektor?: IntFieldUpdateOperationsInput | number
    SizeShireKolektor?: IntFieldUpdateOperationsInput | number
  }

  export type KhatRaneshSegliCreateInput = {
    FIdRanesh: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedCreateInput = {
    IdRanesh?: number
    FIdRanesh: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedUpdateInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliCreateManyInput = {
    FIdRanesh: number
    Zarfiat: Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KhatRaneshSegliUncheckedUpdateManyInput = {
    IdRanesh?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    Zarfiat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type KontorCreateInput = {
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUncheckedCreateInput = {
    IdKon?: number
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUpdateInput = {
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorUncheckedUpdateInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorCreateManyInput = {
    FIdKontor: number
    FIdTarDor: number
    Kontor: number
  }

  export type KontorUpdateManyMutationInput = {
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type KontorUncheckedUpdateManyInput = {
    IdKon?: IntFieldUpdateOperationsInput | number
    FIdKontor?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Kontor?: IntFieldUpdateOperationsInput | number
  }

  export type LandCreateInput = {
    IdLand: number
    Land: string
  }

  export type LandUncheckedCreateInput = {
    IdLand: number
    Land: string
  }

  export type LandUpdateInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type LandUncheckedUpdateInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type LandCreateManyInput = {
    IdLand: number
    Land: string
  }

  export type LandUpdateManyMutationInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type LandUncheckedUpdateManyInput = {
    IdLand?: IntFieldUpdateOperationsInput | number
    Land?: StringFieldUpdateOperationsInput | string
  }

  export type MahCreateInput = {
    IdMah: number
    Mah: string
  }

  export type MahUncheckedCreateInput = {
    IdMah: number
    Mah: string
  }

  export type MahUpdateInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type MahUncheckedUpdateInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type MahCreateManyInput = {
    IdMah: number
    Mah: string
  }

  export type MahUpdateManyMutationInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type MahUncheckedUpdateManyInput = {
    IdMah?: IntFieldUpdateOperationsInput | number
    Mah?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolCreateInput = {
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolUncheckedCreateInput = {
    IdMeasuring?: number
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolUpdateInput = {
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolUncheckedUpdateInput = {
    IdMeasuring?: IntFieldUpdateOperationsInput | number
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolCreateManyInput = {
    MeasuringTool: string
    Precision: string
  }

  export type MeasuringToolUpdateManyMutationInput = {
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type MeasuringToolUncheckedUpdateManyInput = {
    IdMeasuring?: IntFieldUpdateOperationsInput | number
    MeasuringTool?: StringFieldUpdateOperationsInput | string
    Precision?: StringFieldUpdateOperationsInput | string
  }

  export type NashtShabakeCreateInput = {
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeUncheckedCreateInput = {
    IdNasht?: number
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUncheckedUpdateInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeCreateManyInput = {
    FIdRanesh: number
    FIdTriDor: number
    NashtShabake: number
  }

  export type NashtShabakeUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NashtShabakeUncheckedUpdateManyInput = {
    IdNasht?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTriDor?: IntFieldUpdateOperationsInput | number
    NashtShabake?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkCreateInput = {
    Network: string
    FIdSP: number
  }

  export type NetworkUncheckedCreateInput = {
    IdNet?: number
    Network: string
    FIdSP: number
  }

  export type NetworkUpdateInput = {
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkUncheckedUpdateInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkCreateManyInput = {
    Network: string
    FIdSP: number
  }

  export type NetworkUpdateManyMutationInput = {
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkUncheckedUpdateManyInput = {
    IdNet?: IntFieldUpdateOperationsInput | number
    Network?: StringFieldUpdateOperationsInput | string
    FIdSP?: IntFieldUpdateOperationsInput | number
  }

  export type NoeKeshtCreateInput = {
    Kesht: string
  }

  export type NoeKeshtUncheckedCreateInput = {
    IdNoeK?: number
    Kesht: string
  }

  export type NoeKeshtUpdateInput = {
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeKeshtUncheckedUpdateInput = {
    IdNoeK?: IntFieldUpdateOperationsInput | number
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeKeshtCreateManyInput = {
    Kesht: string
  }

  export type NoeKeshtUpdateManyMutationInput = {
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeKeshtUncheckedUpdateManyInput = {
    IdNoeK?: IntFieldUpdateOperationsInput | number
    Kesht?: StringFieldUpdateOperationsInput | string
  }

  export type NoeMahsoolCreateInput = {
    Mahsool: string
    FIdNoeK: number
  }

  export type NoeMahsoolUncheckedCreateInput = {
    IdNoeM?: number
    Mahsool: string
    FIdNoeK: number
  }

  export type NoeMahsoolUpdateInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type NoeMahsoolUncheckedUpdateInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type NoeMahsoolCreateManyInput = {
    Mahsool: string
    FIdNoeK: number
  }

  export type NoeMahsoolUpdateManyMutationInput = {
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type NoeMahsoolUncheckedUpdateManyInput = {
    IdNoeM?: IntFieldUpdateOperationsInput | number
    Mahsool?: StringFieldUpdateOperationsInput | string
    FIdNoeK?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITCreateInput = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor?: number
    VOLUM: number
  }

  export type NonFITUncheckedCreateInput = {
    IdNonFIT: number
    FIdRanesh: number
    FIdTarDor?: number
    VOLUM: number
  }

  export type NonFITUpdateInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUncheckedUpdateInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITCreateManyInput = {
    IdNonFIT: number
    FIdRanesh: number
    VOLUM: number
  }

  export type NonFITUpdateManyMutationInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type NonFITUncheckedUpdateManyInput = {
    IdNonFIT?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    VOLUM?: IntFieldUpdateOperationsInput | number
  }

  export type PumpStationCreateInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
  }

  export type PumpStationUncheckedCreateInput = {
    IdPumpSta?: number
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
  }

  export type PumpStationUpdateInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PumpStationUncheckedUpdateInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PumpStationCreateManyInput = {
    NameStation: string
    KM?: number | null
    FIdNet: number
    FIdDStation: number
    FIdMakhzan?: number | null
  }

  export type PumpStationUpdateManyMutationInput = {
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PumpStationUncheckedUpdateManyInput = {
    IdPumpSta?: IntFieldUpdateOperationsInput | number
    NameStation?: StringFieldUpdateOperationsInput | string
    KM?: NullableIntFieldUpdateOperationsInput | number | null
    FIdNet?: IntFieldUpdateOperationsInput | number
    FIdDStation?: IntFieldUpdateOperationsInput | number
    FIdMakhzan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PumpTypeCreateInput = {
    PumpType: string
  }

  export type PumpTypeUncheckedCreateInput = {
    IdPump?: number
    PumpType: string
  }

  export type PumpTypeUpdateInput = {
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type PumpTypeUncheckedUpdateInput = {
    IdPump?: IntFieldUpdateOperationsInput | number
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type PumpTypeCreateManyInput = {
    PumpType: string
  }

  export type PumpTypeUpdateManyMutationInput = {
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type PumpTypeUncheckedUpdateManyInput = {
    IdPump?: IntFieldUpdateOperationsInput | number
    PumpType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallStationCreateInput = {
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedCreateInput = {
    IdRaiSta?: number
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateInput = {
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationCreateManyInput = {
    FIdWeaSta: number
    FIdTrikh: number
    FIdRaiTy: number
    ErtefaeBaresh: Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUpdateManyMutationInput = {
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallStationUncheckedUpdateManyInput = {
    IdRaiSta?: IntFieldUpdateOperationsInput | number
    FIdWeaSta?: IntFieldUpdateOperationsInput | number
    FIdTrikh?: IntFieldUpdateOperationsInput | number
    FIdRaiTy?: IntFieldUpdateOperationsInput | number
    ErtefaeBaresh?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RainfallTypeCreateInput = {
    RainfallType: string
  }

  export type RainfallTypeUncheckedCreateInput = {
    IdRaiTy?: number
    RainfallType: string
  }

  export type RainfallTypeUpdateInput = {
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallTypeUncheckedUpdateInput = {
    IdRaiTy?: IntFieldUpdateOperationsInput | number
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallTypeCreateManyInput = {
    RainfallType: string
  }

  export type RainfallTypeUpdateManyMutationInput = {
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type RainfallTypeUncheckedUpdateManyInput = {
    IdRaiTy?: IntFieldUpdateOperationsInput | number
    RainfallType?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeCreateInput = {
    SaleZeraee: string
  }

  export type SaleZeraeeUncheckedCreateInput = {
    IdSal?: number
    SaleZeraee: string
  }

  export type SaleZeraeeUpdateInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeUncheckedUpdateInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeCreateManyInput = {
    SaleZeraee: string
  }

  export type SaleZeraeeUpdateManyMutationInput = {
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SaleZeraeeUncheckedUpdateManyInput = {
    IdSal?: IntFieldUpdateOperationsInput | number
    SaleZeraee?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpCreateInput = {
    SeghliPump: string
  }

  export type SeghliPumpUncheckedCreateInput = {
    IdSePu?: number
    SeghliPump: string
  }

  export type SeghliPumpUpdateInput = {
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpUncheckedUpdateInput = {
    IdSePu?: IntFieldUpdateOperationsInput | number
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpCreateManyInput = {
    SeghliPump: string
  }

  export type SeghliPumpUpdateManyMutationInput = {
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SeghliPumpUncheckedUpdateManyInput = {
    IdSePu?: IntFieldUpdateOperationsInput | number
    SeghliPump?: StringFieldUpdateOperationsInput | string
  }

  export type SystemPartCreateInput = {
    Part: string
    KM: number
  }

  export type SystemPartUncheckedCreateInput = {
    IdSP?: number
    Part: string
    KM: number
  }

  export type SystemPartUpdateInput = {
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type SystemPartUncheckedUpdateInput = {
    IdSP?: IntFieldUpdateOperationsInput | number
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type SystemPartCreateManyInput = {
    Part: string
    KM: number
  }

  export type SystemPartUpdateManyMutationInput = {
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type SystemPartUncheckedUpdateManyInput = {
    IdSP?: IntFieldUpdateOperationsInput | number
    Part?: StringFieldUpdateOperationsInput | string
    KM?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanCreateInput = {
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanUncheckedCreateInput = {
    IdTakhlie?: number
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUncheckedUpdateInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Takhlie: number
  }

  export type TakhlieMakhzanUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TakhlieMakhzanUncheckedUpdateManyInput = {
    IdTakhlie?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Takhlie?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    FIdRanesh: number
    FIdTarDor: number
    Test: number
  }

  export type TestUncheckedCreateInput = {
    IdTest?: number
    FIdRanesh: number
    FIdTarDor: number
    Test: number
  }

  export type TestUpdateInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestUncheckedUpdateInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateManyInput = {
    FIdRanesh: number
    FIdTarDor: number
    Test: number
  }

  export type TestUpdateManyMutationInput = {
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TestUncheckedUpdateManyInput = {
    IdTest?: IntFieldUpdateOperationsInput | number
    FIdRanesh?: IntFieldUpdateOperationsInput | number
    FIdTarDor?: IntFieldUpdateOperationsInput | number
    Test?: IntFieldUpdateOperationsInput | number
  }

  export type TrikhDoreKeshtCreateInput = {
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
  }

  export type TrikhDoreKeshtUncheckedCreateInput = {
    IdTarDor?: number
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
  }

  export type TrikhDoreKeshtUpdateInput = {
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
  }

  export type TrikhDoreKeshtUncheckedUpdateInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
  }

  export type TrikhDoreKeshtCreateManyInput = {
    FIdSal: number
    FIdDore: number
    Trikh: Date | string
    TrikhKhorshidi: string
  }

  export type TrikhDoreKeshtUpdateManyMutationInput = {
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
  }

  export type TrikhDoreKeshtUncheckedUpdateManyInput = {
    IdTarDor?: IntFieldUpdateOperationsInput | number
    FIdSal?: IntFieldUpdateOperationsInput | number
    FIdDore?: IntFieldUpdateOperationsInput | number
    Trikh?: DateTimeFieldUpdateOperationsInput | Date | string
    TrikhKhorshidi?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationCreateInput = {
    Station: string
  }

  export type WeatherStationUncheckedCreateInput = {
    IdWeaSta?: number
    Station: string
  }

  export type WeatherStationUpdateInput = {
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationUncheckedUpdateInput = {
    IdWeaSta?: IntFieldUpdateOperationsInput | number
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationCreateManyInput = {
    Station: string
  }

  export type WeatherStationUpdateManyMutationInput = {
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherStationUncheckedUpdateManyInput = {
    IdWeaSta?: IntFieldUpdateOperationsInput | number
    Station?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AbadeMakhzanCountOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanAvgOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
  }

  export type AbadeMakhzanMaxOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanMinOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
    NameStation?: SortOrder
  }

  export type AbadeMakhzanSumOrderByAggregateInput = {
    IdMakhzan?: SortOrder
    TooleBala?: SortOrder
    ArzeBala?: SortOrder
    TooleKaf?: SortOrder
    ArzeKaf?: SortOrder
    Omgh?: SortOrder
    HajmMohasebat?: SortOrder
    HadeaghalHajm?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AbgirCountOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirAvgOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
  }

  export type AbgirMaxOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirMinOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
    Abgir?: SortOrder
  }

  export type AbgirSumOrderByAggregateInput = {
    IdKontor?: SortOrder
    FIdRanesh?: SortOrder
  }

  export type AtashSooziCountOrderByAggregateInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    AtashSoozi?: SortOrder
  }

  export type AtashSooziAvgOrderByAggregateInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    AtashSoozi?: SortOrder
  }

  export type AtashSooziMaxOrderByAggregateInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    AtashSoozi?: SortOrder
  }

  export type AtashSooziMinOrderByAggregateInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    AtashSoozi?: SortOrder
  }

  export type AtashSooziSumOrderByAggregateInput = {
    IdAtash?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    AtashSoozi?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BahrebardairProgramCountOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramAvgOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
  }

  export type BahrebardairProgramMaxOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramMinOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
    Shorooe?: SortOrder
    Paian?: SortOrder
  }

  export type BahrebardairProgramSumOrderByAggregateInput = {
    IdProgram?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Tedad?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BahrebardariKeshtDoreCountOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreAvgOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreMaxOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreMinOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariKeshtDoreSumOrderByAggregateInput = {
    IdBahDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    FIdRanesh?: SortOrder
    FIdNoeM?: SortOrder
    Area?: SortOrder
  }

  export type BahrebardariTaghvimCountOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimAvgOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimMaxOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimMinOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BahrebardariTaghvimSumOrderByAggregateInput = {
    IdTag?: SortOrder
    FIdTarDor?: SortOrder
    FIdRanesh?: SortOrder
    Taghvim?: SortOrder
  }

  export type BareshMotaleatCountOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatAvgOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatMaxOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatMinOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type BareshMotaleatSumOrderByAggregateInput = {
    IdBarMot?: SortOrder
    FIdNet?: SortOrder
    FIdMah?: SortOrder
    BareshMotaleat?: SortOrder
  }

  export type DarajePipeCountOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeAvgOrderByAggregateInput = {
    IdDPipe?: SortOrder
  }

  export type DarajePipeMaxOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeMinOrderByAggregateInput = {
    IdDPipe?: SortOrder
    DarajePipe?: SortOrder
  }

  export type DarajePipeSumOrderByAggregateInput = {
    IdDPipe?: SortOrder
  }

  export type DarjeStationCountOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationAvgOrderByAggregateInput = {
    IdDStation?: SortOrder
  }

  export type DarjeStationMaxOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationMinOrderByAggregateInput = {
    IdDStation?: SortOrder
    DarajeStation?: SortOrder
  }

  export type DarjeStationSumOrderByAggregateInput = {
    IdDStation?: SortOrder
  }

  export type DoreKeshtCountOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtAvgOrderByAggregateInput = {
    IdDore?: SortOrder
  }

  export type DoreKeshtMaxOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtMinOrderByAggregateInput = {
    IdDore?: SortOrder
    Dore?: SortOrder
  }

  export type DoreKeshtSumOrderByAggregateInput = {
    IdDore?: SortOrder
  }

  export type EshtebahAvamelCountOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelAvgOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelMaxOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelMinOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type EshtebahAvamelSumOrderByAggregateInput = {
    IdEsht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Eshtebah?: SortOrder
  }

  export type FlowBehboodCountOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodAvgOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodMaxOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodMinOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FlowBehboodSumOrderByAggregateInput = {
    IdBehbood?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Flow?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FlowmeterCountOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterAvgOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterMaxOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterMinOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FlowmeterSumOrderByAggregateInput = {
    IdFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTrikh?: SortOrder
    Flowmeter?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type KhatRaneshCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    RaneshName?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdPumpSta?: SortOrder
    FIdDPipe?: SortOrder
    FIdSePu?: SortOrder
    FIdMeasuring?: SortOrder
  }

  export type KhatRaneshAreaCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type KhatRaneshAreaSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdLand?: SortOrder
    FIdNet?: SortOrder
    Area?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type KhatRaneshPumpCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    ModelPump?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type KhatRaneshPumpSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    FIdPump?: SortOrder
    TedadPump?: SortOrder
    DebiPomp?: SortOrder
    FesharPump?: SortOrder
    Randeman?: SortOrder
    TavaneNami?: SortOrder
    TavaneJazbi?: SortOrder
    Voltazh?: SortOrder
    DoreMotor?: SortOrder
    FeshareMakesh?: SortOrder
    FeshareRanesh?: SortOrder
    SizeMakesh?: SortOrder
    SizeRanesh?: SortOrder
    SizeKolektor?: SortOrder
    SizeShireKolektor?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type KhatRaneshSegliCountOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliAvgOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliMaxOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliMinOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KhatRaneshSegliSumOrderByAggregateInput = {
    IdRanesh?: SortOrder
    FIdRanesh?: SortOrder
    Zarfiat?: SortOrder
  }

  export type KontorCountOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorAvgOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorMaxOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorMinOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type KontorSumOrderByAggregateInput = {
    IdKon?: SortOrder
    FIdKontor?: SortOrder
    FIdTarDor?: SortOrder
    Kontor?: SortOrder
  }

  export type LandCountOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandAvgOrderByAggregateInput = {
    IdLand?: SortOrder
  }

  export type LandMaxOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandMinOrderByAggregateInput = {
    IdLand?: SortOrder
    Land?: SortOrder
  }

  export type LandSumOrderByAggregateInput = {
    IdLand?: SortOrder
  }

  export type MahCountOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahAvgOrderByAggregateInput = {
    IdMah?: SortOrder
  }

  export type MahMaxOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahMinOrderByAggregateInput = {
    IdMah?: SortOrder
    Mah?: SortOrder
  }

  export type MahSumOrderByAggregateInput = {
    IdMah?: SortOrder
  }

  export type MeasuringToolCountOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolAvgOrderByAggregateInput = {
    IdMeasuring?: SortOrder
  }

  export type MeasuringToolMaxOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolMinOrderByAggregateInput = {
    IdMeasuring?: SortOrder
    MeasuringTool?: SortOrder
    Precision?: SortOrder
  }

  export type MeasuringToolSumOrderByAggregateInput = {
    IdMeasuring?: SortOrder
  }

  export type NashtShabakeCountOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeAvgOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeMaxOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeMinOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NashtShabakeSumOrderByAggregateInput = {
    IdNasht?: SortOrder
    FIdRanesh?: SortOrder
    FIdTriDor?: SortOrder
    NashtShabake?: SortOrder
  }

  export type NetworkCountOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkAvgOrderByAggregateInput = {
    IdNet?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkMaxOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkMinOrderByAggregateInput = {
    IdNet?: SortOrder
    Network?: SortOrder
    FIdSP?: SortOrder
  }

  export type NetworkSumOrderByAggregateInput = {
    IdNet?: SortOrder
    FIdSP?: SortOrder
  }

  export type NoeKeshtCountOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtAvgOrderByAggregateInput = {
    IdNoeK?: SortOrder
  }

  export type NoeKeshtMaxOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtMinOrderByAggregateInput = {
    IdNoeK?: SortOrder
    Kesht?: SortOrder
  }

  export type NoeKeshtSumOrderByAggregateInput = {
    IdNoeK?: SortOrder
  }

  export type NoeMahsoolCountOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolAvgOrderByAggregateInput = {
    IdNoeM?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolMaxOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolMinOrderByAggregateInput = {
    IdNoeM?: SortOrder
    Mahsool?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NoeMahsoolSumOrderByAggregateInput = {
    IdNoeM?: SortOrder
    FIdNoeK?: SortOrder
  }

  export type NonFITCountOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITAvgOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITMaxOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITMinOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type NonFITSumOrderByAggregateInput = {
    IdNonFIT?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    VOLUM?: SortOrder
  }

  export type PumpStationCountOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
  }

  export type PumpStationAvgOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
  }

  export type PumpStationMaxOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
  }

  export type PumpStationMinOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    NameStation?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
  }

  export type PumpStationSumOrderByAggregateInput = {
    IdPumpSta?: SortOrder
    KM?: SortOrder
    FIdNet?: SortOrder
    FIdDStation?: SortOrder
    FIdMakhzan?: SortOrder
  }

  export type PumpTypeCountOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeAvgOrderByAggregateInput = {
    IdPump?: SortOrder
  }

  export type PumpTypeMaxOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeMinOrderByAggregateInput = {
    IdPump?: SortOrder
    PumpType?: SortOrder
  }

  export type PumpTypeSumOrderByAggregateInput = {
    IdPump?: SortOrder
  }

  export type RainfallStationCountOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationAvgOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationMaxOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationMinOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallStationSumOrderByAggregateInput = {
    IdRaiSta?: SortOrder
    FIdWeaSta?: SortOrder
    FIdTrikh?: SortOrder
    FIdRaiTy?: SortOrder
    ErtefaeBaresh?: SortOrder
  }

  export type RainfallTypeCountOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeAvgOrderByAggregateInput = {
    IdRaiTy?: SortOrder
  }

  export type RainfallTypeMaxOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeMinOrderByAggregateInput = {
    IdRaiTy?: SortOrder
    RainfallType?: SortOrder
  }

  export type RainfallTypeSumOrderByAggregateInput = {
    IdRaiTy?: SortOrder
  }

  export type SaleZeraeeCountOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeAvgOrderByAggregateInput = {
    IdSal?: SortOrder
  }

  export type SaleZeraeeMaxOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeMinOrderByAggregateInput = {
    IdSal?: SortOrder
    SaleZeraee?: SortOrder
  }

  export type SaleZeraeeSumOrderByAggregateInput = {
    IdSal?: SortOrder
  }

  export type SeghliPumpCountOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpAvgOrderByAggregateInput = {
    IdSePu?: SortOrder
  }

  export type SeghliPumpMaxOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpMinOrderByAggregateInput = {
    IdSePu?: SortOrder
    SeghliPump?: SortOrder
  }

  export type SeghliPumpSumOrderByAggregateInput = {
    IdSePu?: SortOrder
  }

  export type SystemPartCountOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartAvgOrderByAggregateInput = {
    IdSP?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartMaxOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartMinOrderByAggregateInput = {
    IdSP?: SortOrder
    Part?: SortOrder
    KM?: SortOrder
  }

  export type SystemPartSumOrderByAggregateInput = {
    IdSP?: SortOrder
    KM?: SortOrder
  }

  export type TakhlieMakhzanCountOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanAvgOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanMaxOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanMinOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TakhlieMakhzanSumOrderByAggregateInput = {
    IdTakhlie?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Takhlie?: SortOrder
  }

  export type TestCountOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    IdTest?: SortOrder
    FIdRanesh?: SortOrder
    FIdTarDor?: SortOrder
    Test?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TrikhDoreKeshtCountOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
  }

  export type TrikhDoreKeshtAvgOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type TrikhDoreKeshtMaxOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
  }

  export type TrikhDoreKeshtMinOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
    Trikh?: SortOrder
    TrikhKhorshidi?: SortOrder
  }

  export type TrikhDoreKeshtSumOrderByAggregateInput = {
    IdTarDor?: SortOrder
    FIdSal?: SortOrder
    FIdDore?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WeatherStationCountOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationAvgOrderByAggregateInput = {
    IdWeaSta?: SortOrder
  }

  export type WeatherStationMaxOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationMinOrderByAggregateInput = {
    IdWeaSta?: SortOrder
    Station?: SortOrder
  }

  export type WeatherStationSumOrderByAggregateInput = {
    IdWeaSta?: SortOrder
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}